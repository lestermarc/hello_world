
  CREATE OR REPLACE TRIGGER "C_ITX"."ACI_CSO_BIU_JOIN_KEY"
  before insert or update of "CSO_DATA1", "CSO_DOC_KEY" on ACI_CONVERSION_SOURCE
  referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour de l'index suivant le type de fichier à reprendre
* @author FP
* @version 2003
* @lastUpdate
*/
declare
  source_type ACI_CONVERSION_TYPE.C_SOURCE_TYPE%type;
begin

  -- recherche du type de fichier que l'on reprendre
  select ACI_CONVERSION_TYPE.C_SOURCE_TYPE into source_type
    from ACI_CONVERSION, ACI_CONVERSION_TYPE
   where ACI_CONVERSION.ACI_CONVERSION_ID = :NEW.ACI_CONVERSION_ID and
         ACI_CONVERSION.ACI_CONVERSION_TYPE_ID = ACI_CONVERSION_TYPE.ACI_CONVERSION_TYPE_ID;

  -- Fichier ASCII : 'Interface finance' PCS
  if source_type = '50' then
    :NEW.CSO_JOIN_KEY := rtrim(substr(:NEW.cso_data1,3,30))||to_char(:NEW.CSO_DOC_KEY);
  -- Fichier ASCII : 'Interface débiteurs / créanciers'
  elsif source_type = '80' then
    :NEW.CSO_JOIN_KEY := rtrim(substr(:NEW.cso_data1,3,20))||to_char(:NEW.CSO_DOC_KEY);
  end if;

end ACI_CSO_BIU_JOIN_KEY;

ALTER TRIGGER "C_ITX"."ACI_CSO_BIU_JOIN_KEY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACI_DST_AIU_FINANCIAL_LINK"
  after insert or update of "C_ACI_FINANCIAL_LINK"
  on ACI_DOCUMENT_STATUS
  referencing old as old new as new
  for each row
/**
* Description
*    gestion de l'intégration directe ou différée
* @author FP
* @version 2003
* @lastUpdate
*/
declare
  control_flag number(1);
begin
  -- Intégration financière immédiate ou simulation
  if    (:new.C_ACI_FINANCIAL_LINK = '2')
     or (:new.C_ACI_FINANCIAL_LINK = '7') then
    ACI_DOCUMENT_CONTROL.DOC_CONTROL(:new.ACI_DOCUMENT_ID, control_flag, :new.C_ACI_FINANCIAL_LINK);

    if control_flag = 1 then
      if (:new.C_ACI_FINANCIAL_LINK = '7') then   -- Simulation intégration
        update ACI_DOCUMENT
           set DOC_INTEGRATION_DATE = sysdate
             , ACT_DOCUMENT_ID = 0
             , C_INTERFACE_CONTROL = '1'
         where ACI_DOCUMENT_ID = :new.ACI_DOCUMENT_ID;
      else
        update ACI_DOCUMENT
           set C_INTERFACE_CONTROL = '1'
         where ACI_DOCUMENT_ID = :new.ACI_DOCUMENT_ID;
        --Intégration comptable
        ACT_INTERFACE_RECOVERING.Recover_doc(:new.ACI_DOCUMENT_ID, :new.C_ACI_FINANCIAL_LINK);
      end if;
    else
      update ACI_DOCUMENT
         set C_INTERFACE_CONTROL = '2'
       where ACI_DOCUMENT_ID = :new.ACI_DOCUMENT_ID;
    end if;
  end if;
end ACI_DST_AIU_FINANCIAL_LINK;

ALTER TRIGGER "C_ITX"."ACI_DST_AIU_FINANCIAL_LINK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACR_CFA_AD_DELETE_CHILDRENS"
after delete
on ACR_CASH_FLOW_ANALYSIS
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*    Effacement dasn les tables enfant de ACR_CASH_FLOW_ANALYSIS
* @author BL
* @created  23.05.2001
* @version 2003
* @lastUpdate
*/
begin

  delete from ACR_CF_DATE_WEIGHTING
    where ACR_CASH_FLOW_ANALYSIS_ID = :OLD.ACR_CASH_FLOW_ANALYSIS_ID;
  delete from ACR_CASH_GAS_SELECTED
    where ACR_CASH_FLOW_ANALYSIS_ID = :OLD.ACR_CASH_FLOW_ANALYSIS_ID;
  delete from ACR_CASH_COMP_SELECTED
    where ACR_CASH_FLOW_ANALYSIS_ID = :OLD.ACR_CASH_FLOW_ANALYSIS_ID;
  delete from ACR_DEDUCTED_PERIOD
    where ACR_CASH_FLOW_ANALYSIS_ID = :OLD.ACR_CASH_FLOW_ANALYSIS_ID;
  delete from ACR_ANALYSIS_PERIOD
    where ACR_CASH_FLOW_ANALYSIS_ID = :OLD.ACR_CASH_FLOW_ANALYSIS_ID;
  delete from ACR_CASH_FLOW_FOOT
    where ACR_CASH_FLOW_ANALYSIS_ID = :OLD.ACR_CASH_FLOW_ANALYSIS_ID;

end ACR_CFA_AD_DELETE_CHILDRENS;

ALTER TRIGGER "C_ITX"."ACR_CFA_AD_DELETE_CHILDRENS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_ACC_AIU_REPLICATE"
  after insert or update
  on ACS_ACCOUNT
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des comptes.
 * @author skalayci
 * @author spfister
 * @date 06.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    rep_functions.PublishAccount(:NEW.ACS_ACCOUNT_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_ACC_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_ADV_TAX_AIU_REPLICATE"
  after insert or update
  on ACS_ADV_TAX_ELEM
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des catégories d'intérêt.
 * @author skalayci
 * @author spfister
 * @date 06.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    rep_functions.PublishInterestCateg(:NEW.ACS_INTEREST_CATEG_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_ADV_TAX_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_CAL_MET_AIU_REPLICATE"
  after insert or update
  on ACS_INT_CALC_METHOD
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des méthodes de calcul intérêt.
 * @author skalayci
 * @author spfister
 * @date 06.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    rep_functions.PublishInterestCalcMethod(:NEW.ACS_INT_CALC_METHOD_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_CAL_MET_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_CDA_ACC_AIU_REPLICATE"
  after insert or update
  on ACS_CDA_ACCOUNT
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des comptes CDA.
 * @author skalayci
 * @author spfister
 * @date 09.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    rep_functions.PublishAccount(:NEW.ACS_CDA_ACCOUNT_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_CDA_ACC_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_CPN_ACC_AIU_REPLICATE"
  after insert or update
  on ACS_CPN_ACCOUNT
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des comptes CPN.
 * @author skalayci
 * @author spfister
 * @date 09.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    rep_functions.PublishAccount(:NEW.ACS_CPN_ACCOUNT_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_CPN_ACC_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_DES_AIU_REPLICATE"
  after insert or update
  on ACS_DESCRIPTION
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des comptes.
 * @author skalayci
 * @author spfister
 * @date 06.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    --Seule la description des comptes est prise en compte actuellement
    if :NEW.ACS_ACCOUNT_ID is not null then
      rep_functions.PublishAccount(:NEW.ACS_ACCOUNT_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_DES_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_DIV_ACC_AIU_REPLICATE"
  after insert or update
  on ACS_DIVISION_ACCOUNT
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des comptes.
 * @author skalayci
 * @author spfister
 * @date 06.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    rep_functions.PublishAccount(:NEW.ACS_DIVISION_ACCOUNT_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_DIV_ACC_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_EVA_ACC_AIU_REPLICATE"
  after insert or update
  on ACS_EVALUATION_ACCOUNT
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des méthodes de réévaluation.
 * @author skalayci
 * @author spfister
 * @date 06.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    rep_functions.PublishEvaluationMethod(:NEW.ACS_EVALUATION_METHOD_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_EVA_ACC_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_EVA_CUM_AIU_REPLICATE"
  after insert or update
  on ACS_EVALUATION_CUMUL
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des méthodes de réévaluation.
 * @author skalayci
 * @author spfister
 * @date 06.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    rep_functions.PublishEvaluationMethod(:NEW.ACS_EVALUATION_METHOD_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_EVA_CUM_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_EVA_MET_AIU_REPLICATE"
  after insert or update
  on ACS_EVALUATION_METHOD
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des méthodes de réévaluation.
 * @author skalayci
 * @author spfister
 * @date 06.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    rep_functions.PublishEvaluationMethod(:NEW.ACS_EVALUATION_METHOD_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_EVA_MET_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_FIN_ACC_AIU_REPLICATE"
  after insert or update
  on ACS_FINANCIAL_ACCOUNT
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des comptes.
 * @author skalayci
 * @author spfister
 * @date 06.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    rep_functions.PublishAccount(:NEW.ACS_FINANCIAL_ACCOUNT_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_FIN_ACC_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_FIN_ACCOUNT_AIUD_CPN_ID"
  after insert or update or delete of ACS_CPN_ACCOUNT_ID
  on ACS_FINANCIAL_ACCOUNT
  referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour des interactions FIN -> MGM (ACS_FIN_MGM_INTERACTION)
* @author pvo
* @lastUpdate
*/
begin
  if pcs.PC_CONFIG.GetConfigUpper('ACS_CPN_VARIANCE_VISIBLE') = 'TRUE' then
    if deleting then
      delete from ACS_FIN_MGM_INTERACTION
            where ACS_FINANCIAL_ACCOUNT_ID = :old.ACS_FINANCIAL_ACCOUNT_ID
              and ACS_CPN_ACCOUNT_ID = :old.ACS_CPN_ACCOUNT_ID;
    elsif nvl(:old.ACS_CPN_ACCOUNT_ID, 0) != nvl(:new.ACS_CPN_ACCOUNT_ID, 0) then
      --Supprimer l'interaction pour l'ancien CPN
      --Changer l'interaction 'Défaut=1' en 'Défaut=0'
      --Rechercher une interaction existante pour le compte financier et le nouveau CPN
      --Si elle existe, la flaguer 'Défaut'
      --sinon créer une nouvelle interaction 'Défaut' pour ce nouveau compte CPN
      delete from ACS_FIN_MGM_INTERACTION
            where ACS_FINANCIAL_ACCOUNT_ID = :new.ACS_FINANCIAL_ACCOUNT_ID
              and ACS_CPN_ACCOUNT_ID = :old.ACS_CPN_ACCOUNT_ID
              and FMI_DEFAULT = 1;
      update ACS_FIN_MGM_INTERACTION
         set FMI_DEFAULT = 0
       where ACS_FINANCIAL_ACCOUNT_ID = :new.ACS_FINANCIAL_ACCOUNT_ID
         and FMI_DEFAULT <> 0;

      if :new.ACS_CPN_ACCOUNT_ID is not null then
        --Insertion ou mise à jour de l'existant
        merge into ACS_FIN_MGM_INTERACTION FMI
             using (select :new.ACS_FINANCIAL_ACCOUNT_ID ACS_FINANCIAL_ACCOUNT_ID
                         , :new.ACS_CPN_ACCOUNT_ID ACS_CPN_ACCOUNT_ID
                         , 1 FMI_DEFAULT
                      from dual) FIN
                on (    FIN.ACS_FINANCIAL_ACCOUNT_ID = FMI.ACS_FINANCIAL_ACCOUNT_ID
                    and FIN.ACS_CPN_ACCOUNT_ID = FMI.ACS_CPN_ACCOUNT_ID)
          when matched then
            update
               set FMI.FMI_DEFAULT = 1
                 , FMI.A_DATEMOD = sysdate
                 , FMI.A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
          when not matched then
            insert(FMI.ACS_FIN_MGM_INTERACTION_ID, FMI.ACS_CPN_ACCOUNT_ID, FMI.ACS_FINANCIAL_ACCOUNT_ID
                 , FMI.FMI_DEFAULT, FMI.A_DATECRE, FMI.A_IDCRE)
            values(GetNewId, FIN.ACS_CPN_ACCOUNT_ID, FIN.ACS_FINANCIAL_ACCOUNT_ID, 1, sysdate, PCS.PC_I_LIB_SESSION.GetUserIni);
      end if;
    end if;
  end if;
exception
  when ex.TABLE_MUTATING then
    null;
end ACS_FIN_ACCOUNT_AIUD_CPN_ID;

ALTER TRIGGER "C_ITX"."ACS_FIN_ACCOUNT_AIUD_CPN_ID" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_FIN_CUR_AIU_REPLICATE"
  after insert or update
  on ACS_FIN_ACCOUNT_S_FIN_CURR
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des comptes.
 * @author skalayci
 * @author spfister
 * @date 06.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    rep_functions.PublishAccount(:NEW.ACS_FINANCIAL_ACCOUNT_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_FIN_CUR_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_FIN_MGM_INT_AIUD_DEFAULT"
  after insert or update or delete of FMI_DEFAULT
  on ACS_FIN_MGM_INTERACTION
  referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour de l'interaction CPN -> FIN (ACS_FINANCIAL_ACCOUNT)
* @author pvo
* @lastUpdate
*/
begin
  if pcs.PC_CONFIG.GetConfigUpper('ACS_CPN_VARIANCE_VISIBLE') = 'TRUE' then
    begin
      if deleting then
        update ACS_FINANCIAL_ACCOUNT
           set ACS_CPN_ACCOUNT_ID = null
             , A_DATEMOD = sysdate
             , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
         where ACS_FINANCIAL_ACCOUNT_ID = :old.ACS_FINANCIAL_ACCOUNT_ID;
      elsif nvl(:old.FMI_DEFAULT, 0) != nvl(:new.FMI_DEFAULT, 0) then
        --La valeur par défaut change:
          -- Défaut = 0: l'interaction FIN-CPN est supprimée (mise à null de ACS_FINANCIAL_ACCOUNT.ACS_CPN_ACCOUNT_ID)
          -- Défaut = 1: l'interaction FIN-CPN correspond à la valeur 'Défaut' des interactions FIN - MGM
        if nvl(:new.FMI_DEFAULT, 0) = 0 then
          update ACS_FINANCIAL_ACCOUNT
             set ACS_CPN_ACCOUNT_ID = null
               , A_DATEMOD = sysdate
               , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
           where ACS_FINANCIAL_ACCOUNT_ID = :new.ACS_FINANCIAL_ACCOUNT_ID;
        else
          update ACS_FINANCIAL_ACCOUNT
             set ACS_CPN_ACCOUNT_ID = :new.ACS_CPN_ACCOUNT_ID
               , A_DATEMOD = sysdate
               , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
           where ACS_FINANCIAL_ACCOUNT_ID = :new.ACS_FINANCIAL_ACCOUNT_ID;
        end if;
      end if;
    exception
      when ex.TABLE_MUTATING then
        null;
    end;
  end if;
end ACS_FIN_MGM_INT_AIUD_DEFAULT;

ALTER TRIGGER "C_ITX"."ACS_FIN_MGM_INT_AIUD_DEFAULT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_INT_CAT_AIU_REPLICATE"
  after insert or update
  on ACS_INTEREST_CATEG
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des catégories d'intérêt.
 * @author skalayci
 * @author spfister
 * @date 06.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    rep_functions.PublishInterestCateg(:NEW.ACS_INTEREST_CATEG_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_INT_CAT_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_INT_CUM_AIU_REPLICATE"
  after insert or update
  on ACS_CALC_CUMUL_TYPE
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des méthodes de calcul intérêt.
 * @author skalayci
 * @author spfister
 * @date 06.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    rep_functions.PublishInterestCalcMethod(:NEW.ACS_INT_CALC_METHOD_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_INT_CUM_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_INT_ELE_AIU_REPLICATE"
  after insert or update
  on ACS_INTEREST_ELEM
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des catégories d'intérêt.
 * @author skalayci
 * @author spfister
 * @date 06.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    rep_functions.PublishInterestCateg(:NEW.ACS_INTEREST_CATEG_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_INT_ELE_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_INTER_AIU_REPLICATE"
  after insert or update
  on ACS_INTERACTION
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des comptes.
 * @author skalayci
 * @author spfister
 * @date 06.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    if nvl(:OLD.ACS_FINANCIAL_ACCOUNT_ID,0) <> nvl(:NEW.ACS_FINANCIAL_ACCOUNT_ID,0) then
      rep_functions.PublishAccount(:NEW.ACS_DIVISION_ACCOUNT_ID, ln_result);
    elsif nvl(:OLD.ACS_DIVISION_ACCOUNT_ID,0) = nvl(:NEW.ACS_DIVISION_ACCOUNT_ID,0) then
      rep_functions.PublishAccount(:NEW.ACS_FINANCIAL_ACCOUNT_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_INTER_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_MET_ELE_AIU_REPLICATE"
  after insert or update
  on ACS_METHOD_ELEM
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des méthodes de calcul intérêt.
 * @author skalayci
 * @author spfister
 * @date 06.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    rep_functions.PublishInterestCalcMethod(:NEW.ACS_INT_CALC_METHOD_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_MET_ELE_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_MGM_INTER_AIU_REPLICATE"
  after insert or update
  on ACS_MGM_INTERACTION
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des comptes de l'interaction analytique.
 * @author skalayci
 * @author spfister
 * @date 09.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
  ln_account_id acs_account.acs_account_id%TYPE;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    if nvl(:OLD.ACS_CPN_ACCOUNT_ID,0) <> nvl(:NEW.ACS_CPN_ACCOUNT_ID,0) then
      if (:NEW.ACS_CDA_ACCOUNT_ID is not null) then
        ln_account_id := :NEW.ACS_CDA_ACCOUNT_ID;
      elsif (:NEW.ACS_PF_ACCOUNT_ID is not null) then
        ln_account_id := :NEW.ACS_PF_ACCOUNT_ID;
      elsif (:NEW.ACS_PJ_ACCOUNT_ID is not null) then
        ln_account_id := :NEW.ACS_PJ_ACCOUNT_ID;
      end if;
    elsif (nvl(:OLD.ACS_CDA_ACCOUNT_ID,0) <> nvl(:NEW.ACS_CDA_ACCOUNT_ID,0)) or
          (nvl(:OLD.ACS_PF_ACCOUNT_ID,0)  <> nvl(:NEW.ACS_PF_ACCOUNT_ID,0)) or
          (nvl(:OLD.ACS_PJ_ACCOUNT_ID,0)  <> nvl(:NEW.ACS_PJ_ACCOUNT_ID,0)) then
      ln_account_id := :NEW.ACS_CPN_ACCOUNT_ID;
    end if;
    rep_functions.PublishAccount(ln_account_id, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_MGM_INTER_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_PF_ACC_AIU_REPLICATE"
  after insert or update
  on ACS_PF_ACCOUNT
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des comptes PF.
 * @author skalayci
 * @author spfister
 * @date 09.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    rep_functions.PublishAccount(:NEW.ACS_PF_ACCOUNT_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_PF_ACC_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_PJ_ACC_AIU_REPLICATE"
  after insert or update
  on ACS_PJ_ACCOUNT
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des comptes PJ.
 * @author skalayci
 * @author spfister
 * @date 09.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    rep_functions.PublishAccount(:NEW.ACS_PJ_ACCOUNT_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_PJ_ACC_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_TAX_COD_AIU_REPLICATE"
  after insert or update
  on ACS_TAX_CODE
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des comptes.
 * @author skalayci
 * @author spfister
 * @date 06.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    rep_functions.PublishAccount(:NEW.ACS_TAX_CODE_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_TAX_COD_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACS_VAT_RAT_AIU_REPLICATE"
  after insert or update
  on ACS_VAT_RATE
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des comptes.
 * @author skalayci
 * @author spfister
 * @date 06.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FIN_TRIGGERS') = 1) then
    rep_functions.PublishAccount(:NEW.ACS_TAX_CODE_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."ACS_VAT_RAT_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACT_DOC_AD_GENERAL"
after delete
on ACT_DOCUMENT
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*   Mise à jour des numéros libres
*   Mise à jour du compteur de documents dans ACT_JOB
* @author BL
* @created
* @version 2003
* @lastUpdate
*/
declare
  vMultiUser  number(1);
begin
  -- Ajout du numéro du document au numéro libre
  ACT_FUNCTIONS.AddFreeNumber(:OLD.ACJ_CATALOGUE_DOCUMENT_ID,
                              :OLD.ACS_FINANCIAL_YEAR_ID,
                              :OLD.DOC_NUMBER);

  -- Suppression des données de ACT_EXPIRY_SELECTION
  -- (MutatingTable utilisé pour ne pas effacer lors de l'effacement d'un travail. L'effacement est géré par la cascade sur ACT_ETAT_EVENT)
  begin
    delete from ACT_EXPIRY_SELECTION
    where ACT_DOCUMENT_ID = :OLD.ACT_DOCUMENT_ID;
  exception
    when ex.TABLE_MUTATING then
      null;
  end;

  -- Màj du compteur sur le nombre de documents dans les jobs
  -- (MutatingTable utilisé pour ne pas màj lors de l'effacement d'un travail, et donc des documents liés)
  begin
    --Recherche si travail multi-user
    select nvl(min(EVE_MULTI_USERS), 0)
      into vMultiUser
      from ACJ_EVENT EVE
         , ACT_JOB JOB
     where JOB.ACT_JOB_ID = :OLD.ACT_JOB_ID
       and EVE.ACJ_JOB_TYPE_ID = JOB.ACJ_JOB_TYPE_ID
       and EVE.C_TYPE_EVENT = '1';

    if vMultiUser = 0 then
      update ACT_JOB
        set JOB_DOCUMENTS = JOB_DOCUMENTS - 1
        where ACT_JOB_ID = :OLD.ACT_JOB_ID;
    end if;
  exception
    when ex.TABLE_MUTATING then
      null;
    when others then
      raise;
  end;

end ACT_DOC_AD_GENERAL;

ALTER TRIGGER "C_ITX"."ACT_DOC_AD_GENERAL" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACT_DOC_AI_JOBUPDATE"
after insert
on ACT_DOCUMENT
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*   Mise à jour du compteur de documents dans ACT_JOB
* @author BL
* @version 2003
* @lastUpdate
*/
declare
  vMultiUser  number(1);
begin
  --Recherche si travail multi-user
  select nvl(min(EVE_MULTI_USERS), 0)
    into vMultiUser
    from ACJ_EVENT EVE
       , ACT_JOB JOB
   where JOB.ACT_JOB_ID = :NEW.ACT_JOB_ID
     and EVE.ACJ_JOB_TYPE_ID = JOB.ACJ_JOB_TYPE_ID
     and EVE.C_TYPE_EVENT = '1';

  if vMultiUser = 0 then
    update ACT_JOB
      set JOB_DOCUMENTS = JOB_DOCUMENTS + 1
      where ACT_JOB_ID = :NEW.ACT_JOB_ID;
  end if;
end ACT_DOC_AI_JobUpdate;

ALTER TRIGGER "C_ITX"."ACT_DOC_AI_JOBUPDATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACT_DOC_AU_JOBUPDATE"
after update of
  ACT_JOB_ID
on ACT_DOCUMENT
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*   Mise à jour du compteur de documents dans ACT_JOB
* @author BL
* @version 2003
* @lastUpdate
*/
declare
  vOldDocCount ACT_JOB.JOB_DOCUMENTS%type;
begin
  begin
    select JOB_DOCUMENTS
      into vOldDocCount
      from ACT_JOB
     where ACT_JOB_ID = :OLD.ACT_JOB_ID
       for update of ACT_JOB.JOB_DOCUMENTS nowait;

    update ACT_JOB
      set JOB_DOCUMENTS = vOldDocCount - 1
      where ACT_JOB_ID = :OLD.ACT_JOB_ID;
  exception
    when ex.ROW_LOCKED then
      null;
    when others then
      raise;
  end;

  begin
    select JOB_DOCUMENTS
      into vOldDocCount
      from ACT_JOB
     where ACT_JOB_ID = :NEW.ACT_JOB_ID
       for update of ACT_JOB.JOB_DOCUMENTS nowait;

    update ACT_JOB
      set JOB_DOCUMENTS = vOldDocCount + 1
      where ACT_JOB_ID = :NEW.ACT_JOB_ID;
  exception
    when ex.ROW_LOCKED then
      null;
    when others then
      raise;
  end;

end ACT_DOC_AU_JobUpdate;

ALTER TRIGGER "C_ITX"."ACT_DOC_AU_JOBUPDATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACT_DOC_STATUS_AIU_PART_LET"
  after insert or update of DOC_OK on ACT_DOCUMENT_STATUS
  referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour des numéros de lettrage de ACT_PART_IMPUTATION en fonction de la méthode de numérotation des lettrages partenaires
* @author DWA
* @version 2003
* @lastUpdate pvo 13.09.2007
*/
declare
  NumberMethodId   ACJ_NUMBER_METHOD.ACJ_NUMBER_METHOD_ID%type;
  TypeCatalogue    ACJ_CATALOGUE_DOCUMENT.C_TYPE_CATALOGUE%type;
begin
  if :NEW.DOC_OK = 1 then
    --recherche de l'id de la méthode de numérotation des lettrages partenaires
    select max(ACJ_NUMBER_METHOD_ID)
      into NumberMethodId
      from ACJ_NUMBER_METHOD
     where DNM_ACT_PART_LETTERING = 1;

    if NumberMethodId is not null then
      select max(C_TYPE_CATALOGUE)
        into TypeCatalogue
        from ACT_DOCUMENT DOC
           , ACJ_CATALOGUE_DOCUMENT CAT
       where DOC.ACT_DOCUMENT_ID = :NEW.ACT_DOCUMENT_ID
         and CAT.ACJ_CATALOGUE_DOCUMENT_ID = DOC.ACJ_CATALOGUE_DOCUMENT_ID
         and CAT.C_TYPE_CATALOGUE in('3', '4', '9');
      -- si document lettrage
      if TypeCatalogue is not null then
        ACT_FUNCTIONS.UpdateLetteringNumber(:NEW.ACT_DOCUMENT_ID, NumberMethodId);
      end if;
    end if;
  end if;
end ACT_DOC_STATUS_AIU_PART_LET;

ALTER TRIGGER "C_ITX"."ACT_DOC_STATUS_AIU_PART_LET" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACT_EJO_AU_TOTAL"
after update of
  "C_SUB_SET",
  "ACT_ETAT_JOURNAL_ID",
  "ACT_JOURNAL_ID",
  "C_ETAT_JOURNAL"
on ACT_ETAT_JOURNAL
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*    Mise à jour des totalisateurs
* @author BL
* @version 2003
* @lastUpdate
*/
begin

  if :NEW.C_SUB_SET = 'CPN' then

    ACT_MGM_TOTAL_BY_PERIOD.MgmImputationWrite(:NEW.ACT_JOURNAL_ID,
                                               :OLD.C_ETAT_JOURNAL,
                                               :NEW.C_ETAT_JOURNAL);
  else

    if  (:OLD.C_ETAT_JOURNAL = 'BRO') and (:NEW.C_ETAT_JOURNAL <> 'BRO') then
      ACT_EVOLUTION.ACT_WRITE_JOURNAL_IMPUTATIONS(:NEW.ACT_JOURNAL_ID, :NEW.C_SUB_SET);
    end if;

  end if;

end ACT_EJO_AU_TOTAL;

ALTER TRIGGER "C_ITX"."ACT_EJO_AU_TOTAL" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACT_EXPIRY_BIU_PARTNER"
  before insert or update of ACT_PART_IMPUTATION_ID on ACT_EXPIRY
  referencing new as new
  for each row
/**
* Description
*   Mise à jour des champs dénormalisé EXP_PAC_SUPPLIER_PARTNER_ID et EXP_PAC_CUSTOM_PARTNER_ID en fonction de ACT_PART_IMPUTATION
* @author DWA
* @version 2003
* @lastUpdate
*/
begin

  select min(PAC_SUPPLIER_PARTNER_ID)
       , min(PAC_CUSTOM_PARTNER_ID)
    into :NEW.EXP_PAC_SUPPLIER_PARTNER_ID
       , :NEW.EXP_PAC_CUSTOM_PARTNER_ID
    from ACT_PART_IMPUTATION
   where ACT_PART_IMPUTATION_ID = :NEW.ACT_PART_IMPUTATION_ID;

end ACT_EXPIRY_BIU_PARTNER;

ALTER TRIGGER "C_ITX"."ACT_EXPIRY_BIU_PARTNER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACT_FIN_DIST_AIU_DIV_ACC"
  after insert or update of ACS_DIVISION_ACCOUNT_ID, ACT_FINANCIAL_IMPUTATION_ID on ACT_FINANCIAL_DISTRIBUTION
  referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour du champ ACT_FINANCIAL_IMPUTATION.IMF_ACS_DIVISION_ACCOUNT_ID en fonction de ACS_DIVISION_ACCOUNT_ID
* @author DWA
* @version 2003
* @lastUpdate
*/
begin

  update ACT_FINANCIAL_IMPUTATION
     set IMF_ACS_DIVISION_ACCOUNT_ID = :NEW.ACS_DIVISION_ACCOUNT_ID
   where ACT_FINANCIAL_IMPUTATION_ID = nvl(:NEW.ACT_FINANCIAL_IMPUTATION_ID, :OLD.ACT_FINANCIAL_IMPUTATION_ID);

end ACT_FIN_DIST_AIU_DIV_ACC;

ALTER TRIGGER "C_ITX"."ACT_FIN_DIST_AIU_DIV_ACC" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACT_FIN_IMP_BIU_FIN_YEAR"
  before insert or update of ACS_PERIOD_ID on ACT_FINANCIAL_IMPUTATION
  referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour du champ IMF_ACS_FINANCIAL_YEAR_ID en fonction de ACS_PERIOD_ID
* @author DWA
* @version 2003
* @lastUpdate
*/
begin

  select min(ACS_FINANCIAL_YEAR_ID) into :NEW.IMF_ACS_FINANCIAL_YEAR_ID
    from ACS_PERIOD
   where ACS_PERIOD_ID = :NEW.ACS_PERIOD_ID;

end ACT_FIN_IMP_BIU_FIN_YEAR;

ALTER TRIGGER "C_ITX"."ACT_FIN_IMP_BIU_FIN_YEAR" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACT_FIN_IMP_BIU_PARTNER"
  before insert or update of ACT_PART_IMPUTATION_ID on ACT_FINANCIAL_IMPUTATION
  referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour des champs dénormalisé IMF_PAC_SUPPLIER_PARTNER_ID, IMF_ACS_AUX_ACCOUNT_SUPP_ID,
*    IMF_PAC_CUSTOM_PARTNER_ID et IMF_ACS_AUX_ACCOUNT_CUST_ID en fonction de ACT_PART_IMPUTATION
* @author DWA
* @version 2003
* @lastUpdate
*/
begin

  select min(PAC_SUPPLIER_PARTNER_ID)
       , min(PAC_CUSTOM_PARTNER_ID)
    into :NEW.IMF_PAC_SUPPLIER_PARTNER_ID
       , :NEW.IMF_PAC_CUSTOM_PARTNER_ID
    from ACT_PART_IMPUTATION
   where ACT_PART_IMPUTATION_ID = :NEW.ACT_PART_IMPUTATION_ID;

  if :NEW.IMF_PAC_SUPPLIER_PARTNER_ID is not null then
    select ACS_AUXILIARY_ACCOUNT_ID
      into :NEW.IMF_ACS_AUX_ACCOUNT_SUPP_ID
      from PAC_SUPPLIER_PARTNER
     where PAC_SUPPLIER_PARTNER_ID = :NEW.IMF_PAC_SUPPLIER_PARTNER_ID;
  else
    :NEW.IMF_ACS_AUX_ACCOUNT_SUPP_ID := null;
  end if;

  if :NEW.IMF_PAC_CUSTOM_PARTNER_ID is not null then
    select ACS_AUXILIARY_ACCOUNT_ID
      into :NEW.IMF_ACS_AUX_ACCOUNT_CUST_ID
      from PAC_CUSTOM_PARTNER
     where PAC_CUSTOM_PARTNER_ID = :NEW.IMF_PAC_CUSTOM_PARTNER_ID;
  else
    :NEW.IMF_ACS_AUX_ACCOUNT_CUST_ID := null;
  end if;

end ACT_FIN_IMP_BIU_PARTNER;

ALTER TRIGGER "C_ITX"."ACT_FIN_IMP_BIU_PARTNER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACT_JOB_AU_JOURNAL_DESCR"
after update of
  JOB_DESCRIPTION
on ACT_JOB
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*     Mise à jour de la description du journal en fonction de celle du Job
* @author BL
* @version 2003
* @lastUpdate
*/
begin

  update ACT_JOURNAL
    set JOU_DESCRIPTION = :NEW.JOB_DESCRIPTION
    where ACT_JOB_ID    = :NEW.ACT_JOB_ID;

end ACT_JOB_AU_JOURNAL_DESCR;

ALTER TRIGGER "C_ITX"."ACT_JOB_AU_JOURNAL_DESCR" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACT_JOB_AU_STATUSUPDATE"
after update of
  C_JOB_STATE
on ACT_JOB
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*    Mise à jour du status de ACT_ETAT_JOURNAL
*    Exécution de la procédure stockée du modèle de travail
* @author BL
* @version 2003
* @lastUpdate
*/
declare
  vStoredProcs ACJ_JOB_TYPE.TYP_STORED_PROC_TODO%type;
  vStoredProc  ACJ_JOB_TYPE.TYP_STORED_PROC_TODO%type;
  vArgument    varchar2(100);
  vSqlText     varchar2(500);
  vKeyWord     varchar2(11);
begin
  select
    case
      when :NEW.C_JOB_STATE = 'TODO' then Upper(TYP_STORED_PROC_TODO)
      when :NEW.C_JOB_STATE = 'PEND' then Upper(TYP_STORED_PROC_PEND)
      when :NEW.C_JOB_STATE = 'FINT' then Upper(TYP_STORED_PROC_FINT)
      when :NEW.C_JOB_STATE = 'TERM' then Upper(TYP_STORED_PROC_TERM)
      when :NEW.C_JOB_STATE = 'DEF'  then Upper(TYP_STORED_PROC_DEF)
      else ''
      end STORED_PROC
    into vStoredProcs
    from ACJ_JOB_TYPE
   where ACJ_JOB_TYPE_ID = :NEW.ACJ_JOB_TYPE_ID;
  if length(vStoredProcs) > 0 then
    --Ajouter un ; à la fin
    if InStr(vStoredProcs, ';', -1) <> length(vStoredProcs) then
      vStoredProcs := vStoredProcs || ';';
    end if;
    vArgument := '(pACT_JOB_ID)';
    while InStr(vStoredProcs, ';') > 1 loop
      vStoredProc  := Trim(SubStr(vStoredProcs, 1, InStr(vStoredProcs, ';')-1));
      vStoredProcs := SubStr(vStoredProcs, InStr(vStoredProcs, ';') + 1); --Suppression de la première procédure stockée de la liste pour ne garder que les suivantes

      --Recherche du mot clé PROCEDURE
      vKeyWord := 'PROCEDURE ';
      if InStr(vStoredProc, vKeyWord) = 1 then
        vStoredProc := SubStr(vStoredProc, length(vKeyWord) + 1);
        vSQLText  := replace('BEGIN ' || vStoredProc || vArgument || ';' || 'END;', 'pACT_JOB_ID', :NEW.ACT_JOB_ID);
        execute immediate vSqlText;
      end if;
    end loop;
  end if;

  if :OLD.C_JOB_STATE <> 'DEF' and :NEW.C_JOB_STATE = 'DEF' then

    update ACT_ETAT_JOURNAL
      set C_ETAT_JOURNAL = 'DEF'
      where ACT_JOURNAL_ID in (select ETA.ACT_JOURNAL_ID
                                 from ACT_JOURNAL      JOU,
                                      ACT_ETAT_JOURNAL ETA
                                 where JOU.ACT_JOB_ID     = :NEW.ACT_JOB_ID
                                   and JOU.ACT_JOURNAL_ID = ETA.ACT_JOURNAL_ID);
  end if;

end ACT_JOB_AU_StatusUpdate;

ALTER TRIGGER "C_ITX"."ACT_JOB_AU_STATUSUPDATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACT_JOB_BU_A_DATEMOD"
before update of A_DATEMOD
on ACT_JOB
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*     Mise à jour du nombre de document dans le travail pour les travaux multi-user
* @author DWA
* @version 2003
* @lastUpdate
*/
declare
  vMultiUser  number(1);
begin
  --Recherche si travail multi-user
  select nvl(min(EVE_MULTI_USERS), 0)
    into vMultiUser
    from ACJ_EVENT EVE
   where EVE.ACJ_JOB_TYPE_ID = :NEW.ACJ_JOB_TYPE_ID
     and EVE.C_TYPE_EVENT = '1';

  if vMultiUser = 1 and :NEW.JOB_DOCUMENTS = :OLD.JOB_DOCUMENTS then
    select count(*)
      into :NEW.JOB_DOCUMENTS
      from ACT_DOCUMENT
     where ACT_JOB_ID = :NEW.ACT_JOB_ID;
  end if;

end ACT_JOB_BU_A_DATEMOD;

ALTER TRIGGER "C_ITX"."ACT_JOB_BU_A_DATEMOD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACT_PARTIMP_AIU_FINIMP_PARTNER"
  after insert or update of PAC_SUPPLIER_PARTNER_ID, PAC_CUSTOM_PARTNER_ID on ACT_PART_IMPUTATION
  referencing new as new
  for each row
/**
* Description
*   Mise à jour des champs dénormalisé IMF_PAC_SUPPLIER_PARTNER_ID, IMF_ACS_AUX_ACCOUNT_SUPP_ID,
*    IMF_PAC_CUSTOM_PARTNER_ID et IMF_ACS_AUX_ACCOUNT_CUST_ID en fonction de ACT_FINANCIAL_IMPUTATION
* @author DWA
* @version 2003
* @lastUpdate
*/
declare
  vSuppAccId PAC_SUPPLIER_PARTNER.ACS_AUXILIARY_ACCOUNT_ID%type;
  vCustAccId PAC_CUSTOM_PARTNER.ACS_AUXILIARY_ACCOUNT_ID%type;
  vTest ACT_FINANCIAL_IMPUTATION.ACT_FINANCIAL_IMPUTATION_ID%type;
begin
  if inserting then
    select min(ACT_FINANCIAL_IMPUTATION_ID)
      into vTest
      from ACT_FINANCIAL_IMPUTATION
     where ACT_PART_IMPUTATION_ID = :NEW.ACT_PART_IMPUTATION_ID
       and rownum = 1;
  else
    vTest := 1;
  end if;

  if vTest is not null then
    if :NEW.PAC_SUPPLIER_PARTNER_ID is not null then
      select ACS_AUXILIARY_ACCOUNT_ID
        into vSuppAccId
        from PAC_SUPPLIER_PARTNER
       where PAC_SUPPLIER_PARTNER_ID = :NEW.PAC_SUPPLIER_PARTNER_ID;
    else
      vSuppAccId := null;
    end if;

    if :NEW.PAC_CUSTOM_PARTNER_ID is not null then
      select ACS_AUXILIARY_ACCOUNT_ID
        into vCustAccId
        from PAC_CUSTOM_PARTNER
       where PAC_CUSTOM_PARTNER_ID = :NEW.PAC_CUSTOM_PARTNER_ID;
    else
      vCustAccId := null;
    end if;

    --Màj ACT_FINANCIAL_IMPUTATION
    update ACT_FINANCIAL_IMPUTATION
       set IMF_PAC_SUPPLIER_PARTNER_ID = :NEW.PAC_SUPPLIER_PARTNER_ID
         , IMF_PAC_CUSTOM_PARTNER_ID = :NEW.PAC_CUSTOM_PARTNER_ID
         , IMF_ACS_AUX_ACCOUNT_SUPP_ID = vSuppAccId
         , IMF_ACS_AUX_ACCOUNT_CUST_ID = vCustAccId
     where ACT_PART_IMPUTATION_ID = :NEW.ACT_PART_IMPUTATION_ID;
  end if;

end ACT_PARTIMP_AIU_FINIMP_PARTNER;

ALTER TRIGGER "C_ITX"."ACT_PARTIMP_AIU_FINIMP_PARTNER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACT_PART_IMP_AU_EXP_PARTNER"
  after update of PAC_SUPPLIER_PARTNER_ID, PAC_CUSTOM_PARTNER_ID on ACT_PART_IMPUTATION
  referencing new as new
  for each row
/**
* Description
*   Mise à jour des champs dénormalisé EXP_PAC_SUPPLIER_PARTNER_ID et EXP_PAC_CUSTOM_PARTNER_ID de ACT_EXPIRY en fonction de ACT_PART_IMPUTATION
* @author DWA
* @version 2003
* @lastUpdate
*/
begin

  update ACT_EXPIRY
     set EXP_PAC_SUPPLIER_PARTNER_ID = :NEW.PAC_SUPPLIER_PARTNER_ID
       , EXP_PAC_CUSTOM_PARTNER_ID = :NEW.PAC_CUSTOM_PARTNER_ID
   where ACT_PART_IMPUTATION_ID = :NEW.ACT_PART_IMPUTATION_ID;

end ACT_PART_IMP_AU_EXP_PARTNER;

ALTER TRIGGER "C_ITX"."ACT_PART_IMP_AU_EXP_PARTNER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ACT_PART_IMPUT_BU_PAR_LETT"
  before update of PAC_SUPPLIER_PARTNER_ID, PAC_CUSTOM_PARTNER_ID on ACT_PART_IMPUTATION
  referencing old as old new as new
  for each row
/**
* Description
*   Suppression du numéro de lettrage en cas de changement de partenaire
* @author DWA
* @version 2003
* @lastUpdate
*/
begin
  if nvl(:OLD.PAC_SUPPLIER_PARTNER_ID, 0) != nvl(:NEW.PAC_SUPPLIER_PARTNER_ID, 0) or
     nvl(:OLD.PAC_CUSTOM_PARTNER_ID, 0) != nvl(:NEW.PAC_CUSTOM_PARTNER_ID, 0) then
    :NEW.PAR_LETTERING := null;
  end if;

end ACT_PART_IMPUT_BU_PAR_LETT;


ALTER TRIGGER "C_ITX"."ACT_PART_IMPUT_BU_PAR_LETT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_AGC_BIUD_ELEMENT_NUMBER"
  before insert or delete or update of AGC_CHAR1_VALUE, AGC_CHAR2_VALUE, AGC_CHAR3_VALUE, AGC_CHAR4_VALUE, AGC_CHAR5_VALUE
  on ASA_GUARANTY_CARDS
  referencing old as old new as new
  for each row
/**
* Description
*    Maj de STM_ELEMENT_NUMBER
* @created fp 25.09.2003
* @version 2003
* @lastUpdate
*/
declare
  vMovementSort     STM_MOVEMENT_KIND.C_MOVEMENT_SORT%type;
  vElementNumberID1 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vElementNumberID2 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vElementNumberID3 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  lQualityStatusId  STM_ELEMENT_NUMBER.GCO_QUALITY_STATUS_ID%type;
  updateMode        varchar2(2);
begin
  -- si on a au moins une caractérization
  if nvl(:new.GCO_CHAR1_ID, :old.GCO_CHAR1_ID) is not null then
    -- Reception PT => Entrée en stock
    vMovementSort  := 'ENT';

    -- En effacement et en modification, traitement des anciennes valeurs
    if    deleting
       or updating then
      -- Maj STM_ELEMENT_NUMBER en mode suppression
      STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => :old.GCO_GOOD_ID   -- Bien
                                              , iUpdateMode               => 'D'   -- Mode de mise à jour (A-> Archivage des numéro)
                                              , iMovementSort             => vMovementSort   -- Type de mouvement 'ENT' = Entrée 'SOR' = Sortie
                                              , iCharacterizationId       => :old.GCO_CHAR1_ID   -- Caractérisation
                                              , iCharacterization2Id      => :old.GCO_CHAR2_ID
                                              , iCharacterization3Id      => :old.GCO_CHAR3_ID
                                              , iCharacterization4Id      => :old.GCO_CHAR4_ID
                                              , iCharacterization5Id      => :old.GCO_CHAR5_ID
                                              , iCharacterizationValue1   => :old.AGC_CHAR1_VALUE   -- Valeur de caractérisation
                                              , iCharacterizationValue2   => :old.AGC_CHAR2_VALUE
                                              , iCharacterizationValue3   => :old.AGC_CHAR3_VALUE
                                              , iCharacterizationValue4   => :old.AGC_CHAR4_VALUE
                                              , iCharacterizationValue5   => :old.AGC_CHAR5_VALUE
                                              , iVerifyChar               => 1   -- Vérification de l'unicité des valeurs de caract.
                                              , iElementStatus            => null   -- Statut de l'élement après mise à jour
                                              , ioElementNumberId1        => vElementNumberID1   -- Elément 1 en sortie
                                              , ioElementNumberId2        => vElementNumberID2   -- Elément 2 en sortie
                                              , ioElementNumberId3        => vElementNumberID3   -- Elément 3 en sortie
                                              , ioQualityStatusId         => lQualityStatusId
                                               );
    end if;

    -- En création et en modification, traitement des nouvelles valeurs
    if    inserting
       or updating then
      -- Maj STM_ELEMENT_NUMBER en mode insertion
      STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => :new.GCO_GOOD_ID   -- Bien
                                              , iUpdateMode               => 'H'   -- Mode de mise à jour (H-> Historique des numéro)
                                              , iMovementSort             => vMovementSort   -- Type de mouvement 'ENT' = Entrée 'SOR' = Sortie
                                              , iCharacterizationId       => :new.GCO_CHAR1_ID   -- Caractérisation
                                              , iCharacterization2Id      => :new.GCO_CHAR2_ID
                                              , iCharacterization3Id      => :new.GCO_CHAR3_ID
                                              , iCharacterization4Id      => :new.GCO_CHAR4_ID
                                              , iCharacterization5Id      => :new.GCO_CHAR5_ID
                                              , iCharacterizationValue1   => :new.AGC_CHAR1_VALUE   -- Valeur de caractérisation
                                              , iCharacterizationValue2   => :new.AGC_CHAR2_VALUE
                                              , iCharacterizationValue3   => :new.AGC_CHAR3_VALUE
                                              , iCharacterizationValue4   => :new.AGC_CHAR4_VALUE
                                              , iCharacterizationValue5   => :new.AGC_CHAR5_VALUE
                                              , iVerifyChar               => 1   -- Vérification de l'unicité des valeurs de caract.
                                              , iElementStatus            => null   -- Statut de l'élement après mise à jour
                                              , ioElementNumberId1        => vElementNumberID1   -- Elément 1 en sortie
                                              , ioElementNumberId2        => vElementNumberID2   -- Elément 2 en sortie
                                              , ioElementNumberId3        => vElementNumberID3   -- Elément 3 en sortie
                                              , ioQualityStatusId         => lQualityStatusId
                                               );
    end if;
  end if;
end ASA_AGC_BIUD_ELEMENT_NUMBER;

ALTER TRIGGER "C_ITX"."ASA_AGC_BIUD_ELEMENT_NUMBER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_AID_BD_CONSTRAINTS"
  before delete
  on ASA_INTERVENTION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Suppression du lien du détail qui est sur les mvts de stock si
*    ceux-ci ont tous été extournés
* @version 2003
*/
begin
  -- Suppression du lien du détail qui est sur les mvts de stock si ceux-ci ont tous été extournés
  ASA_MISSION_FUNCTIONS.ClearMvtInterventionRef(:old.ASA_INTERVENTION_DETAIL_ID);
end ASA_AID_BD_CONSTRAINTS;

ALTER TRIGGER "C_ITX"."ASA_AID_BD_CONSTRAINTS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_AID_BIU_CHARACTERIZATION"
  before insert or update of GCO_GOOD_ID, GCO_GOOD_EXCH_ID
  on ASA_INTERVENTION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*     Mise à jour des caractérisations en fonction du bien sélectionné
* @author DSA
* @version 2003
* @lastUpdate
*/
declare
  aCharacType1     varchar2(10);
  aCharacType2     varchar2(10);
  aCharacType3     varchar2(10);
  aCharacType4     varchar2(10);
  aCharacType5     varchar2(10);
  aCharacStk1      number;
  aCharacStk2      number;
  aCharacStk3      number;
  aCharacStk4      number;
  aCharacStk5      number;
  aPieceManagement number;
begin
  if    inserting
     or (    updating
         and (    (nvl(:new.GCO_GOOD_ID, 0) <> nvl(:old.GCO_GOOD_ID, 0) )
              or (nvl(:new.GCO_GOOD_EXCH_ID, 0) <> nvl(:old.GCO_GOOD_EXCH_ID, 0) )
             )
        ) then
    if (nvl(:new.GCO_GOOD_ID, 0) <> nvl(:old.GCO_GOOD_ID, 0) ) then
      GCO_CHARACTERIZATION_FUNCTIONS.GetListOfCharacterization(:new.GCO_GOOD_ID
                                                             , 1
                                                             , 'SOR'
                                                             , '7'
                                                             , :new.GCO_CHAR1_ID
                                                             , :new.GCO_CHAR2_ID
                                                             , :new.GCO_CHAR3_ID
                                                             , :new.GCO_CHAR4_ID
                                                             , :new.GCO_CHAR5_ID
                                                             , aCharacType1
                                                             , aCharacType2
                                                             , aCharacType3
                                                             , aCharacType4
                                                             , aCharacType5
                                                             , aCharacStk1
                                                             , aCharacStk2
                                                             , aCharacStk3
                                                             , aCharacStk4
                                                             , aCharacStk5
                                                             , aPieceManagement
                                                              );
      :new.AID_CHAR1_VALUE  := '';
      :new.AID_CHAR2_VALUE  := '';
      :new.AID_CHAR3_VALUE  := '';
      :new.AID_CHAR4_VALUE  := '';
      :new.AID_CHAR5_VALUE  := '';
    elsif(nvl(:new.GCO_GOOD_EXCH_ID, 0) <> nvl(:old.GCO_GOOD_EXCH_ID, 0) ) then
      GCO_CHARACTERIZATION_FUNCTIONS.GetListOfCharacterization(:new.GCO_GOOD_EXCH_ID
                                                             , 1
                                                             , 'ENT'
                                                             , '7'
                                                             , :new.GCO_EXCH_CHAR1_ID
                                                             , :new.GCO_EXCH_CHAR2_ID
                                                             , :new.GCO_EXCH_CHAR3_ID
                                                             , :new.GCO_EXCH_CHAR4_ID
                                                             , :new.GCO_EXCH_CHAR5_ID
                                                             , aCharacType1
                                                             , aCharacType2
                                                             , aCharacType3
                                                             , aCharacType4
                                                             , aCharacType5
                                                             , aCharacStk1
                                                             , aCharacStk2
                                                             , aCharacStk3
                                                             , aCharacStk4
                                                             , aCharacStk5
                                                             , aPieceManagement
                                                              );
      :new.AID_EXCH_CHAR1_VALUE  := '';
      :new.AID_EXCH_CHAR2_VALUE  := '';
      :new.AID_EXCH_CHAR3_VALUE  := '';
      :new.AID_EXCH_CHAR4_VALUE  := '';
      :new.AID_EXCH_CHAR5_VALUE  := '';
    end if;
  end if;
end ASA_AID_BIU_CHARACTERIZATION;

ALTER TRIGGER "C_ITX"."ASA_AID_BIU_CHARACTERIZATION" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_AID_BIU_DETAIL_TYPE"
  before insert or update of GCO_GOOD_ID, GCO_SERVICE_ID
  on ASA_INTERVENTION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*     Mise à jour du champ type de détail
* @author NGV
* @version 2014
* @lastUpdate
*/
declare
begin
  if :new.GCO_SERVICE_ID is not null then
    :new.C_ASA_INTERV_DETAIL_TYPE := '1';
  else
    :new.C_ASA_INTERV_DETAIL_TYPE := '2';
  end if;
end ASA_AID_BIU_DETAIL_TYPE;

ALTER TRIGGER "C_ITX"."ASA_AID_BIU_DETAIL_TYPE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_ARC_BI_STM_WORK"
BEFORE INSERT
ON ASA_RECORD_COMP
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
/**
* Description
*    Attribution des informtations sur le stock atelier (STM_WORK)
* @author sma
* @created 15.03.2011
* @version 2011
* @lastUpdate 15.03.2011
*/
declare
  lStockId    ASA_RECORD_COMP.STM_WORK_STOCK_ID%type;
  lLocationId ASA_RECORD_COMP.STM_WORK_LOCATION_ID%TYPE;
begin
  -- Vérifier la valeur de la config ASA_WORK_STOCK_MNG
  if (upper(PCS.PC_CONFIG.GetConfig('ASA_WORK_STOCK_MNG')) = 'TRUE') and
     (:new.STM_WORK_STOCK_ID is null) and
     (:new.STM_WORK_LOCATION_ID is null) then
    begin
      -- Récupération des données du stock atelier dans les config
      select STO.STM_STOCK_ID
           , LOC.STM_LOCATION_ID
        into lStockId
           , lLocationId
        from STM_STOCK STO
           , STM_LOCATION LOC
       where STO.STO_DESCRIPTION = PCS.PC_CONFIG.GetConfig('ASA_WORK_STO_DESCRIPTION')
         and LOC.LOC_DESCRIPTION = PCS.PC_CONFIG.GetConfig('ASA_WORK_LOC_DESCRIPTION')
         and LOC.STM_STOCK_ID = STO.STM_STOCK_ID;

      -- Initialiser les valeurs concernant le stock atelier en fonction
      -- des valeurs calculés ci-dessus
      :new.STM_WORK_STOCK_ID := lStockId;
      :new.STM_WORK_LOCATION_ID := lLocationId;
    exception
      when no_data_found then
        null;
    end;

  end if;
end ASA_ARC_BI_STM_WORK;

ALTER TRIGGER "C_ITX"."ASA_ARC_BI_STM_WORK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_ARC_BIUD_ELEMENT_NUMBER"
  before insert or delete or update of ARC_CHAR1_VALUE, ARC_CHAR2_VALUE, ARC_CHAR3_VALUE, ARC_CHAR4_VALUE, ARC_CHAR5_VALUE
  on ASA_RECORD_COMP
  referencing old as old new as new
  for each row
/**
* Description
*    Maj de STM_ELEMENT_NUMBER
* @created fp 23.09.2003
* @version 2003
* @lastUpdate
*/
declare
  vMovementSort     STM_MOVEMENT_KIND.C_MOVEMENT_SORT%type;
  vElementNumberID1 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vElementNumberID2 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vElementNumberID3 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  lQualityStatusId  STM_ELEMENT_NUMBER.GCO_QUALITY_STATUS_ID%type;
  updateMode        varchar2(2);
begin
  -- si on a au moins une caractérization
  if nvl(:new.GCO_CHAR1_ID, :old.GCO_CHAR1_ID) is not null then
    -- En effacement et en modification, traitement des anciennes valeurs
    if    deleting
       or updating then
      select C_MOVEMENT_SORT
        into vMovementSort
        from STM_MOVEMENT_KIND
       where STM_MOVEMENT_KIND_ID = :old.STM_COMP_MVT_KIND_ID;

      -- Maj STM_ELEMENT_NUMBER en mode suppression
      STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => :old.GCO_COMPONENT_ID   -- Bien
                                              , iUpdateMode               => 'D'   -- Mode de mise à jour
                                              , iMovementSort             => vMovementSort   -- Type de mouvement 'ENT' = Entrée 'SOR' = Sortie
                                              , iCharacterizationId       => :old.GCO_CHAR1_ID   -- Caractérisation
                                              , iCharacterization2Id      => :old.GCO_CHAR2_ID
                                              , iCharacterization3Id      => :old.GCO_CHAR3_ID
                                              , iCharacterization4Id      => :old.GCO_CHAR4_ID
                                              , iCharacterization5Id      => :old.GCO_CHAR5_ID
                                              , iCharacterizationValue1   => :old.ARC_CHAR1_VALUE   -- Valeur de caractérisation
                                              , iCharacterizationValue2   => :old.ARC_CHAR2_VALUE
                                              , iCharacterizationValue3   => :old.ARC_CHAR3_VALUE
                                              , iCharacterizationValue4   => :old.ARC_CHAR4_VALUE
                                              , iCharacterizationValue5   => :old.ARC_CHAR5_VALUE
                                              , iVerifyChar               => 1   -- Vérification de l'unicité des valeurs de caract.
                                              , iElementStatus            => null   -- Statut de l'élement après mise à jour
                                              , ioElementNumberId1        => vElementNumberID1   -- Elément 1 en sortie
                                              , ioElementNumberId2        => vElementNumberID2   -- Elément 2 en sortie
                                              , ioElementNumberId3        => vElementNumberID3   -- Elément 3 en sortie
                                              , ioQualityStatusId         => lQualityStatusId
                                               );
    end if;

    -- En création et en modification, traitement des nouvelles valeurs
    if    inserting
       or updating then
      select C_MOVEMENT_SORT
        into vMovementSort
        from STM_MOVEMENT_KIND
       where STM_MOVEMENT_KIND_ID = :new.STM_COMP_MVT_KIND_ID;

      -- Maj STM_ELEMENT_NUMBER en mode insertion
      STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => :new.GCO_COMPONENT_ID   -- Bien
                                              , iUpdateMode               => 'I'   -- Mode de mise à jour (A-> Archivage des numéro)
                                              , iMovementSort             => vMovementSort   -- Type de mouvement 'ENT' = Entrée 'SOR' = Sortie
                                              , iCharacterizationId       => :new.GCO_CHAR1_ID   -- Caractérisation
                                              , iCharacterization2Id      => :new.GCO_CHAR2_ID
                                              , iCharacterization3Id      => :new.GCO_CHAR3_ID
                                              , iCharacterization4Id      => :new.GCO_CHAR4_ID
                                              , iCharacterization5Id      => :new.GCO_CHAR5_ID
                                              , iCharacterizationValue1   => :new.ARC_CHAR1_VALUE   -- Valeur de caractérisation
                                              , iCharacterizationValue2   => :new.ARC_CHAR2_VALUE
                                              , iCharacterizationValue3   => :new.ARC_CHAR3_VALUE
                                              , iCharacterizationValue4   => :new.ARC_CHAR4_VALUE
                                              , iCharacterizationValue5   => :new.ARC_CHAR5_VALUE
                                              , iVerifyChar               => 1   -- Vérification de l'unicité des valeurs de caract.
                                              , iElementStatus            => null   -- Statut de l'élement après mise à jour
                                              , ioElementNumberId1        => vElementNumberID1   -- Elément 1 en sortie
                                              , ioElementNumberId2        => vElementNumberID2   -- Elément 2 en sortie
                                              , ioElementNumberId3        => vElementNumberID3   -- Elément 3 en sortie
                                              , ioQualityStatusId         => lQualityStatusId
                                               );
    end if;
  end if;
end ASA_ARC_BIUD_ELEMENT_NUMBER;

ALTER TRIGGER "C_ITX"."ASA_ARC_BIUD_ELEMENT_NUMBER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_ARC_BIU_DENORM_CHAR"
  before insert or update of GCO_CHAR1_ID
                           , GCO_CHAR2_ID
                           , GCO_CHAR3_ID
                           , GCO_CHAR4_ID
                           , GCO_CHAR5_ID
                           , ARC_CHAR1_VALUE
                           , ARC_CHAR2_VALUE
                           , ARC_CHAR3_VALUE
                           , ARC_CHAR4_VALUE
                           , ARC_CHAR5_VALUE
  on ASA_RECORD_COMP
  referencing old as old new as new
  for each row
/**
* Description
*    Dénormalisation des caractérisations dans l'événement before insert/update
* @author DSA
* @created 10.01.2005
* @version 2003
* @lastUpdate 10.01.2005
*/
begin
  -- on vérifie que ce trigger est déclenché par une modif d'un des champs ci-dessous
  if    nvl(:old.GCO_CHAR1_ID, -1) <> nvl(:new.GCO_CHAR1_ID, -1)
     or nvl(:old.GCO_CHAR2_ID, -1) <> nvl(:new.GCO_CHAR2_ID, -1)
     or nvl(:old.GCO_CHAR3_ID, -1) <> nvl(:new.GCO_CHAR3_ID, -1)
     or nvl(:old.GCO_CHAR4_ID, -1) <> nvl(:new.GCO_CHAR4_ID, -1)
     or nvl(:old.GCO_CHAR5_ID, -1) <> nvl(:new.GCO_CHAR5_ID, -1)
     or nvl(:old.ARC_CHAR1_VALUE, 'null') <> nvl(:new.ARC_CHAR1_VALUE, 'null')
     or nvl(:old.ARC_CHAR2_VALUE, 'null') <> nvl(:new.ARC_CHAR2_VALUE, 'null')
     or nvl(:old.ARC_CHAR3_VALUE, 'null') <> nvl(:new.ARC_CHAR3_VALUE, 'null')
     or nvl(:old.ARC_CHAR4_VALUE, 'null') <> nvl(:new.ARC_CHAR4_VALUE, 'null')
     or nvl(:old.ARC_CHAR5_VALUE, 'null') <> nvl(:new.ARC_CHAR5_VALUE, 'null') then
    -- vérifie qu'on ait au moins une caractérisation
    if :new.GCO_CHAR1_ID is not null then
      -- Mise à jour des champs dénormalisé d'affichage des caractérisations
      GCO_FUNCTIONS.ClassifyCharacterizations(:new.GCO_CHAR1_ID
                                            , :new.GCO_CHAR2_ID
                                            , :new.GCO_CHAR3_ID
                                            , :new.GCO_CHAR4_ID
                                            , :new.GCO_CHAR5_ID
                                            , :new.ARC_CHAR1_VALUE
                                            , :new.ARC_CHAR2_VALUE
                                            , :new.ARC_CHAR3_VALUE
                                            , :new.ARC_CHAR4_VALUE
                                            , :new.ARC_CHAR5_VALUE
                                            , :new.ARC_PIECE
                                            , :new.ARC_SET
                                            , :new.ARC_VERSION
                                            , :new.ARC_CHRONOLOGICAL
                                            , :new.ARC_STD_CHAR_1
                                            , :new.ARC_STD_CHAR_2
                                            , :new.ARC_STD_CHAR_3
                                            , :new.ARC_STD_CHAR_4
                                            , :new.ARC_STD_CHAR_5
                                             );
    end if;
  end if;
end ASA_ARC_BIU_DENORM_CHAR;


ALTER TRIGGER "C_ITX"."ASA_ARC_BIU_DENORM_CHAR" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_ARC_BU_ATTRIB"
  before update of GCO_COMPONENT_ID
                 , STM_COMP_LOCATION_ID
                 , ARC_QUANTITY
                 , ARC_CHAR1_VALUE
                 , ARC_CHAR2_VALUE
                 , ARC_CHAR3_VALUE
                 , ARC_CHAR4_VALUE
                 , ARC_CHAR5_VALUE
                 , STM_COMP_STOCK_MVT_ID
  on ASA_RECORD_COMP
  referencing old as old new as new
  for each row
/**
* Description
*     Suppression du lien avec la position du document de gestion des attributions associé au composant du dossier SAV
* @author DSA
* @version 2003
* @lastUpdate
*/
declare
  vCount integer;
begin
  -- Rechercher si le composant possède tjrs une attrib
  if     (:old.DOC_ATTRIB_POSITION_ID is not null)
     and (    (:new.GCO_COMPONENT_ID <> :old.GCO_COMPONENT_ID)
          or (nvl(:new.STM_COMP_LOCATION_ID, 0) <> nvl(:old.STM_COMP_LOCATION_ID, 0) )
          or (nvl(:new.ARC_CHAR1_VALUE, 'null') <> nvl(:old.ARC_CHAR1_VALUE, 'null') )
          or (nvl(:new.ARC_CHAR2_VALUE, 'null') <> nvl(:old.ARC_CHAR2_VALUE, 'null') )
          or (nvl(:new.ARC_CHAR3_VALUE, 'null') <> nvl(:old.ARC_CHAR3_VALUE, 'null') )
          or (nvl(:new.ARC_CHAR4_VALUE, 'null') <> nvl(:old.ARC_CHAR4_VALUE, 'null') )
          or (nvl(:new.ARC_CHAR5_VALUE, 'null') <> nvl(:old.ARC_CHAR5_VALUE, 'null') )
          or (nvl(:new.ARC_QUANTITY, 0) <> nvl(:old.ARC_QUANTITY, 0) )
          or (nvl(:new.STM_COMP_STOCK_MVT_ID, 0) <> nvl(:old.STM_COMP_STOCK_MVT_ID, 0) )
         ) then
    select count(*)
      into vCount
      from FAL_NETWORK_NEED FAN
         , FAL_NETWORK_LINK FLN
         , STM_STOCK_POSITION SPO
         , DOC_POSITION_DETAIL PDE
     where SPO.STM_STOCK_POSITION_ID(+) = FLN.STM_STOCK_POSITION_ID
       and FLN.FAL_NETWORK_NEED_ID(+) = FAN.FAL_NETWORK_NEED_ID
       and FAN.DOC_POSITION_DETAIL_ID(+) = PDE.DOC_POSITION_DETAIL_ID
       and PDE.DOC_POSITION_ID = :new.DOC_ATTRIB_POSITION_ID
       and nvl(FLN.STM_LOCATION_ID, 0) = nvl(:new.STM_COMP_LOCATION_ID, 0)
       and nvl(SPO.SPO_CHARACTERIZATION_VALUE_1, 'null') = nvl(:new.ARC_CHAR1_VALUE, 'null')
       and nvl(SPO.SPO_CHARACTERIZATION_VALUE_2, 'null') = nvl(:new.ARC_CHAR2_VALUE, 'null')
       and nvl(SPO.SPO_CHARACTERIZATION_VALUE_3, 'null') = nvl(:new.ARC_CHAR3_VALUE, 'null')
       and nvl(SPO.SPO_CHARACTERIZATION_VALUE_4, 'null') = nvl(:new.ARC_CHAR4_VALUE, 'null')
       and nvl(SPO.SPO_CHARACTERIZATION_VALUE_5, 'null') = nvl(:new.ARC_CHAR5_VALUE, 'null');

    if vCount = 0 then
      :new.DOC_ATTRIB_POSITION_ID  := null;
    end if;
  end if;
end ASA_ARC_BU_ATTRIB;

ALTER TRIGGER "C_ITX"."ASA_ARC_BU_ATTRIB" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_ARE_AI_FREE_NUMBER"
after insert
on ASA_RECORD
referencing OLD as OLD new as new
for each row
/**
* Description
*    Suppression du numéro de dossier dans la table doc_free_number
* @author AG
* @version DEVELOP
* @lastUpdate
*/


declare
  gau_number         DOC_GAUGE.GAU_NUMBERING%type;
  gauge_numbering_id DOC_GAUGE.DOC_GAUGE_NUMBERING_ID%type;
  gauge_name         DOC_GAUGE.GAU_DESCRIBE%type;
  free_number        DOC_GAUGE_NUMBERING.GAN_FREE_NUMBER%type;
begin

  select DOC_GAUGE.GAU_NUMBERING
       , DOC_GAUGE.DOC_GAUGE_NUMBERING_ID
       , DOC_GAUGE_NUMBERING.GAN_FREE_NUMBER into
         gau_number
       , gauge_numbering_id
       , free_number
    from DOC_GAUGE
       , DOC_GAUGE_NUMBERING
   where DOC_GAUGE.DOC_GAUGE_ID = :new.DOC_GAUGE_ID
     and DOC_GAUGE_NUMBERING.DOC_GAUGE_NUMBERING_ID (+) = DOC_GAUGE.DOC_GAUGE_NUMBERING_ID;

  -- si on gère la numérotation sur ce type de document
  if (gau_number = 1) and (free_number = 1) then

    delete from DOC_FREE_NUMBER
     where (DOF_NUMBER = '*'||:new.ARE_NUMBER or DOF_NUMBER = :new.ARE_NUMBER)
       and DOC_GAUGE_NUMBERING_ID = gauge_numbering_id;

  end if;

end ASA_ARE_AI_FREE_NUMBER;


ALTER TRIGGER "C_ITX"."ASA_ARE_AI_FREE_NUMBER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_ARE_AU_DELAY"
  after update of ARE_DATE_REG_REP, ARE_NB_DAYS_WAIT
  on ASA_RECORD
  referencing old as old new as new
  for each row
/**
* Description
*     Mise à jour du délai des détails de position du document d'attribution du dossier SAV
* @author DSA
* @version 2003
* @lastUpdate
*/
declare
  aDelay DOC_POSITION_DETAIL.PDE_BASIS_DELAY%type;
begin
  if    (:new.ARE_DATE_REG_REP <> :old.ARE_DATE_REG_REP)
     or (:new.ARE_NB_DAYS_WAIT <> :old.ARE_NB_DAYS_WAIT) then
    -- Recherche du nouveau délai des détails de position
    aDelay  :=
      DOC_DELAY_FUNCTIONS.GetShiftOpenDate(aDate          => :new.ARE_DATE_REG_REP
                                         , aCalcDays      => :new.ARE_NB_DAYS_WAIT
                                         , aAdminDomain   => '7'
                                         , aThirdID       => :new.PAC_CUSTOM_PARTNER_ID
                                         , aForward       => 1
                                          );

    -- Mise à jour de tous les détails de positions non liquidées du document d'attribution
    update DOC_POSITION_DETAIL
       set PDE_BASIS_DELAY = nvl(aDelay, PDE_BASIS_DELAY)
         , PDE_INTERMEDIATE_DELAY = nvl(aDelay, PDE_INTERMEDIATE_DELAY)
         , PDE_FINAL_DELAY = nvl(aDelay, PDE_FINAL_DELAY)
     where DOC_POSITION_ID in(
             select POS.DOC_POSITION_ID
               from DOC_POSITION POS
                  , ASA_RECORD_COMP ARC
              where POS.DOC_POSITION_ID = ARC.DOC_ATTRIB_POSITION_ID
                and ARC.ASA_RECORD_ID = :new.ASA_RECORD_ID
                and ARC.ASA_RECORD_EVENTS_ID = :new.ASA_RECORD_EVENTS_ID
                and (   POS.C_DOC_POS_STATUS = '01'
                     or POS.C_DOC_POS_STATUS = '02') );
  end if;
end ASA_ARE_AU_DELAY;

ALTER TRIGGER "C_ITX"."ASA_ARE_AU_DELAY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_ARE_BD_CONSTRAINTS"
  before delete
  on ASA_RECORD
  referencing old as old new as new
  for each row
/**
* Description
*    Suppression de tous les diagnostics du dossier de réparation
*    et de tous les textes de documents
* @version 2003
*/
begin
  delete from ASA_DIAGNOSTICS
        where ASA_RECORD_ID = :old.ASA_RECORD_ID;

  delete from ASA_RECORD_DOC_TEXT
        where ASA_RECORD_ID = :old.ASA_RECORD_ID;
end ASA_ARE_BD_CONSTRAINTS;

ALTER TRIGGER "C_ITX"."ASA_ARE_BD_CONSTRAINTS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_ARE_BD_FREE_NUMBER"
before delete
on ASA_RECORD
referencing old as old new as new
for each row
/**
* Description
*   Vérifie que le dossier ne soit pas encore en mode protégé lors de l'effacement
*   Récupération du numéro de dossier dans la table doc_free_number
* @author AG
* @version DEVELOP
* @lastUpdate
*/


declare
  gau_number                   DOC_GAUGE.GAU_NUMBERING%type;
  gauge_numbering_id           DOC_GAUGE.DOC_GAUGE_NUMBERING_ID%type;
  free_number                  DOC_GAUGE_NUMBERING.GAN_FREE_NUMBER%type;
  temp_number                  DOC_FREE_NUMBER.DOF_NUMBER%type;
  temp_gaugestructuredid       DOC_GAUGE_STRUCTURED.DOC_GAUGE_ID%type;
begin

  -- Récupération du numéro de dossier seulement si le document qui est en train d'être
  -- effacé ne possède pas de gabarit structuré

  select GAU_NUMBERING
       , DOC_GAUGE.DOC_GAUGE_NUMBERING_ID
       , GAN_FREE_NUMBER into
         gau_number
       , gauge_numbering_id
       , free_number
    from DOC_GAUGE, DOC_GAUGE_NUMBERING
   where DOC_GAUGE_ID = :old.DOC_GAUGE_ID
     and DOC_GAUGE_NUMBERING.DOC_GAUGE_NUMBERING_ID (+) = DOC_GAUGE.DOC_GAUGE_NUMBERING_ID;

  -- si on gère la numérotation sur ce type de document
  if (gau_number = 1) and (free_number = 1) then

    select MAX(DOF_NUMBER) into temp_number
      from DOC_FREE_NUMBER
     where (DOF_NUMBER = :old.ARE_NUMBER or DOF_NUMBER = CONCAT('*',:old.ARE_NUMBER)) and
           DOC_GAUGE_NUMBERING_ID = gauge_numbering_id;

    -- Il faut que le numéro n'existe pas encore dans la table des numéros libres
    if temp_number is null then
      insert into DOC_FREE_NUMBER (DOC_FREE_NUMBER_ID, DOC_GAUGE_NUMBERING_ID, DOF_NUMBER)
        values (init_id_seq.nextval, gauge_numbering_id, :old.ARE_NUMBER);
    end if;

  end if;

end ASA_ARE_BD_FREE_NUMBER;


ALTER TRIGGER "C_ITX"."ASA_ARE_BD_FREE_NUMBER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_ARE_BID_MISSING_NUMBERS"
  after insert or delete or update of "ARE_NUMBER"
  on ASA_RECORD
  referencing old as old new as new
  for each row
/**
* Description
*    Gestion des numéros manquants
* @created DSA 08.11.2004
* @version 2003
* @lastUpdate
*/
declare
  ganIncrement DOC_GAUGE_NUMBERING.GAN_INCREMENT%type;
begin
  -- suppression du numéro manquant
  if    inserting
     or updating then
    delete from DOC_MISSING_NUMBER
          where DMN_NUMBER = :new.ARE_NUMBER;
  end if;

  -- insertion du numéro dans la liste des numéros manquants
  if    updating
     or deleting then
    select gan.gan_increment
      into ganIncrement
      from doc_gauge gau
         , doc_gauge_numbering gan
     where gau.doc_gauge_id = :old.DOC_GAUGE_ID
       and gau.doc_gauge_numbering_id = gan.doc_gauge_numbering_id(+);

    if ganIncrement = 1 then
      begin
        insert into DOC_MISSING_NUMBER
                    (DOC_MISSING_NUMBER_ID
                   , DOC_GAUGE_NUMBERING_ID
                   , STM_EXERCISE_ID
                   , DOC_GAUGE_ID
                   , DMN_NUMBER
                   , DMN_CREATING
                   , A_DATECRE
                   , A_IDCRE
                    )
          select init_id_seq.nextval
               , DOC_GAUGE_NUMBERING_ID
               , STM_FUNCTIONS.GetPeriodExerciseId(STM_FUNCTIONS.GetPeriodId(:old.ARE_DATECRE) )
               , :old.DOC_GAUGE_ID
               , :old.ARE_NUMBER
               , 0
               , sysdate
               , PCS.PC_I_LIB_SESSION.GetUserIni
            from DOC_GAUGE
           where DOC_GAUGE_ID = :old.DOC_GAUGE_ID;
      exception
        when dup_val_on_index then   -- ne pas déclencher d'exception si insertion de doublon
          null;
      end;
    end if;
  end if;
end ASA_ARE_BID_MISSING_NUMBERS;

ALTER TRIGGER "C_ITX"."ASA_ARE_BID_MISSING_NUMBERS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_ARE_BI_RECORD"
BEFORE INSERT ON ASA_RECORD
Referencing OLD as OLD NEW as NEW
For each row
/**
* Description
*     Créeation autotmatique du dossier pour les document SAV
* @author AG
* @version DEVELOP
* @lastUpdate
*/


declare
  CreatedRecordId ASA_RECORD.DOC_RECORD_ID%TYPE;
Begin
  if (:NEW.DOC_RECORD_ID is Null) then
    CreatedRecordID := DOC_RECORD_MANAGEMENT.CreateRecord(:NEW.DOC_GAUGE_ID,
					   									  '',
                                                          :NEW.DOC_RECORD_ID,
                                                          :NEW.PAC_CUSTOM_PARTNER_ID,
                                                          :NEW.ARE_NUMBER);
    if CreatedRecordId <> -1 then
      :NEW.DOC_RECORD_ID := CreatedRecordId;
    end if;
  end if;
end ASA_ARE_BI_RECORD;


ALTER TRIGGER "C_ITX"."ASA_ARE_BI_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_ARE_BIUD_ELEMENT_NUMBER"
  before insert or delete or update of GCO_ASA_TO_REPAIR_ID
                                     , ARE_CHAR1_VALUE
                                     , ARE_CHAR2_VALUE
                                     , ARE_CHAR3_VALUE
                                     , ARE_CHAR4_VALUE
                                     , ARE_CHAR5_VALUE
                                     , ARE_NEW_CHAR1_VALUE
                                     , ARE_NEW_CHAR2_VALUE
                                     , ARE_NEW_CHAR3_VALUE
                                     , ARE_NEW_CHAR4_VALUE
                                     , ARE_NEW_CHAR5_VALUE
  on ASA_RECORD
  referencing old as old new as new
  for each row
/**
* Description
*    Maj de STM_ELEMENT_NUMBER
* @created fp 23.09.2003
* @version 2003
* @lastUpdate
*/
declare
  vMovementSort     STM_MOVEMENT_KIND.C_MOVEMENT_SORT%type;
  vElementNumberID1 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vElementNumberID2 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vElementNumberID3 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  lQualityStatusId  STM_ELEMENT_NUMBER.GCO_QUALITY_STATUS_ID%type;
begin
  /* Produit à réparer */

  -- si on a au moins une caractérization
  if nvl(:new.GCO_CHAR1_ID, :old.GCO_CHAR1_ID) is not null then
    -- Reception PT => Entrée en stock
    vMovementSort  := 'ENT';

    -- En effacement et en modification, traitement des anciennes valeurs
    if    deleting
       or updating then
      -- Maj STM_ELEMENT_NUMBER en mode suppression
      STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => :old.GCO_ASA_TO_REPAIR_ID   -- Bien
                                              , iUpdateMode               => 'D'   -- Mode de mise à jour
                                              , iMovementSort             => vMovementSort   -- Type de mouvement 'ENT' = Entrée 'SOR' = Sortie
                                              , iCharacterizationId       => :old.GCO_CHAR1_ID   -- Caractérisation
                                              , iCharacterization2Id      => :old.GCO_CHAR2_ID
                                              , iCharacterization3Id      => :old.GCO_CHAR3_ID
                                              , iCharacterization4Id      => :old.GCO_CHAR4_ID
                                              , iCharacterization5Id      => :old.GCO_CHAR5_ID
                                              , iCharacterizationValue1   => :old.ARE_CHAR1_VALUE   -- Valeur de caractérisation
                                              , iCharacterizationValue2   => :old.ARE_CHAR2_VALUE
                                              , iCharacterizationValue3   => :old.ARE_CHAR3_VALUE
                                              , iCharacterizationValue4   => :old.ARE_CHAR4_VALUE
                                              , iCharacterizationValue5   => :old.ARE_CHAR5_VALUE
                                              , iVerifyChar               => 1   -- Vérification de l'unicité des valeurs de caract.
                                              , iElementStatus            => null   -- Statut de l'élement après mise à jour
                                              , ioElementNumberId1        => vElementNumberID1   -- Elément 1 en sortie
                                              , ioElementNumberId2        => vElementNumberID2   -- Elément 2 en sortie
                                              , ioElementNumberId3        => vElementNumberID3   -- Elément 3 en sortie
                                              , ioQualityStatusId         => lQualityStatusId
                                               );
    end if;

    -- En création et en modification, traitement des nouvelles valeurs
    if    inserting
       or updating then
      -- Maj STM_ELEMENT_NUMBER en mode insertion
      STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => :new.GCO_ASA_TO_REPAIR_ID   -- Bien
                                              , iUpdateMode               => 'H'   -- Mode de mise à jour
                                              , iMovementSort             => vMovementSort   -- Type de mouvement 'ENT' = Entrée 'SOR' = Sortie
                                              , iCharacterizationId       => :new.GCO_CHAR1_ID   -- Caractérisation
                                              , iCharacterization2Id      => :new.GCO_CHAR2_ID
                                              , iCharacterization3Id      => :new.GCO_CHAR3_ID
                                              , iCharacterization4Id      => :new.GCO_CHAR4_ID
                                              , iCharacterization5Id      => :new.GCO_CHAR5_ID
                                              , iCharacterizationValue1   => :new.ARE_CHAR1_VALUE   -- Valeur de caractérisation
                                              , iCharacterizationValue2   => :new.ARE_CHAR2_VALUE
                                              , iCharacterizationValue3   => :new.ARE_CHAR3_VALUE
                                              , iCharacterizationValue4   => :new.ARE_CHAR4_VALUE
                                              , iCharacterizationValue5   => :new.ARE_CHAR5_VALUE
                                              , iVerifyChar               => 1   -- Vérification de l'unicité des valeurs de caract.
                                              , iElementStatus            => null   -- Statut de l'élement après mise à jour
                                              , ioElementNumberId1        => vElementNumberID1   -- Elément 1 en sortie
                                              , ioElementNumberId2        => vElementNumberID2   -- Elément 2 en sortie
                                              , ioElementNumberId3        => vElementNumberID3   -- Elément 3 en sortie
                                              , ioQualityStatusId         => lQualityStatusId
                                               );
    end if;
  end if;

  /* Produit Réparé */
  -- si on a au moins une caractérization
  if nvl(:new.GCO_NEW_CHAR1_ID, :old.GCO_NEW_CHAR1_ID) is not null then
    -- Reception PT => Entrée en stock
    vMovementSort  := 'SOR';

    -- En effacement et en modification, traitement des anciennes valeurs
    if    deleting
       or updating then
      -- Maj STM_ELEMENT_NUMBER en mode suppression
      STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => :old.GCO_NEW_GOOD_ID   -- Bien
                                              , iUpdateMode               => 'D'   -- Mode de mise à jour
                                              , iMovementSort             => vMovementSort   -- Type de mouvement 'ENT' = Entrée 'SOR' = Sortie
                                              , iCharacterizationId       => :old.GCO_NEW_CHAR1_ID   -- Caractérisation
                                              , iCharacterization2Id      => :old.GCO_NEW_CHAR2_ID
                                              , iCharacterization3Id      => :old.GCO_NEW_CHAR3_ID
                                              , iCharacterization4Id      => :old.GCO_NEW_CHAR4_ID
                                              , iCharacterization5Id      => :old.GCO_NEW_CHAR5_ID
                                              , iCharacterizationValue1   => :old.ARE_NEW_CHAR1_VALUE   -- Valeur de caractérisation
                                              , iCharacterizationValue2   => :old.ARE_NEW_CHAR2_VALUE
                                              , iCharacterizationValue3   => :old.ARE_NEW_CHAR3_VALUE
                                              , iCharacterizationValue4   => :old.ARE_NEW_CHAR4_VALUE
                                              , iCharacterizationValue5   => :old.ARE_NEW_CHAR5_VALUE
                                              , iVerifyChar               => 1   -- Vérification de l'unicité des valeurs de caract.
                                              , iElementStatus            => null   -- Statut de l'élement après mise à jour
                                              , ioElementNumberId1        => vElementNumberID1   -- Elément 1 en sortie
                                              , ioElementNumberId2        => vElementNumberID2   -- Elément 2 en sortie
                                              , ioElementNumberId3        => vElementNumberID3   -- Elément 3 en sortie
                                              , ioQualityStatusId         => lQualityStatusId
                                               );
    end if;

    -- En création et en modification, traitement des nouvelles valeurs
    if    inserting
       or updating then
      -- Maj STM_ELEMENT_NUMBER en mode insertion
      STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => :new.GCO_NEW_GOOD_ID   -- Bien
                                              , iUpdateMode               => 'H'   -- Mode de mise à jour
                                              , iMovementSort             => vMovementSort   -- Type de mouvement 'ENT' = Entrée 'SOR' = Sortie
                                              , iCharacterizationId       => :new.GCO_NEW_CHAR1_ID   -- Caractérisation
                                              , iCharacterization2Id      => :new.GCO_NEW_CHAR2_ID
                                              , iCharacterization3Id      => :new.GCO_NEW_CHAR3_ID
                                              , iCharacterization4Id      => :new.GCO_NEW_CHAR4_ID
                                              , iCharacterization5Id      => :new.GCO_NEW_CHAR5_ID
                                              , iCharacterizationValue1   => :new.ARE_NEW_CHAR1_VALUE   -- Valeur de caractérisation
                                              , iCharacterizationValue2   => :new.ARE_NEW_CHAR2_VALUE
                                              , iCharacterizationValue3   => :new.ARE_NEW_CHAR3_VALUE
                                              , iCharacterizationValue4   => :new.ARE_NEW_CHAR4_VALUE
                                              , iCharacterizationValue5   => :new.ARE_NEW_CHAR5_VALUE
                                              , iVerifyChar               => 1   -- Vérification de l'unicité des valeurs de caract.
                                              , iElementStatus            => null   -- Statut de l'élement après mise à jour
                                              , ioElementNumberId1        => vElementNumberID1   -- Elément 1 en sortie
                                              , ioElementNumberId2        => vElementNumberID2   -- Elément 2 en sortie
                                              , ioElementNumberId3        => vElementNumberID3   -- Elément 3 en sortie
                                              , ioQualityStatusId         => lQualityStatusId
                                               );
    end if;
  end if;
end ASA_ARE_BIUD_ELEMENT_NUMBER;

ALTER TRIGGER "C_ITX"."ASA_ARE_BIUD_ELEMENT_NUMBER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_ARE_BIU_DENORM_CHAR"
  before insert or update of GCO_CHAR1_ID
                           , GCO_CHAR2_ID
                           , GCO_CHAR3_ID
                           , GCO_CHAR4_ID
                           , GCO_CHAR5_ID
                           , ARE_CHAR1_VALUE
                           , ARE_CHAR2_VALUE
                           , ARE_CHAR3_VALUE
                           , ARE_CHAR4_VALUE
                           , ARE_CHAR5_VALUE
  on ASA_RECORD
  referencing old as old new as new
  for each row
/**
* Description
*    Dénormalisation des caractérisations dans l'événement before insert/update
* @author DSA
* @created 10.01.2005
* @version 2003
* @lastUpdate 10.01.2005
*/
begin
  -- on vérifie que ce trigger est déclenché par une modif d'un des champs ci-dessous
  if    nvl(:old.GCO_CHAR1_ID, -1) <> nvl(:new.GCO_CHAR1_ID, -1)
     or nvl(:old.GCO_CHAR2_ID, -1) <> nvl(:new.GCO_CHAR2_ID, -1)
     or nvl(:old.GCO_CHAR3_ID, -1) <> nvl(:new.GCO_CHAR3_ID, -1)
     or nvl(:old.GCO_CHAR4_ID, -1) <> nvl(:new.GCO_CHAR4_ID, -1)
     or nvl(:old.GCO_CHAR5_ID, -1) <> nvl(:new.GCO_CHAR5_ID, -1)
     or nvl(:old.ARE_CHAR1_VALUE, 'null') <> nvl(:new.ARE_CHAR1_VALUE, 'null')
     or nvl(:old.ARE_CHAR2_VALUE, 'null') <> nvl(:new.ARE_CHAR2_VALUE, 'null')
     or nvl(:old.ARE_CHAR3_VALUE, 'null') <> nvl(:new.ARE_CHAR3_VALUE, 'null')
     or nvl(:old.ARE_CHAR4_VALUE, 'null') <> nvl(:new.ARE_CHAR4_VALUE, 'null')
     or nvl(:old.ARE_CHAR5_VALUE, 'null') <> nvl(:new.ARE_CHAR5_VALUE, 'null') then
    -- vérifie qu'on ait au moins une caractérisation
    if :new.GCO_CHAR1_ID is not null then
      -- Mise à jour des champs dénormalisé d'affichage des caractérisations
      GCO_FUNCTIONS.ClassifyCharacterizations(:new.GCO_CHAR1_ID
                                            , :new.GCO_CHAR2_ID
                                            , :new.GCO_CHAR3_ID
                                            , :new.GCO_CHAR4_ID
                                            , :new.GCO_CHAR5_ID
                                            , :new.ARE_CHAR1_VALUE
                                            , :new.ARE_CHAR2_VALUE
                                            , :new.ARE_CHAR3_VALUE
                                            , :new.ARE_CHAR4_VALUE
                                            , :new.ARE_CHAR5_VALUE
                                            , :new.ARE_PIECE
                                            , :new.ARE_SET
                                            , :new.ARE_VERSION
                                            , :new.ARE_CHRONOLOGICAL
                                            , :new.ARE_STD_CHAR_1
                                            , :new.ARE_STD_CHAR_2
                                            , :new.ARE_STD_CHAR_3
                                            , :new.ARE_STD_CHAR_4
                                            , :new.ARE_STD_CHAR_5
                                             );
    end if;
  end if;
end ASA_ARE_BIU_DENORM_CHAR;


ALTER TRIGGER "C_ITX"."ASA_ARE_BIU_DENORM_CHAR" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_ASG_BIUD_ELEMENT_NUMBER"
  before insert or delete or update of ASG_CHAR1_VALUE, ASG_CHAR2_VALUE, ASG_CHAR3_VALUE, ASG_CHAR4_VALUE, ASG_CHAR5_VALUE
  on ASA_STOLEN_GOODS
  referencing old as old new as new
  for each row
/**
* Description
*    Maj de STM_ELEMENT_NUMBER
* @created fp 25.09.2003
* @version 2003
* @lastUpdate
*/
declare
  vMovementSort     STM_MOVEMENT_KIND.C_MOVEMENT_SORT%type;
  vElementNumberID1 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vElementNumberID2 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vElementNumberID3 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  lQualityStatusId  STM_ELEMENT_NUMBER.GCO_QUALITY_STATUS_ID%type;
  updateMode        varchar2(2);
begin
  -- si on a au moins une caractérization
  if nvl(:new.GCO_CHAR1_ID, :old.GCO_CHAR1_ID) is not null then
    -- Reception PT => Entrée en stock
    vMovementSort  := 'ENT';

    -- En effacement et en modification, traitement des anciennes valeurs
    if    deleting
       or updating then
      -- Maj STM_ELEMENT_NUMBER en mode suppression
      STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => :old.GCO_GOOD_ID   -- Bien
                                              , iUpdateMode               => 'D'   -- Mode de mise à jour
                                              , iMovementSort             => vMovementSort   -- Type de mouvement 'ENT' = Entrée 'SOR' = Sortie
                                              , iCharacterizationId       => :old.GCO_CHAR1_ID   -- Caractérisation
                                              , iCharacterization2Id      => :old.GCO_CHAR2_ID
                                              , iCharacterization3Id      => :old.GCO_CHAR3_ID
                                              , iCharacterization4Id      => :old.GCO_CHAR4_ID
                                              , iCharacterization5Id      => :old.GCO_CHAR5_ID
                                              , iCharacterizationValue1   => :old.ASG_CHAR1_VALUE   -- Valeur de caractérisation
                                              , iCharacterizationValue2   => :old.ASG_CHAR2_VALUE
                                              , iCharacterizationValue3   => :old.ASG_CHAR3_VALUE
                                              , iCharacterizationValue4   => :old.ASG_CHAR4_VALUE
                                              , iCharacterizationValue5   => :old.ASG_CHAR5_VALUE
                                              , iVerifyChar               => 1   -- Vérification de l'unicité des valeurs de caract.
                                              , iElementStatus            => null   -- Statut de l'élement après mise à jour
                                              , ioElementNumberId1        => vElementNumberID1   -- Elément 1 en sortie
                                              , ioElementNumberId2        => vElementNumberID2   -- Elément 2 en sortie
                                              , ioElementNumberId3        => vElementNumberID3   -- Elément 3 en sortie
                                              , ioQualityStatusId         => lQualityStatusId
                                               );
    end if;

    -- En création et en modification, traitement des nouvelles valeurs
    if    inserting
       or updating then
      -- Maj STM_ELEMENT_NUMBER en mode insertion
      STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => :new.GCO_GOOD_ID   -- Bien
                                              , iUpdateMode               => 'H'   -- Mode de mise à jour
                                              , iMovementSort             => vMovementSort   -- Type de mouvement 'ENT' = Entrée 'SOR' = Sortie
                                              , iCharacterizationId       => :new.GCO_CHAR1_ID   -- Caractérisation
                                              , iCharacterization2Id      => :new.GCO_CHAR2_ID
                                              , iCharacterization3Id      => :new.GCO_CHAR3_ID
                                              , iCharacterization4Id      => :new.GCO_CHAR4_ID
                                              , iCharacterization5Id      => :new.GCO_CHAR5_ID
                                              , iCharacterizationValue1   => :new.ASG_CHAR1_VALUE   -- Valeur de caractérisation
                                              , iCharacterizationValue2   => :new.ASG_CHAR2_VALUE
                                              , iCharacterizationValue3   => :new.ASG_CHAR3_VALUE
                                              , iCharacterizationValue4   => :new.ASG_CHAR4_VALUE
                                              , iCharacterizationValue5   => :new.ASG_CHAR5_VALUE
                                              , iVerifyChar               => 1   -- Vérification de l'unicité des valeurs de caract.
                                              , iElementStatus            => null   -- Statut de l'élement après mise à jour
                                              , ioElementNumberId1        => vElementNumberID1   -- Elément 1 en sortie
                                              , ioElementNumberId2        => vElementNumberID2   -- Elément 2 en sortie
                                              , ioElementNumberId3        => vElementNumberID3   -- Elément 3 en sortie
                                              , ioQualityStatusId         => lQualityStatusId
                                               );
    end if;
  end if;
end ASA_ASG_BIUD_ELEMENT_NUMBER;

ALTER TRIGGER "C_ITX"."ASA_ASG_BIUD_ELEMENT_NUMBER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_BIU_OBJECT_ACL"
  before insert or update
  on ASA_RECORD_OBJECT_ACL
  referencing old as old new as new
  for each row
/**
* Description
*     Mise Ã  jour des champs obligatoire pour la saisie depuis un GridLaunch
* @author SKalayci
* @version 2003
* @lastUpdate
*/
declare
begin
  if inserting then
    :new.ASA_RECORD_OBJECT_ACL_ID := init_id_seq.nextval;
    :new.A_DATECRE := sysdate;
    :new.A_IDCRE := PCS.PC_I_LIB_SESSION.GetUserIni;
  else
    :new.A_DATEMOD := sysdate;
    :new.A_IDMOD := PCS.PC_I_LIB_SESSION.GetUserIni;
  end if;
end ASA_BIU_OBJECT_ACL;

ALTER TRIGGER "C_ITX"."ASA_BIU_OBJECT_ACL" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_BIU_TRF_DEST"
  before insert or update
  on ASA_RECORD_TRF_DEST
  referencing old as old new as new
  for each row
/**
* Description
*     Mise Ã  jour des champs obligatoire pour la saisie depuis un GridLaunch
* @author SKalayci
* @version 2003
* @lastUpdate
*/
declare
begin
  if inserting then
    :new.ASA_RECORD_TRF_DEST_ID  := init_id_seq.nextval;
    :new.A_DATECRE               := sysdate;
    :new.A_IDCRE                 := PCS.PC_I_LIB_SESSION.GetUserIni;
  else
    :new.A_DATEMOD  := sysdate;
    :new.A_IDMOD    := PCS.PC_I_LIB_SESSION.GetUserIni;
  end if;
end ASA_BIU_TRF_DEST;

ALTER TRIGGER "C_ITX"."ASA_BIU_TRF_DEST" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_BIU_TRF_SRC"
  before insert or update
  on ASA_RECORD_TRF_SRC
  referencing old as old new as new
  for each row
/**
* Description
*     Mise à jour des champs obligatoire pour la saisie depuis un GridLaunch
* @author SKalayci
* @version 2003
* @lastUpdate
*/
declare
begin
  if inserting then
    :new.ASA_RECORD_TRF_SRC_ID  := init_id_seq.nextval;
    :new.A_DATECRE               := sysdate;
    :new.A_IDCRE                 := PCS.PC_I_LIB_SESSION.GetUserIni;
  else
    :new.A_DATEMOD  := sysdate;
    :new.A_IDMOD    := PCS.PC_I_LIB_SESSION.GetUserIni;
  end if;
end ASA_BIU_TRF_SRC;

ALTER TRIGGER "C_ITX"."ASA_BIU_TRF_SRC" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_BIU_TRF_SRC_FLOW"
  before insert or update
  on ASA_RECORD_MSG_SRC_FLOW
  referencing old as old new as new
  for each row
/**
* Description
*     Mise à jour des champs obligatoire pour la saisie depuis un GridLaunch
* @author SKalayci
* @version 2003
* @lastUpdate
*/
declare
begin
  if inserting then
    :new.ASA_RECORD_MSG_SRC_FLOW_ID  := init_id_seq.nextval;
    :new.A_DATECRE                   := sysdate;
    :new.A_IDCRE                     := PCS.PC_I_LIB_SESSION.GetUserIni;
  else
    :new.A_DATEMOD  := sysdate;
    :new.A_IDMOD    := PCS.PC_I_LIB_SESSION.GetUserIni;
  end if;
end ASA_BIU_TRF_SRC_FLOW;

ALTER TRIGGER "C_ITX"."ASA_BIU_TRF_SRC_FLOW" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_ITR_AU_TARIFF"
  after update of ITR_START_DATE
  on ASA_INTERVENTION
  referencing old as old new as new
  for each row
/**
* Description
*     Mise à jour des tarifs des détails d'intervention
* @author DSA
* @version 2003
* @lastUpdate
*/
declare
  vDIC_TARIFF_ID                ASA_MISSION.DIC_TARIFF_ID%type;
  vASA_MISSION_TYPE_ID          ASA_MISSION.ASA_MISSION_TYPE_ID%type;
  vCML_POSITION_ID              ASA_MISSION.CML_POSITION_ID%type;
  vPAC_CUSTOM_PARTNER_ID        ASA_MISSION.PAC_CUSTOM_PARTNER_ID%type;
  vPAC_CUSTOM_PARTNER_TARIFF_ID ASA_MISSION.PAC_CUSTOM_PARTNER_TARIFF_ID%type;
  vDOC_RECORD_ID                ASA_MISSION.DOC_RECORD_ID%type;
  vMIS_REQUEST_DATE             ASA_MISSION.MIS_REQUEST_DATE%type;
  vACS_FINANCIAL_CURRENCY_ID    ASA_MISSION.ACS_FINANCIAL_CURRENCY_ID%type;
begin
  if (trunc(nvl(:old.ITR_START_DATE, to_date('01.01.1899', 'dd.mm.yyyy') ) ) <>
                                                  trunc(nvl(:new.ITR_START_DATE, to_date('01.01.1899', 'dd.mm.yyyy') ) )
     ) then
    select DIC_TARIFF_ID
         , ASA_MISSION_TYPE_ID
         , CML_POSITION_ID
         , PAC_CUSTOM_PARTNER_ID
         , PAC_CUSTOM_PARTNER_TARIFF_ID
         , DOC_RECORD_ID
         , MIS_REQUEST_DATE
         , ACS_FINANCIAL_CURRENCY_ID
      into vDIC_TARIFF_ID
         , vASA_MISSION_TYPE_ID
         , vCML_POSITION_ID
         , vPAC_CUSTOM_PARTNER_ID
         , vPAC_CUSTOM_PARTNER_TARIFF_ID
         , vDOC_RECORD_ID
         , vMIS_REQUEST_DATE
         , vACS_FINANCIAL_CURRENCY_ID
      from ASA_MISSION
     where ASA_MISSION_ID = :new.ASA_MISSION_ID;

    -- la modification de la date début intervention entraîne la mise à jour des tarifs des détails d'intervention
    for cr_IntervDet in (select AID.ASA_INTERVENTION_DETAIL_ID
                           from ASA_INTERVENTION_DETAIL AID
                          where AID.ASA_INTERVENTION_ID = :new.ASA_INTERVENTION_ID) loop
      ASA_MISSION_FUNCTIONS.SetPrices(aASA_INTERVENTION_DETAIL_ID     => cr_IntervDet.ASA_INTERVENTION_DETAIL_ID
                                    , aDIC_TARIFF_ID                  => vDIC_TARIFF_ID
                                    , aASA_MISSION_TYPE_ID            => vASA_MISSION_TYPE_ID
                                    , aCML_POSITION_ID                => vCML_POSITION_ID
                                    , aPAC_CUSTOM_PARTNER_ID          => vPAC_CUSTOM_PARTNER_ID
                                    , aPAC_CUSTOM_PARTNER_TARIFF_ID   => vPAC_CUSTOM_PARTNER_TARIFF_ID
                                    , aDOC_RECORD_ID                  => vDOC_RECORD_ID
                                    , aMIS_REQUEST_DATE               => vMIS_REQUEST_DATE
                                    , aACS_FINANCIAL_CURRENCY_ID      => vACS_FINANCIAL_CURRENCY_ID
                                    , aITR_START_DATE                 => :new.ITR_START_DATE
                                     );
    end loop;
  end if;
end ASA_ITR_AU_TARIFF;

ALTER TRIGGER "C_ITX"."ASA_ITR_AU_TARIFF" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_MIS_AU_TARIFF"
  after update of PAC_CUSTOM_PARTNER_ID
                , CML_POSITION_ID
                , PAC_CUSTOM_PARTNER_TARIFF_ID
                , DIC_TARIFF_ID
                , PAC_CUSTOM_PARTNER_ACI_ID
                , ACS_FINANCIAL_CURRENCY_ID
                , MIS_REQUEST_DATE
  on ASA_MISSION
  referencing old as old new as new
  for each row
/**
* Description
*     Mise à jour des tarifs des détails d'intervention
* @author DSA
* @version 2003
* @lastUpdate
*/
begin
  if    (nvl(:old.PAC_CUSTOM_PARTNER_ID, 0) <> nvl(:new.PAC_CUSTOM_PARTNER_ID, 0) )
     or (nvl(:old.CML_POSITION_ID, 0) <> nvl(:new.CML_POSITION_ID, 0) )
     or (nvl(:old.PAC_CUSTOM_PARTNER_TARIFF_ID, 0) <> nvl(:new.PAC_CUSTOM_PARTNER_TARIFF_ID, 0) )
     or (nvl(:old.DIC_TARIFF_ID, 0) <> nvl(:new.DIC_TARIFF_ID, 0) )
     or (nvl(:old.PAC_CUSTOM_PARTNER_ACI_ID, 0) <> nvl(:new.PAC_CUSTOM_PARTNER_ACI_ID, 0) )
     or (nvl(:old.ACS_FINANCIAL_CURRENCY_ID, 0) <> nvl(:new.ACS_FINANCIAL_CURRENCY_ID, 0) )
     or (trunc(nvl(:old.MIS_REQUEST_DATE, to_date('01.01.1899', 'dd.mm.yyyy') ) ) <>
                                                trunc(nvl(:new.MIS_REQUEST_DATE, to_date('01.01.1899', 'dd.mm.yyyy') ) )
        ) then
    -- la modification de la date de la demande entraîne seulement la mise à jour des tarifs des détails d'intervention
    -- dont la date début est nulle. Les autres modifications entrainent la màj de tous les détails
    for cr_IntervDet in (select AID.ASA_INTERVENTION_DETAIL_ID
                              , ITR.ITR_START_DATE
                           from ASA_INTERVENTION_DETAIL AID
                              , ASA_INTERVENTION ITR
                          where AID.ASA_INTERVENTION_ID = ITR.ASA_INTERVENTION_ID
                            and ITR.ASA_MISSION_ID = :new.ASA_MISSION_ID) loop
      if    not(trunc(:old.MIS_REQUEST_DATE) <> trunc(:new.MIS_REQUEST_DATE) )
         or (cr_IntervDet.ITR_START_DATE is null) then
        ASA_MISSION_FUNCTIONS.SetPrices(aASA_INTERVENTION_DETAIL_ID     => cr_IntervDet.ASA_INTERVENTION_DETAIL_ID
                                      , aDIC_TARIFF_ID                  => :new.DIC_TARIFF_ID
                                      , aASA_MISSION_TYPE_ID            => :new.ASA_MISSION_TYPE_ID
                                      , aCML_POSITION_ID                => :new.CML_POSITION_ID
                                      , aPAC_CUSTOM_PARTNER_ID          => :new.PAC_CUSTOM_PARTNER_ID
                                      , aPAC_CUSTOM_PARTNER_TARIFF_ID   => :new.PAC_CUSTOM_PARTNER_TARIFF_ID
                                      , aDOC_RECORD_ID                  => :new.DOC_RECORD_ID
                                      , aMIS_REQUEST_DATE               => :new.MIS_REQUEST_DATE
                                      , aACS_FINANCIAL_CURRENCY_ID      => :new.ACS_FINANCIAL_CURRENCY_ID
                                      , aITR_START_DATE                 => cr_IntervDet.ITR_START_DATE
                                       );
      end if;
    end loop;
  end if;
end ASA_MIS_AU_TARIFF;

ALTER TRIGGER "C_ITX"."ASA_MIS_AU_TARIFF" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."ASA_MIS_BU_STATUS"
  before update of C_ASA_MIS_STATUS
  on ASA_MISSION
  referencing old as old new as new
  for each row
/**
* Description
*     Mise à jour du statut des interventions de la mission
* @author DSA
* @version 2003
* @lastUpdate
*/
begin
  -- Le passage du statut Facturée au statut Clôturée n'entraîne pas la modification des statuts des interventions
  -- Ce changement de statut provient déjà d'une modification du statut d'une intervention

  -- La confirmation d'une intervention provisoire entraine (A_CONFIRM = 1) le passage du statut de la mission à
  -- "confirmé" si la mission avait le statut "provisoire" mais n'entraine pas la mise à jour des autres interventions
  if     (:new.C_ASA_MIS_STATUS <> :old.C_ASA_MIS_STATUS)
     and not(     (:new.C_ASA_MIS_STATUS = '02')
             and (:old.C_ASA_MIS_STATUS = '05') )
     and not(    :old.C_ASA_MIS_STATUS = '00'
             and :new.C_ASA_MIS_STATUS = '01'
             and :new.A_CONFIRM = 1) then
    update ASA_INTERVENTION
       set C_ASA_ITR_STATUS = :new.C_ASA_MIS_STATUS
     where ASA_MISSION_ID = :new.ASA_MISSION_ID
       and C_ASA_ITR_STATUS not in('02', '04', '05');
  end if;

  if (:new.A_CONFIRM = 1) then
    :new.A_CONFIRM  := 0;
  end if;
end ASA_MIS_BU_STATUS;

ALTER TRIGGER "C_ITX"."ASA_MIS_BU_STATUS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."CLA_CLA_AU_DESCRIPTION"
  after update of "CLA_DESCR"
  on CLASSIFICATION
  for each row
/**
* Description
*    Changer la description du noeud principal lors du changement de description de la classif
* @created   fp 13.06.2008
* @version 2003
* @lastUpdate
*/
begin
  update CLASSIF_NODE_DESCR
     set DES_DESCR = :new.CLA_DESCR
   where CLASSIF_NODE_ID = (select CLASSIF_NODE_ID
                              from CLASSIF_NODE
                             where CLASSIFICATION_ID = :new.CLASSIFICATION_ID
                               and CLN_PARENT_ID = 0);
end CLA_CLA_AU_DESCRIPTION;

ALTER TRIGGER "C_ITX"."CLA_CLA_AU_DESCRIPTION" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."CLA_CLA_BUI_UNIQUE_KEY"
  before insert or update of "CLA_TABLENAME", "CLA_DESCR"
  on "CLASSIFICATION"
  for each row
/**
* Description
*    Maj de la clef unique UniqueKey
* @created   fp 28.08.2008
* @version 2003
* @lastUpdate
*/
begin
  :new.CLA_UNIQUE_KEY := :new.CLA_TABLENAME||'.'||:new.CLA_DESCR;
end CLA_CLA_BUI_UNIQUE_KEY;

ALTER TRIGGER "C_ITX"."CLA_CLA_BUI_UNIQUE_KEY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."CLA_CTA_AUI_DENORM_TABLE"
  after insert or update of "CTA_TABLENAME"
  on CLASSIF_TABLES
  for each row
/**
* Description
*    Dénormaliser le nom de la table liée à une classif dans la table CLASSIFICATION
* @created   fp 28.08.2008
* @version 2003
* @lastUpdate
*/
begin
  update CLASSIFICATION
     set CLA_TABLENAME = :new.CTA_TABLENAME
   where CLASSIFICATION_ID = :new.CLASSIFICATION_ID;
end CLA_CTA_AUI_DENORM_TABLE;

ALTER TRIGGER "C_ITX"."CLA_CTA_AUI_DENORM_TABLE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."CML_CCO_AI_FREE_NUMBER"
  after insert
  on CML_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*   Suppression du numéro de document dans la table doc_free_number
* @author AG
* @version 2003
* @lastUpdate
*/
declare
  gauge_numbering_id DOC_GAUGE.DOC_GAUGE_NUMBERING_ID%type;
  free_number        DOC_GAUGE_NUMBERING.GAN_FREE_NUMBER%type;
  descr_numbering    DOC_GAUGE_NUMBERING.GAN_DESCRIBE%type;
begin
  descr_numbering  := PCS.PC_CONFIG.GetConfig('CML_DOC_GAUGE_NUMBERING_DESCR');

  begin
    select DOC_GAUGE_NUMBERING_ID
         , GAN_FREE_NUMBER
      into gauge_numbering_id
         , free_number
      from DOC_GAUGE_NUMBERING
     where GAN_DESCRIBE = descr_numbering;
  exception
    when no_data_found then
      gauge_numbering_id  := -1;
      free_number         := 0;
  end;

  -- si on gère les numéros libre pour ce type de numérotation
  if (free_number = 1) then
    delete from DOC_FREE_NUMBER
          where (   DOF_NUMBER = '*' || :new.CCO_NUMBER
                 or DOF_NUMBER = :new.CCO_NUMBER)
            and DOC_GAUGE_NUMBERING_ID = gauge_numbering_id;
  end if;
end CML_CCO_AI_FREE_NUMBER;


ALTER TRIGGER "C_ITX"."CML_CCO_AI_FREE_NUMBER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."CML_CEV_AD_EVENTS"
  after delete
  on CML_EVENTS
  referencing old as old new as new
  for each row
/**
* Description
*   Effacement d'un événement
* @author Nuno Gomes Vieira
* @version 2003
* @lastUpdate
*/
declare
  vCPD_PERIOD_QTY   CML_POSITION_SERVICE_DETAIL.CPD_PERIOD_QTY%type;
  vCPD_BALANCE_QTY  CML_POSITION_SERVICE_DETAIL.CPD_BALANCE_QTY%type;
  vCPD_CONSUMED_QTY CML_POSITION_SERVICE_DETAIL.CPD_CONSUMED_QTY%type;
  vCPD_EXPIRY_DATE  CML_POSITION_SERVICE_DETAIL.CPD_EXPIRY_DATE%type;
begin
  if :old.C_CML_EVENT_TYPE = '5' then
    -- Màj l'état compteur qui est lié à l'évènement
    -- passer de "facturé" à "validé"
    update ASA_COUNTER_STATEMENT
       set C_COUNTER_STATEMENT_STATUS = '1'
         , CML_EVENTS_ID = null
         , A_DATEMOD = sysdate
         , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
     where CML_EVENTS_ID = :old.CML_EVENTS_ID;

    -- Màj qté consommée et qté solde de la prestation
    update CML_POSITION_MACHINE_DETAIL
       set CMD_LAST_INVOICE_STATEMENT = :old.CEV_BEF_INV_COUNTER_STMT
         , A_DATEMOD = sysdate
         , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
     where CML_POSITION_MACHINE_DETAIL_ID = :old.CML_POSITION_MACHINE_DETAIL_ID;

    -- Si l'id CML_POS_SERV_DET_HISTORY_ID n'est pas null
    -- cela veut dire que l'événement à été effectué lors du renouvellement
    -- des avoirs.
    if :old.CML_POS_SERV_DET_HISTORY_ID is not null then
      -- Rechercher les infos pour la màj prestation dans la table d'historique
      select CPD_PERIOD_QTY
           , CPD_BALANCE_QTY
           , CPD_CONSUMED_QTY
           , CPD_EXPIRY_DATE
        into vCPD_PERIOD_QTY
           , vCPD_BALANCE_QTY
           , vCPD_CONSUMED_QTY
           , vCPD_EXPIRY_DATE
        from CML_POS_SERV_DET_HISTORY
       where CML_POS_SERV_DET_HISTORY_ID = :old.CML_POS_SERV_DET_HISTORY_ID;
    else
      vCPD_PERIOD_QTY    := null;
      vCPD_BALANCE_QTY   := :old.CEV_BEF_INV_BALANCE_QTY;
      vCPD_CONSUMED_QTY  := :old.CEV_BEF_INV_CONSUMED_QTY;
      vCPD_EXPIRY_DATE   := null;
    end if;

    -- Màj qtés prestation
    update CML_POSITION_SERVICE_DETAIL
       set CPD_PERIOD_QTY = nvl(vCPD_PERIOD_QTY, CPD_PERIOD_QTY)
         , CPD_BALANCE_QTY = vCPD_BALANCE_QTY
         , CPD_CONSUMED_QTY = vCPD_CONSUMED_QTY
         , CPD_EXPIRY_DATE = nvl(vCPD_EXPIRY_DATE, CPD_EXPIRY_DATE)
         , A_DATEMOD = sysdate
         , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
     where CML_POSITION_SERVICE_DETAIL_ID = :old.CML_POSITION_SERVICE_DETAIL_ID;
  end if;
end CML_CEV_AD_EVENTS;

ALTER TRIGGER "C_ITX"."CML_CEV_AD_EVENTS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."CML_CPD_AIU_PROCESSING"
  after insert or update of C_SERVICE_RENEWAL
  on CML_POSITION_SERVICE_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*   Insertion automatique des codes de traitement du détail de la prestation
* @author David Saadé
* @version 2003
* @lastUpdate
*/
declare
  vCount number;
begin
  vCount  := -1;

  if (:new.C_SERVICE_RENEWAL in('1', '4') ) then
    -- En mise à jour, on vérifie que le code 200 n'existe pas
    if (    updating
        and :old.C_SERVICE_RENEWAL <> :new.C_SERVICE_RENEWAL) then
      select count(*)
        into vCount
        from CML_PROCESSING
       where CML_POSITION_SERVICE_DETAIL_ID = :new.CML_POSITION_SERVICE_DETAIL_ID;
    end if;

    if    (    inserting
           and (nvl(:new.A_CONFIRM, 0) = 0) )
       or (vCount = 0) then
      begin
        insert into CML_PROCESSING
                    (CML_PROCESSING_ID
                   , CML_POSITION_SERVICE_DETAIL_ID
                   , C_CML_PROCESSING_TYPE
                   , CPR_JANUARY
                   , CPR_FEBRUARY
                   , CPR_MARCH
                   , CPR_APRIL
                   , CPR_MAY
                   , CPR_JUNE
                   , CPR_JULY
                   , CPR_AUGUST
                   , CPR_SEPTEMBER
                   , CPR_OCTOBER
                   , CPR_NOVEMBER
                   , CPR_DECEMBER
                   , A_DATECRE
                   , A_IDCRE
                    )
          select init_id_seq.nextval
               , :new.CML_POSITION_SERVICE_DETAIL_ID
               , '200'
               , CPR_JANUARY
               , CPR_FEBRUARY
               , CPR_MARCH
               , CPR_APRIL
               , CPR_MAY
               , CPR_JUNE
               , CPR_JULY
               , CPR_AUGUST
               , CPR_SEPTEMBER
               , CPR_OCTOBER
               , CPR_NOVEMBER
               , CPR_DECEMBER
               , sysdate
               , pcs.PC_I_LIB_SESSION.getUserIni
            from CML_PROCESSING CPR
               , CML_POSITION_SERVICE CPS
           where CPR.CML_POSITION_ID = CPS.CML_POSITION_ID
             and CPS.CML_POSITION_SERVICE_ID = :new.CML_POSITION_SERVICE_ID;
      exception
        when ex.TABLE_MUTATING then
          insert into CML_PROCESSING
                      (CML_PROCESSING_ID
                     , CML_POSITION_SERVICE_DETAIL_ID
                     , C_CML_PROCESSING_TYPE
                     , CPR_JANUARY
                     , CPR_FEBRUARY
                     , CPR_MARCH
                     , CPR_APRIL
                     , CPR_MAY
                     , CPR_JUNE
                     , CPR_JULY
                     , CPR_AUGUST
                     , CPR_SEPTEMBER
                     , CPR_OCTOBER
                     , CPR_NOVEMBER
                     , CPR_DECEMBER
                     , A_DATECRE
                     , A_IDCRE
                      )
               values (init_id_seq.nextval
                     , :new.CML_POSITION_SERVICE_DETAIL_ID
                     , '200'
                     , 0   -- CPR_JANUARY
                     , 0   -- CPR_FEBRUARY
                     , 0   -- CPR_MARCH
                     , 0   -- CPR_APRIL
                     , 0   -- CPR_MAY
                     , 0   -- CPR_JUNE
                     , 0   -- CPR_JULY
                     , 0   -- CPR_AUGUST
                     , 0   -- CPR_SEPTEMBER
                     , 0   -- CPR_OCTOBER
                     , 0   -- CPR_NOVEMBER
                     , 0   -- CPR_DECEMBER
                     , sysdate
                     , pcs.PC_I_LIB_SESSION.getUserIni
                      );
      end;
    end if;
  end if;
end CML_CPD_AIU_PROCESSING;

ALTER TRIGGER "C_ITX"."CML_CPD_AIU_PROCESSING" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."CML_CPD_HIST_BD_CTRL_EVENT"
  before delete
  on CML_POS_SERV_DET_HISTORY
  referencing old as old new as new
  for each row
/**
* Description
*   Effacement d'un historique de détail préstation
*     Vérifier que l'id de cet historique n'est pas présent dans la table
*     des événements (CML_EVENTS)
*     Ce trigger a été créé au lieu d'une contrainte par cause de simplicité
*     au niveau de la modélisation CDM
* @author NGV
* @version 2003
* @lastUpdate
*/
declare
  vCount integer;
begin
  -- Vérifier que l'id de cet historique n'est pas présent dans la table CML_EVENTS
  select count(*)
    into vCount
    from CML_EVENTS
   where CML_POS_SERV_DET_HISTORY_ID = :old.CML_POS_SERV_DET_HISTORY_ID;

  -- Si l'id de l'historique est présent dans la table des événements
  --   alors il faut bloquer l'effacement de cet enregistrement
  if vCount > 0 then
    raise_application_error
      (-20000
     , PCS.PC_FUNCTIONS.TranslateWord
                     (substr('PCS - Effacement impossible, il existe un lien sur les événements pour cet historique!'
                           , 1
                           , 80
                            )
                     )
      );
  end if;
end CML_CPD_HIST_BD_CTRL_EVENT;


ALTER TRIGGER "C_ITX"."CML_CPD_HIST_BD_CTRL_EVENT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."CML_CPM_AI_DETAIL"
  after insert
  on CML_POSITION_MACHINE
  referencing old as old new as new
  for each row
/**
* Description
*   Création du détail de la machine
* @author David Saadé
* @version 2003
* @lastUpdate
*/
declare
begin
  if nvl(:new.A_CONFIRM, 0) = 0 then
    insert into CML_POSITION_MACHINE_DETAIL
                (CML_POSITION_MACHINE_DETAIL_ID
               , CML_POSITION_MACHINE_ID
               , ASA_COUNTER_ID
               , CMD_INITIAL_STATEMENT
               , A_DATECRE
               , A_IDCRE
                )
      select INIT_ID_SEQ.nextval
           , :new.CML_POSITION_MACHINE_ID
           , COU.ASA_COUNTER_ID
           , (select nvl(max(CST_STATEMENT_QUANTITY), 0)
                from ASA_COUNTER_STATEMENT
               where ASA_COUNTER_ID = COU.ASA_COUNTER_ID
                 and C_COUNTER_STATEMENT_STATUS in('1', '3') )   -- CMD_INITIAL_STATEMENT
           , sysdate
           , pcs.PC_I_LIB_SESSION.GetUserIni
        from ASA_COUNTER COU
       where COU.DOC_RECORD_ID = :new.DOC_RCO_MACHINE_ID;
  end if;
end CML_CPM_AI_DETAIL;

ALTER TRIGGER "C_ITX"."CML_CPM_AI_DETAIL" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."CML_CPO_AI_PROCESSING"
  after insert
  on CML_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*   Initialisation du code de traitement '100' de la position
* @author David Saadé
* @version 2003
* @lastUpdate
*/
begin
  if (nvl(:new.A_CONFIRM, 0) = 0) then
    insert into CML_PROCESSING
                (CML_PROCESSING_ID
               , CML_POSITION_ID
               , C_CML_PROCESSING_TYPE
               , CPR_JANUARY
               , CPR_FEBRUARY
               , CPR_MARCH
               , CPR_APRIL
               , CPR_MAY
               , CPR_JUNE
               , CPR_JULY
               , CPR_AUGUST
               , CPR_SEPTEMBER
               , CPR_OCTOBER
               , CPR_NOVEMBER
               , CPR_DECEMBER
               , A_DATECRE
               , A_IDCRE
                )
      select init_id_seq.nextval
           , :new.CML_POSITION_ID
           , '100'
           , 1   -- CPR_JANUARY
           , case :new.C_CML_POS_TREATMENT
               when '01' then 1
               else 0
             end   -- CPR_FEBRUARY
           , case :new.C_CML_POS_TREATMENT
               when '01' then 1
               else 0
             end   -- CPR_MARCH
           , case :new.C_CML_POS_TREATMENT
               when '01' then 1
               when '03' then 1
               else 0
             end   --CPR_APRIL
           , case :new.C_CML_POS_TREATMENT
               when '01' then 1
               else 0
             end   --CPR_MAY
           , case :new.C_CML_POS_TREATMENT
               when '01' then 1
               else 0
             end   --CPR_JUNE
           , case :new.C_CML_POS_TREATMENT
               when '01' then 1
               when '03' then 1
               when '06' then 1
               else 0
             end   --CPR_JULY
           , case :new.C_CML_POS_TREATMENT
               when '01' then 1
               else 0
             end   --CPR_AUGUST
           , case :new.C_CML_POS_TREATMENT
               when '01' then 1
               else 0
             end   --CPR_SEPTEMBER
           , case :new.C_CML_POS_TREATMENT
               when '01' then 1
               when '03' then 1
               else 0
             end   --CPR_OCTOBER
           , case :new.C_CML_POS_TREATMENT
               when '01' then 1
               else 0
             end   --CPR_NOVEMBER
           , case :new.C_CML_POS_TREATMENT
               when '01' then 1
               else 0
             end   --CPR_DECEMBER
           , sysdate
           , pcs.PC_I_LIB_SESSION.GetUserIni
        from dual;
  end if;
end CML_CPO_AI_PROCESSING;

ALTER TRIGGER "C_ITX"."CML_CPO_AI_PROCESSING" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."CML_CPO_AU_STATUS"
  after update of C_CML_POS_STATUS, CPO_EXTENSION_TIME
  on CML_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*   Historique de la position de contrat (modification du statut )
* @author David Saadé
* @version 2003
* @lastUpdate
*/
begin
  if    (:old.C_CML_POS_STATUS <> :new.C_CML_POS_STATUS)
     or (     (:old.CPO_EXTENSION_TIME <> :new.CPO_EXTENSION_TIME)
         and (:new.C_CML_POS_STATUS = '03') ) then
    insert into CML_POSITION_HISTORY
                (CML_POSITION_HISTORY_ID
               , CML_POSITION_ID
               , PC_USER_ID
               , C_CML_HISTORY_CODE
               , CPH_DATE
               , CPH_DESCRIPTION
               , A_DATECRE
               , A_IDCRE
                )
      select INIT_ID_SEQ.nextval
           , :new.CML_POSITION_ID
           , pcs.PC_I_LIB_SESSION.GetUserId   -- PC_USER_ID
           , case
               when(:old.C_CML_POS_STATUS = '01')
               and (:new.C_CML_POS_STATUS = '02') then '100'   -- activation position
               when(:new.C_CML_POS_STATUS = '07') then '200'   -- suspension position
               when(     (:old.C_CML_POS_STATUS = '07')
                    and (:new.C_CML_POS_STATUS = '02') )
                or (     (:old.C_CML_POS_STATUS = '04')
                    and (:new.C_CML_POS_STATUS in('02', '03') ) ) then '300'   -- réactivation position
               when(:new.C_CML_POS_STATUS = '03') then '400'   -- prolongation position
               when(:new.C_CML_POS_STATUS = '06') then '500'   -- résiliation position
               when(:new.C_CML_POS_STATUS = '05') then '600'   -- terminaison position
               when(:new.C_CML_POS_STATUS = '04') then '700'   -- échéance position
             end
           , sysdate   -- CPH_DATE
           , case
               when(:new.C_CML_POS_STATUS = '03') then PCS.PC_FUNCTIONS.TranslateWord('Date fin prévue prolongée') ||
                                                       ' : ' ||
                                                       to_char(:new.CPO_END_EXTENDED_DATE, 'dd.mm.yyyy')
               else ''
             end
           , sysdate   -- A_DATECRE
           , pcs.PC_I_LIB_SESSION.GetUserIni   -- A_ICDRE
        from dual;
  end if;
end CML_CPO_AU_STATUS;

ALTER TRIGGER "C_ITX"."CML_CPO_AU_STATUS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."CML_CPR_BIU_PROCESSING"
  before insert or update of CPR_JANUARY
                           , CPR_FEBRUARY
                           , CPR_MARCH
                           , CPR_APRIL
                           , CPR_MAY
                           , CPR_JUNE
                           , CPR_JULY
                           , CPR_AUGUST
                           , CPR_SEPTEMBER
                           , CPR_OCTOBER
                           , CPR_NOVEMBER
                           , CPR_DECEMBER
  on CML_PROCESSING
  referencing old as old new as new
  for each row
/**
* Description
*   Màj automatique du champ contenant la liste des mois cochés
* @author NGV
* @version 2003
* @lastUpdate
*/
declare
  vMonths varchar2(50) default null;
begin
  if :new.CPR_JANUARY = 1 then
    vMonths  := '01' || ',';
  end if;

  if :new.CPR_FEBRUARY = 1 then
    vMonths  := vMonths || '02' || ',';
  end if;

  if :new.CPR_MARCH = 1 then
    vMonths  := vMonths || '03' || ',';
  end if;

  if :new.CPR_APRIL = 1 then
    vMonths  := vMonths || '04' || ',';
  end if;

  if :new.CPR_MAY = 1 then
    vMonths  := vMonths || '05' || ',';
  end if;

  if :new.CPR_JUNE = 1 then
    vMonths  := vMonths || '06' || ',';
  end if;

  if :new.CPR_JULY = 1 then
    vMonths  := vMonths || '07' || ',';
  end if;

  if :new.CPR_AUGUST = 1 then
    vMonths  := vMonths || '08' || ',';
  end if;

  if :new.CPR_SEPTEMBER = 1 then
    vMonths  := vMonths || '09' || ',';
  end if;

  if :new.CPR_OCTOBER = 1 then
    vMonths  := vMonths || '10' || ',';
  end if;

  if :new.CPR_NOVEMBER = 1 then
    vMonths  := vMonths || '11' || ',';
  end if;

  if :new.CPR_DECEMBER = 1 then
    vMonths  := vMonths || '12' || ',';
  end if;

  if length(vMonths) > 0 then
    select substr(vMonths, 1, length(vMonths) - 1)
      into vMonths
      from dual;

    :new.CPR_MONTHS  := vMonths;
  end if;
end CML_CPR_BIU_PROCESSING;


ALTER TRIGGER "C_ITX"."CML_CPR_BIU_PROCESSING" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."CML_CPS_AI_DETAIL"
  after insert
  on CML_POSITION_SERVICE
  referencing old as old new as new
  for each row
/**
* Description
*   Création du détail de la prestation
* @author David Saadé
* @version 2003
* @lastUpdate
*/
declare
  aKind  GCO_GOOD.C_SERVICE_KIND%type;
  aMode  GCO_GOOD.C_SERVICE_GOOD_LINK%type;
  aDetID CML_POSITION_SERVICE_DETAIL.CML_POSITION_SERVICE_DETAIL_ID%type;
begin
  if (nvl(:new.A_CONFIRM, 0) = 0) then
    -- Récupération de la nature et du code relation bien de la prestation
    select C_SERVICE_KIND
         , C_SERVICE_GOOD_LINK
      into aKind
         , aMode
      from GCO_GOOD
     where GCO_GOOD_ID = :new.GCO_CML_SERVICE_ID;

    -- Prestation associé à un ou plusieurs compteur(s)
    -- On crée un détail de prestation par compteur associé
    if aKind = '1' then
      insert into CML_POSITION_SERVICE_DETAIL
                  (CML_POSITION_SERVICE_DETAIL_ID
                 , CML_POSITION_SERVICE_ID
                 , ASA_COUNTER_TYPE_ID
                 , C_SERVICE_RENEWAL
                 , DIC_TARIFF_ID
                 , CPD_SQL_CONDITION
                 , CPD_PERIOD_QTY
                 , CPD_CONSUMED_QTY
                 , CPD_BALANCE_QTY
                 , A_DATECRE
                 , A_IDCRE
                  )
        select init_id_seq.nextval
             , :new.CML_POSITION_SERVICE_ID
             , GCL.ASA_COUNTER_TYPE_ID
             , GOO.C_SERVICE_RENEWAL
             , GOO.DIC_TARIFF_ID
             , GOO.GOO_CONTRACT_CONDITION
             , 0.0
             , 0.0
             , 0.0
             , sysdate
             , PCS.PC_I_LIB_SESSION.GetUserIni
          from GCO_SERVICE_COUNTER_LINK GCL
             , GCO_GOOD GOO
         where GOO.GCO_GOOD_ID = :new.GCO_CML_SERVICE_ID
           and GCL.GCO_SERVICE_ID = GOO.GCO_GOOD_ID;
    elsif    (aKind = '2')
          or (aKind = '3') then
      if (aMode = '1') then
-- Prestation associé à un ou plusieurs bien(s) selon une sélection manuelle
-- On crée un détail de prestation par bien associé
        insert into CML_POSITION_SERVICE_DETAIL
                    (CML_POSITION_SERVICE_DETAIL_ID
                   , CML_POSITION_SERVICE_ID
                   , GCO_GOOD_ID
                   , C_SERVICE_RENEWAL
                   , DIC_TARIFF_ID
                   , CPD_SQL_CONDITION
                   , CPD_PERIOD_QTY
                   , CPD_CONSUMED_QTY
                   , CPD_BALANCE_QTY
                   , A_DATECRE
                   , A_IDCRE
                    )
          select init_id_seq.nextval
               , :new.CML_POSITION_SERVICE_ID
               , GGL.GCO_GOOD_ID
               , GOO.C_SERVICE_RENEWAL
               , GOO.DIC_TARIFF_ID
               , GOO.GOO_CONTRACT_CONDITION
               , 0.0
               , 0.0
               , 0.0
               , sysdate
               , PCS.PC_I_LIB_SESSION.GetUserIni
            from GCO_SERVICE_GOOD_LINK GGL
               , GCO_GOOD GOO
           where GOO.GCO_GOOD_ID = :new.GCO_CML_SERVICE_ID
             and GGL.GCO_SERVICE_ID = GOO.GCO_GOOD_ID;
      else
        -- Prestation associée à un ou plusieurs bien(s) selon une sélection auto
        -- On crée un seul détail sans bien ni compteur
        insert into CML_POSITION_SERVICE_DETAIL
                    (CML_POSITION_SERVICE_DETAIL_ID
                   , CML_POSITION_SERVICE_ID
                   , C_SERVICE_RENEWAL
                   , DIC_TARIFF_ID
                   , CPD_SQL_CONDITION
                   , CPD_PERIOD_QTY
                   , CPD_CONSUMED_QTY
                   , CPD_BALANCE_QTY
                   , A_DATECRE
                   , A_IDCRE
                    )
          select init_id_seq.nextval
               , :new.CML_POSITION_SERVICE_ID
               , GOO.C_SERVICE_RENEWAL
               , GOO.DIC_TARIFF_ID
               , GOO.GOO_CONTRACT_CONDITION
               , 0.0
               , 0.0
               , 0.0
               , sysdate
               , PCS.PC_I_LIB_SESSION.GetUserIni
            from GCO_GOOD GOO
           where GOO.GCO_GOOD_ID = :new.GCO_CML_SERVICE_ID;
      end if;
    end if;
  end if;
end CML_CPS_AI_DETAIL;

ALTER TRIGGER "C_ITX"."CML_CPS_AI_DETAIL" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."CML_INP_AD_EVENTS_DELETE"
  after delete
  on CML_INVOICING_PROCESS
  referencing old as old new as new
  for each row
/**
* Description
*   Effacement d'un événement lors de l'éffacement d'une proposition de
*   facturation pour un événement de type '5'
* @author Nuno Gomes Vieira
* @version 2003
* @lastUpdate
*/
declare
begin
  -- Effacement d'une proposition de facturation d'un événement de type
  -- '5' Excédents de consommation
  if     (:old.CML_EVENTS_ID is not null)
     and (:old.CML_CML_EVENTS_ID is null)
     and (:old.C_CML_EVENT_TYPE = '5') then
    -- Effacer l'événement
    delete from CML_EVENTS
          where CML_EVENTS_ID = :old.CML_EVENTS_ID;
  end if;
end CML_INP_AD_EVENTS_DELETE;

ALTER TRIGGER "C_ITX"."CML_INP_AD_EVENTS_DELETE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."COM_IMF_AIUD_SHP_GCO_PUBLISH"
  after insert or update or delete
  on COM_IMAGE_FILES
  referencing old as old new as new
  for each row
/**
* Description
*    Ajout de l' ID de l'élément concerné dans la table SHP_TO_PUBLISH pour republication
*    si le nom de l'image commence par 'SHP-'
* @created PYV 22.12.2011
* @lastUpdate age 07.06.2012
*/
declare
  ln_Result integer;
begin
  if PCS.PC_CONFIG.GetConfig(aConfigName => 'SHP_SHOP_VERSION', aCompanyID => PCS.PC_I_LIB_SESSION.GetCompanyId, aConliID => null) =
                                                                                                                  SHP_I_LIB_TYPES.gcvExternalShopConnectorValue then
    if     deleting
       and :old.imf_table = 'GCO_GOOD'
       and instr(:old.dic_image_type_id, 'SHP-') > 0 then
      ln_result  :=
        shp_prc_publish.publishRecord(inStpRecID        => :old.imf_rec_id
                                    , ivStpContext      => 'PRODUCT'
                                    , ivGooWebStatus    => '1'
                                    , ivShopDocStatus   => null
                                    , ivShopDocNumber   => null
                                     );
    elsif     :new.imf_table = 'GCO_GOOD'
          and instr(:new.dic_image_type_id, 'SHP-') > 0 then
      ln_result  :=
        shp_prc_publish.publishRecord(inStpRecID        => :new.imf_rec_id
                                    , ivStpContext      => 'PRODUCT'
                                    , ivGooWebStatus    => '1'
                                    , ivShopDocStatus   => null
                                    , ivShopDocNumber   => null
                                     );
    end if;
  end if;
end COM_IMF_AIUD_SHP_GCO_PUBLISH;

ALTER TRIGGER "C_ITX"."COM_IMF_AIUD_SHP_GCO_PUBLISH" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."COM_IMF_AIU_REPLICATE"
  after insert or update
  on COM_IMAGE_FILES
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author jsomers
 * @author spfister
 * @date 12.2002
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result integer;
begin
  if (    :new.IMF_TABLE = 'GCO_GOOD'
      and rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
--    if (Nvl(:old.COM_OLE_ID,0) <> Nvl(:new.COM_OLE_ID,0)) or
    if    (nvl(:old.IMF_CABINET, ' ') <> nvl(:new.IMF_CABINET, ' ') )
       or (nvl(:old.IMF_COM_IMAGE_PATH, ' ') <> nvl(:new.IMF_COM_IMAGE_PATH, ' ') )
       or (nvl(:old.IMF_DESCR, ' ') <> nvl(:new.IMF_DESCR, ' ') )
       or (nvl(:old.IMF_DRAWER, ' ') <> nvl(:new.IMF_DRAWER, ' ') )
       or (nvl(:old.IMF_FILE, ' ') <> nvl(:new.IMF_FILE, ' ') )
       or (nvl(:old.IMF_FOLDER, ' ') <> nvl(:new.IMF_FOLDER, ' ') )
       or (nvl(:old.IMF_IMAGE_INDEX, 0) <> nvl(:new.IMF_IMAGE_INDEX, 0) )
       or (nvl(:old.IMF_KEY01, ' ') <> nvl(:new.IMF_KEY01, ' ') )
       or (nvl(:old.IMF_KEY02, ' ') <> nvl(:new.IMF_KEY02, ' ') )
       or (nvl(:old.IMF_KEY03, ' ') <> nvl(:new.IMF_KEY03, ' ') )
       or (nvl(:old.IMF_KEY04, ' ') <> nvl(:new.IMF_KEY04, ' ') )
       or (nvl(:old.IMF_KEY05, ' ') <> nvl(:new.IMF_KEY05, ' ') )
       or (nvl(:old.IMF_KEY06, ' ') <> nvl(:new.IMF_KEY06, ' ') )
       or (nvl(:old.IMF_KEY07, ' ') <> nvl(:new.IMF_KEY07, ' ') )
       or (nvl(:old.IMF_KEY08, ' ') <> nvl(:new.IMF_KEY08, ' ') )
       or (nvl(:old.IMF_KEY09, ' ') <> nvl(:new.IMF_KEY09, ' ') )
       or (nvl(:old.IMF_KEY10, ' ') <> nvl(:new.IMF_KEY10, ' ') )
       or (nvl(:old.IMF_KEY11, ' ') <> nvl(:new.IMF_KEY11, ' ') )
       or (nvl(:old.IMF_KEY12, ' ') <> nvl(:new.IMF_KEY12, ' ') )
       or (nvl(:old.IMF_KEY13, ' ') <> nvl(:new.IMF_KEY13, ' ') )
       or (nvl(:old.IMF_KEY14, ' ') <> nvl(:new.IMF_KEY14, ' ') )
       or (nvl(:old.IMF_KEY15, ' ') <> nvl(:new.IMF_KEY15, ' ') )
       or
--       (Nvl(:old.IMF_LINKED_FILE,0) <> Nvl(:new.IMF_LINKED_FILE,0)) or
          (nvl(:old.IMF_PATHFILE, ' ') <> nvl(:new.IMF_PATHFILE, ' ') )
       or (nvl(:old.IMF_REC_ID, 0) <> nvl(:new.IMF_REC_ID, 0) )
       or (nvl(:old.IMF_SEQUENCE, 0) <> nvl(:new.IMF_SEQUENCE, 0) )
       or (nvl(:old.IMF_STORED_IN, ' ') <> nvl(:new.IMF_STORED_IN, ' ') ) then
--       (Nvl(:old.IMF_TABLE,' ') <> Nvl(:new.IMF_TABLE,' ')) then
      rep_functions.PublishArticle(:new.IMF_REC_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."COM_IMF_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_CAT_DESC_AIU_REPLICATE"
  after insert or update
  on DOC_RECORD_CATEGORY_DESCR
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des catégories de documents.
 * @author rforchelet
 * @author spfister
 * @date 10.2006
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_RCO_TRIGGERS') = 1) then
    rep_functions.PublishDocRecordCategory(:NEW.DOC_RECORD_CATEGORY_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."DOC_CAT_DESC_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_CAT_LNK_AIU_REPLICATE"
  after insert or update
  on DOC_RECORD_CATEGORY_LINK
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des catégories de documents.
 * @author rforchelet
 * @author spfister
 * @date 10.2006
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_RCO_TRIGGERS') = 1) then
    rep_functions.PublishDocRecordCategory(:NEW.DOC_RECORD_CAT_FATHER_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."DOC_CAT_LNK_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DAA_BD_ALLOY_ADVANCE"
  before delete
  on DOC_ALLOY_ADVANCE
  referencing old as old new as new
  for each row
/**
* Description
*    Maj des qtés soldes détail/position parent
*      et maj du statut position/document parent
* @author NGV
* @created 31.03.2004
* @version 2003
*/
declare
  nQuantity DOC_ALLOY_ADVANCE.DAA_WEIGHT_DISCHARGE%type;
begin
  /* En effacement, il faut ajouter la qté déchargé au solde de la qté parent */
  nQuantity  := -:old.DAA_WEIGHT_DISCHARGE;
  /* Maj des qtés soldes détail/position parent
       et maj du statut position/document parent */
  DOC_ALLOY_ADVANCE_FUNCTIONS.UpdateDeductedParent(:old.DOC_DOCUMENT_ID
                                                 , :old.DOC_POSITION_ID
                                                 , :old.DOC_POSITION_DETAIL_ID
                                                 , nQuantity
                                                  );
end DOC_DAA_BD_ALLOY_ADVANCE;

ALTER TRIGGER "C_ITX"."DOC_DAA_BD_ALLOY_ADVANCE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DCD_BI_INIT_ID"
before insert
on DOC_POS_DET_COPY_DISCHARGE
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*   Initialisation du champ DOC_POS_DET_COPY_DISCHARGE_ID
* @author Fabrice Perotto
* @created 11.03.2002
* @version 2003
*/
begin
  -- Initialisation du champ DOC_POS_DET_COPY_DISCHARGE_ID avec init_id_seq
  select INIT_ID_SEQ.NEXTVAL into :NEW.DOC_POS_DET_COPY_DISCHARGE_ID
    from DUAL;
end DOC_DCD_BI_INIT_ID;


ALTER TRIGGER "C_ITX"."DOC_DCD_BI_INIT_ID" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DFA_AIU_METAL_ACCOUNT"
  after insert or update of STM_STOCK_ID, A_DATEMOD
  on DOC_FOOT_ALLOY
  referencing old as old new as new
  for each row
/**
* Description
*    Effectue la mise à jour du compte poids des matières positions en fonction du compte poids de la matière pied
*
* @author Vincent Jeanfavre
* @created 22/07/2005
* @version 2003
*/
declare
  bStop             boolean;
  cMaterialMgntMode PAC_CUSTOM_PARTNER.C_MATERIAL_MGNT_MODE%type;
begin
  if PCS.PC_CONFIG.GetConfig('DOC_METAL_ACCOUNT') = '1' then
    bStop  := false;

    begin
      select decode(GAU.C_ADMIN_DOMAIN
                  , '1', SUP.C_MATERIAL_MGNT_MODE
                  , '2', CUS.C_MATERIAL_MGNT_MODE
                  , '5', SUP.C_MATERIAL_MGNT_MODE
                  , nvl(CUS.C_MATERIAL_MGNT_MODE, SUP.C_MATERIAL_MGNT_MODE)
                   ) C_MATERIAL_MGNT_MODE
        into cMaterialMgntMode
        from DOC_DOCUMENT DMT
           , DOC_GAUGE GAU
           , PAC_CUSTOM_PARTNER CUS
           , PAC_SUPPLIER_PARTNER SUP
       where DMT.DOC_DOCUMENT_ID = :new.DOC_FOOT_ID
         and GAU.DOC_GAUGE_ID = DMT.DOC_GAUGE_ID
         and CUS.PAC_CUSTOM_PARTNER_ID(+) = DMT.PAC_THIRD_ID
         and SUP.PAC_SUPPLIER_PARTNER_ID(+) = DMT.PAC_THIRD_ID;
    exception
      when no_data_found then
        bStop  := true;
    end;

    if not bStop then
      if inserting then
        if cMaterialMgntMode = '1' then   -- Alliage
          update DOC_POSITION_ALLOY DOA
             set DOA.STM_STOCK_ID = :new.STM_STOCK_ID
               , DOA.A_DATEMOD = sysdate
               , DOA.A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
           where DOA.DOC_DOCUMENT_ID = :new.DOC_FOOT_ID
             and DOA.GCO_ALLOY_ID = :new.GCO_ALLOY_ID
             and nvl(DOA.STM_STOCK_ID, 0) <> nvl(:new.STM_STOCK_ID, 0);
        elsif cMaterialMgntMode = '2' then   -- Matière de base
          update DOC_POSITION_ALLOY DOA
             set DOA.STM_STOCK_ID = :new.STM_STOCK_ID
               , DOA.A_DATEMOD = sysdate
               , DOA.A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
           where DOA.DOC_DOCUMENT_ID = :new.DOC_FOOT_ID
             and DOA.DIC_BASIS_MATERIAL_ID = :new.DIC_BASIS_MATERIAL_ID
             and nvl(DOA.STM_STOCK_ID, 0) <> nvl(:new.STM_STOCK_ID, 0);
        end if;
      elsif updating then
        if cMaterialMgntMode = '1' then   -- Alliage
          update DOC_POSITION_ALLOY DOA
             set DOA.STM_STOCK_ID = :new.STM_STOCK_ID
               , DOA.A_DATEMOD = sysdate
               , DOA.A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
           where DOA.DOC_DOCUMENT_ID = :new.DOC_FOOT_ID
             and DOA.GCO_ALLOY_ID = :new.GCO_ALLOY_ID
             and nvl(DOA.STM_STOCK_ID, 0) <> nvl(:new.STM_STOCK_ID, 0)
             and nvl(DOA.DOA_RATE_DATE, to_date('31.12.2999', 'DD.MM.YYYY') ) = nvl(:new.DFA_RATE_DATE, to_date('31.12.2999', 'DD.MM.YYYY') );
        elsif cMaterialMgntMode = '2' then   -- Matière de base
          update DOC_POSITION_ALLOY DOA
             set DOA.STM_STOCK_ID = :new.STM_STOCK_ID
               , DOA.A_DATEMOD = sysdate
               , DOA.A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
           where DOA.DOC_DOCUMENT_ID = :new.DOC_FOOT_ID
             and DOA.DIC_BASIS_MATERIAL_ID = :new.DIC_BASIS_MATERIAL_ID
             and nvl(DOA.STM_STOCK_ID, 0) <> nvl(:new.STM_STOCK_ID, 0)
             and nvl(DOA.DOA_RATE_DATE, to_date('31.12.2999', 'DD.MM.YYYY') ) = nvl(:new.DFA_RATE_DATE, to_date('31.12.2999', 'DD.MM.YYYY') );
        end if;
      end if;
    end if;
  end if;
end DOC_DFA_AIU_METAL_ACCOUNT;

ALTER TRIGGER "C_ITX"."DOC_DFA_AIU_METAL_ACCOUNT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DFA_BU_RATE_DATE"
  before update of DFA_RATE_DATE
  on DOC_FOOT_ALLOY
  referencing old as old new as new
  for each row
/**
* Description
*    Effectue la mise à jour du cours en fonction de la modification de la date cours
*
* @author Vincent Jeanfavre
* @created 21/07/2005
* @version 2003
*/
declare
  bStop                      boolean;
  dmtDocumentDate            DOC_DOCUMENT.DMT_DATE_DOCUMENT%type;
  dmtRateOfExchange          DOC_DOCUMENT.DMT_RATE_OF_EXCHANGE%type;
  dmtBasePrice               DOC_DOCUMENT.DMT_BASE_PRICE%type;
  cAdminDomain               DOC_GAUGE.C_ADMIN_DOMAIN%type;
  cThirdMaterialRelationType PAC_CUSTOM_PARTNER.C_THIRD_MATERIAL_RELATION_TYPE%type;
  cMaterialMgntMode          PAC_CUSTOM_PARTNER.C_MATERIAL_MGNT_MODE%type;
  nAdvMaterialMgnt           PAC_CUSTOM_PARTNER.CUS_ADV_MATERIAL_MGNT%type;
  dicFreeCode1ID             DIC_FREE_CODE1.DIC_FREE_CODE1_ID%type;
  dicComplementaryDataID     DIC_COMPLEMENTARY_DATA.DIC_COMPLEMENTARY_DATA_ID%type;
begin
  if nvl(:old.DFA_RATE_DATE, to_date('31.12.2999', 'DD.MM.YYYY') ) <> nvl(:new.DFA_RATE_DATE, to_date('31.12.2999', 'DD.MM.YYYY') ) then
    bStop  := false;

    begin
      select DMT.DMT_DATE_DOCUMENT
           , DMT.DMT_RATE_OF_EXCHANGE
           , DMT.DMT_BASE_PRICE
           , GAU.C_ADMIN_DOMAIN
           , decode(GAU.C_ADMIN_DOMAIN
                  , '1', nvl(DMT.C_THIRD_MATERIAL_RELATION_TYPE, SUP.C_THIRD_MATERIAL_RELATION_TYPE)
                  , '2', nvl(DMT.C_THIRD_MATERIAL_RELATION_TYPE, CUS.C_THIRD_MATERIAL_RELATION_TYPE)
                  , '5', nvl(DMT.C_THIRD_MATERIAL_RELATION_TYPE, SUP.C_THIRD_MATERIAL_RELATION_TYPE)
                  , nvl(nvl(DMT.C_THIRD_MATERIAL_RELATION_TYPE, CUS.C_THIRD_MATERIAL_RELATION_TYPE), SUP.C_THIRD_MATERIAL_RELATION_TYPE)
                   ) C_THIRD_MATERIAL_RELATION_TYPE
           , decode(GAU.C_ADMIN_DOMAIN
                  , '1', SUP.C_MATERIAL_MGNT_MODE
                  , '2', CUS.C_MATERIAL_MGNT_MODE
                  , '5', SUP.C_MATERIAL_MGNT_MODE
                  , nvl(CUS.C_MATERIAL_MGNT_MODE, SUP.C_MATERIAL_MGNT_MODE)
                   ) C_MATERIAL_MGNT_MODE
           , decode(GAU.C_ADMIN_DOMAIN
                  , '1', SUP.CRE_ADV_MATERIAL_MGNT
                  , '2', CUS.CUS_ADV_MATERIAL_MGNT
                  , '5', SUP.CRE_ADV_MATERIAL_MGNT
                  , nvl(CUS.CUS_ADV_MATERIAL_MGNT, SUP.CRE_ADV_MATERIAL_MGNT)
                   ) ADV_MATERIAL_MGNT
           , PER.DIC_FREE_CODE1_ID
           , decode(GAU.C_ADMIN_DOMAIN
                  , '1', SUP.DIC_COMPLEMENTARY_DATA_ID
                  , '2', CUS.DIC_COMPLEMENTARY_DATA_ID
                  , '5', SUP.DIC_COMPLEMENTARY_DATA_ID
                  , nvl(CUS.DIC_COMPLEMENTARY_DATA_ID, SUP.DIC_COMPLEMENTARY_DATA_ID)
                   ) DIC_COMPLEMENTARY_DATA_ID
        into dmtDocumentDate
           , dmtRateOfExchange
           , dmtBasePrice
           , cAdminDomain
           , cThirdMaterialRelationType
           , cMaterialMgntMode
           , nAdvMaterialMgnt
           , dicFreeCode1ID
           , dicComplementaryDataID
        from DOC_DOCUMENT DMT
           , DOC_GAUGE_STRUCTURED GAS
           , DOC_GAUGE GAU
           , PAC_CUSTOM_PARTNER CUS
           , PAC_SUPPLIER_PARTNER SUP
           , PAC_PERSON PER
       where DMT.DOC_DOCUMENT_ID = :new.DOC_FOOT_ID
         and GAU.DOC_GAUGE_ID = DMT.DOC_GAUGE_ID
         and GAS.DOC_GAUGE_ID = DMT.DOC_GAUGE_ID
         and GAS.GAS_WEIGHT_MAT = 1
         and CUS.PAC_CUSTOM_PARTNER_ID(+) = DMT.PAC_THIRD_ID
         and SUP.PAC_SUPPLIER_PARTNER_ID(+) = DMT.PAC_THIRD_ID
         and PER.PAC_PERSON_ID(+) = DMT.PAC_THIRD_ID;
    exception
      when no_data_found then
        bStop  := true;
    end;

    -- Vérifie si le document courant possède au moins une position déchargée
    if not bStop then
      if    :new.GCO_ALLOY_ID is not null
         or :new.DIC_BASIS_MATERIAL_ID is not null then
        DOC_FOOT_ALLOY_FUNCTIONS.GetRates(:new.DOC_FOOT_ID
                                        , :new.GCO_ALLOY_ID
                                        , :new.DIC_BASIS_MATERIAL_ID
                                        , nvl(:new.DFA_RATE_DATE, dmtDocumentDate)
                                        , dmtRateOfExchange
                                        , dmtBasePrice
                                        , cAdminDomain
                                        , cThirdMaterialRelationType
                                        , cMaterialMgntMode
                                        , nAdvMaterialMgnt
                                        , dicFreeCode1ID
                                        , dicComplementaryDataID
                                        , :new.DFA_WEIGHT_DELIVERY
                                        , :new.DFA_LOSS
                                        , :new.DFA_WEIGHT_INVEST
                                        , :new.DFA_RATE_TH
                                        , :new.DFA_AMOUNT_TH
                                        , :new.DFA_RATE
                                        , :new.DFA_AMOUNT
                                         );

        -- Mode gestion = matière de base et alliage non null
        -- Mode gestion = Alliage et matière non null
        if    (    cMaterialMgntMode = 2
               and :new.GCO_ALLOY_ID is not null)
           or (    cMaterialMgntMode = 1
               and :new.DIC_BASIS_MATERIAL_ID is not null) then
          :new.DFA_AMOUNT_TH  := null;
          :new.DFA_AMOUNT     := null;
        end if;
      else
        :new.DFA_RATE_TH    := null;
        :new.DFA_AMOUNT_TH  := null;
        :new.DFA_RATE       := null;
        :new.DFA_AMOUNT     := null;
      end if;
    end if;
  end if;
end DOC_DFA_BU_RATE_DATE;

ALTER TRIGGER "C_ITX"."DOC_DFA_BU_RATE_DATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DJD_BIU_DENORM"
before insert or update of C_PROJECT_CONSOLIDATION
on DOC_JOURNAL_DETAIL
/**
* Description
*    denormalisation of field C_PROJECT_CONSOLIDATION
* @created fpe 08.03.2011
* @lastUpdate
*/
referencing new as new old as old
for each row
begin
  :NEW.DJD_PROJECT_CONSOLIDATION := sign(nvl(:NEW.C_PROJECT_CONSOLIDATION,0));
end DOC_DJD_BIU_DENORM;

ALTER TRIGGER "C_ITX"."DOC_DJD_BIU_DENORM" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DJP_BIU_DENORM"
before insert or update of C_PROJECT_CONSOLIDATION
on DOC_JOURNAL_DETAIL_PROV
/**
* Description
*    denormalisation of field C_PROJECT_CONSOLIDATION
* @created fpe 08.03.2011
* @lastUpdate
*/
referencing new as new old as old
for each row
begin
  :NEW.DJD_PROJECT_CONSOLIDATION := sign(nvl(:NEW.C_PROJECT_CONSOLIDATION,0));
end DOC_DJP_BIU_DENORM;

ALTER TRIGGER "C_ITX"."DOC_DJP_BIU_DENORM" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMN_BI_SESSION"
  before insert
  on DOC_MISSING_NUMBER
  referencing old as old new as new
  for each row
/**
* Description
*    Initialisation de la session Oracle
* @created FP 14.02.2003
* @version 2003
* @lastUpdate fp 22.11.2007
*/
begin
  if :new.DMN_SESSION_ID is null then
    :new.DMN_SESSION_ID  := DBMS_SESSION.unique_session_id;
  end if;
end DOC_DMN_BI_SESSION;

ALTER TRIGGER "C_ITX"."DOC_DMN_BI_SESSION" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_AD_CONSTRAINTS"
  after delete
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*    1) Vérifie qu'il n'y ait plus de positions de document
*    2) effacement en cascade de DOC_FOOT DOC_FOOT
* @created fp
* @lastUpdate fp 03.11.2006
*/
declare
  vNbPos pls_integer;
begin
  -- Recherche du nombre de positions liées au document
  select count(*)
    into vNbPos
    from DOC_POSITION
   where DOC_DOCUMENT_ID = :old.DOC_DOCUMENT_ID;

  if vNbPos <> 0 then
    -- déclenchement d'une erreur s'il reste des positions
    raise_application_error
      (-20099
     , 'PCS - You must delete all position before deleting a document or you must use the DOC_DELETE.DeleteDocument function to delete a document'
      );
  end if;

  -- Effacement en cascade des pieds de document liés au document
  delete from DOC_FOOT
        where DOC_FOOT_ID = :old.DOC_DOCUMENT_ID;
end DOC_DMT_AD_CONSTRAINTS;


ALTER TRIGGER "C_ITX"."DOC_DMT_AD_CONSTRAINTS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_AD_JOURNAL"
  after delete
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*    Journaliser l'effacement du document
*
* @author Nuno Gomes Vieira
* @created 11/10/2005
* @version 2003
*/
declare
  vOld DOC_DOCUMENT%rowtype;
begin
  -- Condition pour journaliser le document
  --   Le champ "Journaliser document" du gabarit doit être coché
  if (DOC_JOURNAL_FUNCTIONS.MustJournalize(:old.DOC_GAUGE_ID) = 1) then
    --
    -- OLD values
    vOld.DOC_DOCUMENT_ID            := :old.DOC_DOCUMENT_ID;
    vOld.DOC_GAUGE_ID               := :old.DOC_GAUGE_ID;
    vOld.DMT_NUMBER                 := :old.DMT_NUMBER;
    vOld.DMT_DATE_DOCUMENT          := :old.DMT_DATE_DOCUMENT;
    vOld.DMT_DATE_VALUE             := :old.DMT_DATE_VALUE;
    vOld.DMT_DATE_DELIVERY          := :old.DMT_DATE_DELIVERY;
    vOld.DMT_DATE_PARTNER_DOCUMENT  := :old.DMT_DATE_PARTNER_DOCUMENT;
    vOld.C_DOCUMENT_STATUS          := :old.C_DOCUMENT_STATUS;
    vOld.DOC_RECORD_ID              := :old.DOC_RECORD_ID;
    vOld.PAC_THIRD_ID               := :old.PAC_THIRD_ID;
    vOld.PAC_THIRD_ACI_ID           := :old.PAC_THIRD_ACI_ID;
    vOld.PAC_THIRD_DELIVERY_ID      := :old.PAC_THIRD_DELIVERY_ID;
    vOld.PAC_THIRD_TARIFF_ID        := :old.PAC_THIRD_TARIFF_ID;
    vOld.PAC_REPRESENTATIVE_ID      := :old.PAC_REPRESENTATIVE_ID;
    vOld.PAC_REPR_ACI_ID            := :old.PAC_REPR_ACI_ID;
    vOld.PAC_REPR_DELIVERY_ID       := :old.PAC_REPR_DELIVERY_ID;
    vOld.ACS_FINANCIAL_CURRENCY_ID  := :old.ACS_FINANCIAL_CURRENCY_ID;
    vOld.ACS_FINANCIAL_ACCOUNT_ID   := :old.ACS_FINANCIAL_ACCOUNT_ID;
    vOld.ACS_DIVISION_ACCOUNT_ID    := :old.ACS_DIVISION_ACCOUNT_ID;
    vOld.ACS_CPN_ACCOUNT_ID         := :old.ACS_CPN_ACCOUNT_ID;
    vOld.ACS_PF_ACCOUNT_ID          := :old.ACS_PF_ACCOUNT_ID;
    vOld.ACS_PJ_ACCOUNT_ID          := :old.ACS_PJ_ACCOUNT_ID;
    vOld.ACS_CDA_ACCOUNT_ID         := :old.ACS_CDA_ACCOUNT_ID;
    vOld.A_DATECRE                  := :old.A_DATECRE;
    vOld.A_DATEMOD                  := :old.A_DATEMOD;
    vOld.A_IDCRE                    := :old.A_IDCRE;
    vOld.A_IDMOD                    := :old.A_IDMOD;
    -- Journaliser document
    DOC_JOURNAL_FUNCTIONS.JournalizeDocument('DELETE', vOld, vOld);
  end if;
end DOC_DMT_AD_JOURNAL;


ALTER TRIGGER "C_ITX"."DOC_DMT_AD_JOURNAL" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_AI_FREE_NUMBER"
  after insert
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*    Suppression du numéro de document dans la table doc_free_number
* @author Fabrice Perotto
* @lastUpdate FP 19.11.2007
* @version 2003
*/
begin
  -- supression coute que coute de la table des numéros libres
  DOC_PRC_DOCUMENT.DeleteFreeNumber(:new.DMT_NUMBER);
end DOC_DMT_AI_FREE_NUMBER;

ALTER TRIGGER "C_ITX"."DOC_DMT_AI_FREE_NUMBER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_AI_JOURNAL"
  after insert
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*    Journaliser l'effacement du document
*
* @author Nuno Gomes Vieira
* @created 11/10/2005
* @version 2003
*/
declare
  vNew DOC_DOCUMENT%rowtype;
begin
  -- Condition pour journaliser le document
  --   Le champ "Journaliser document" du gabarit doit être coché
  if (DOC_JOURNAL_FUNCTIONS.MustJournalize(:new.DOC_GAUGE_ID) = 1) then
    --
    -- NEW values
    vNew.DOC_DOCUMENT_ID            := :new.DOC_DOCUMENT_ID;
    vNew.DOC_GAUGE_ID               := :new.DOC_GAUGE_ID;
    vNew.DMT_NUMBER                 := :new.DMT_NUMBER;
    vNew.DMT_DATE_DOCUMENT          := :new.DMT_DATE_DOCUMENT;
    vNew.DMT_DATE_VALUE             := :new.DMT_DATE_VALUE;
    vNew.DMT_DATE_DELIVERY          := :new.DMT_DATE_DELIVERY;
    vNew.DMT_DATE_PARTNER_DOCUMENT  := :new.DMT_DATE_PARTNER_DOCUMENT;
    vNew.C_DOCUMENT_STATUS          := :new.C_DOCUMENT_STATUS;
    vNew.DOC_RECORD_ID              := :new.DOC_RECORD_ID;
    vNew.PAC_THIRD_ID               := :new.PAC_THIRD_ID;
    vNew.PAC_THIRD_ACI_ID           := :new.PAC_THIRD_ACI_ID;
    vNew.PAC_THIRD_DELIVERY_ID      := :new.PAC_THIRD_DELIVERY_ID;
    vNew.PAC_THIRD_TARIFF_ID        := :new.PAC_THIRD_TARIFF_ID;
    vNew.PAC_REPRESENTATIVE_ID      := :new.PAC_REPRESENTATIVE_ID;
    vNew.PAC_REPR_ACI_ID            := :new.PAC_REPR_ACI_ID;
    vNew.PAC_REPR_DELIVERY_ID       := :new.PAC_REPR_DELIVERY_ID;
    vNew.ACS_FINANCIAL_CURRENCY_ID  := :new.ACS_FINANCIAL_CURRENCY_ID;
    vNew.ACS_FINANCIAL_ACCOUNT_ID   := :new.ACS_FINANCIAL_ACCOUNT_ID;
    vNew.ACS_DIVISION_ACCOUNT_ID    := :new.ACS_DIVISION_ACCOUNT_ID;
    vNew.ACS_CPN_ACCOUNT_ID         := :new.ACS_CPN_ACCOUNT_ID;
    vNew.ACS_PF_ACCOUNT_ID          := :new.ACS_PF_ACCOUNT_ID;
    vNew.ACS_PJ_ACCOUNT_ID          := :new.ACS_PJ_ACCOUNT_ID;
    vNew.ACS_CDA_ACCOUNT_ID         := :new.ACS_CDA_ACCOUNT_ID;
    vNew.A_DATECRE                  := :new.A_DATECRE;
    vNew.A_DATEMOD                  := :new.A_DATEMOD;
    vNew.A_IDCRE                    := :new.A_IDCRE;
    vNew.A_IDMOD                    := :new.A_IDMOD;
    -- Journaliser document
    DOC_JOURNAL_FUNCTIONS.JournalizeDocument('INSERT', vNew, vNew);
  end if;
end DOC_DMT_AI_JOURNAL;


ALTER TRIGGER "C_ITX"."DOC_DMT_AI_JOURNAL" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_AIU_SHP_DMT_PUBLISH"
  after insert or update of C_DOCUMENT_STATUS, DMT_BALANCED
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*    Ajout de l'ID du document concerné dans la table SHP_TO_PUBLISH pour republication
*    si les conditions sont réunies pour modifier le statut du document du shop.
* @created AGE 09.02.2012
* @lastUpdate age 07.06.2012
*/
declare
  lnResult        integer;
  lvShopDocStatus SHP_TO_PUBLISH.STP_SHOP_DOC_STATUS%type;
begin
  if :new.C_DOC_CREATE_MODE = '142' then   -- Document E-Shop
    if PCS.PC_CONFIG.GetConfig(aConfigName => 'SHP_SHOP_VERSION', aCompanyID => PCS.PC_I_LIB_SESSION.GetCompanyId, aConliID => null) =
                                                                                                                  SHP_I_LIB_TYPES.gcvExternalShopConnectorValue then
      /* Résolution du statut du document shop en fonction du statut ERP */
      lvShopDocStatus  := SHP_LIB_DOCUMENT.getShopFromErpDocStatus(ivErpDocStatus => :new.C_DOCUMENT_STATUS, inDmtBalanced => :new.DMT_BALANCED);
      /* Insertion dans la table SHP_TO_PUBLISH */
      lnResult         :=
        SHP_PRC_PUBLISH.publishRecord(inStpRecID        => :new.DOC_DOCUMENT_ID
                                    , ivStpContext      => 'DOCUMENT'
                                    , ivGooWebStatus    => '1'   -- A publier
                                    , ivShopDocStatus   => lvShopDocStatus
                                    , ivShopDocNumber   => :new.DMT_PARTNER_NUMBER
                                     );
    end if;
  end if;
end DOC_DMT_AIU_SHP_DMT_PUBLISH;

ALTER TRIGGER "C_ITX"."DOC_DMT_AIU_SHP_DMT_PUBLISH" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_AU_FORNETWORK"
  after update of DMT_NUMBER
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
begin
  -- VÃ©rifier que les rÃ©seaux Logiqistiques sont activÃ©s
  if (:old.DMT_NUMBER <> :new.DMT_NUMBER) and
     FAL_NETWORK_DOC.IsDOCNetWorkEnabled then
    -- MÃ j des appros/besoins logistiques lors d'un changement du nÂ° de document
    FAL_NETWORK_DOC.ReseauMAJ_DOC_NUMBER(:new.DOC_DOCUMENT_ID, :new.DMT_NUMBER);
  end if;
end DOC_DMT_AU_FORNETWORK;

ALTER TRIGGER "C_ITX"."DOC_DMT_AU_FORNETWORK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_AU_JOURNAL"
  after update of DMT_NUMBER
                , DMT_DATE_DOCUMENT
                , DMT_DATE_VALUE
                , DMT_DATE_DELIVERY
                , DMT_DATE_PARTNER_DOCUMENT
                , C_DOCUMENT_STATUS
                , DOC_RECORD_ID
                , PAC_THIRD_ID
                , PAC_THIRD_ACI_ID
                , PAC_THIRD_DELIVERY_ID
                , PAC_THIRD_TARIFF_ID
                , PAC_REPRESENTATIVE_ID
                , PAC_REPR_ACI_ID
                , PAC_REPR_DELIVERY_ID
                , ACS_FINANCIAL_CURRENCY_ID
                , DMT_RATE_OF_EXCHANGE
                , DMT_BASE_PRICE
                , ACS_FINANCIAL_ACCOUNT_ID
                , ACS_DIVISION_ACCOUNT_ID
                , ACS_CPN_ACCOUNT_ID
                , ACS_PF_ACCOUNT_ID
                , ACS_PJ_ACCOUNT_ID
                , ACS_CDA_ACCOUNT_ID
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*    Journaliser la modification du document
*
* @author Nuno Gomes Vieira
* @created 11/10/2005
* @version 2003
*/
declare
  vOld DOC_DOCUMENT%rowtype;
  vNew DOC_DOCUMENT%rowtype;
begin
  -- Condition pour journaliser le document
  --   Document ne doit pas avoir le statut à "confirmer"
  --   Le champ "Journaliser document" du gabarit doit être coché
  if (DOC_JOURNAL_FUNCTIONS.MustJournalize(:new.DOC_GAUGE_ID) = 1) then
    --
    -- NEW values
    vNew.DOC_DOCUMENT_ID            := :new.DOC_DOCUMENT_ID;
    vNew.DOC_GAUGE_ID               := :new.DOC_GAUGE_ID;
    vNew.DMT_NUMBER                 := :new.DMT_NUMBER;
    vNew.DMT_DATE_DOCUMENT          := :new.DMT_DATE_DOCUMENT;
    vNew.DMT_DATE_VALUE             := :new.DMT_DATE_VALUE;
    vNew.DMT_DATE_DELIVERY          := :new.DMT_DATE_DELIVERY;
    vNew.DMT_DATE_PARTNER_DOCUMENT  := :new.DMT_DATE_PARTNER_DOCUMENT;
    vNew.C_DOCUMENT_STATUS          := :new.C_DOCUMENT_STATUS;
    vNew.DOC_RECORD_ID              := :new.DOC_RECORD_ID;
    vNew.PAC_THIRD_ID               := :new.PAC_THIRD_ID;
    vNew.PAC_THIRD_ACI_ID           := :new.PAC_THIRD_ACI_ID;
    vNew.PAC_THIRD_DELIVERY_ID      := :new.PAC_THIRD_DELIVERY_ID;
    vNew.PAC_THIRD_TARIFF_ID        := :new.PAC_THIRD_TARIFF_ID;
    vNew.PAC_REPRESENTATIVE_ID      := :new.PAC_REPRESENTATIVE_ID;
    vNew.PAC_REPR_ACI_ID            := :new.PAC_REPR_ACI_ID;
    vNew.PAC_REPR_DELIVERY_ID       := :new.PAC_REPR_DELIVERY_ID;
    vNew.ACS_FINANCIAL_CURRENCY_ID  := :new.ACS_FINANCIAL_CURRENCY_ID;
    vNew.DMT_RATE_OF_EXCHANGE       := :new.DMT_RATE_OF_EXCHANGE;
    vNew.DMT_BASE_PRICE             := :new.DMT_BASE_PRICE;
    vNew.ACS_FINANCIAL_ACCOUNT_ID   := :new.ACS_FINANCIAL_ACCOUNT_ID;
    vNew.ACS_DIVISION_ACCOUNT_ID    := :new.ACS_DIVISION_ACCOUNT_ID;
    vNew.ACS_CPN_ACCOUNT_ID         := :new.ACS_CPN_ACCOUNT_ID;
    vNew.ACS_PF_ACCOUNT_ID          := :new.ACS_PF_ACCOUNT_ID;
    vNew.ACS_PJ_ACCOUNT_ID          := :new.ACS_PJ_ACCOUNT_ID;
    vNew.ACS_CDA_ACCOUNT_ID         := :new.ACS_CDA_ACCOUNT_ID;
    vNew.A_DATECRE                  := :new.A_DATECRE;
    vNew.A_DATEMOD                  := :new.A_DATEMOD;
    vNew.A_IDCRE                    := :new.A_IDCRE;
    vNew.A_IDMOD                    := :new.A_IDMOD;
    --
    -- OLD values
    vOld.DOC_DOCUMENT_ID            := :old.DOC_DOCUMENT_ID;
    vOld.DOC_GAUGE_ID               := :old.DOC_GAUGE_ID;
    vOld.DMT_NUMBER                 := :old.DMT_NUMBER;
    vOld.DMT_DATE_DOCUMENT          := :old.DMT_DATE_DOCUMENT;
    vOld.DMT_DATE_VALUE             := :old.DMT_DATE_VALUE;
    vOld.DMT_DATE_DELIVERY          := :old.DMT_DATE_DELIVERY;
    vOld.DMT_DATE_PARTNER_DOCUMENT  := :old.DMT_DATE_PARTNER_DOCUMENT;
    vOld.C_DOCUMENT_STATUS          := :old.C_DOCUMENT_STATUS;
    vOld.DOC_RECORD_ID              := :old.DOC_RECORD_ID;
    vOld.PAC_THIRD_ID               := :old.PAC_THIRD_ID;
    vOld.PAC_THIRD_ACI_ID           := :old.PAC_THIRD_ACI_ID;
    vOld.PAC_THIRD_DELIVERY_ID      := :old.PAC_THIRD_DELIVERY_ID;
    vOld.PAC_THIRD_TARIFF_ID        := :old.PAC_THIRD_TARIFF_ID;
    vOld.PAC_REPRESENTATIVE_ID      := :old.PAC_REPRESENTATIVE_ID;
    vOld.PAC_REPR_ACI_ID            := :old.PAC_REPR_ACI_ID;
    vOld.PAC_REPR_DELIVERY_ID       := :old.PAC_REPR_DELIVERY_ID;
    vOld.ACS_FINANCIAL_CURRENCY_ID  := :old.ACS_FINANCIAL_CURRENCY_ID;
    vOld.DMT_RATE_OF_EXCHANGE       := :old.DMT_RATE_OF_EXCHANGE;
    vOld.DMT_BASE_PRICE             := :old.DMT_BASE_PRICE;
    vOld.ACS_FINANCIAL_ACCOUNT_ID   := :old.ACS_FINANCIAL_ACCOUNT_ID;
    vOld.ACS_DIVISION_ACCOUNT_ID    := :old.ACS_DIVISION_ACCOUNT_ID;
    vOld.ACS_CPN_ACCOUNT_ID         := :old.ACS_CPN_ACCOUNT_ID;
    vOld.ACS_PF_ACCOUNT_ID          := :old.ACS_PF_ACCOUNT_ID;
    vOld.ACS_PJ_ACCOUNT_ID          := :old.ACS_PJ_ACCOUNT_ID;
    vOld.ACS_CDA_ACCOUNT_ID         := :old.ACS_CDA_ACCOUNT_ID;
    vOld.A_DATECRE                  := :old.A_DATECRE;
    vOld.A_DATEMOD                  := :old.A_DATEMOD;
    vOld.A_IDCRE                    := :old.A_IDCRE;
    vOld.A_IDMOD                    := :old.A_IDMOD;
    -- Journaliser document
    DOC_JOURNAL_FUNCTIONS.JournalizeDocument('UPDATE', vOld, vNew);
  end if;
end DOC_DMT_AU_JOURNAL;

ALTER TRIGGER "C_ITX"."DOC_DMT_AU_JOURNAL" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_AU_MACHINE"
  before update of C_DOCUMENT_STATUS
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*    Effectue la mise à jour des donnnées d'achat des machines liéés à la position
*
* @author Vincent Jeanfavre
* @created 05.08.2005
* @lastUpdate 08.06.2006 JCH
* @version 2003
*/
declare
  numInstallations number;
  cGaugeTitle      DOC_GAUGE_STRUCTURED.C_GAUGE_TITLE%type;
begin
  if     :old.C_DOCUMENT_STATUS = '01'
     and :new.C_DOCUMENT_STATUS in('02', '03', '04') then
    -- Controle si le gabarit courant gère les installations et qu'au moins un
    -- détail de position est lié à une intallation.
    select count(PDE.DOC_RECORD_ID)
      into numInstallations
      from DOC_GAUGE GAU
         , DOC_GAUGE_STRUCTURED GAS
         , DOC_POSITION POS
         , DOC_POSITION_DETAIL PDE
         , DOC_RECORD RCO
     where GAU.DOC_GAUGE_ID = :new.DOC_GAUGE_ID
       and GAU.C_ADMIN_DOMAIN = '1'
       and GAS.DOC_GAUGE_ID = GAU.DOC_GAUGE_ID
       and GAS.GAS_INSTALLATION_MGM = 1
       and ',' || GAS.C_GAUGE_TITLE || ',' in(',3,', ',4,')
       and POS.DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID
       and PDE.DOC_POSITION_ID = POS.DOC_POSITION_ID
       and RCO.DOC_RECORD_ID = PDE.DOC_RECORD_ID;

    if numInstallations > 0 then
      -- Mise à jour des données de l'onglet fournisseur des installations du document
      DOC_RECORD_FUNCTIONS.UpdateRecordMachines(:new.DOC_DOCUMENT_ID, :new.DMT_DATE_DOCUMENT);
    end if;
  end if;
end DOC_DMT_AU_MACHINE;


ALTER TRIGGER "C_ITX"."DOC_DMT_AU_MACHINE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_AU_PIC_ORDER_QTY"
  after update of DMT_DATE_VALUE
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*    Effectue la mise à jour des quantités en commande pour les BL non confirmés
*  , la date valeur du document étant prise en compte comme période PIC
* @author ECA
* @created 12.12.2088
* @lastUpdate
* @version 2003
*/
declare
  Cursor CrDocPositionDetails(aDocDocumentId number) is
    select pde.gco_good_id
         , pde.pac_third_id
         , pos.pac_representative_id
         , cus.dic_pic_group_id
         , pde.stm_location_id
         , pde.pde_balance_quantity
      from doc_position pos
         , doc_position_detail pde
         , pac_custom_partner cus
     where pos.doc_document_id = aDocDocumentId
       and pos.doc_position_id = pde.doc_position_id
       and pde.pac_third_id = cus.pac_custom_partner_id (+)
       and pos.c_gauge_type_pos in ('1', '2', '3', '71', '81', '91', '101')
       and pos.pos_transfert_proprietor <> '1';

  aGaugeType             DOC_GAUGE.C_GAUGE_TYPE%Type;
  aGasUpdatePicOrderQty  DOC_GAUGE_STRUCTURED.GAS_UPDATE_PIC_ORDER_QTY%Type;
begin
  if to_number(PCS.PC_CONFIG.GetConfig('FAL_PIC') ) in (2, 3) then

    -- Récupérer le type de gabarit du document, ainsi que le Flag de MAJ de la Qté commande PIC
    begin
      select GAU.C_GAUGE_TYPE
           , GAS.GAS_UPDATE_PIC_ORDER_QTY
        into aGaugeType
           , aGasUpdatePicOrderQty
        from DOC_GAUGE_STRUCTURED GAS
           , DOC_GAUGE GAU
       where GAU.DOC_GAUGE_ID = :new.DOC_GAUGE_ID
         and GAU.DOC_GAUGE_ID = GAS.DOC_GAUGE_ID;
    exception
      when no_data_found then begin
        aGaugeType := '';
        aGasUpdatePicOrderQty := 0;
      end;
    end;

    if :new.c_document_status = '01'
      and aGaugeType = '3'
      and aGasUpdatePicOrderQty = 1
      and :old.dmt_date_value <> :new.dmt_date_value then

      for tplDocPositionDetails in CrDocPositionDetails(:new.doc_document_id) loop
        if FAL_TOOLS.IsLocationOnStockNeedPic(tplDocPositionDetails.stm_location_id) then
          -- Diminution de la qté en commande du BL non confirmé, pour l'ancienne date valeur du document
          FAL_PLAN_DIRECTEUR.ProcessusMajQteCmdPicLine(tplDocPositionDetails.GCO_GOOD_ID
                                                     , :old.DMT_DATE_VALUE
                                                     , tplDocPositionDetails.PAC_THIRD_ID
                                                     , tplDocPositionDetails.PAC_REPRESENTATIVE_ID
                                                     , - tplDocPositionDetails.pde_balance_quantity
                                                     , tplDocPositionDetails.DIC_PIC_GROUP_ID
                                                     );
          -- Augmentation de la qté en commande du BL non confirmé, pour l'ancienne date valeur du document
          FAL_PLAN_DIRECTEUR.ProcessusMajQteCmdPicLine(tplDocPositionDetails.GCO_GOOD_ID
                                                     , :new.DMT_DATE_VALUE
                                                     , tplDocPositionDetails.PAC_THIRD_ID
                                                     , tplDocPositionDetails.PAC_REPRESENTATIVE_ID
                                                     , tplDocPositionDetails.pde_balance_quantity
                                                     , tplDocPositionDetails.DIC_PIC_GROUP_ID
                                                     );
        end if;
      end loop;

    end if;
  end if;

end DOC_DMT_AU_PIC_ORDER_QTY;

ALTER TRIGGER "C_ITX"."DOC_DMT_AU_PIC_ORDER_QTY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_AU_SQM_PENALTY"
  after update of DMT_DATE_DOCUMENT, DMT_DATE_VALUE
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*    Recalcul des notes après modification de la date du document cible
* @created DSA 19.08.2003
 *@modified DSA 21.06.2004
* @version 2003
* @lastUpdate
*/
declare
  -- curseur sur tous les DOC_POSITION_DETAIL_ID du document concernés par la modification pour le calcul des notes
  cursor crDocPosDet(DocumentId in number, DmtDate in date)
  is
    select DmtDate DATE_REF
         , SQM_FUNCTIONS.GetFirstFitScale(SPE.SQM_AXIS_ID, DmtDate, SPE.GCO_GOOD_ID) SQM_SCALE_ID
         , SPE.SQM_AXIS_ID
         , SPE.DOC_POSITION_DETAIL_ID
         , SPE.GCO_GOOD_ID
         , SPE.SQM_PENALTY_ID
         , SPE.SPE_EXPECTED_VALUE
      from DOC_POSITION POS
         , SQM_PENALTY SPE
     where SPE.DOC_POSITION_ID = POS.DOC_POSITION_ID
       and POS.DOC_DOCUMENT_ID = DocumentId;

  tplDocPosDet crDocPosDet%rowtype;
  vEffValue    SQM_PENALTY.SPE_EFFECTIVE_VALUE%type;
  vAxisValue   SQM_PENALTY.SPE_INIT_VALUE%type;
begin
  if PCS.PC_CONFIG.GETCONFIG('SQM_QUALITY_MGM') = '1' then
    -- si la date document a été modifiée et que le calcul des notes se fait par rapport à la date document
    if     (:new.DMT_DATE_DOCUMENT <> :old.DMT_DATE_DOCUMENT)
       and (upper(PCS.PC_CONFIG.GETCONFIG('SQM_REFERENCE_DATE') ) = 'DOC') then
      open crDocPosDet(:new.DOC_DOCUMENT_ID, :new.DMT_DATE_DOCUMENT);

      SQM_INIT_METHOD.dtDateDoc  := :new.DMT_DATE_DOCUMENT;
    -- si la date valeur a été modifiée et que le calcul des notes se fait par rapport à la date valeur
    elsif     (:new.DMT_DATE_VALUE <> :old.DMT_DATE_VALUE)
          and (upper(PCS.PC_CONFIG.GETCONFIG('SQM_REFERENCE_DATE') ) = 'VAL') then
      open crDocPosDet(:new.DOC_DOCUMENT_ID, :new.DMT_DATE_VALUE);

      SQM_INIT_METHOD.dtDateDoc  := :new.DMT_DATE_VALUE;
    end if;

    -- Recalcul de toutes les notes du document
    if crDocPosDet%isopen then
      fetch crDocPosDet
       into tplDocPosDet;

      while crDocPosDet%found loop
        SQM_INIT_METHOD.CalcAxisValue(tplDocPosDet.SQM_AXIS_ID, tplDocPosDet.SPE_EXPECTED_VALUE, vEffValue, vAxisValue, tplDocPosDet.DOC_POSITION_DETAIL_ID);

        update SQM_PENALTY
           set SQM_SCALE_ID = tplDocPosDet.SQM_SCALE_ID
             , SPE_DATE_REFERENCE = tplDocPosDet.DATE_REF
             , SPE_CALC_PENALTY = SQM_FUNCTIONS.CalcPenalty(tplDocPosDet.SQM_SCALE_ID, vAxisValue)
             , SPE_EXPECTED_VALUE = tplDocPosDet.SPE_EXPECTED_VALUE
             , SPE_EFFECTIVE_VALUE = vEffValue
             , SPE_INIT_VALUE = vAxisValue
             , A_DATEMOD = sysdate
             , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
         where SQM_PENALTY_ID = tplDocPosDet.SQM_PENALTY_ID;

        fetch crDocPosDet
         into tplDocPosDet;
      end loop;

      close crDocPosDet;
    end if;
  end if;
end DOC_DMT_AU_SQM_PENALTY;

ALTER TRIGGER "C_ITX"."DOC_DMT_AU_SQM_PENALTY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_BD_DOCU_ACCU"
  before delete
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des totalisateurs de document avant effacement
* @author Fabrice Perotto
* @version 2003
*/
declare
  -- curseur sur les totaux du pied de document
  cursor DOC_VALUES_CURSOR(doc_id number)
  is
    select FOO_DOCUMENT_TOTAL_AMOUNT
         , FOO_TOTAL_VAT_AMOUNT
      from DOC_FOOT
     where DOC_FOOT.DOC_DOCUMENT_ID = doc_id;

  doc_values_tuple doc_values_cursor%rowtype;
begin
  -- pas de mise à jour des totalisateurs (possible uniquement par recalcul global)
  if PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '0' then
    null;
  -- mise à jour instantannée des totalisateurs de position
  elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '1' then
    -- recherche des montants du document
    open DOC_VALUES_CURSOR(:old.DOC_DOCUMENT_ID);

    fetch DOC_VALUES_CURSOR
     into doc_values_tuple;

    if DOC_VALUES_CURSOR%found then
      -- mise à jour des totalisateurs de document
      DOC_ACCUMULATOR.DOC_TOTAL_DOCUMENT(:old.DOC_DOCUMENT_ID
                                       , :old.DMT_DATE_DOCUMENT
                                       , :old.DIC_GAUGE_TYPE_DOC_ID
                                       , :old.C_DOCUMENT_STATUS
                                       , :old.PAC_THIRD_ID
                                       , doc_values_tuple.FOO_DOCUMENT_TOTAL_AMOUNT
                                       , doc_values_tuple.FOO_TOTAL_VAT_AMOUNT
                                       , -1
                                       , 0
                                        );
    end if;

    close DOC_VALUES_CURSOR;
  -- insertion dans le buffer des totalisateurs de position (maj différée)
  elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '2' then
    insert into DOC_DOCU_ACCU_BUFFER
                (DOC_DOCU_ACCU_BUFFER_ID
               , DOC_DOCUMENT_ID
               , C_DOCUMENT_STATUS
               , DIC_GAUGE_TYPE_DOC_ID
               , PAC_THIRD_ID
               , DAB_SIGN
               , DMT_DATE_DOCUMENT
               , FOO_DOCUMENT_TOTAL_AMOUNT
               , FOO_TOTAL_VAT_AMOUNT
                )
      select INIT_ID_SEQ.nextval
           , :old.DOC_DOCUMENT_ID
           , :old.C_DOCUMENT_STATUS
           , :old.DIC_GAUGE_TYPE_DOC_ID
           , :old.PAC_THIRD_ID
           , -1
           , :old.DMT_DATE_DOCUMENT
           , FOO_DOCUMENT_TOTAL_AMOUNT
           , FOO_TOTAL_VAT_AMOUNT
        from DOC_FOOT
       where DOC_FOOT_ID = :old.DOC_DOCUMENT_ID;
  end if;
end DOC_DMT_BD_DOCU_ACCU;

ALTER TRIGGER "C_ITX"."DOC_DMT_BD_DOCU_ACCU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_BD_FREE_NUMBER"
  before delete
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*     Gestion des numéros libres avant effacement
*     Vérifie que le document ne soit pas encore en mode protégé lors de l'effacement
*     Récupération du numéro de document dans la table doc_free_number
* @author Fabrice Perotto
* @lastUpdate FP 19.02.2003
* @version 2003
*/
declare
  gau_number             DOC_GAUGE.GAU_NUMBERING%type;
  gauge_numbering_id     DOC_GAUGE.DOC_GAUGE_NUMBERING_ID%type;
  free_number            DOC_GAUGE_NUMBERING.GAN_FREE_NUMBER%type;
  temp_number            DOC_FREE_NUMBER.DOF_NUMBER%type;
  temp_gaugestructuredid DOC_GAUGE_STRUCTURED.DOC_GAUGE_ID%type;
begin
  -- Ne peut pas effacer un document protégé
  if :old.DMT_PROTECTED = 1 then
    raise_application_error(-20020, 'Unable to delete a protected document');
  end if;

  -- Récupération du numéro de document seulement si le document qui est en train d'être
  -- effacé n'est pas "liquidé" ou ne possède pas de gabarit structuré
  select max(DOC_GAUGE_ID)
    into temp_gaugestructuredid
    from DOC_GAUGE_STRUCTURED
   where DOC_GAUGE_STRUCTURED.DOC_GAUGE_ID = :old.DOC_GAUGE_ID;

  if    :old.C_DOCUMENT_STATUS <> '04'
     or (temp_gaugestructuredid is null) then
    select GAU_NUMBERING
         , DOC_GAUGE.DOC_GAUGE_NUMBERING_ID
         , GAN_FREE_NUMBER
      into gau_number
         , gauge_numbering_id
         , free_number
      from DOC_GAUGE
         , DOC_GAUGE_NUMBERING
     where DOC_GAUGE_ID = :old.DOC_GAUGE_ID
       and DOC_GAUGE_NUMBERING.DOC_GAUGE_NUMBERING_ID(+) = DOC_GAUGE.DOC_GAUGE_NUMBERING_ID;

    -- si on gère la numérotation sur ce type de document
    if     (gau_number = 1)
       and (free_number = 1) then
      begin
        insert into DOC_FREE_NUMBER
                    (DOC_FREE_NUMBER_ID
                   , DOC_GAUGE_NUMBERING_ID
                   , DOF_NUMBER
                   , DOF_CREATING
                   , DOF_SESSION_ID
                    )
             values (init_id_seq.nextval
                   , gauge_numbering_id
                   , :old.DMT_NUMBER
                   , 0
                   , 0
                    );
      exception
        when dup_val_on_index then
          null;   -- en cas de doublons, on continue sans errur
      end;
    end if;
  end if;
end DOC_DMT_BD_FREE_NUMBER;

ALTER TRIGGER "C_ITX"."DOC_DMT_BD_FREE_NUMBER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_BI_DENORM"
  before insert
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des champs dénormalisés de DOC_DOCUMENT
* @author NGV
* @version 2003
*/
begin
  select C_GAU_THIRD_VAT
    into :new.C_GAU_THIRD_VAT
    from DOC_GAUGE
   where DOC_GAUGE_ID = :new.DOC_GAUGE_ID;
end DOC_DMT_BI_DENORM;

ALTER TRIGGER "C_ITX"."DOC_DMT_BI_DENORM" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_BI_RECORD"
  before insert
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*     Initialisation automatique du dossier avant l'insertion
* @author SK
* @lastupdate hto 19.11.2007
* @version 2003
*/
declare
  vCreatedRecordId DOC_DOCUMENT.DOC_RECORD_ID%type;
  vLinkRecord      number(1);
  vRecordCategoryId  DOC_RECORD.DOC_RECORD_ID%type;
begin
  select DOC_RECORD_CATEGORY_ID
      into vRecordCategoryId
      from DOC_GAUGE
     where DOC_GAUGE_ID = :new.DOC_GAUGE_ID;

  vCreatedRecordID  :=
    DOC_RECORD_MANAGEMENT.CreateRecord(:new.DOC_GAUGE_ID
                                     , ''
                                     , :new.DOC_RECORD_ID
                                     , :new.PAC_THIRD_ID
                                     , :new.DOC_DOCUMENT_ID
                                     , :new.DMT_NUMBER
                                     , vLinkRecord
                                     , vRecordCategoryId
                                      );

  if     vCreatedRecordId <> -1
     and vLinkRecord = 1
     and :new.DOC_RECORD_ID is null then
    :new.DOC_RECORD_ID  := vCreatedRecordId;
  end if;
end DOC_DMT_BI_RECORD;

ALTER TRIGGER "C_ITX"."DOC_DMT_BI_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_BIUD_MISSING_NUMBERS"
  after insert or delete or update of "DMT_NUMBER"
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*    Gestion des numéros manquants
* @created fp 14.02.2003
* @version 2003
* @lastUpdate
*/
declare
  ganIncrement DOC_GAUGE_NUMBERING.GAN_INCREMENT%type;
begin
  -- suppression du numéro manquant
  if    inserting
     or updating then
    DOC_PRC_DOCUMENT.DeleteMissingNumber(:new.DMT_NUMBER);
  end if;

  -- insertion du numéro dans la liste des numéros manquants
  if    updating
     or deleting then
    select gan.gan_increment
      into ganIncrement
      from doc_gauge gau
         , doc_gauge_numbering gan
     where gau.doc_gauge_id = :old.DOC_GAUGE_ID
       and gau.doc_gauge_numbering_id = gan.doc_gauge_numbering_id(+);

    if ganIncrement = 1 then
      declare
        vSessionId DOC_MISSING_NUMBER.DMN_SESSION_ID%type;
      begin
        if deleting then
          vSessionId  := 0;
        end if;

        insert into DOC_MISSING_NUMBER
                    (DOC_MISSING_NUMBER_ID
                   , DOC_GAUGE_NUMBERING_ID
                   , STM_EXERCISE_ID
                   , DOC_GAUGE_ID
                   , DMN_NUMBER
                   , DMN_CREATING
                   , DMN_SESSION_ID
                   , A_DATECRE
                   , A_IDCRE
                    )
          select init_id_seq.nextval
               , DOC_GAUGE_NUMBERING_ID
               , STM_FUNCTIONS.GetPeriodExerciseId(STM_FUNCTIONS.GetPeriodId(:old.DMT_DATE_DOCUMENT) )
               , :old.DOC_GAUGE_ID
               , :old.DMT_NUMBER
               , 0
               , vSessionId
               , sysdate
               , PCS.PC_I_LIB_SESSION.GetUserIni
            from DOC_GAUGE
           where DOC_GAUGE_ID = :old.DOC_GAUGE_ID;
      exception
        when dup_val_on_index then   -- ne pas déclencher d'exception si insertion de doublon
          null;
      end;
    end if;
  end if;
end DOC_DMT_BIUD_MISSING_NUMBERS;

ALTER TRIGGER "C_ITX"."DOC_DMT_BIUD_MISSING_NUMBERS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_BIUD_UPDATE_HISTORY"
  before insert or update or delete
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*     Trigger mettant à jour la table d'historique des modifications DML sur les documents
* @author Fabrice Perotto
* @created 08/10/2001
* @version 2003
*/
declare
  hisDescription DOC_UPDATE_HISTORY.DUH_DESCRIPTION%type;
begin
  if inserting then
    hisDescription  := 'DOCUMENT INSERT (START EDITION)';
    DOC_FUNCTIONS.CreateHistoryInformation(nvl(:new.DOC_DOCUMENT_ID, :old.DOC_DOCUMENT_ID)
                                         , null
                                         ,   -- DOC_POSITION_ID
                                           nvl(:new.DMT_NUMBER, :old.DMT_NUMBER)
                                         ,   -- no de document
                                           'TRIGGER'
                                         ,   -- DUH_TYPE
                                           hisDescription
                                         , null
                                         ,   -- description libre
                                           nvl(:new.C_DOCUMENT_STATUS, :old.C_DOCUMENT_STATUS)
                                         ,   -- status document
                                           null
                                          );   -- status position
  elsif deleting then
    hisDescription  := 'DOCUMENT DELETE';
    DOC_FUNCTIONS.CreateHistoryInformation(nvl(:new.DOC_DOCUMENT_ID, :old.DOC_DOCUMENT_ID)
                                         , null
                                         ,   -- DOC_POSITION_ID
                                           nvl(:new.DMT_NUMBER, :old.DMT_NUMBER)
                                         ,   -- no de document
                                           'TRIGGER'
                                         ,   -- DUH_TYPE
                                           hisDescription
                                         , null
                                         ,   -- description libre
                                           nvl(:new.C_DOCUMENT_STATUS, :old.C_DOCUMENT_STATUS)
                                         ,   -- status document
                                           null
                                          );   -- status position
  elsif updating then
    -- recherche si on part en modification de document
    if     :old.DMT_PROTECTED = 0
       and :new.DMT_PROTECTED = 1 then
      hisDescription  := 'DOCUMENT START EDITION';
      DOC_FUNCTIONS.CreateHistoryInformation(nvl(:new.DOC_DOCUMENT_ID, :old.DOC_DOCUMENT_ID)
                                           , null
                                           ,   -- DOC_POSITION_ID
                                             nvl(:new.DMT_NUMBER, :old.DMT_NUMBER)
                                           ,   -- no de document
                                             'TRIGGER'
                                           ,   -- DUH_TYPE
                                             hisDescription
                                           , null
                                           ,   -- description libre
                                             nvl(:new.C_DOCUMENT_STATUS, :old.C_DOCUMENT_STATUS)
                                           ,   -- status document
                                             null
                                            );   -- status position
    elsif     :old.DMT_PROTECTED = 1
          and :new.DMT_PROTECTED = 0 then
      hisDescription  := 'DOCUMENT END EDITION';
      DOC_FUNCTIONS.CreateHistoryInformation(nvl(:new.DOC_DOCUMENT_ID, :old.DOC_DOCUMENT_ID)
                                           , null
                                           ,   -- DOC_POSITION_ID
                                             nvl(:new.DMT_NUMBER, :old.DMT_NUMBER)
                                           ,   -- no de document
                                             'TRIGGER'
                                           ,   -- DUH_TYPE
                                             hisDescription
                                           , null
                                           ,   -- description libre
                                             nvl(:new.C_DOCUMENT_STATUS, :old.C_DOCUMENT_STATUS)
                                           ,   -- status document
                                             null
                                            );   -- status position
    end if;

    -- intégration financière
    if     :old.DMT_FINANCIAL_CHARGING = 0
       and :new.DMT_FINANCIAL_CHARGING = 1 then
      hisDescription  := 'DOCUMENT FINANCIAL INTEGRATION';
      DOC_FUNCTIONS.CreateHistoryInformation(nvl(:new.DOC_DOCUMENT_ID, :old.DOC_DOCUMENT_ID)
                                           , null
                                           ,   -- DOC_POSITION_ID
                                             nvl(:new.DMT_NUMBER, :old.DMT_NUMBER)
                                           ,   -- no de document
                                             'TRIGGER'
                                           ,   -- DUH_TYPE
                                             hisDescription
                                           , null
                                           ,   -- description libre
                                             nvl(:new.C_DOCUMENT_STATUS, :old.C_DOCUMENT_STATUS)
                                           ,   -- status document
                                             null
                                            );   -- status position
    end if;

    -- impression du document
    if     :old.DMT_MAIN_PRINTING = 0
       and :new.DMT_MAIN_PRINTING = 1 then
      hisDescription  := 'DOCUMENT PRINT';
      DOC_FUNCTIONS.CreateHistoryInformation(nvl(:new.DOC_DOCUMENT_ID, :old.DOC_DOCUMENT_ID)
                                           , null
                                           ,   -- DOC_POSITION_ID
                                             nvl(:new.DMT_NUMBER, :old.DMT_NUMBER)
                                           ,   -- no de document
                                             'TRIGGER'
                                           ,   -- DUH_TYPE
                                             hisDescription
                                           , null
                                           ,   -- description libre
                                             nvl(:new.C_DOCUMENT_STATUS, :old.C_DOCUMENT_STATUS)
                                           ,   -- status document
                                             null
                                            );   -- status position
    end if;

    -- Solde du document
    if     :old.DMT_BALANCED = 0
       and :new.DMT_BALANCED = 1 then
      hisDescription  := 'DOCUMENT BALANCE';
      DOC_FUNCTIONS.CreateHistoryInformation(nvl(:new.DOC_DOCUMENT_ID, :old.DOC_DOCUMENT_ID)
                                           , null
                                           ,   -- DOC_POSITION_ID
                                             nvl(:new.DMT_NUMBER, :old.DMT_NUMBER)
                                           ,   -- no de document
                                             'TRIGGER'
                                           ,   -- DUH_TYPE
                                             hisDescription
                                           , null
                                           ,   -- description libre
                                             nvl(:new.C_DOCUMENT_STATUS, :old.C_DOCUMENT_STATUS)
                                           ,   -- status document
                                             null
                                            );   -- status position
    end if;

    -- Exportation du document
    if     :old.DMT_EXPORTED = 0
       and :new.DMT_EXPORTED = 1 then
      hisDescription  := 'DOCUMENT EXPORT';
      DOC_FUNCTIONS.CreateHistoryInformation(nvl(:new.DOC_DOCUMENT_ID, :old.DOC_DOCUMENT_ID)
                                           , null
                                           ,   -- DOC_POSITION_ID
                                             nvl(:new.DMT_NUMBER, :old.DMT_NUMBER)
                                           ,   -- no de document
                                             'TRIGGER'
                                           ,   -- DUH_TYPE
                                             hisDescription
                                           , null
                                           ,   -- description libre
                                             nvl(:new.C_DOCUMENT_STATUS, :old.C_DOCUMENT_STATUS)
                                           ,   -- status document
                                             null
                                            );   -- status position
    end if;

    -- modification du status
    if :old.C_DOCUMENT_STATUS <> :new.C_DOCUMENT_STATUS then
      hisDescription  := 'DOCUMENT STATUS UPDATE';
      DOC_FUNCTIONS.CreateHistoryInformation(nvl(:new.DOC_DOCUMENT_ID, :old.DOC_DOCUMENT_ID)
                                           , null
                                           ,   -- DOC_POSITION_ID
                                             nvl(:new.DMT_NUMBER, :old.DMT_NUMBER)
                                           ,   -- no de document
                                             'TRIGGER'
                                           ,   -- DUH_TYPE
                                             hisDescription
                                           , null
                                           ,   -- description libre
                                             nvl(:new.C_DOCUMENT_STATUS, :old.C_DOCUMENT_STATUS)
                                           ,   -- status document
                                             null
                                            );   -- status position
    end if;
  end if;
end DOC_DMT_BIUD_UPDATE_HISTORY;

ALTER TRIGGER "C_ITX"."DOC_DMT_BIUD_UPDATE_HISTORY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_BIU_INIT_FLAGS"
  before insert or update of "PAC_PAYMENT_CONDITION_ID", "PAC_FINANCIAL_REFERENCE_ID", "DMT_DATE_VALUE", "ACS_FIN_ACC_S_PAYMENT_ID"
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*    trigger sur la modification des flags de récapitulation
* @created fp 15.02.2002
* @lastupdate fpe 03.07.2013
*/
declare
  lWeightMat       DOC_GAUGE_STRUCTURED.GAS_WEIGHT_MAT%type;
  lInvoiceExpiry   DOC_GAUGE_STRUCTURED.GAS_INVOICE_EXPIRY%type;
  lCharge          DOC_GAUGE_STRUCTURED.GAS_CHARGE%type;
  lConditionKind   PAC_PAYMENT_CONDITION.C_PAYMENT_CONDITION_KIND%type;
  lExpiryInputType PAC_PAYMENT_CONDITION.C_INVOICE_EXPIRY_INPUT_TYPE%type;
  lOnlyAmount      PAC_PAYMENT_CONDITION.PCO_ONLY_AMOUNT_BILL_BOOK%type;
begin
  -- si on a pas affaire à un gabarit structuré, on passe dans l'exception silencieuse
  select GAS_WEIGHT_MAT
       , GAS_INVOICE_EXPIRY
       , sign(GAS_CHARGE + GAS_DISCOUNT)
    into lWeightMat
       , lInvoiceExpiry
       , lCharge
    from DOC_GAUGE_STRUCTURED
   where DOC_GAUGE_ID = :new.DOC_GAUGE_ID;

  -- activation du flag de génération des remises/taxes
  if inserting then
    :new.DMT_CREATE_FOOT_CHARGE  := lCharge;
    -- maj du flag document de gestion des poids matières précieuses
    :new.DMT_CREATE_FOOT_MAT     := lWeightMat;
    -- initialisation de l'id de la session du document
    :new.DMT_SESSION_ID          := DBMS_SESSION.UNIQUE_SESSION_ID;
  end if;

  -- force le recalcul des échéances et de la référence BVR
  if    :new.PAC_PAYMENT_CONDITION_ID is not null
     or updating then
    :new.DMT_REDO_PAYMENT_DATE  := 1;

    -- seulement si une modification autre que la date valeur, on regénère les no BVR
    if    nvl(:new.PAC_PAYMENT_CONDITION_ID, 0) <> nvl(:old.PAC_PAYMENT_CONDITION_ID, 0)
       or nvl(:new.PAC_FINANCIAL_REFERENCE_ID, 0) <> nvl(:old.PAC_FINANCIAL_REFERENCE_ID, 0)
       or nvl(:new.ACS_FIN_ACC_S_PAYMENT_ID, 0) <> nvl(:old.ACS_FIN_ACC_S_PAYMENT_ID, 0) then
      :new.DMT_REDO_PAYMENT_BVR  := 1;
    end if;
  end if;

  -- logique de l'échéancier
  if :new.PAC_PAYMENT_CONDITION_ID is not null then
    -- en insertion ou si on a changé les cond de payment
    if    inserting
       or (    updating
           and nvl(:new.PAC_PAYMENT_CONDITION_ID, 0) <> nvl(:old.PAC_PAYMENT_CONDITION_ID, 0) ) then
      -- recherche du type de condition de paiement (normal ou échéancier)
      select C_PAYMENT_CONDITION_KIND
           , nvl(C_INVOICE_EXPIRY_INPUT_TYPE, '01')
           , nvl(PCO_ONLY_AMOUNT_BILL_BOOK, 0)
        into lConditionKind
           , lExpiryInputType
           , lOnlyAmount
        from PAC_PAYMENT_CONDITION
       where PAC_PAYMENT_CONDITION_ID = :new.PAC_PAYMENT_CONDITION_ID;

      --si on est en modification et qu'on avait précédement un échéancier
      if     updating
         and :old.DMT_INVOICE_EXPIRY = 1 then
        delete from DOC_INVOICE_EXPIRY
              where DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID;
      end if;

      -- si la nouvelle condition de paiement est de type échéancier, maj des propriétés de l'échéancier
      if lConditionKind = '02' then
        :new.DMT_INVOICE_EXPIRY           := lInvoiceExpiry;
        :new.DMT_CREATE_INVOICE_EXPIRY    := lInvoiceExpiry;
        :new.C_INVOICE_EXPIRY_INPUT_TYPE  := lExpiryInputType;
        :new.DMT_ONLY_AMOUNT_BILL_BOOK    := lOnlyAmount;
      -- sinon reset des propriétés de l'échéancier
      else
        :new.DMT_INVOICE_EXPIRY           := 0;
        :new.DMT_CREATE_INVOICE_EXPIRY    := 0;
        :new.C_INVOICE_EXPIRY_INPUT_TYPE  := null;
        :new.DMT_ONLY_AMOUNT_BILL_BOOK    := null;
      end if;
    end if;
  -- si on a supprimé les conditions de paiement
  elsif     :old.PAC_PAYMENT_CONDITION_ID is not null
        and :new.PAC_PAYMENT_CONDITION_ID is null then
    -- suppression de l'échéancier
    delete from DOC_INVOICE_EXPIRY
          where DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID;

    -- reset des propriétés de l'échéancier
    :new.DMT_INVOICE_EXPIRY           := 0;
    :new.DMT_CREATE_INVOICE_EXPIRY    := 0;
    :new.C_INVOICE_EXPIRY_INPUT_TYPE  := null;
    :new.DMT_ONLY_AMOUNT_BILL_BOOK    := null;
  end if;

  if     updating
     and (nvl(:new.ACS_FIN_ACC_S_PAYMENT_ID, 0) <> nvl(:old.ACS_FIN_ACC_S_PAYMENT_ID, 0) ) then
    :new.DMT_REDO_PAYMENT_BVR  := 1;
  end if;
exception
  when no_data_found then
    null;
end DOC_DMT_BIU_INIT_FLAGS;

ALTER TRIGGER "C_ITX"."DOC_DMT_BIU_INIT_FLAGS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_BU_CURRENCY_RISK"
  before update of DMT_RATE_OF_EXCHANGE, DMT_BASE_PRICE
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*    Empêcher la modifiaction du cours de change d'un document dont le cours a été forcé par la gestion du risque de change
*
* @author NGV
* @created 27.08.2013
* @version 2003
*/
declare
begin
  -- Si la tranche virtuelle (risque de change) est assignée avant la modification du cours
  --   il faut interdire la modification du cours de change
  if     (nvl(:old.DMT_RATE_OF_EXCHANGE, 0) <> nvl(:new.DMT_RATE_OF_EXCHANGE, 0) )
     and (nvl(:old.DMT_BASE_PRICE, 0) <> nvl(:new.DMT_BASE_PRICE, 0) )
     and (:old.GAL_CURRENCY_RISK_VIRTUAL_ID is not null)
     and (:new.GAL_CURRENCY_RISK_VIRTUAL_ID is not null) then
    raise_application_error
          (-20000
         , PCS.PC_FUNCTIONS.TranslateWord('Le cours de change du document ne peut plus être modifié, celui-ci est forcé par la gestion du risque de change !')
          );
  end if;
end DOC_DMT_BU_CURRENCY_RISK;

ALTER TRIGGER "C_ITX"."DOC_DMT_BU_CURRENCY_RISK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_BU_DOCU_ACCU"
  before update of DOC_DOCUMENT_ID, DMT_DATE_DOCUMENT, DIC_GAUGE_TYPE_DOC_ID, C_DOCUMENT_STATUS, DMT_RATE_OF_EXCHANGE, DMT_BASE_PRICE, PAC_THIRD_ID
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des totalisateurs de document
* @author Fabrice Perotto
* @version 2003
*/
declare
  -- curseur sur les totaux du pied de document
  cursor DOC_VALUES_CURSOR(doc_id number)
  is
    select FOO_DOCUMENT_TOT_AMOUNT_B
         , FOO_TOT_VAT_AMOUNT_B
      from DOC_FOOT
     where DOC_FOOT.DOC_DOCUMENT_ID = doc_id;

  doc_values_tuple doc_values_cursor%rowtype;
begin
  -- pas de mise à jour des totalisateurs (possible uniquement par recalcul global)
  if PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '0' then
    null;
  -- mise à jour instantannée des totalisateurs de position
  elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '1' then
    -- ouverture du curseur sur les totaux du document
    open DOC_VALUES_CURSOR(:old.DOC_DOCUMENT_ID);

    fetch DOC_VALUES_CURSOR
     into doc_values_tuple;

    if DOC_VALUES_CURSOR%found then
      -- Retrait des anciennes valeurs
      DOC_ACCUMULATOR.DOC_TOTAL_DOCUMENT(:old.DOC_DOCUMENT_ID
                                       , :old.DMT_DATE_DOCUMENT
                                       , :old.DIC_GAUGE_TYPE_DOC_ID
                                       , :old.C_DOCUMENT_STATUS
                                       , :old.PAC_THIRD_ID
                                       , doc_values_tuple.FOO_DOCUMENT_TOT_AMOUNT_B
                                       , doc_values_tuple.FOO_TOT_VAT_AMOUNT_B
                                       , -1
                                       , 0
                                        );
      -- Ajout des nouvelles valeurs
      DOC_ACCUMULATOR.DOC_TOTAL_DOCUMENT(:new.DOC_DOCUMENT_ID
                                       , :new.DMT_DATE_DOCUMENT
                                       , :new.DIC_GAUGE_TYPE_DOC_ID
                                       , :new.C_DOCUMENT_STATUS
                                       , :new.PAC_THIRD_ID
                                       , doc_values_tuple.FOO_DOCUMENT_TOT_AMOUNT_B
                                       , doc_values_tuple.FOO_TOT_VAT_AMOUNT_B
                                       , 1
                                       , 0
                                        );
    end if;

    close DOC_VALUES_CURSOR;
  -- insertion dans le buffer des totalisateurs de position (maj différée)
  elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '2' then
    insert into DOC_DOCU_ACCU_BUFFER
                (DOC_DOCU_ACCU_BUFFER_ID
               , DOC_DOCUMENT_ID
               , C_DOCUMENT_STATUS
               , DIC_GAUGE_TYPE_DOC_ID
               , PAC_THIRD_ID
               , DAB_SIGN
               , DMT_DATE_DOCUMENT
               , FOO_DOCUMENT_TOTAL_AMOUNT
               , FOO_TOTAL_VAT_AMOUNT
                )
      select INIT_ID_SEQ.nextval
           , :old.DOC_DOCUMENT_ID
           , :old.C_DOCUMENT_STATUS
           , :old.DIC_GAUGE_TYPE_DOC_ID
           , :old.PAC_THIRD_ID
           , -1
           , :old.DMT_DATE_DOCUMENT
           , FOO_DOCUMENT_TOT_AMOUNT_B
           , FOO_TOT_VAT_AMOUNT_B
        from DOC_FOOT
       where DOC_FOOT_ID = :old.DOC_DOCUMENT_ID;

    insert into DOC_DOCU_ACCU_BUFFER
                (DOC_DOCU_ACCU_BUFFER_ID
               , DOC_DOCUMENT_ID
               , C_DOCUMENT_STATUS
               , DIC_GAUGE_TYPE_DOC_ID
               , PAC_THIRD_ID
               , DAB_SIGN
               , DMT_DATE_DOCUMENT
               , FOO_DOCUMENT_TOTAL_AMOUNT
               , FOO_TOTAL_VAT_AMOUNT
                )
      select INIT_ID_SEQ.nextval
           , :new.DOC_DOCUMENT_ID
           , :new.C_DOCUMENT_STATUS
           , :new.DIC_GAUGE_TYPE_DOC_ID
           , :new.PAC_THIRD_ID
           , 1
           , :new.DMT_DATE_DOCUMENT
           , FOO_DOCUMENT_TOT_AMOUNT_B
           , FOO_TOT_VAT_AMOUNT_B
        from DOC_FOOT
       where DOC_FOOT_ID = :new.DOC_DOCUMENT_ID;
  end if;
end DOC_DMT_BU_DOCU_ACCU;

ALTER TRIGGER "C_ITX"."DOC_DMT_BU_DOCU_ACCU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_BU_PM_RATE_DATE"
  before update of DMT_PM_RATE_DATE
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*    Effecture la mise à jour de la date cours des matières position avec la date initialisation du cours matières
*    figurant sur le document
*
* @author Vincent Jeanfavre
* @created 20/07/2005
* @version 2003
*/
declare
  numFootAlloy number;
  gasWeightMat DOC_GAUGE_STRUCTURED.GAS_WEIGHT_MAT%type;
  bStop        boolean;
begin
  if nvl(:old.DMT_PM_RATE_DATE, to_date('31.12.2999', 'DD.MM.YYYY') ) <> nvl(:new.DMT_PM_RATE_DATE, to_date('31.12.2999', 'DD.MM.YYYY') ) then
    -- Controle si le gabarit courant gère les matières précieuses.
    bStop  := false;

    begin
      select GAS.GAS_WEIGHT_MAT
        into gasWeightMat
        from DOC_GAUGE_STRUCTURED GAS
       where GAS.DOC_GAUGE_ID = :new.DOC_GAUGE_ID
         and GAS.GAS_WEIGHT_MAT = 1;
    exception
      when no_data_found then
        bStop  := true;
    end;

    if not bStop then
      update DOC_POSITION_ALLOY DOA
         set DOA.DOA_RATE_DATE = :new.DMT_PM_RATE_DATE
           , DOA.A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
           , DOA.A_DATEMOD = sysdate
       where DOA.DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID
         and nvl(DOA.DOA_RATE_DATE, to_date('31.12.2999', 'DD.MM.YYYY') ) <> nvl(:new.DMT_PM_RATE_DATE, to_date('31.12.2999', 'DD.MM.YYYY') );

      begin
        select count(DFA.DOC_FOOT_ALLOY_ID)
          into numFootAlloy
          from DOC_FOOT_ALLOY DFA;

        :new.DMT_RECALC_FOOT_MAT  := 1;
      exception
        when no_data_found then
          :new.DMT_CREATE_FOOT_MAT  := 1;
      end;
    end if;
  end if;
end DOC_DMT_BU_PM_RATE_DATE;

ALTER TRIGGER "C_ITX"."DOC_DMT_BU_PM_RATE_DATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_BU_POSI_ACCU"
  before update of PAC_THIRD_ID, DIC_GAUGE_TYPE_DOC_ID, DMT_DATE_DOCUMENT, DMT_RATE_OF_EXCHANGE, DMT_BASE_PRICE, DOC_DOCUMENT_ID, DOC_GAUGE_ID
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des totalisateurs de positions avant MAJ
* @author Fabrice Perotto
* @version 2003
*/
declare
  -- curseur sur tous les detail position de la position
  cursor detail_position_cursor(document_id number, gauge_id number)
  is
    select DET.GCO_CHARACTERIZATION_ID
         , DET.GCO_GCO_CHARACTERIZATION_ID
         , DET.GCO2_GCO_CHARACTERIZATION_ID
         , DET.GCO3_GCO_CHARACTERIZATION_ID
         , DET.GCO4_GCO_CHARACTERIZATION_ID
         , DET.PDE_CHARACTERIZATION_VALUE_1
         , DET.PDE_CHARACTERIZATION_VALUE_2
         , DET.PDE_CHARACTERIZATION_VALUE_3
         , DET.PDE_CHARACTERIZATION_VALUE_4
         , DET.PDE_CHARACTERIZATION_VALUE_5
         , DET.PDE_FINAL_DELAY
         , DET.PDE_FINAL_QUANTITY
         , DET.PDE_BALANCE_QUANTITY
         , POS.GCO_GOOD_ID
         , POS.POS_NET_VALUE_EXCL_B
         , POS.C_DOC_POS_STATUS
         , POS.C_GAUGE_TYPE_POS
         , GPO.GAP_DELAY
         , GST.GAS_BALANCE_STATUS
         , GAU.C_GAUGE_TYPE
      from DOC_POSITION_DETAIL DET
         , DOC_POSITION POS
         , DOC_GAUGE_POSITION GPO
         , DOC_GAUGE_STRUCTURED GST
         , DOC_GAUGE GAU
     where POS.DOC_DOCUMENT_ID = document_id
       and DET.DOC_POSITION_ID = POS.DOC_POSITION_ID
       and GPO.DOC_GAUGE_POSITION_ID = POS.DOC_GAUGE_POSITION_ID
       and GST.DOC_GAUGE_ID = gauge_id
       and GAU.DOC_GAUGE_ID = GST.DOC_GAUGE_ID;

  detail_position_tuple detail_position_cursor%rowtype;
begin
  -- Interdiction de modifier l'ID du document
  if (:old.DOC_DOCUMENT_ID <> :new.DOC_DOCUMENT_ID) then
    raise_application_error(-20010, 'PCS - Cannot change the value of DOC_DOCUMENT_ID in DOC_DOCUMENT');
  end if;

  -- Interdiction de modifier l'ID du gabarit
  if (:old.DOC_GAUGE_ID <> :new.DOC_GAUGE_ID) then
    raise_application_error(-20011, 'PCS - Cannot change the value of DOC_GAUGE_ID in DOC_DOCUMENT');
  end if;

  -- pas de mise à jour des totalisateurs (possible uniquement par recalcul global)
  if PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '0' then
    null;
  -- mise à jour instantannée des totalisateurs de position
  elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '1' then
    -- Ouverture du curseur sur les details de position
    open detail_position_cursor(:old.DOC_DOCUMENT_ID, :old.DOC_GAUGE_ID);

    fetch detail_position_cursor
     into detail_position_tuple;

    while detail_position_cursor%found loop
      -- mise à jour  des totalisateurs de position
      if detail_position_tuple.c_gauge_type_pos in('1', '2', '3', '7', '8', '91', '101', '21') then
        -- Retrait des anciennes valeurs
        DOC_ACCUMULATOR.DOC_TOTAL_POSITION(detail_position_tuple.GCO_GOOD_ID
                                         , :old.PAC_THIRD_ID
                                         , :old.DIC_GAUGE_TYPE_DOC_ID
                                         , detail_position_tuple.GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.GCO_GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.GCO2_GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.GCO3_GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.GCO4_GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_1
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_2
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_3
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_4
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_5
                                         , detail_position_tuple.GAP_DELAY
                                         , nvl(detail_position_tuple.PDE_FINAL_DELAY, :old.DMT_DATE_DOCUMENT)
                                         , :old.DMT_DATE_DOCUMENT
                                         , detail_position_tuple.PDE_FINAL_QUANTITY
                                         , detail_position_tuple.PDE_BALANCE_QUANTITY
                                         , detail_position_tuple.POS_NET_VALUE_EXCL_B
                                         , detail_position_tuple.C_DOC_POS_STATUS
                                         , detail_position_tuple.GAS_BALANCE_STATUS
                                         , detail_position_tuple.C_GAUGE_TYPE
                                         , -1
                                         , 0
                                          );
        -- Ajout des nouvelles valeurs
        DOC_ACCUMULATOR.DOC_TOTAL_POSITION(detail_position_tuple.GCO_GOOD_ID
                                         , :new.PAC_THIRD_ID
                                         , :new.DIC_GAUGE_TYPE_DOC_ID
                                         , detail_position_tuple.GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.GCO_GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.GCO2_GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.GCO3_GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.GCO4_GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_1
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_2
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_3
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_4
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_5
                                         , detail_position_tuple.GAP_DELAY
                                         , nvl(detail_position_tuple.PDE_FINAL_DELAY, :new.DMT_DATE_DOCUMENT)
                                         , :new.DMT_DATE_DOCUMENT
                                         , detail_position_tuple.PDE_FINAL_QUANTITY
                                         , detail_position_tuple.PDE_BALANCE_QUANTITY
                                         , detail_position_tuple.POS_NET_VALUE_EXCL_B
                                         , detail_position_tuple.C_DOC_POS_STATUS
                                         , detail_position_tuple.GAS_BALANCE_STATUS
                                         , detail_position_tuple.C_GAUGE_TYPE
                                         , 1
                                         , 0
                                          );
      end if;

      fetch detail_position_cursor
       into detail_position_tuple;
    end loop;

    close detail_position_cursor;
  -- insertion dans le buffer des totalisateurs de position (maj différée)
  elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '2' then
    -- retrait des anciennes valeurs
    insert into DOC_POSI_ACCU_BUFFER
                (DOC_POSI_ACCU_BUFFER_ID
               , ABU_SIGN
               , C_DOC_POS_STATUS
               , C_GAUGE_TYPE
               , GCO_GOOD_ID
               , PAC_THIRD_ID
               , DIC_GAUGE_TYPE_DOC_ID
               , GCO_CHARACTERIZATION_ID
               , GCO_GCO_CHARACTERIZATION_ID
               , GCO2_GCO_CHARACTERIZATION_ID
               , GCO3_GCO_CHARACTERIZATION_ID
               , GCO4_GCO_CHARACTERIZATION_ID
               , ABU_CHARACTERIZATION_VALUE_1
               , ABU_CHARACTERIZATION_VALUE_2
               , ABU_CHARACTERIZATION_VALUE_3
               , ABU_CHARACTERIZATION_VALUE_4
               , ABU_CHARACTERIZATION_VALUE_5
               , ABU_DELAY
               , ABU_FINAL_DELAY
               , ABU_DOCUMENT_DATE
               , ABU_FINAL_QUANTITY
               , ABU_BALANCE_QUANTITY
               , ABU_NET_VALUE_EXCL
               , ABU_BALANCE_STATUS
                )
      select INIT_ID_SEQ.nextval
           , -1
           , POS.C_DOC_POS_STATUS
           , GAU.C_GAUGE_TYPE
           , POS.GCO_GOOD_ID
           , :old.PAC_THIRD_ID
           , :old.DIC_GAUGE_TYPE_DOC_ID
           , DET.GCO_CHARACTERIZATION_ID
           , DET.GCO_GCO_CHARACTERIZATION_ID
           , DET.GCO2_GCO_CHARACTERIZATION_ID
           , DET.GCO3_GCO_CHARACTERIZATION_ID
           , DET.GCO4_GCO_CHARACTERIZATION_ID
           , DET.PDE_CHARACTERIZATION_VALUE_1
           , DET.PDE_CHARACTERIZATION_VALUE_2
           , DET.PDE_CHARACTERIZATION_VALUE_3
           , DET.PDE_CHARACTERIZATION_VALUE_4
           , DET.PDE_CHARACTERIZATION_VALUE_5
           , GPO.GAP_DELAY
           , nvl(DET.PDE_FINAL_DELAY, :old.DMT_DATE_DOCUMENT)
           , :old.DMT_DATE_DOCUMENT
           , DET.PDE_FINAL_QUANTITY
           , DET.PDE_BALANCE_QUANTITY
           , POS.POS_NET_VALUE_EXCL_B
           , GST.GAS_BALANCE_STATUS
        from DOC_POSITION_DETAIL DET
           , DOC_POSITION POS
           , DOC_GAUGE_POSITION GPO
           , DOC_GAUGE_STRUCTURED GST
           , DOC_GAUGE GAU
       where POS.DOC_DOCUMENT_ID = :old.DOC_DOCUMENT_ID
         and GPO.DOC_GAUGE_POSITION_ID = POS.DOC_GAUGE_POSITION_ID
         and POS.DOC_POSITION_ID = DET.DOC_POSITION_ID
         and GST.DOC_GAUGE_ID = :old.DOC_GAUGE_ID
         and GAU.DOC_GAUGE_ID = GST.DOC_GAUGE_ID
         and POS.C_GAUGE_TYPE_POS in('1', '2', '3', '7', '8', '91', '101', '21');

    -- ajout des nouvelles valeurs
    insert into DOC_POSI_ACCU_BUFFER
                (DOC_POSI_ACCU_BUFFER_ID
               , ABU_SIGN
               , C_DOC_POS_STATUS
               , C_GAUGE_TYPE
               , GCO_GOOD_ID
               , PAC_THIRD_ID
               , DIC_GAUGE_TYPE_DOC_ID
               , GCO_CHARACTERIZATION_ID
               , GCO_GCO_CHARACTERIZATION_ID
               , GCO2_GCO_CHARACTERIZATION_ID
               , GCO3_GCO_CHARACTERIZATION_ID
               , GCO4_GCO_CHARACTERIZATION_ID
               , ABU_CHARACTERIZATION_VALUE_1
               , ABU_CHARACTERIZATION_VALUE_2
               , ABU_CHARACTERIZATION_VALUE_3
               , ABU_CHARACTERIZATION_VALUE_4
               , ABU_CHARACTERIZATION_VALUE_5
               , ABU_DELAY
               , ABU_FINAL_DELAY
               , ABU_DOCUMENT_DATE
               , ABU_FINAL_QUANTITY
               , ABU_BALANCE_QUANTITY
               , ABU_NET_VALUE_EXCL
               , ABU_BALANCE_STATUS
                )
      select INIT_ID_SEQ.nextval
           , 1
           , POS.C_DOC_POS_STATUS
           , GAU.C_GAUGE_TYPE
           , POS.GCO_GOOD_ID
           , :new.PAC_THIRD_ID
           , :new.DIC_GAUGE_TYPE_DOC_ID
           , DET.GCO_CHARACTERIZATION_ID
           , DET.GCO_GCO_CHARACTERIZATION_ID
           , DET.GCO2_GCO_CHARACTERIZATION_ID
           , DET.GCO3_GCO_CHARACTERIZATION_ID
           , DET.GCO4_GCO_CHARACTERIZATION_ID
           , DET.PDE_CHARACTERIZATION_VALUE_1
           , DET.PDE_CHARACTERIZATION_VALUE_2
           , DET.PDE_CHARACTERIZATION_VALUE_3
           , DET.PDE_CHARACTERIZATION_VALUE_4
           , DET.PDE_CHARACTERIZATION_VALUE_5
           , GPO.GAP_DELAY
           , nvl(DET.PDE_FINAL_DELAY, :new.DMT_DATE_DOCUMENT)
           , :new.DMT_DATE_DOCUMENT
           , DET.PDE_FINAL_QUANTITY
           , DET.PDE_BALANCE_QUANTITY
           , POS.POS_NET_VALUE_EXCL_B
           , GST.GAS_BALANCE_STATUS
        from DOC_POSITION_DETAIL DET
           , DOC_POSITION POS
           , DOC_GAUGE_POSITION GPO
           , DOC_GAUGE_STRUCTURED GST
           , DOC_GAUGE GAU
       where POS.DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID
         and GPO.DOC_GAUGE_POSITION_ID = POS.DOC_GAUGE_POSITION_ID
         and POS.DOC_POSITION_ID = DET.DOC_POSITION_ID
         and GST.DOC_GAUGE_ID = :new.DOC_GAUGE_ID
         and GAU.DOC_GAUGE_ID = GST.DOC_GAUGE_ID
         and POS.C_GAUGE_TYPE_POS in('1', '2', '3', '7', '8', '91', '101', '21');
  end if;
end DOC_DMT_BU_POSI_ACCU;

ALTER TRIGGER "C_ITX"."DOC_DMT_BU_POSI_ACCU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DMT_BU_REVALUATION_DATE"
  before update of DMT_REVALUATION_DATE
  on DOC_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*    Effectue la mise à jour de l'indicateur de demande de recalcul du cours en fonction de la nouvelle date de réevaluation.
*
* @author Vincent Jeanfavre
* @created 16/08/2005
* @version 2003
*/
declare
begin
  if nvl(:old.DMT_REVALUATION_DATE, to_date('31.12.2999', 'DD.MM.YYYY') ) <>
                                                   nvl(:new.DMT_REVALUATION_DATE, to_date('31.12.2999', 'DD.MM.YYYY') ) then
    :new.DMT_REVALUATION_RATE  := 1;
  end if;
end DOC_DMT_BU_REVALUATION_DATE;


ALTER TRIGGER "C_ITX"."DOC_DMT_BU_REVALUATION_DATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DOA_BI_RATE_DATE"
  before insert
  on DOC_POSITION_ALLOY
  referencing old as old new as new
  for each row
/**
* Description
*    Effectue la mise à jour de la date cours de la nouvelle matière position avec la date initialisation du cours matières
*    figurant sur le document
*
* @author Vincent Jeanfavre
* @created 20/07/2005
* @version 2003
*/
declare
  dmtPMRateDate DOC_DOCUMENT.DMT_PM_RATE_DATE%type;
  bStop         boolean;
begin
  bStop  := false;

  begin
    select DMT.DMT_PM_RATE_DATE
      into dmtPMRateDate
      from DOC_DOCUMENT DMT
     where DMT.DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID;
  exception
    when no_data_found then
      bStop  := true;
  end;

  if     not bStop
     and :new.DOA_RATE_DATE is null then
    :new.DOA_RATE_DATE  := dmtPMRateDate;
  end if;
end DOC_DOA_BI_RATE_DATE;


ALTER TRIGGER "C_ITX"."DOC_DOA_BI_RATE_DATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DOF_BI_SESSION"
  before insert
  on DOC_FREE_NUMBER
  referencing old as old new as new
  for each row
/**
* Description
*    Initialisation de la session Oracle
* @created FP 14.02.2003
* @version 2003
* @lastUpdate
*/
begin
  if :new.DOF_SESSION_ID is null then
    :new.DOF_SESSION_ID  := DBMS_SESSION.unique_session_id;
  end if;
end DOC_DOF_BI_SESSION;

ALTER TRIGGER "C_ITX"."DOC_DOF_BI_SESSION" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DOI_BI_DENORM"
  before insert
  on DOC_INTERFACE
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des champs dénormalisés de DOC_INTERFACE
* @author NGV
* @version 2003
*/
begin
  if :new.DOI_ORIGIN_GEN_MODE is null then
    :new.DOI_ORIGIN_GEN_MODE  := :new.C_INTERFACE_GEN_MODE;
  end if;
end DOC_DOI_BI_DENORM;

ALTER TRIGGER "C_ITX"."DOC_DOI_BI_DENORM" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DOP_BI_DENORM"
  before insert
  on DOC_INTERFACE_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des champs dénormalisés de DOC_INTERFACE_POSITION
* @author NGV
* @version 2003
*/
begin
  if :new.DOP_ORIGIN_GEN_MODE is null then
    :new.DOP_ORIGIN_GEN_MODE  := :new.C_INTERFACE_GEN_MODE;
  end if;
end DOC_DOP_BI_DENORM;

ALTER TRIGGER "C_ITX"."DOC_DOP_BI_DENORM" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_DTP_BI_SERIAL_POS"
  before insert
  on DOC_TMP_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour de la table des matières positions suite à la création d'une pesée
* @author VJ
* @created 24.06.2004
* @version 2003
* @lastUpdate
*/
declare
  bStop              boolean;
  dcType             varchar2(10);
  pacThirdID         PAC_THIRD.PAC_THIRD_ID%type;
  convertFactor      GCO_COMPL_DATA_PURCHASE.CDA_CONVERSION_FACTOR%type;
  gooNumberOfDecimal GCO_GOOD.GOO_NUMBER_OF_DECIMAL%type;
  posNumberOfDecimal GCO_GOOD.GOO_NUMBER_OF_DECIMAL%type;
  dicUnitOfMeasure   GCO_GOOD.DIC_UNIT_OF_MEASURE_ID%type;
begin
  if     (:new.POS_CONVERT_FACTOR is null)
     and (:new.GCO_GOOD_ID is not null) then
    bStop  := false;

    begin
      select (case GAU.C_ADMIN_DOMAIN
                when '1' then 'PURCHASE'
                when '2' then 'SALE'
                else 'GOOD'
              end)
           , (case GAU.C_ADMIN_DOMAIN
                when '2' then DMT.PAC_THIRD_DELIVERY_ID
                when '7' then DMT.PAC_THIRD_DELIVERY_ID
                else DMT.PAC_THIRD_ID
              end
             )
        into dcType
           , pacThirdID
        from DOC_DOCUMENT DMT
           , DOC_GAUGE GAU
       where DMT.DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID
         and GAU.DOC_GAUGE_ID = DMT.DOC_GAUGE_ID;

      select nvl(GOO_NUMBER_OF_DECIMAL, 0)
        into gooNumberOfDecimal
        from GCO_GOOD
       where GCO_GOOD_ID = :new.GCO_GOOD_ID;
    exception
      when no_data_found then
        bStop  := true;
    end;

    if not bStop then
      posNumberOfDecimal       := 0;
      -- Recherche les données complémenaires en relation aux quantités de stockage.
      GCO_FUNCTIONS.GetCDAStock(:new.GCO_GOOD_ID
                              , dcType
                              , pacThirdId
                              , convertFactor
                              , posNumberOfDecimal
                              , dicUnitOfMeasure
                               );
      :new.POS_CONVERT_FACTOR  := nvl(convertFactor, 1);
    else
      :new.POS_CONVERT_FACTOR  := 1;
    end if;
  end if;

  if (:new.POS_CONVERT_FACTOR <> 1) then
    -- Vérifie dans quelle sens la quantité est proposée. Quantité document -> Quantité stock ou Quantité stock -> Quantité document
    if :new.PDE_BASIS_QUANTITY is not null then
      -- Arrondi la quantité de la position en fonction des données complémentaires.
      :new.PDE_BASIS_QUANTITY     :=
                                  ACS_FUNCTION.RoundNear(:new.PDE_BASIS_QUANTITY, 1 / power(10, posNumberOfDecimal), 0);
      -- Recalcul la quantité de la position en unité de stockage en fonction du facteur de conversion des données complémentaires.
      :new.PDE_BASIS_QUANTITY_SU  :=
         ACS_FUNCTION.RoundNear(:new.PDE_BASIS_QUANTITY * :new.POS_CONVERT_FACTOR, 1 / power(10, gooNumberOfDecimal)
                              , 0);
    elsif :new.PDE_BASIS_QUANTITY_SU is not null then
      -- Recalcul la quantité de la position en unité de stockage en fonction du facteur de conversion des données
      -- et du nombre de décimal complémentaires.
      :new.PDE_BASIS_QUANTITY     :=
        ACS_FUNCTION.RoundNear(:new.PDE_BASIS_QUANTITY_SU / :new.POS_CONVERT_FACTOR
                             , 1 / power(10, posNumberOfDecimal)
                             , -1
                              );
      ----
      -- Recalcul la quantité de la position en unité de stockage en fonction de la nouvelle quantité de base en unité
      -- du document. Cela garantit le respect de la formule suivante :
      --
      --    Quantité en unité de stockage = Quantité en unité de document * Facteur de conversion
      --
      :new.PDE_BASIS_QUANTITY_SU  :=
          ACS_FUNCTION.RoundNear(:new.PDE_BASIS_QUANTITY * :new.POS_CONVERT_FACTOR, 1 / power(10, gooNumberOfDecimal)
                               , 0);
    else
      :new.PDE_BASIS_QUANTITY     := 0;
      :new.PDE_BASIS_QUANTITY_SU  := 0;
    end if;
  else
    if :new.PDE_BASIS_QUANTITY is null then
      :new.PDE_BASIS_QUANTITY  := :new.PDE_BASIS_QUANTITY_SU;
    elsif :new.PDE_BASIS_QUANTITY_SU is null then
      :new.PDE_BASIS_QUANTITY_SU  := :new.PDE_BASIS_QUANTITY;
    end if;
  end if;
end DOC_DTP_BI_SERIAL_POS;


ALTER TRIGGER "C_ITX"."DOC_DTP_BI_SERIAL_POS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_EPC_BIU_LOCAL_CURRENCY"
  before insert or update of POS_MODIFY_RATE
                           , POS_NET_VALUE_EXCL
                           , POS_NET_VALUE_INCL
                           , POS_GROSS_VALUE
                           , POS_GROSS_VALUE_INCL
                           , POS_VAT_TOTAL_AMOUNT
                           , POS_VAT_AMOUNT
                           , POS_VAT_RATE
                           , ACS_TAX_CODE_ID
  on DOC_ESTIMATED_POS_CASH_FLOW
  referencing old as old new as new
  for each row
/**
* Description
*    Maj des montants en monnaie locale
* @created fpe 23.03.2012 (par copie et adaptation du trigger DOC_POS_BIU_LOCAL_CURRENCY)
* @updated fpe 25.09.2013 prise en compte des documents liés aux risques de change DEVLOG-16582
*/
declare
  lEuroRate        DOC_DOCUMENT.DMT_RATE_OF_EXCHANGE%type;
  lCurrencyId      DOC_DOCUMENT.ACS_FINANCIAL_CURRENCY_ID%type;
  lVatCurrencyId   DOC_DOCUMENT.ACS_ACS_FINANCIAL_CURRENCY_ID%type;
  lLocalCurrencyId DOC_DOCUMENT.ACS_FINANCIAL_CURRENCY_ID%type;
  lDocumentDate    DOC_DOCUMENT.DMT_DATE_DOCUMENT%type;
  lExchangeRate    DOC_DOCUMENT.DMT_RATE_OF_EXCHANGE%type;
  lBasePrice       DOC_DOCUMENT.DMT_BASE_PRICE%type;
  lVatExchangeRate DOC_DOCUMENT.DMT_VAT_EXCHANGE_RATE%type;
  lVatBasePrice    DOC_DOCUMENT.DMT_VAT_BASE_PRICE%type;
  lDetAccountId    DOC_VAT_DET_ACCOUNT.DOC_VAT_DET_ACCOUNT_ID%type;
  lnBidon          DOC_ESTIMATED_POS_CASH_FLOW.POS_NET_VALUE_EXCL_E%type;
  lTaxTransaction  ACS_ACCOUNT.ACC_INTEREST%type;
  lRefDate         DOC_DOCUMENT.DMT_DATE_DELIVERY%type;
  lDocumentId      DOC_DOCUMENT.DOC_DOCUMENT_ID%type;
  lRiskId          GAL_CURRENCY_RISK_VIRTUAL.GAL_CURRENCY_RISK_VIRTUAL_ID%type;
begin
  -- Si ce n'est pas une modification des taux de change, on recalcule la TVA

  -- Recherche de la date de livraison de la position source et des informations de change
  select nvl(:new.POS_DATE_DELIVERY, nvl(DMT.DMT_DATE_DELIVERY, nvl(DMT.DMT_REVALUATION_DATE, DMT.DMT_DATE_VALUE) ) )
       , DMT.DOC_DOCUMENT_ID
       , ACS_FINANCIAL_CURRENCY_ID
       , ACS_ACS_FINANCIAL_CURRENCY_ID
       , trunc(sysdate)
       , GAL_CURRENCY_RISK_VIRTUAL_ID
       , DMT.DMT_RATE_OF_EXCHANGE
       , DMT.DMT_BASE_PRICE
       , DMT.DMT_VAT_EXCHANGE_RATE
       , DMT.DMT_VAT_BASE_PRICE
    into lRefDate
       , lDocumentId
       , lCurrencyId
       , lVatCurrencyId
       , lDocumentDate
       , lRiskId
       , lExchangeRate
       , lBasePrice
       , lVatExchangeRate
       , lVatBasePrice
    from DOC_DOCUMENT DMT
       , DOC_INVOICE_EXPIRY INX
   where INX.DOC_INVOICE_EXPIRY_ID = :new.DOC_INVOICE_EXPIRY_ID
     and DMT.DOC_DOCUMENT_ID = INX.DOC_DOCUMENT_ID;

  -- Si pas de gestion des risque de change on recherche le taux spot (DEVLOG-16582 règle 3800)
  if lRiskId is null then
    -- monnaie de base
    acs_function.getexchangerate(lDocumentDate, lCurrencyId, 1, lExchangeRate, lBasePrice);
    -- monnaie TVA
    acs_function.getexchangerate(lDocumentDate, lVatCurrencyId, 1, lVatExchangeRate, lVatBasePrice);
  end if;

  begin
    select nvl(ACC.ACC_INTEREST, 0)
      into lTaxTransaction
      from ACS_ACCOUNT ACC
     where ACC.ACS_ACCOUNT_ID = :new.ACS_TAX_CODE_ID;
  exception
    when no_data_found then
      lTaxTransaction  := 0;
  end;

  lLocalCurrencyId      := ACS_FUNCTION.GetLocalCurrencyId;

  -- Les différents cas possibles
  -- n°   Monnaie base    Monnaie Document    Monnaie TVA
  -- 1.   CHF             CHF                 CHF
  -- 2.   CHF             EUR                 CHF
  -- 3.   CHF             EUR                 EUR
  -- 4.   CHF             CHF                 EUR
  -- 5.   CHF             USD                 EUR
  if     (lLocalCurrencyId = lVatCurrencyId)
     and (lCurrencyId = lVatCurrencyId) then   -- Cas n° 1 -> Ex : CHF - CHF - CHF
    :new.POS_NET_VALUE_INCL_B    := :new.POS_NET_VALUE_INCL;
    :new.POS_NET_VALUE_EXCL_B    := :new.POS_NET_VALUE_EXCL;
    :new.POS_GROSS_VALUE_B       := :new.POS_GROSS_VALUE;
    :new.POS_GROSS_VALUE_INCL_B  := :new.POS_GROSS_VALUE_INCL;
    :new.POS_NET_VALUE_INCL_V    := :new.POS_NET_VALUE_INCL;
    :new.POS_NET_VALUE_EXCL_V    := :new.POS_NET_VALUE_EXCL;
    :new.POS_GROSS_VALUE_V       := :new.POS_GROSS_VALUE;
    :new.POS_GROSS_VALUE_INCL_V  := :new.POS_GROSS_VALUE_INCL;
    :new.POS_VAT_TOTAL_AMOUNT_B  := :new.POS_VAT_TOTAL_AMOUNT;
    :new.POS_VAT_TOTAL_AMOUNT_V  := :new.POS_VAT_TOTAL_AMOUNT;
    :new.POS_VAT_BASE_AMOUNT     := :new.POS_VAT_AMOUNT;
    :new.POS_VAT_AMOUNT_V        := :new.POS_VAT_BASE_AMOUNT;
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_INCL, 0)
                             , lCurrencyId
                             , lLocalCurrencyId
                             , lDocumentDate
                             , lExchangeRate
                             , lBasePrice
                             , 0
                             , :new.POS_NET_VALUE_INCL_E
                             , lnBidon
                              );
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_EXCL, 0)
                             , lCurrencyId
                             , lLocalCurrencyId
                             , lDocumentDate
                             , lExchangeRate
                             , lBasePrice
                             , 0
                             , :new.POS_NET_VALUE_EXCL_E
                             , lnBidon
                              );
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE, 0)
                             , lCurrencyId
                             , lLocalCurrencyId
                             , lDocumentDate
                             , lExchangeRate
                             , lBasePrice
                             , 0
                             , :new.POS_GROSS_VALUE_E
                             , lnBidon
                              );
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE_INCL, 0)
                             , lCurrencyId
                             , lLocalCurrencyId
                             , lDocumentDate
                             , lExchangeRate
                             , lBasePrice
                             , 0
                             , :new.POS_GROSS_VALUE_INCL_E
                             , lnBidon
                              );
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_VAT_AMOUNT, 0)
                             , lCurrencyId
                             , lLocalCurrencyId
                             , lDocumentDate
                             , lExchangeRate
                             , lBasePrice
                             , 0
                             , :new.POS_VAT_AMOUNT_E
                             , lnBidon
                              );
--      :new.POS_VAT_AMOUNT_E        := :new.POS_NET_VALUE_INCL_E - :new.POS_NET_VALUE_EXCL_E;
  elsif     (lLocalCurrencyId = lVatCurrencyId)
        and (lCurrencyId <> lLocalCurrencyId) then   -- Cas n° 2 -> Ex : CHF - EUR - CHF
    -- ATTENTION : Les paramètres lVatBasePrice et lVatExchangeRate
    --             ont été inversés exprès dans l'appel ConvertAmount()
    --             pour le cas n°2 car le cours TVA stocké est le cours
    --             entre Monnaie TVA et Monnaie Document

    -- Cas n° 2 -> Ex : CHF - EUR - CHF

    -- Les montants en monnaie TVA sont convertis depuis les montants document avec le cours inversé stocké pour la monnaie TVA
    -- Valeur Nette TTC en monnaie TVA
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_INCL, 0)
                             , lVatCurrencyId
                             , lCurrencyId
                             , lDocumentDate
                             , lVatBasePrice
                             , lVatExchangeRate
                             , 0
                             , lnBidon
                             , :new.POS_NET_VALUE_INCL_V
                              );
    -- Valeur Nette HT en monnaie TVA
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_EXCL, 0)
                             , lVatCurrencyId
                             , lCurrencyId
                             , lDocumentDate
                             , lVatBasePrice
                             , lVatExchangeRate
                             , 0
                             , lnBidon
                             , :new.POS_NET_VALUE_EXCL_V
                              );
    -- Valeur Brutte TTC en monnaie TVA
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE_INCL, 0)
                             , lVatCurrencyId
                             , lCurrencyId
                             , lDocumentDate
                             , lVatBasePrice
                             , lVatExchangeRate
                             , 0
                             , lnBidon
                             , :new.POS_GROSS_VALUE_INCL_V
                              );
    -- Valeur Brutte HT en monnaie TVA
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE, 0)
                             , lVatCurrencyId
                             , lCurrencyId
                             , lDocumentDate
                             , lVatBasePrice
                             , lVatExchangeRate
                             , 0
                             , lnBidon
                             , :new.POS_GROSS_VALUE_V
                              );
    -- Calcul Montant total TVA en monnaie TVA
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_VAT_TOTAL_AMOUNT, 0)
                             , lVatCurrencyId
                             , lCurrencyId
                             , lDocumentDate
                             , lVatBasePrice
                             , lVatExchangeRate
                             , 0
                             , lnBidon
                             , :new.POS_VAT_TOTAL_AMOUNT_V
                              );
    -- Montant total TVA en monnaie de Base = Montant TVA en monnaie TVA
    :new.POS_VAT_TOTAL_AMOUNT_B  := :new.POS_VAT_TOTAL_AMOUNT_V;
    -- Calcul Montant TVA en monnaie TVA
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_VAT_AMOUNT, 0)
                             , lVatCurrencyId
                             , lCurrencyId
                             , lDocumentDate
                             , lVatBasePrice
                             , lVatExchangeRate
                             , 0
                             , lnBidon
                             , :new.POS_VAT_AMOUNT_V
                              );
    -- Le Montant TVA en monnaie de Base = Montant TVA en monnaie TVA
    :new.POS_VAT_BASE_AMOUNT     := :new.POS_VAT_AMOUNT_V;
    -- ATTENTION : Ce bout de code est à vérifier NGOMES
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_VAT_AMOUNT, 0)
                             , lCurrencyId
                             , lLocalCurrencyId
                             , lDocumentDate
                             , lExchangeRate
                             , lBasePrice
                             , 0
                             , :new.POS_VAT_AMOUNT_E
                             , lnBidon
                              );

    if :new.POS_INCLUDE_TAX_TARIFF = 0 then   -- HT
      -- Valeur Nette HT en monnaie de base et en monnaie IN
      ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_EXCL, 0)
                               , lCurrencyId
                               , lLocalCurrencyId
                               , lDocumentDate
                               , lExchangeRate
                               , lBasePrice
                               , 0
                               , :new.POS_NET_VALUE_EXCL_E
                               , :new.POS_NET_VALUE_EXCL_B
                                );

      -- Valeur Nette TTC en monnaie de base et en monnaie IN
      if lTaxTransaction = 1 then
        :new.POS_NET_VALUE_INCL_B  := :new.POS_NET_VALUE_EXCL_B;
        :new.POS_NET_VALUE_INCL_E  := :new.POS_NET_VALUE_EXCL_E;
      else
        :new.POS_NET_VALUE_INCL_B  := :new.POS_NET_VALUE_EXCL_B + :new.POS_VAT_TOTAL_AMOUNT_B;
      end if;

      -- Valeur Brutte HT en monnaie de base et en monnaie IN
      ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE, 0)
                               , lCurrencyId
                               , lLocalCurrencyId
                               , lDocumentDate
                               , lExchangeRate
                               , lBasePrice
                               , 0
                               , :new.POS_GROSS_VALUE_E
                               , :new.POS_GROSS_VALUE_B
                                );
    else   -- TTC
      -- Valeur Nette TTC en monnaie de base et en monnaie IN
      ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_INCL, 0)
                               , lCurrencyId
                               , lLocalCurrencyId
                               , lDocumentDate
                               , lExchangeRate
                               , lBasePrice
                               , 0
                               , :new.POS_NET_VALUE_INCL_E
                               , :new.POS_NET_VALUE_INCL_B
                                );

      -- Valeur Nette HT en monnaie de base et en monnaie IN
      if lTaxTransaction = 1 then
        :new.POS_NET_VALUE_EXCL_B  := :new.POS_NET_VALUE_INCL_B;
        :new.POS_NET_VALUE_EXCL_E  := :new.POS_NET_VALUE_INCL_E;
      else
        :new.POS_NET_VALUE_EXCL_B  := :new.POS_NET_VALUE_INCL_B - :new.POS_VAT_TOTAL_AMOUNT_B;
      end if;

      -- Valeur Brutte TTC en monnaie de base et en monnaie IN
      ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE_INCL, 0)
                               , lLocalCurrencyId
                               , lCurrencyId
                               , lDocumentDate
                               , lVatBasePrice
                               , lVatExchangeRate
                               , 0
                               , :new.POS_GROSS_VALUE_INCL_E
                               , :new.POS_GROSS_VALUE_INCL_B
                                );
    end if;
  elsif     (lCurrencyId = lVatCurrencyId)
        and (lCurrencyId <> lLocalCurrencyId) then   -- Cas n° 3 -> Ex : CHF - EUR - EUR
    -- Cas n° 3 -> Ex : CHF - EUR - EUR

    -- Montant en monnaie TVA = Montant en monnaie Document
    :new.POS_NET_VALUE_INCL_V    := :new.POS_NET_VALUE_INCL;
    :new.POS_NET_VALUE_EXCL_V    := :new.POS_NET_VALUE_EXCL;
    :new.POS_GROSS_VALUE_V       := :new.POS_GROSS_VALUE;
    :new.POS_GROSS_VALUE_INCL_V  := :new.POS_GROSS_VALUE_INCL;
    :new.POS_VAT_TOTAL_AMOUNT_V  := :new.POS_VAT_TOTAL_AMOUNT;
    :new.POS_VAT_AMOUNT_V        := :new.POS_VAT_AMOUNT;
    -- Le montant total TVA de la monnaie de base est converti à partir du cours TVA
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_VAT_TOTAL_AMOUNT_V, 0)
                             , lVatCurrencyId
                             , lLocalCurrencyId
                             , lDocumentDate
                             , lVatExchangeRate
                             , lVatBasePrice
                             , 0
                             , lnBidon
                             , :new.POS_VAT_TOTAL_AMOUNT_B
                              );
    -- Le montant TVA de la monnaie de base est converti à partir du cours TVA
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_VAT_AMOUNT_V, 0)
                             , lVatCurrencyId
                             , lLocalCurrencyId
                             , lDocumentDate
                             , lVatExchangeRate
                             , lVatBasePrice
                             , 0
                             , lnBidon
                             , :new.POS_VAT_BASE_AMOUNT
                              );
    -- ATTENTION : Ce bout de code est à vérifier NGOMES
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_VAT_AMOUNT, 0)
                             , lCurrencyId
                             , lLocalCurrencyId
                             , lDocumentDate
                             , lExchangeRate
                             , lBasePrice
                             , 0
                             , :new.POS_VAT_AMOUNT_E
                             , lnBidon
                              );

    if :new.POS_INCLUDE_TAX_TARIFF = 0 then   -- HT
      -- Valeur Nette HT en monnaie de base et en monnaie IN
      ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_EXCL, 0)
                               , lCurrencyId
                               , lLocalCurrencyId
                               , lDocumentDate
                               , lExchangeRate
                               , lBasePrice
                               , 0
                               , :new.POS_NET_VALUE_EXCL_E
                               , :new.POS_NET_VALUE_EXCL_B
                                );

      -- Valeur Nette TTC en monnaie de base et en monnaie IN
      if lTaxTransaction = 1 then
        :new.POS_NET_VALUE_INCL_B  := :new.POS_NET_VALUE_EXCL_B;
        :new.POS_NET_VALUE_INCL_E  := :new.POS_NET_VALUE_EXCL_E;
      else
        :new.POS_NET_VALUE_INCL_B  := :new.POS_NET_VALUE_EXCL_B + :new.POS_VAT_TOTAL_AMOUNT_B;
      end if;

      -- Valeur Brutte HT en monnaie de base et en monnaie IN
      ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE, 0)
                               , lCurrencyId
                               , lLocalCurrencyId
                               , lDocumentDate
                               , lExchangeRate
                               , lBasePrice
                               , 0
                               , :new.POS_GROSS_VALUE_E
                               , :new.POS_GROSS_VALUE_B
                                );
    else   -- TTC
      -- Valeur Nette TTC en monnaie de base et en monnaie IN
      ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_INCL, 0)
                               , lCurrencyId
                               , lLocalCurrencyId
                               , lDocumentDate
                               , lExchangeRate
                               , lBasePrice
                               , 0
                               , :new.POS_NET_VALUE_INCL_E
                               , :new.POS_NET_VALUE_INCL_B
                                );

      -- Valeur Nette HT en monnaie de base et en monnaie IN
      if lTaxTransaction = 1 then
        :new.POS_NET_VALUE_EXCL_B  := :new.POS_NET_VALUE_INCL_B;
        :new.POS_NET_VALUE_EXCL_E  := :new.POS_NET_VALUE_INCL_E;
      else
        :new.POS_NET_VALUE_EXCL_B  := :new.POS_NET_VALUE_INCL_B - :new.POS_VAT_TOTAL_AMOUNT_B;
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_EXCL, 0)
                                 , lCurrencyId
                                 , lLocalCurrencyId
                                 , lDocumentDate
                                 , lExchangeRate
                                 , lBasePrice
                                 , 0
                                 , :new.POS_NET_VALUE_EXCL_E
                                 , lnBidon
                                  );
      end if;

      -- Valeur Brutte TTC en monnaie de base et en monnaie IN
      ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE_INCL, 0)
                               , lLocalCurrencyId
                               , lCurrencyId
                               , lDocumentDate
                               , lVatBasePrice
                               , lVatExchangeRate
                               , 0
                               , :new.POS_GROSS_VALUE_INCL_E
                               , :new.POS_GROSS_VALUE_INCL_B
                                );
    end if;
  else
    -- Cas n° 4 -> Ex : CHF - CHF - EUR
    -- Cas n° 5 -> Ex : CHF - USD - EUR
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_INCL, 0)
                             , lCurrencyId
                             , lLocalCurrencyId
                             , lDocumentDate
                             , lExchangeRate
                             , lBasePrice
                             , 0
                             , :new.POS_NET_VALUE_INCL_E
                             , :new.POS_NET_VALUE_INCL_B
                              );
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_EXCL, 0)
                             , lCurrencyId
                             , lLocalCurrencyId
                             , lDocumentDate
                             , lExchangeRate
                             , lBasePrice
                             , 0
                             , :new.POS_NET_VALUE_EXCL_E
                             , :new.POS_NET_VALUE_EXCL_B
                              );
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE, 0)
                             , lCurrencyId
                             , lLocalCurrencyId
                             , lDocumentDate
                             , lExchangeRate
                             , lBasePrice
                             , 0
                             , :new.POS_GROSS_VALUE_E
                             , :new.POS_GROSS_VALUE_B
                              );
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE_INCL, 0)
                             , lCurrencyId
                             , lLocalCurrencyId
                             , lDocumentDate
                             , lExchangeRate
                             , lBasePrice
                             , 0
                             , :new.POS_GROSS_VALUE_INCL_E
                             , :new.POS_GROSS_VALUE_INCL_B
                              );
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_VAT_AMOUNT, 0)
                             , lCurrencyId
                             , lLocalCurrencyId
                             , lDocumentDate
                             , lExchangeRate
                             , lBasePrice
                             , 0
                             , :new.POS_VAT_AMOUNT_E
                             , :new.POS_VAT_BASE_AMOUNT
                              );

    if lTaxTransaction = 1 then
      :new.POS_VAT_TOTAL_AMOUNT_B  := :new.POS_NET_VALUE_EXCL_B;
    else
      :new.POS_VAT_TOTAL_AMOUNT_B  := :new.POS_NET_VALUE_INCL_B - :new.POS_NET_VALUE_EXCL_B;
    end if;

    -- Montants TVA
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_INCL_B, 0)
                             , lLocalCurrencyId
                             , lVatCurrencyId
                             , lDocumentDate
                             , lVatExchangeRate
                             , lVatBasePrice
                             , 0
                             , lnBidon
                             , :new.POS_NET_VALUE_INCL_V
                              );
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_EXCL_B, 0)
                             , lLocalCurrencyId
                             , lVatCurrencyId
                             , lDocumentDate
                             , lVatExchangeRate
                             , lVatBasePrice
                             , 0
                             , lnBidon
                             , :new.POS_NET_VALUE_EXCL_V
                              );
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE_B, 0)
                             , lLocalCurrencyId
                             , lVatCurrencyId
                             , lDocumentDate
                             , lVatExchangeRate
                             , lVatBasePrice
                             , 0
                             , lnBidon
                             , :new.POS_GROSS_VALUE_V
                              );
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE_INCL_B, 0)
                             , lLocalCurrencyId
                             , lVatCurrencyId
                             , lDocumentDate
                             , lVatExchangeRate
                             , lVatBasePrice
                             , 0
                             , lnBidon
                             , :new.POS_GROSS_VALUE_INCL_V
                              );
    ACS_FUNCTION.ConvertAmount(nvl(:new.POS_VAT_BASE_AMOUNT, 0)
                             , lLocalCurrencyId
                             , lVatCurrencyId
                             , lDocumentDate
                             , lVatExchangeRate
                             , lVatBasePrice
                             , 0
                             , lnBidon
                             , :new.POS_VAT_AMOUNT_V
                              );

    if lTaxTransaction = 1 then
      :new.POS_VAT_TOTAL_AMOUNT_V  := :new.POS_NET_VALUE_EXCL_V;
    else
      :new.POS_VAT_TOTAL_AMOUNT_V  := :new.POS_NET_VALUE_INCL_V - :new.POS_NET_VALUE_EXCL_V;
    end if;
  end if;

  if     updating
     and :old.POS_MODIFY_RATE = 0
     and :new.POS_MODIFY_RATE = 1 then
    -- Mise à jour du récapitulatif TVA des positions
    -- Ajout des valeurs après recalcul des montants B/E/V
    DOC_VAT.UPDATE_POSITION_VAT(:new.DOC_DOCUMENT_ID
                              , :new.C_GAUGE_TYPE_POS
                              , :new.ACS_TAX_CODE_ID
                              , :new.POS_NET_VALUE_EXCL
                              , :new.POS_NET_VALUE_EXCL_B
                              , :new.POS_NET_VALUE_EXCL_V
                              , :new.POS_VAT_RATE
                              , :new.POS_VAT_TOTAL_AMOUNT
                              , :new.POS_VAT_TOTAL_AMOUNT_B
                              , :new.POS_VAT_TOTAL_AMOUNT_V
                              , :new.POS_VAT_AMOUNT
                              , :new.POS_VAT_BASE_AMOUNT
                              , :new.POS_VAT_AMOUNT_V
                              , 1
                               );
  end if;

  :new.POS_MODIFY_RATE  := 0;
end DOC_EPC_BIU_LOCAL_CURRENCY;

ALTER TRIGGER "C_ITX"."DOC_EPC_BIU_LOCAL_CURRENCY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_FCH_AD_VAT"
  after delete
  on DOC_FOOT_CHARGE
  referencing old as old new as new
  for each row
/**
* Description
*     Mise à jour du décompte TVA après effacement d'une
*     remise/taxe de pied
* @author Fabrice Perotto
* @version 2003
*/
declare
  discount_coef number(1);
begin
  if :old.C_FINANCIAL_CHARGE = '02' then
    discount_coef  := -1;
  else
    discount_coef  := 1;
  end if;

  -- Retrait des récapitulatifs TVA
  DOC_PRC_VAT.UpdateVatAccount(:old.DOC_FOOT_ID
                             , :old.ACS_TAX_CODE_ID
                             , :old.FCH_EXCL_AMOUNT
                             , :old.FCH_EXCL_AMOUNT_B
                             , :old.FCH_EXCL_AMOUNT_V
                             , :old.FCH_VAT_RATE
                             , :old.FCH_VAT_TOTAL_AMOUNT
                             , :old.FCH_VAT_TOTAL_AMOUNT_B
                             , :old.FCH_VAT_TOTAL_AMOUNT_V
                             , :old.FCH_VAT_AMOUNT
                             , :old.FCH_VAT_BASE_AMOUNT
                             , :old.FCH_VAT_AMOUNT_V
                             , discount_coef * -1
                            );
end DOC_FCH_AD_VAT;

ALTER TRIGGER "C_ITX"."DOC_FCH_AD_VAT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_FCH_AIUD_FLAG_DOCUMENT"
  after insert or delete or update of "FCH_EXCL_AMOUNT", "FCH_VAT_AMOUNT", "FCH_INCL_AMOUNT"
  on DOC_FOOT_CHARGE
  referencing old as old new as new
  for each row
/**
* Description
*    Maj des flag de recalculation des échéances et de rewgénération des no de BVR
* @created fpe 15.02.2002
* @lastUpdate fpe 28.06.2013
*/
begin
  -- Si un montant change, il faut recalculer les totaux du document
  if    inserting
     or deleting
     or :new.FCH_EXCL_AMOUNT <> :old.FCH_EXCL_AMOUNT
     or :new.FCH_VAT_AMOUNT <> :old.FCH_VAT_AMOUNT
     or :new.FCH_INCL_AMOUNT <> :old.FCH_INCL_AMOUNT then
    update DOC_DOCUMENT
       set DMT_REDO_PAYMENT_DATE = 1
         , DMT_RECALC_TOTAL = 1
     where DOC_DOCUMENT_ID = nvl(:new.DOC_FOOT_ID, :old.DOC_FOOT_ID);
  end if;
exception
  -- dans ce cas c'est le trigger DOC_DMT_AU_PROTECTED qui provoque cette mise à jour
  -- et il fait de toute façon le traîtement
  when ex.TABLE_MUTATING then
    null;
end DOC_FCH_AIUD_FLAG_DOCUMENT;

ALTER TRIGGER "C_ITX"."DOC_FCH_AIUD_FLAG_DOCUMENT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_FCH_AI_VAT"
  after insert
  on DOC_FOOT_CHARGE
  referencing old as old new as new
  for each row
/**
* Description
*     Mise à jour du décompte TVA après insertion d'une
*     remise/taxe de pied
* @author Fabrice Perotto
* @version 2003
*/
declare
  discount_coef number(1);
begin
  if :new.C_FINANCIAL_CHARGE = '02' then
    discount_coef  := -1;
  else
    discount_coef  := 1;
  end if;

  -- Ajout des récapitulatifs TVA
  DOC_PRC_VAT.UpdateVatAccount(:new.DOC_FOOT_ID
                             , :new.ACS_TAX_CODE_ID
                             , :new.FCH_EXCL_AMOUNT
                             , :new.FCH_EXCL_AMOUNT_B
                             , :new.FCH_EXCL_AMOUNT_V
                             , :new.FCH_VAT_RATE
                             , :new.FCH_VAT_TOTAL_AMOUNT
                             , :new.FCH_VAT_TOTAL_AMOUNT_B
                             , :new.FCH_VAT_TOTAL_AMOUNT_V
                             , :new.FCH_VAT_AMOUNT
                             , :new.FCH_VAT_BASE_AMOUNT
                             , :new.FCH_VAT_AMOUNT_V
                             , discount_coef * 1
                              );
end DOC_FCH_AI_VAT;

ALTER TRIGGER "C_ITX"."DOC_FCH_AI_VAT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_FCH_AU_VAT"
  after update of ACS_TAX_CODE_ID, DOC_FOOT_ID, FCH_EXCL_AMOUNT, FCH_VAT_AMOUNT, FCH_VAT_BASE_AMOUNT, FCH_VAT_RATE
  on DOC_FOOT_CHARGE
  referencing old as old new as new
  for each row
/**
* Description
*     Mise à jour du décompte TVA après mise à jour d'une
*     remise/taxe de pied
* @author Fabrice Perotto
* @version 2003
*/
declare
  discount_coef number(1);
begin
  if :old.C_FINANCIAL_CHARGE = '02' then
    DISCOUNT_COEF  := -1;
  else
    DISCOUNT_COEF  := 1;
  end if;

  -- Mise à jour des récapitulatifs TVA

  -- Retrait des anciennes valeurs
  DOC_PRC_VAT.UpdateVatAccount(:old.DOC_FOOT_ID
                             , :old.ACS_TAX_CODE_ID
                             , :old.FCH_EXCL_AMOUNT
                             , :old.FCH_EXCL_AMOUNT_B
                             , :old.FCH_EXCL_AMOUNT_V
                             , :old.FCH_VAT_RATE
                             , :old.FCH_VAT_TOTAL_AMOUNT
                             , :old.FCH_VAT_TOTAL_AMOUNT_B
                             , :old.FCH_VAT_TOTAL_AMOUNT_V
                             , :old.FCH_VAT_AMOUNT
                             , :old.FCH_VAT_BASE_AMOUNT
                             , :old.FCH_VAT_AMOUNT_V
                             , discount_coef * -1
                              );
  -- Ajout des nouvelles valeurs
  DOC_PRC_VAT.UpdateVatAccount(:new.DOC_FOOT_ID
                             , :new.ACS_TAX_CODE_ID
                             , :new.FCH_EXCL_AMOUNT
                             , :new.FCH_EXCL_AMOUNT_B
                             , :new.FCH_EXCL_AMOUNT_V
                             , :new.FCH_VAT_RATE
                             , :new.FCH_VAT_TOTAL_AMOUNT
                             , :new.FCH_VAT_TOTAL_AMOUNT_B
                             , :new.FCH_VAT_TOTAL_AMOUNT_V
                             , :new.FCH_VAT_AMOUNT
                             , :new.FCH_VAT_BASE_AMOUNT
                             , :new.FCH_VAT_AMOUNT_V
                             , discount_coef * 1
                              );
end DOC_FCH_AU_VAT;

ALTER TRIGGER "C_ITX"."DOC_FCH_AU_VAT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_FCH_BI_DENORM"
  before insert
  on DOC_FOOT_CHARGE
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des champs dénormalisés de DOC_FOOT_CHARGE
* @author Fabrice Perotto
* @version 2003
*/
begin
  select PAC_THIRD_ID
       , PAC_THIRD_ACI_ID
       , PAC_THIRD_DELIVERY_ID
       , PAC_THIRD_TARIFF_ID
    into :new.PAC_THIRD_ID
       , :new.PAC_THIRD_ACI_ID
       , :new.PAC_THIRD_DELIVERY_ID
       , :new.PAC_THIRD_TARIFF_ID
    from DOC_FOOT
   where DOC_FOOT_ID = :new.DOC_FOOT_ID;
end DOC_FCH_BI_DENORM;

ALTER TRIGGER "C_ITX"."DOC_FCH_BI_DENORM" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_FCH_BIU_LOCAL_CURRENCY"
  before insert or update of FCH_MODIFY_RATE
                           , FCH_CALC_AMOUNT
                           , FCH_EXCL_AMOUNT
                           , FCH_INCL_AMOUNT
                           , FCH_VAT_TOTAL_AMOUNT
                           , FCH_VAT_AMOUNT
                           , FCH_VAT_RATE
                           , FCH_LIABLED_AMOUNT
                           , ACS_TAX_CODE_ID
  on DOC_FOOT_CHARGE
  referencing old as old new as new
  for each row
/**
* Description
*     Mise à jour des montants en monnaie de base
*     après insertion ou modifications des montants en monnaie document
* @author Fabrice Perotto
* @version 2003
* @lastUpdate 09.04.2002
*/
declare
  euro_rate            DOC_DOCUMENT.DMT_RATE_OF_EXCHANGE%type;
  curr_id              DOC_DOCUMENT.ACS_FINANCIAL_CURRENCY_ID%type;
  vat_curr_id          DOC_DOCUMENT.ACS_ACS_FINANCIAL_CURRENCY_ID%type;
  local_curr_id        DOC_DOCUMENT.ACS_FINANCIAL_CURRENCY_ID%type;
  document_date        DOC_DOCUMENT.DMT_DATE_DOCUMENT%type;
  rate_of_exchange     DOC_DOCUMENT.DMT_RATE_OF_EXCHANGE%type;
  base_price           DOC_DOCUMENT.DMT_BASE_PRICE%type;
  det_account_id       DOC_VAT_DET_ACCOUNT.DOC_VAT_DET_ACCOUNT_ID%type;
  vat_rate_of_exchange DOC_DOCUMENT.DMT_VAT_EXCHANGE_RATE%type;
  vat_base_price       DOC_DOCUMENT.DMT_VAT_BASE_PRICE%type;
  bidon                DOC_POSITION.POS_NET_VALUE_EXCL_E%type;
  includeTaxTariff     DOC_GAUGE_POSITION.GAP_INCLUDE_TAX_TARIFF%type;
  discount_coef        number(1);
  vTaxTransaction      ACS_ACCOUNT.ACC_INTEREST%type;
  vRefDate             DOC_DOCUMENT.DMT_DATE_DELIVERY%type;
begin
  if :old.C_FINANCIAL_CHARGE = '02' then
    discount_coef  := -1;
  else
    discount_coef  := 1;
  end if;

  includeTaxTariff  := DOC_FUNCTIONS.isDocumentTTC(:new.DOC_FOOT_ID);

  -- recherche si l'on effectue une correction du montant de TVA
  select max(VDA.DOC_VAT_DET_ACCOUNT_ID)
    into det_account_id
    from DOC_VAT_DET_ACCOUNT VDA
   where VDA.DOC_FOOT_ID = :new.DOC_FOOT_ID
     and VDA.DOC_FOOT_CHARGE_ID = :new.DOC_FOOT_CHARGE_ID;

  if    det_account_id is null
     or :new.FCH_MODIFY_RATE = 1 then
    -- Si c'est une modification des taux de change,
    if     updating
       and :old.FCH_MODIFY_RATE = 0
       and :new.FCH_MODIFY_RATE = 1 then
      -- Mise à jour du récapitulatif TVA des positions
      -- Retrait des valeurs avant recalcul des montants B/E/V
      DOC_PRC_VAT.UpdateVatAccount(:new.DOC_FOOT_ID
                                 , :new.ACS_TAX_CODE_ID
                                 , :new.FCH_EXCL_AMOUNT
                                 , :new.FCH_EXCL_AMOUNT_B
                                 , :new.FCH_EXCL_AMOUNT_V
                                 , :new.FCH_VAT_RATE
                                 , :new.FCH_VAT_TOTAL_AMOUNT
                                 , :new.FCH_VAT_TOTAL_AMOUNT_B
                                 , :new.FCH_VAT_TOTAL_AMOUNT_V
                                 , :new.FCH_VAT_AMOUNT
                                 , :new.FCH_VAT_BASE_AMOUNT
                                 , :new.FCH_VAT_AMOUNT_V
                                 , discount_coef * -1
                                  );
    else
      -- Si ce n'est pas une modification des taux de change, on recalcule la TVA

      -- Recherche de la date de référence
      select nvl(DMT.DMT_DATE_DELIVERY, DMT.DMT_DATE_VALUE)
        into vRefDate
        from DOC_DOCUMENT DMT
       where DMT.DOC_DOCUMENT_ID = :new.DOC_FOOT_ID;

      if     (includeTaxTariff = 1)
         and (:new.FCH_INCL_AMOUNT is not null) then   -- TTC
        ACS_FUNCTION.CalcVatAmount
                                 (aTaxCodeId        => :new.ACS_TAX_CODE_ID
                                , aRefDate          => vRefDate
                                , aIncludedVat      => 'I'
                                , aRoundAmount      => to_number
                                                              (nvl(2   /*PCS.PC_CONFIG.GetConfig('DOC_ROUND_POSITION')*/
                                                                 , '0'
                                                                  )
                                                              )
                                , aNetAmountExcl    => :new.FCH_EXCL_AMOUNT
                                , aNetAmountIncl    => :new.FCH_INCL_AMOUNT
                                , aLiabledRate      => :new.FCH_VAT_LIABLED_RATE
                                , aLiabledAmount    => :new.FCH_VAT_LIABLED_AMOUNT
                                , aTaxeRate         => :new.FCH_VAT_RATE
                                , aVatTotalAmount   => :new.FCH_VAT_TOTAL_AMOUNT
                                , aDeductibleRate   => :new.FCH_VAT_DEDUCTIBLE_RATE
                                , aVatAmount        => :new.FCH_VAT_AMOUNT
                                 );
      else   -- HT
        ACS_FUNCTION.CalcVatAmount
                                 (aTaxCodeId        => :new.ACS_TAX_CODE_ID
                                , aRefDate          => vRefDate
                                , aIncludedVat      => 'E'
                                , aRoundAmount      => to_number
                                                              (nvl(2   /*PCS.PC_CONFIG.GetConfig('DOC_ROUND_POSITION')*/
                                                                 , '0'
                                                                  )
                                                              )
                                , aNetAmountExcl    => :new.FCH_EXCL_AMOUNT
                                , aNetAmountIncl    => :new.FCH_INCL_AMOUNT
                                , aLiabledRate      => :new.FCH_VAT_LIABLED_RATE
                                , aLiabledAmount    => :new.FCH_VAT_LIABLED_AMOUNT
                                , aTaxeRate         => :new.FCH_VAT_RATE
                                , aVatTotalAmount   => :new.FCH_VAT_TOTAL_AMOUNT
                                , aDeductibleRate   => :new.FCH_VAT_DEDUCTIBLE_RATE
                                , aVatAmount        => :new.FCH_VAT_AMOUNT
                                 );
      end if;
    -- Fin du calcul décompte TVA
    end if;

    -- recherche des informations nécessaires à la conversion dans la table DOC_DOCUMENT
    select ACS_FINANCIAL_CURRENCY_ID
         , ACS_ACS_FINANCIAL_CURRENCY_ID
         , DMT_DATE_DOCUMENT
         , DMT_RATE_OF_EXCHANGE
         , DMT_BASE_PRICE
         , DMT_VAT_EXCHANGE_RATE
         , DMT_VAT_BASE_PRICE
      into curr_id
         , vat_curr_id
         , document_date
         , rate_of_exchange
         , base_price
         , vat_rate_of_exchange
         , vat_base_price
      from DOC_DOCUMENT
     where DOC_DOCUMENT_ID = :new.DOC_FOOT_ID;

    begin
      select nvl(ACC.ACC_INTEREST, 0)
        into vTaxTransaction
        from ACS_ACCOUNT ACC
       where ACC.ACS_ACCOUNT_ID = :new.ACS_TAX_CODE_ID;
    exception
      when no_data_found then
        vTaxTransaction  := 0;
    end;

    local_curr_id         := ACS_FUNCTION.GetLocalCurrencyId;

    if :new.C_CALCULATION_MODE in('0', '1', '6') then
      if     (includeTaxTariff = 1) then
        :new.FCH_FIXED_AMOUNT  := :new.FCH_INCL_AMOUNT;
      else
        :new.FCH_FIXED_AMOUNT  := :new.FCH_EXCL_AMOUNT;
      end if;

      if inserting then
        ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_FIXED_AMOUNT_B, 0)
                                 , local_curr_id
                                 , curr_id
                                 , document_date
                                 , base_price
                                 , rate_of_exchange
                                 , 0
                                 , :new.FCH_FIXED_AMOUNT_E
                                 , bidon
                                  );
      elsif updating then
        ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_FIXED_AMOUNT, 0)
                                 , curr_id
                                 , local_curr_id
                                 , document_date
                                 , rate_of_exchange
                                 , base_price
                                 , 0
                                 , :new.FCH_FIXED_AMOUNT_E
                                 , :new.FCH_FIXED_AMOUNT_B
                                  );
      end if;
    end if;

    ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_CALC_AMOUNT, 0)
                             , curr_id
                             , local_curr_id
                             , document_date
                             , rate_of_exchange
                             , base_price
                             , 0
                             , :new.FCH_CALC_AMOUNT_E
                             , :new.FCH_CALC_AMOUNT_B
                              );
    ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_LIABLED_AMOUNT, 0)
                             , curr_id
                             , local_curr_id
                             , document_date
                             , rate_of_exchange
                             , base_price
                             , 0
                             , :new.FCH_LIABLED_AMOUNT_E
                             , :new.FCH_LIABLED_AMOUNT_B
                              );

    if     (local_curr_id = vat_curr_id)
       and (curr_id = vat_curr_id) then   -- Cas n°1 CHF - CHF - CHF
      -- Cas n°1 CHF - CHF - CHF
      ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_INCL_AMOUNT, 0)
                               , curr_id
                               , local_curr_id
                               , document_date
                               , rate_of_exchange
                               , base_price
                               , 0
                               , :new.FCH_INCL_AMOUNT_E
                               , :new.FCH_INCL_AMOUNT_B
                                );
      :new.FCH_INCL_AMOUNT_V       := :new.FCH_INCL_AMOUNT_B;
      ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_EXCL_AMOUNT, 0)
                               , curr_id
                               , local_curr_id
                               , document_date
                               , rate_of_exchange
                               , base_price
                               , 0
                               , :new.FCH_EXCL_AMOUNT_E
                               , :new.FCH_EXCL_AMOUNT_B
                                );
      :new.FCH_EXCL_AMOUNT_V       := :new.FCH_EXCL_AMOUNT_B;
      ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_VAT_AMOUNT, 0)
                               , curr_id
                               , local_curr_id
                               , document_date
                               , rate_of_exchange
                               , base_price
                               , 0
                               , :new.FCH_VAT_AMOUNT_E
                               , :new.FCH_VAT_BASE_AMOUNT
                                );
      :new.FCH_VAT_AMOUNT_V        := :new.FCH_VAT_AMOUNT;
      :new.FCH_VAT_TOTAL_AMOUNT_B  := :new.FCH_VAT_TOTAL_AMOUNT;
      :new.FCH_VAT_TOTAL_AMOUNT_V  := :new.FCH_VAT_TOTAL_AMOUNT;
    elsif     (local_curr_id = vat_curr_id)
          and (curr_id <> vat_curr_id) then   -- Cas n°2 CHF - EUR - CHF
      -- Cas n°2 CHF - EUR - CHF

      -- Le cours de la monnaie TVA est stockée spécialement dans le cas n° 2.
      -- Il s'agit du cours entre la monnaie TVA et la monnaie Document

      -- Lorsque l'on fait une convertion pour obtenir un montant TVA en monnaie de Base
      --  on a inversé expres les paramètres entrants rate_of_exchange et base_price
      --  à cause justement du stockage spécial du cours cité ci-dessus

      -- * Montant total TVA monnaie Document -> Montant total TVA monnaie Base
      --   en utilisant le cours TVA
      ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_VAT_TOTAL_AMOUNT, 0)
                               , vat_curr_id
                               , curr_id
                               , document_date
                               , vat_base_price
                               , vat_rate_of_exchange
                               , 0
                               , bidon
                               , :new.FCH_VAT_TOTAL_AMOUNT_B
                                );
      -- * Montant total TVA monnaie TVA = Montant total TVA monnaie base
      :new.FCH_VAT_TOTAL_AMOUNT_V  := :new.FCH_VAT_TOTAL_AMOUNT_B;
      -- * Montant TVA monnaie Document -> Montant TVA monnaie Base
      --   en utilisant le cours TVA
      ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_VAT_AMOUNT, 0)
                               , vat_curr_id
                               , curr_id
                               , document_date
                               , vat_base_price
                               , vat_rate_of_exchange
                               , 0
                               , bidon
                               , :new.FCH_VAT_BASE_AMOUNT
                                );
      -- * Montant TVA monnaie Document -> Montant TVA monnaie E
      --   en utilisant le cours du document
      ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_VAT_AMOUNT, 0)
                               , curr_id
                               , local_curr_id
                               , document_date
                               , rate_of_exchange
                               , base_price
                               , 0
                               , :new.FCH_VAT_AMOUNT_E
                               , bidon
                                );
      -- * Montant TVA monnaie TVA = Montant TVA monnaie base
      :new.FCH_VAT_AMOUNT_V        := :new.FCH_VAT_BASE_AMOUNT;
      -- * Montant HT en monnaie Document -> Montant HT en monnaie TVA
      --   en utilisant le cours TVA
      ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_EXCL_AMOUNT, 0)
                               , vat_curr_id
                               , curr_id
                               , document_date
                               , vat_base_price
                               , vat_rate_of_exchange
                               , 0
                               , bidon
                               , :new.FCH_EXCL_AMOUNT_V
                                );
      -- * Montant TTC en monnaie Document -> Montant TTC en monnaie TVA
      --   en utilisant le cours TVA
      ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_INCL_AMOUNT, 0)
                               , vat_curr_id
                               , curr_id
                               , document_date
                               , vat_base_price
                               , vat_rate_of_exchange
                               , 0
                               , bidon
                               , :new.FCH_INCL_AMOUNT_V
                                );

      if includeTaxTariff = 0 then   -- HT
        -- * Montant HT en monnaie Document -> Montant HT en monnaie Base et monnaie E
        --   en utilisant le cours du Document
        ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_EXCL_AMOUNT, 0)
                                 , curr_id
                                 , local_curr_id
                                 , document_date
                                 , rate_of_exchange
                                 , base_price
                                 , 0
                                 , :new.FCH_EXCL_AMOUNT_E
                                 , :new.FCH_EXCL_AMOUNT_B
                                  );

        -- Les montants TTC en monnaie de Base et monnaie E sont calculés par
        -- addition des respectifs montants HT + la TVA sauf cas de transaction
        -- de taxe
        if vTaxTransaction = 1 then
          :new.FCH_INCL_AMOUNT_B  := :new.FCH_EXCL_AMOUNT_B;
          :new.FCH_INCL_AMOUNT_E  := :new.FCH_EXCL_AMOUNT_E;
        else
          :new.FCH_INCL_AMOUNT_B  := :new.FCH_EXCL_AMOUNT_B + :new.FCH_VAT_TOTAL_AMOUNT_B;
--          :new.FCH_INCL_AMOUNT_E  := :new.FCH_EXCL_AMOUNT_E + :new.FCH_VAT_TOTAL_AMOUNT_E;
          ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_INCL_AMOUNT, 0)
                                   , curr_id
                                   , local_curr_id
                                   , document_date
                                   , rate_of_exchange
                                   , base_price
                                   , 0
                                   , :new.FCH_INCL_AMOUNT_E
                                   , bidon
                                    );
        end if;
      else   -- TTC
        -- * Montant TTC en monnaie Document -> Montant TTC en monnaie Base et monnaie E
        --   en utilisant le cours du Document
        ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_INCL_AMOUNT, 0)
                                 , curr_id
                                 , local_curr_id
                                 , document_date
                                 , rate_of_exchange
                                 , base_price
                                 , 0
                                 , :new.FCH_INCL_AMOUNT_E
                                 , :new.FCH_INCL_AMOUNT_B
                                  );

        -- Les montants HT en monnaie de Base et monnaie E sont calculés par
        -- soustraction des respectifs montants TTC - la TVA sauf cas de
        -- transaction de taxe
        if vTaxTransaction = 1 then
          :new.FCH_EXCL_AMOUNT_B  := :new.FCH_INCL_AMOUNT_B;
          :new.FCH_EXCL_AMOUNT_E  := :new.FCH_INCL_AMOUNT_E;
        else
          :new.FCH_EXCL_AMOUNT_B  := :new.FCH_INCL_AMOUNT_B - :new.FCH_VAT_TOTAL_AMOUNT_B;
--          :new.FCH_EXCL_AMOUNT_E  := :new.FCH_INCL_AMOUNT_E - :new.FCH_VAT_TOTAL_AMOUNT_E;
          ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_EXCL_AMOUNT, 0)
                                   , curr_id
                                   , local_curr_id
                                   , document_date
                                   , rate_of_exchange
                                   , base_price
                                   , 0
                                   , :new.FCH_EXCL_AMOUNT_E
                                   , bidon
                                    );
        end if;
      end if;
    elsif     (local_curr_id <> vat_curr_id)
          and (curr_id = vat_curr_id) then   -- Cas n°3 CHF - EUR - EUR
      -- Cas n°3 CHF - EUR - EUR

      -- Les montants en monnaie TVA sont les mêmes que les montants en monnaie Document
      :new.FCH_EXCL_AMOUNT_V       := :new.FCH_EXCL_AMOUNT;
      :new.FCH_INCL_AMOUNT_V       := :new.FCH_INCL_AMOUNT;
      :new.FCH_VAT_TOTAL_AMOUNT_V  := :new.FCH_VAT_TOTAL_AMOUNT;
      :new.FCH_VAT_AMOUNT_V        := :new.FCH_VAT_AMOUNT;
      -- * Montant total TVA en monnaie Document -> Montant total TVA en monnaie Base
      --   en utilisant le cours du TVA
      ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_VAT_TOTAL_AMOUNT, 0)
                               , vat_curr_id
                               , local_curr_id
                               , document_date
                               , vat_rate_of_exchange
                               , vat_base_price
                               , 0
                               , bidon
                               , :new.FCH_VAT_TOTAL_AMOUNT_B
                                );
      -- * Montant TVA en monnaie Document -> Montant TVA en monnaie Base et monnaie E
      --   en utilisant le cours du TVA
      ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_VAT_AMOUNT, 0)
                               , vat_curr_id
                               , local_curr_id
                               , document_date
                               , vat_rate_of_exchange
                               , vat_base_price
                               , 0
                               , :new.FCH_VAT_AMOUNT_E
                               , :new.FCH_VAT_BASE_AMOUNT
                                );

      if includeTaxTariff = 0 then   -- HT
        -- * Montant HT en monnaie Document -> Montant HT en monnaie Base et monnaie E
        --   en utilisant le cours du Document
        ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_EXCL_AMOUNT, 0)
                                 , curr_id
                                 , local_curr_id
                                 , document_date
                                 , rate_of_exchange
                                 , base_price
                                 , 0
                                 , :new.FCH_EXCL_AMOUNT_E
                                 , :new.FCH_EXCL_AMOUNT_B
                                  );

        -- Les montants TTC en monnaie de Base et monnaie E sont calculés par
        -- addition des respectifs montants HT + la TVA sauf cas de
        -- transaction de taxe
        if vTaxTransaction = 1 then
          :new.FCH_INCL_AMOUNT_B  := :new.FCH_EXCL_AMOUNT_B;
          :new.FCH_INCL_AMOUNT_E  := :new.FCH_EXCL_AMOUNT_E;
        else
          :new.FCH_INCL_AMOUNT_B  := :new.FCH_EXCL_AMOUNT_B + :new.FCH_VAT_TOTAL_AMOUNT_B;
--          :new.FCH_INCL_AMOUNT_E  := :new.FCH_EXCL_AMOUNT_E + :new.FCH_VAT_TOTAL_AMOUNT_E;
          ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_INCL_AMOUNT, 0)
                                   , curr_id
                                   , local_curr_id
                                   , document_date
                                   , rate_of_exchange
                                   , base_price
                                   , 0
                                   , :new.FCH_INCL_AMOUNT_E
                                   , bidon
                                    );
        end if;
      else   -- TTC
        -- * Montant TTC en monnaie Document -> Montant TTC en monnaie Base et monnaie E
        --   en utilisant le cours du Document
        ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_INCL_AMOUNT, 0)
                                 , curr_id
                                 , local_curr_id
                                 , document_date
                                 , rate_of_exchange
                                 , base_price
                                 , 0
                                 , :new.FCH_INCL_AMOUNT_E
                                 , :new.FCH_INCL_AMOUNT_B
                                  );

        -- Les montants HT en monnaie de Base et monnaie E sont calculés par
        -- soustraction des respectifs montants TTC - la TVA sauf cas de
        -- transaction de taxe
        if vTaxTransaction = 1 then
          :new.FCH_EXCL_AMOUNT_B  := :new.FCH_INCL_AMOUNT_B;
          :new.FCH_EXCL_AMOUNT_E  := :new.FCH_INCL_AMOUNT_E;
        else
          :new.FCH_EXCL_AMOUNT_B  := :new.FCH_INCL_AMOUNT_B - :new.FCH_VAT_TOTAL_AMOUNT_B;
--          :new.FCH_EXCL_AMOUNT_E  := :new.FCH_INCL_AMOUNT_E - :new.FCH_VAT_TOTAL_AMOUNT_E;
          ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_EXCL_AMOUNT, 0)
                                   , curr_id
                                   , local_curr_id
                                   , document_date
                                   , rate_of_exchange
                                   , base_price
                                   , 0
                                   , :new.FCH_EXCL_AMOUNT_E
                                   , bidon
                                    );
        end if;
      end if;
    else
      -- Cas n°4 CHF - CHF - EUR
      -- Cas n°5 CHF - USD - EUR
      ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_INCL_AMOUNT, 0)
                               , curr_id
                               , local_curr_id
                               , document_date
                               , rate_of_exchange
                               , base_price
                               , 0
                               , :new.FCH_INCL_AMOUNT_E
                               , :new.FCH_INCL_AMOUNT_B
                                );
      ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_EXCL_AMOUNT, 0)
                               , curr_id
                               , local_curr_id
                               , document_date
                               , rate_of_exchange
                               , base_price
                               , 0
                               , :new.FCH_EXCL_AMOUNT_E
                               , :new.FCH_EXCL_AMOUNT_B
                                );
      ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_VAT_TOTAL_AMOUNT, 0)
                               , curr_id
                               , local_curr_id
                               , document_date
                               , rate_of_exchange
                               , base_price
                               , 0
                               , bidon
                               , :new.FCH_VAT_TOTAL_AMOUNT_B
                                );
      ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_VAT_AMOUNT, 0)
                               , curr_id
                               , local_curr_id
                               , document_date
                               , rate_of_exchange
                               , base_price
                               , 0
                               , :new.FCH_VAT_AMOUNT_E
                               , :new.FCH_VAT_BASE_AMOUNT
                                );
      ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_INCL_AMOUNT_B, 0)
                               , local_curr_id
                               , vat_curr_id
                               , document_date
                               , vat_rate_of_exchange
                               , vat_base_price
                               , 0
                               , bidon
                               , :new.FCH_INCL_AMOUNT_V
                                );
      ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_EXCL_AMOUNT_B, 0)
                               , local_curr_id
                               , vat_curr_id
                               , document_date
                               , vat_rate_of_exchange
                               , vat_base_price
                               , 0
                               , bidon
                               , :new.FCH_EXCL_AMOUNT_V
                                );
      ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_VAT_TOTAL_AMOUNT_B, 0)
                               , local_curr_id
                               , vat_curr_id
                               , document_date
                               , vat_rate_of_exchange
                               , vat_base_price
                               , 0
                               , bidon
                               , :new.FCH_VAT_TOTAL_AMOUNT_V
                                );
      ACS_FUNCTION.ConvertAmount(nvl(:new.FCH_VAT_BASE_AMOUNT, 0)
                               , local_curr_id
                               , vat_curr_id
                               , document_date
                               , vat_rate_of_exchange
                               , vat_base_price
                               , 0
                               , bidon
                               , :new.FCH_VAT_AMOUNT_V
                                );
    end if;

    if     updating
       and :old.fch_modify_rate = 0
       and :new.fch_modify_rate = 1 then
      -- Mise à jour du récapitulatif TVA des positions
      -- Ajout des valeurs après recalcul des montants B/E/V
      DOC_PRC_VAT.UpdateVatAccount(:new.DOC_FOOT_ID
                                 , :new.ACS_TAX_CODE_ID
                                 , :new.FCH_EXCL_AMOUNT
                                 , :new.FCH_EXCL_AMOUNT_B
                                 , :new.FCH_EXCL_AMOUNT_V
                                 , :new.FCH_VAT_RATE
                                 , :new.FCH_VAT_TOTAL_AMOUNT
                                 , :new.FCH_VAT_TOTAL_AMOUNT_B
                                 , :new.FCH_VAT_TOTAL_AMOUNT_V
                                 , :new.FCH_VAT_AMOUNT
                                 , :new.FCH_VAT_BASE_AMOUNT
                                 , :new.FCH_VAT_AMOUNT_V
                                 , discount_coef * 1
                                  );
    end if;

    :new.FCH_MODIFY_RATE  := 0;
  end if;
end DOC_FCH_BIU_LOCAL_CURRENCY;

ALTER TRIGGER "C_ITX"."DOC_FCH_BIU_LOCAL_CURRENCY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_FOO_AD_CONSTRAINTS"
after delete
on DOC_FOOT
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*     Vérification des contraintes d'intégrité par rapport à DOC_VAT_DET_ACCOUNT
* @author Fabrice Perotto
* @version DEVELOP
*/


begin

  --Effacement des enregistrements de doc_vat_det_accoumt
  -- liés au pierd que l'on efface
  -- Remplace une contrainte
  DELETE FROM DOC_VAT_DET_ACCOUNT WHERE DOC_FOOT_ID = :OLD.DOC_FOOT_ID;

end DOC_FOO_AD_CONSTRAINTS;


ALTER TRIGGER "C_ITX"."DOC_FOO_AD_CONSTRAINTS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_FOO_AIUD_CURR_RISK_BALANCE"
  after insert or delete or update of "GAL_CURRENCY_RISK_VIRTUAL_ID", "FOO_CURR_RISK_BAL_POS_AMOUNT", "FOO_CURR_RISK_BAL_FCH_AMOUNT"
  on DOC_FOOT
  referencing old as old new as new
  for each row
/**
* Description
*    Maj du solde à disposition dans la tranche virtuelle liée
* @created    fpe 01.07.2013
* @lastupdate fpe 24.09.2013 - changement de nom du trigger, prise en compte échéancier
*/
declare
  ltComp         FWK_I_TYP_DEFINITION.t_crud_def;
  lSign          number(1);
  lDocDocumentID doc_document.doc_document_id%type;
  lDocAmount1    GAL_CURRENCY_RISK_VIRTUAL.GCV_BALANCE%type;
  lDocAmount2    GAL_CURRENCY_RISK_VIRTUAL.GCV_BALANCE%type;
  lPositionId    DOC_POSITION.DOC_POSITION_ID%type;
begin
  -- Seuls les documents non-issus d'un échéancier sont pris en compte (sauf les NC sur contrat) (DEVLOG-16582 règle 3720)
  if (PCS.PC_CONFIG.GetConfig('COM_CURRENCY_RISK_MANAGE') = '1') then
    -- inversion du signe pour les notes de crédit
    lDocDocumentID  := nvl(:new.DOC_FOOT_ID, :old.DOC_FOOT_ID);

---CTRL HMO
    select nvl(max(DOC_POSITION_ID), 0)
      into lPositionId
      from DOC_POSITION
     where DOC_DOCUMENT_ID = lDocDocumentID;

--     IF DOC_INVOICE_EXPIRY_FUNCTIONS.IsPosCreditNote (lPositionId) = 1 then
--                  lSign :=1;
--     else
--     if DOC_I_LIB_POSITION.IsPosFromCreditNoteOutOfExpiry(lPositionId) = 0 then
--     lSign = 1
--     else
--      lSign = -1
--      end if;
--      SELECT CASE
--                WHEN NVL (GAS.C_DOC_JOURNAL_CALCULATION, 'ADD') = 'ADD'
--                THEN
--                   1
--                ELSE
--                   -1
--             END
--                MULTIPLY_FACTOR
--        INTO lSign
--        FROM DOC_DOCUMENT DMT, DOC_GAUGE_STRUCTURED GAS
--       WHERE DMT.DOC_DOCUMENT_ID = lDocDocumentID
--             AND GAS.DOC_GAUGE_ID = DMT.DOC_GAUGE_ID;
-- end if;
    lDocAmount1     := nvl(:old.FOO_CURR_RISK_BAL_POS_AMOUNT, 0) + nvl(:old.FOO_CURR_RISK_BAL_FCH_AMOUNT, 0);

-- mettre à jur le solde si plus de position dans le document après effecament dela dernière position
    if lPositionId = 0 then
      lDocAmount2  := nvl(:new.FOO_CURR_RISK_BAL_FCH_AMOUNT, 0);
    else
      lDocAmount2  := nvl(:new.FOO_CURR_RISK_BAL_POS_AMOUNT, 0) + nvl(:new.FOO_CURR_RISK_BAL_FCH_AMOUNT, 0);
    end if;

    -- enlever les anciennes valeurs
    if     deleting
       and :old.GAL_CURRENCY_RISK_VIRTUAL_ID is not null then
      GAL_I_PRC_CURRENCY_RISK.UpdateVirtualBalance(iGalCurrencyRiskVirtualId   => :old.GAL_CURRENCY_RISK_VIRTUAL_ID
                                                 , iDocDocumentID              => lDocDocumentID
                                                 , iDocAmount1                 => lDocAmount1
                                                 , iDeltaAmount                => lDocAmount1 * -1
                                                  );
    end if;

    -- enlever les anciennes valeurs
    if     updating
       and :old.GAL_CURRENCY_RISK_VIRTUAL_ID is not null
       and (:old.GAL_CURRENCY_RISK_VIRTUAL_ID <> nvl(:new.GAL_CURRENCY_RISK_VIRTUAL_ID, 0) ) then
      GAL_I_PRC_CURRENCY_RISK.UpdateVirtualBalance(iGalCurrencyRiskVirtualId   => :old.GAL_CURRENCY_RISK_VIRTUAL_ID
                                                 , iDocDocumentID              => lDocDocumentID
                                                 , iDocAmount1                 => lDocAmount1
                                                 , iDeltaAmount                => lDocAmount1 * -1
                                                  );
    end if;

    -- ajouter les nouvelles valeurs
    if    (    inserting
           and :new.GAL_CURRENCY_RISK_VIRTUAL_ID is not null)
       or (    updating
           and :new.GAL_CURRENCY_RISK_VIRTUAL_ID is not null
           and (nvl(:old.GAL_CURRENCY_RISK_VIRTUAL_ID, 0) <> :new.GAL_CURRENCY_RISK_VIRTUAL_ID) ) then
      GAL_I_PRC_CURRENCY_RISK.UpdateVirtualBalance(iGalCurrencyRiskVirtualId   => :new.GAL_CURRENCY_RISK_VIRTUAL_ID
                                                 , iDocDocumentID              => lDocDocumentID
                                                 , iDocAmount2                 => lDocAmount2
                                                 , iDeltaAmount                => lDocAmount2
                                                  );
    end if;

    -- mettre a jour les valeurs selon delta
    if     updating
       and :new.GAL_CURRENCY_RISK_VIRTUAL_ID is not null
       and (:old.GAL_CURRENCY_RISK_VIRTUAL_ID = :new.GAL_CURRENCY_RISK_VIRTUAL_ID) then
      GAL_I_PRC_CURRENCY_RISK.UpdateVirtualBalance(iGalCurrencyRiskVirtualId   => :new.GAL_CURRENCY_RISK_VIRTUAL_ID
                                                 , iDocDocumentID              => lDocDocumentID
                                                 , iDocAmount1                 => lDocAmount1
                                                 , iDocAmount2                 => lDocAmount2
                                                 , iDeltaAmount                => (lDocAmount2 - lDocAmount1)
                                                  );
    end if;

    if     (   updating
            or inserting)
       and lPositionId = 0
       and lDocAmount1 <> 0 then
      GAL_I_PRC_CURRENCY_RISK.UpdateVirtualBalance(iGalCurrencyRiskVirtualId   => :old.GAL_CURRENCY_RISK_VIRTUAL_ID
                                                 , iDocDocumentID              => lDocDocumentID
                                                 , iDocAmount1                 => lDocAmount1
                                                 , iDocAmount2                 => lDocAmount2
                                                 , iDeltaAmount                => (lDocAmount2 - lDocAmount1)
                                                  );
    end if;
  end if;
end DOC_FOO_AIUD_CURR_RISK_BALANCE;

ALTER TRIGGER "C_ITX"."DOC_FOO_AIUD_CURR_RISK_BALANCE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_FOO_AU_FLAG_DOCUMENT"
  after update of C_BVR_GENERATION_METHOD
  on DOC_FOOT
  referencing old as old new as new
  for each row
/**
* Description
*    Activation du flag de regénération des BVR
* @created fp 22.10.2003
* @version 2003
*/
begin
  update DOC_PAYMENT_DATE
     set PAD_BVR_CODING_LINE = null
       , A_DATEMOD = sysdate
       , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
   where DOC_FOOT_ID = nvl(:new.DOC_FOOT_ID, :old.DOC_FOOT_ID)
     and PAD_BVR_CODING_LINE is not null;

  update DOC_DOCUMENT
     set DMT_REDO_PAYMENT_BVR = 1
   where DOC_DOCUMENT_ID = nvl(:new.DOC_FOOT_ID, :old.DOC_FOOT_ID);
end DOC_FOO_AU_FLAG_DOCUMENT;

ALTER TRIGGER "C_ITX"."DOC_FOO_AU_FLAG_DOCUMENT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_FOO_BD_DOCU_ACCU"
  before delete
  on DOC_FOOT
  referencing old as old new as new
  for each row
/**
* Description
*     Mise à jour des totalisateurs de document avant effacement du pied
* @author Fabrice Perotto
* @version 2003
*/
declare
  -- curseur sur les totaux du pied de document
  cursor DOC_VALUES_CURSOR(doc_id number)
  is
    select DOC_DOCUMENT_ID
         , DMT_DATE_DOCUMENT
         , DIC_GAUGE_TYPE_DOC_ID
         , C_DOCUMENT_STATUS
         , PAC_THIRD_ID
      from DOC_DOCUMENT
     where DOC_DOCUMENT_ID = doc_id;

  doc_values_tuple doc_values_cursor%rowtype;
begin
  -- pas de mise à jour des totalisateurs (possible uniquement par recalcul global)
  if PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '0' then
    null;
  -- mise à jour instantannée des totalisateurs de position
  elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '1' then
    -- recherche des montants du document
    open DOC_VALUES_CURSOR(:old.DOC_DOCUMENT_ID);

    fetch DOC_VALUES_CURSOR
     into doc_values_tuple;

    if DOC_VALUES_CURSOR%found then
      -- mise à jour des totalisateurs de document
      -- Retrait des anciennes valeurs
      DOC_ACCUMULATOR.DOC_TOTAL_DOCUMENT(doc_values_tuple.DOC_DOCUMENT_ID
                                       , doc_values_tuple.DMT_DATE_DOCUMENT
                                       , doc_values_tuple.DIC_GAUGE_TYPE_DOC_ID
                                       , doc_values_tuple.C_DOCUMENT_STATUS
                                       , doc_values_tuple.PAC_THIRD_ID
                                       , :old.FOO_DOCUMENT_TOT_AMOUNT_B
                                       , :old.FOO_TOT_VAT_AMOUNT_B
                                       , -1
                                       , 0
                                        );
    end if;

    close DOC_VALUES_CURSOR;
  -- insertion dans le buffer des totalisateurs de position (maj différée)
  elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '2' then
    insert into DOC_DOCU_ACCU_BUFFER
                (DOC_DOCU_ACCU_BUFFER_ID
               , DOC_DOCUMENT_ID
               , C_DOCUMENT_STATUS
               , DIC_GAUGE_TYPE_DOC_ID
               , PAC_THIRD_ID
               , DAB_SIGN
               , DMT_DATE_DOCUMENT
               , FOO_DOCUMENT_TOTAL_AMOUNT
               , FOO_TOTAL_VAT_AMOUNT
                )
      select INIT_ID_SEQ.nextval
           , DOC_DOCUMENT_ID
           , C_DOCUMENT_STATUS
           , DIC_GAUGE_TYPE_DOC_ID
           , PAC_THIRD_ID
           , -1
           , DMT_DATE_DOCUMENT
           , :old.FOO_DOCUMENT_TOT_AMOUNT_B
           , :old.FOO_TOT_VAT_AMOUNT_B
        from DOC_DOCUMENT
       where DOC_DOCUMENT_ID = :old.DOC_FOOT_ID;
  end if;
-- Si on passe dans cette exception, cela signifie que la mise à jour est faite à
-- partir du curseur DOC_DOC_BU2
exception
  when ex.TABLE_MUTATING then
    null;
end DOC_FOO_BD_DOCU_ACCU;

ALTER TRIGGER "C_ITX"."DOC_FOO_BD_DOCU_ACCU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_FOO_BI_DENORM"
  before insert
  on DOC_FOOT
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des champs dénormalisés de DOC_FOOT
* @author Fabrice Perotto
* @version 2003
*/
begin
  select PAC_THIRD_ID
       , PAC_THIRD_ACI_ID
       , PAC_THIRD_DELIVERY_ID
       , PAC_THIRD_TARIFF_ID
       , PAC_THIRD_VAT_ID
       , PAC_THIRD_CDA_ID
    into :new.PAC_THIRD_ID
       , :new.PAC_THIRD_ACI_ID
       , :new.PAC_THIRD_DELIVERY_ID
       , :new.PAC_THIRD_TARIFF_ID
       , :new.PAC_THIRD_VAT_ID
       , :new.PAC_THIRD_CDA_ID
    from DOC_DOCUMENT
   where DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID;
end DOC_FOO_BI_DENORM;

ALTER TRIGGER "C_ITX"."DOC_FOO_BI_DENORM" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_FOO_BI_DOCU_ACCU"
before insert
on DOC_FOOT
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*    Mise à jour des totalisateurs de document
* @author Fabrice Perotto
* @version DEVELOP
*/


declare

  -- curseur sur les totaux du pied de document
  CURSOR DOC_VALUES_CURSOR(doc_id number) IS
  SELECT DOC_DOCUMENT_ID,
         DMT_DATE_DOCUMENT,
         DIC_GAUGE_TYPE_DOC_ID,
         C_DOCUMENT_STATUS,
         PAC_THIRD_ID
    FROM DOC_DOCUMENT
   WHERE DOC_DOCUMENT_ID = doc_id;

  doc_values_tuple doc_values_cursor%rowtype;
  doc_id DOC_FOOT.DOC_DOCUMENT_ID%type;

begin

  -- exception si l'id du document n'existe pas
  -- afin de remplacer la contrainte
  select DOC_DOCUMENT_ID into doc_id
  from DOC_DOCUMENT
  where DOC_DOCUMENT_ID = :NEW.DOC_DOCUMENT_ID;

  -- exception si l'id du pied n'existe pas comme ID du document
  -- afin de remplacer la contrainte
  select DOC_DOCUMENT_ID into doc_id
  from DOC_DOCUMENT
  where DOC_DOCUMENT_ID = :NEW.DOC_FOOT_ID;

  if :NEW.DOC_DOCUMENT_ID <> :NEW.DOC_FOOT_ID then
    raise_application_error(-20017,'PCS - DOC_DOCUMENT_ID and DOC_FOOT_ID must be identical on DOC_FOOT');
  end if;

  -- pas de mise à jour des totalisateurs (possible uniquement par recalcul global)
  if PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '0' then
    NULL;
  -- mise à jour instantannée des totalisateurs de position
  elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '1' then

    -- recherche des montants du document
    open DOC_VALUES_CURSOR(:NEW.DOC_DOCUMENT_ID);
    fetch DOC_VALUES_CURSOR into doc_values_tuple;

    if DOC_VALUES_CURSOR%found then

      -- mise à jour des totalisateurs de document
      -- Ajout des nouvelles valeurs
      DOC_ACCUMULATOR.DOC_TOTAL_DOCUMENT(doc_values_tuple.DOC_DOCUMENT_ID,
                                         doc_values_tuple.DMT_DATE_DOCUMENT,
                                         doc_values_tuple.DIC_GAUGE_TYPE_DOC_ID,
                                         doc_values_tuple.C_DOCUMENT_STATUS,
                                         doc_values_tuple.PAC_THIRD_ID,
                                         :NEW.FOO_DOCUMENT_TOT_AMOUNT_B,
                                         :NEW.FOO_TOT_VAT_AMOUNT_B,
                                         1,
                                         0);

    end if;

    close DOC_VALUES_CURSOR;

  -- insertion dans le buffer des totalisateurs de position (maj différée)
  elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '2' then

    INSERT INTO DOC_DOCU_ACCU_BUFFER(
      DOC_DOCU_ACCU_BUFFER_ID,
      DOC_DOCUMENT_ID,
      C_DOCUMENT_STATUS,
      DIC_GAUGE_TYPE_DOC_ID,
      PAC_THIRD_ID,
      DAB_SIGN,
      DMT_DATE_DOCUMENT,
      FOO_DOCUMENT_TOTAL_AMOUNT,
      FOO_TOTAL_VAT_AMOUNT)
    SELECT
      INIT_ID_SEQ.NEXTVAL,
      DOC_DOCUMENT_ID,
      C_DOCUMENT_STATUS,
      DIC_GAUGE_TYPE_DOC_ID,
      PAC_THIRD_ID,
      1,
      DMT_DATE_DOCUMENT,
      :NEW.FOO_DOCUMENT_TOT_AMOUNT_B,
      :NEW.FOO_TOT_VAT_AMOUNT_B
    FROM DOC_DOCUMENT
    WHERE DOC_DOCUMENT_ID = :NEW.DOC_FOOT_ID;

  end if;

  exception
    when NO_DATA_FOUND then
      raise_application_error(-20014,'PCS - Value of DOC_FOOT_ID or DOC_DOCUMENT_ID does not exist in table DOC_DOCUMENT');

end DOC_FOO_BI_DOCU_ACCU;


ALTER TRIGGER "C_ITX"."DOC_FOO_BI_DOCU_ACCU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_FOO_BIU_BVR_REF"
  before insert or update of "FOO_REF_BVR_NUMBER"
  on DOC_FOOT
  referencing old as old new as new
  for each row
/**
* Description
*    Suppression des espaces dans la référence BVR en entrée
* @created DSA 02.06.2004
* @version 2003
*/
declare
  strCleanRef DOC_FOOT.FOO_REF_BVR_NUMBER%type;
begin
  strCleanRef              := :new.FOO_REF_BVR_NUMBER;
  strCleanRef              := replace(strCleanRef, ' ', '');
  :new.FOO_REF_BVR_NUMBER  := strCleanRef;

  update DOC_DOCUMENT
     set DMT_REDO_PAYMENT_BVR = 1
   where DOC_DOCUMENT_ID = :new.DOC_FOOT_ID;
end DOC_FOO_BIU_BVR_REF;


ALTER TRIGGER "C_ITX"."DOC_FOO_BIU_BVR_REF" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_FOO_BIU_CURR_RISK_BALANCE"
  before insert or update of "GAL_CURRENCY_RISK_VIRTUAL_ID", "FOO_CURR_RISK_BAL_POS_AMOUNT"
  on DOC_FOOT
  referencing old as old new as new
  for each row
/**
* Description
*    Maj du montant de couverture consommé par le document, dans le cas particulier ou plus une seule position est présente dans le document, suite à effacement
* @created    hmo 15.03.2014
* @lastupdate
*/
declare
  lCountPosition number;
  lDocDocumentID doc_document.doc_document_id%type;
begin
  lDocDocumentID  := nvl(:new.DOC_FOOT_ID, :old.DOC_FOOT_ID);

  select count(DOC_POSITION_ID)
    into lCountPosition
    from DOC_POSITION
   where DOC_DOCUMENT_ID = lDocDocumentID;

  if lCountPosition = 0 then
    :new.FOO_CURR_RISK_BAL_POS_AMOUNT  := 0;
  end if;
end DOC_FOO_BIU_CURR_RISK_BALANCE;

ALTER TRIGGER "C_ITX"."DOC_FOO_BIU_CURR_RISK_BALANCE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_FOO_BIU_LOCAL_CURRENCY"
before insert or update
of FOO_MODIFY_RATE,
   FOO_PAID_AMOUNT
on DOC_FOOT
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*    Mise à jour des montants de paiement direct en monnaie de base
* @author Fabrice Perotto
* @version DEVELOP
*/


declare
  euro_rate DOC_DOCUMENT.DMT_RATE_OF_EXCHANGE%TYPE;
  curr_id DOC_DOCUMENT.ACS_FINANCIAL_CURRENCY_ID%TYPE;
  local_curr_id DOC_DOCUMENT.ACS_FINANCIAL_CURRENCY_ID%TYPE;
  document_date DOC_DOCUMENT.DMT_DATE_DOCUMENT%TYPE;
  rate_of_exchange DOC_DOCUMENT.DMT_RATE_OF_EXCHANGE%TYPE;
  base_price DOC_DOCUMENT.DMT_BASE_PRICE%TYPE;
begin

  -- recherche des informations nécessaires à la conversion dans la table DOC_DOCUMENT
  select
    ACS_FINANCIAL_CURRENCY_ID,
    DMT_DATE_DOCUMENT,
    DMT_RATE_OF_EXCHANGE,
    DMT_BASE_PRICE
  into
    curr_id,
    document_date,
    rate_of_exchange,
    base_price
  from
    DOC_DOCUMENT
  where DOC_DOCUMENT_ID = :NEW.DOC_FOOT_ID;

  local_curr_id := ACS_FUNCTION.GetLocalCurrencyId;

  if local_curr_id <> curr_id then
    ACS_FUNCTION.ConvertAmount(NVL(:NEW.FOO_PAID_AMOUNT,0),
                               curr_id,
                               local_curr_id,
                               document_date,
                               rate_of_exchange,
                               base_price,
                               0,
                               :NEW.FOO_PAID_AMOUNT_EUR,
                               :NEW.FOO_PAID_AMOUNT_B);
  else
    :NEW.FOO_PAID_AMOUNT_B := :NEW.FOO_PAID_AMOUNT;
  end if;

  :NEW.FOO_MODIFY_RATE := 0;

end DOC_FOO_BIU_LOCAL_CURRENCY;


ALTER TRIGGER "C_ITX"."DOC_FOO_BIU_LOCAL_CURRENCY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_FOO_BU_DOCU_ACCU"
before update
of FOO_DOCUMENT_TOTAL_AMOUNT,
   FOO_TOTAL_VAT_AMOUNT,
   DOC_DOCUMENT_ID,
   DOC_FOOT_ID
on DOC_FOOT
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*    Mise à jour des totalisateurs de document
* @author Fabrice Perotto
* @version DEVELOP
*/


declare

  -- curseur sur les totaux du pied de document
  CURSOR DOC_VALUES_CURSOR(doc_id number) IS
  SELECT DOC_DOCUMENT_ID,
         DMT_DATE_DOCUMENT,
         DIC_GAUGE_TYPE_DOC_ID,
         C_DOCUMENT_STATUS,
         PAC_THIRD_ID
    FROM DOC_DOCUMENT
   WHERE DOC_DOCUMENT_ID = doc_id;

  doc_values_tuple doc_values_cursor%rowtype;

begin

  -- Interdiction de modifier l'ID du pied
  if (:OLD.DOC_FOOT_ID <> :NEW.DOC_FOOT_ID) then
    raise_application_error(-20010,'PCS - Cannot change the value of DOC_FOOT_ID in DOC_FOOT');
  end if;

  -- Interdiction de modifier l'ID du document
  if (:OLD.DOC_DOCUMENT_ID <> :NEW.DOC_DOCUMENT_ID) then
    raise_application_error(-20013,'PCS - Cannot change the value of DOC_DOCUMENT_ID in DOC_FOOT');
  end if;

  -- pas de mise à jour des totalisateurs (possible uniquement par recalcul global)
  if PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '0' then
    NULL;
  -- mise à jour instantannée des totalisateurs de position
  elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '1' then

    -- recherche des montants du document
    open DOC_VALUES_CURSOR(:NEW.DOC_DOCUMENT_ID);
    fetch DOC_VALUES_CURSOR into doc_values_tuple;

    if DOC_VALUES_CURSOR%found then

      -- mise à jour des totalisateurs de document

      -- Retrait des anciennes valeurs
      DOC_ACCUMULATOR.DOC_TOTAL_DOCUMENT(doc_values_tuple.DOC_DOCUMENT_ID,
                                         doc_values_tuple.DMT_DATE_DOCUMENT,
                                         doc_values_tuple.DIC_GAUGE_TYPE_DOC_ID,
                                         doc_values_tuple.C_DOCUMENT_STATUS,
                                         doc_values_tuple.PAC_THIRD_ID,
                                         :OLD.FOO_DOCUMENT_TOT_AMOUNT_B,
                                         :OLD.FOO_TOT_VAT_AMOUNT_B,
                                         -1,
                                         0);

      -- Ajout des nouvelles valeurs
      DOC_ACCUMULATOR.DOC_TOTAL_DOCUMENT(doc_values_tuple.DOC_DOCUMENT_ID,
                                         doc_values_tuple.DMT_DATE_DOCUMENT,
                                         doc_values_tuple.DIC_GAUGE_TYPE_DOC_ID,
                                         doc_values_tuple.C_DOCUMENT_STATUS,
                                         doc_values_tuple.PAC_THIRD_ID,
                                         :NEW.FOO_DOCUMENT_TOT_AMOUNT_B,
                                         :NEW.FOO_TOT_VAT_AMOUNT_B,
                                         1,
                                         0);

    end if;

    close DOC_VALUES_CURSOR;

  -- insertion dans le buffer des totalisateurs de position (maj différée)
  elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '2' then

    -- retrait des anciennes valeurs
    INSERT INTO DOC_DOCU_ACCU_BUFFER(
      DOC_DOCU_ACCU_BUFFER_ID,
      DOC_DOCUMENT_ID,
      C_DOCUMENT_STATUS,
      DIC_GAUGE_TYPE_DOC_ID,
      PAC_THIRD_ID,
      DAB_SIGN,
      DMT_DATE_DOCUMENT,
      FOO_DOCUMENT_TOTAL_AMOUNT,
      FOO_TOTAL_VAT_AMOUNT)
    SELECT
      INIT_ID_SEQ.NEXTVAL,
      DOC_DOCUMENT_ID,
      C_DOCUMENT_STATUS,
      DIC_GAUGE_TYPE_DOC_ID,
      PAC_THIRD_ID,
      -1,
      DMT_DATE_DOCUMENT,
      :OLD.FOO_DOCUMENT_TOT_AMOUNT_B,
      :OLD.FOO_TOT_VAT_AMOUNT_B
    FROM DOC_DOCUMENT
    WHERE DOC_DOCUMENT_ID = :OLD.DOC_FOOT_ID;

    -- ajout des nouvelles valeurs
    INSERT INTO DOC_DOCU_ACCU_BUFFER(
      DOC_DOCU_ACCU_BUFFER_ID,
      DOC_DOCUMENT_ID,
      C_DOCUMENT_STATUS,
      DIC_GAUGE_TYPE_DOC_ID,
      PAC_THIRD_ID,
      DAB_SIGN,
      DMT_DATE_DOCUMENT,
      FOO_DOCUMENT_TOTAL_AMOUNT,
      FOO_TOTAL_VAT_AMOUNT)
    SELECT
      INIT_ID_SEQ.NEXTVAL,
      DOC_DOCUMENT_ID,
      C_DOCUMENT_STATUS,
      DIC_GAUGE_TYPE_DOC_ID,
      PAC_THIRD_ID,
      1,
      DMT_DATE_DOCUMENT,
      :NEW.FOO_DOCUMENT_TOT_AMOUNT_B,
      :NEW.FOO_TOT_VAT_AMOUNT_B
    FROM DOC_DOCUMENT
    WHERE DOC_DOCUMENT_ID = :OLD.DOC_FOOT_ID;

  end if;

end DOC_FOO_BU_DOCU_ACCU;


ALTER TRIGGER "C_ITX"."DOC_FOO_BU_DOCU_ACCU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_FOP_BI_AMOUNTS"
  before insert
  on DOC_FOOT_PAYMENT
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour de la table des transactions de paiement comptant
* @author VJ
* @created 26.07.2004
* @created 24.07.2008
* @version 2003
* @lastUpdate
*/
declare
begin

  -- Garantit une valeur non nulle pour tous les champs numériques
  :new.FOP_EXCHANGE_RATE           := nvl(:new.FOP_EXCHANGE_RATE, 1);
  :new.FOP_BASE_PRICE              := nvl(:new.FOP_BASE_PRICE, 1);
  :new.FOP_PAID_AMOUNT             := nvl(:new.FOP_PAID_AMOUNT, 0);
  :new.FOP_PAID_AMOUNT_MD          := nvl(:new.FOP_PAID_AMOUNT_MD, 0);
  :new.FOP_PAID_AMOUNT_MB          := nvl(:new.FOP_PAID_AMOUNT_MB, 0);
  :new.FOP_RECEIVED_AMOUNT         := nvl(:new.FOP_RECEIVED_AMOUNT, 0);
  :new.FOP_RECEIVED_AMOUNT_MD      := nvl(:new.FOP_RECEIVED_AMOUNT_MD, 0);
  :new.FOP_RECEIVED_AMOUNT_MB      := nvl(:new.FOP_RECEIVED_AMOUNT_MB, 0);
  :new.FOP_RETURNED_AMOUNT         := nvl(:new.FOP_RETURNED_AMOUNT, 0);
  :new.FOP_RETURNED_AMOUNT_MD      := nvl(:new.FOP_RETURNED_AMOUNT_MD, 0);
  :new.FOP_RETURNED_AMOUNT_MB      := nvl(:new.FOP_RETURNED_AMOUNT_MB, 0);
  :new.FOP_DISCOUNT_AMOUNT         := nvl(:new.FOP_DISCOUNT_AMOUNT, 0);
  :new.FOP_DISCOUNT_AMOUNT_MD      := nvl(:new.FOP_DISCOUNT_AMOUNT_MD, 0);
  :new.FOP_DISCOUNT_AMOUNT_MB      := nvl(:new.FOP_DISCOUNT_AMOUNT_MB, 0);
  :new.FOP_DEDUCTION_AMOUNT        := nvl(:new.FOP_DEDUCTION_AMOUNT, 0);
  :new.FOP_DEDUCTION_AMOUNT_MD     := nvl(:new.FOP_DEDUCTION_AMOUNT_MD, 0);
  :new.FOP_DEDUCTION_AMOUNT_MB     := nvl(:new.FOP_DEDUCTION_AMOUNT_MB, 0);
  :new.FOP_PAID_BALANCED_AMOUNT    := nvl(:new.FOP_PAID_BALANCED_AMOUNT, 0);
  :new.FOP_PAID_BALANCED_AMOUNT_MD := nvl(:new.FOP_PAID_BALANCED_AMOUNT_MD, 0);
  :new.FOP_PAID_BALANCED_AMOUNT_MB := nvl(:new.FOP_PAID_BALANCED_AMOUNT_MB, 0);

end DOC_FOP_BI_AMOUNTS;

ALTER TRIGGER "C_ITX"."DOC_FOP_BI_AMOUNTS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_GAC_BD_GAUGE_COPY"
  before delete
  on DOC_GAUGE_COPY
  referencing old as old new as new
  for each row
/**
* Description
*    Contrôle que le gabarit Copiable ne figure pas dans les détails de position
* @author NGV
* @created 10.10.2003
* @version 2003
* @lastUpdate 10.10.2003
*/
declare
  intResult integer;
begin
  begin
    select 0
      into intResult
      from DOC_POSITION_DETAIL
     where DOC_GAUGE_COPY_ID = :old.DOC_GAUGE_COPY_ID
       and rownum = 1;
  exception
    when no_data_found then
      intResult  := 1;
  end;

  if intResult = 0 then
    raise_application_error
      (-20000
     , PCS.PC_FUNCTIONS.TranslateWord
                                    (SUBSTR('PCS - Effacement impossible, un lien de copie de document existe pour ce gabarit!',1,80))
      );
    -- La longueur du champ pcs.pc_wordr.workeycontenant la clé de recherche d'un texte est de 80 caractères
    -- et voilà le pourquoi de l'utilisation du SUBSTR()
  end if;
end DOC_GAC_BD_GAUGE_COPY;

ALTER TRIGGER "C_ITX"."DOC_GAC_BD_GAUGE_COPY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_GAC_BI_DENORM"
  before insert
  on DOC_GAUGE_COPY
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des champs dénormalisés de DOC_GAUGE_COPY
* @author NGV
* @lastupdate
* @version 2011
*/
begin
  select DOC_GAUGE_FLOW_ID
    into :new.DOC_GAUGE_FLOW_ID
    from DOC_GAUGE_FLOW_DOCUM
   where DOC_GAUGE_FLOW_DOCUM_ID = :new.DOC_GAUGE_FLOW_DOCUM_ID;
end DOC_GAC_BI_DENORM;

ALTER TRIGGER "C_ITX"."DOC_GAC_BI_DENORM" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_GAF_BU_FLOW_DOCUM"
  before update of DOC_GAUGE_ID
  on DOC_GAUGE_FLOW_DOCUM
  referencing old as old new as new
  for each row
/**
* @author rf
* @created 27.03.2007
* @version 2003
*/
begin

  update DOC_GAUGE_RECEIPT
     set DOC_DOC_GAUGE_ID = :new.DOC_GAUGE_ID
   where DOC_GAUGE_FLOW_DOCUM_ID = :old.DOC_GAUGE_FLOW_DOCUM_ID
     and DOC_DOC_GAUGE_ID = :old.DOC_GAUGE_ID;

  update DOC_GAUGE_COPY
     set DOC_DOC_GAUGE_ID = :new.DOC_GAUGE_ID
   where DOC_GAUGE_FLOW_DOCUM_ID = :old.DOC_GAUGE_FLOW_DOCUM_ID
     and DOC_DOC_GAUGE_ID = :old.DOC_GAUGE_ID;

end DOC_GAF_BU_FLOW_DOCUM;

ALTER TRIGGER "C_ITX"."DOC_GAF_BU_FLOW_DOCUM" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_GAP_BD_CONSTRAINTS"
  before delete
  on DOC_GAUGE_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Vérifie que le gabarit position ne soit pas utilisé dans les positions de document
* @created fp 21.04.2008
*/
declare
  vCount pls_integer;
begin
  select count(*) into vCount from DOC_POSITION where DOC_GAUGE_POSITION_ID = :OLD.DOC_GAUGE_POSITION_ID;
  if vCount > 0 then
    ra('PCS - Child records found in DOC_POSITION !');
  end if;
end DOC_GAP_BD_CONSTRAINTS;

ALTER TRIGGER "C_ITX"."DOC_GAP_BD_CONSTRAINTS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_GAP_BI_WEIGHT"
  before insert
  on DOC_GAUGE_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour du poids
* @author Fabrice Perotto
* @version 2003
* @lastUpdate
*/
begin
  select gas.gas_weight
    into :new.gap_weight
    from doc_gauge_structured gas
   where gas.doc_gauge_id = :new.doc_gauge_id;
end DOC_GAP_BI_WEIGHT;

ALTER TRIGGER "C_ITX"."DOC_GAP_BI_WEIGHT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_GAR_BD_GAUGE_RECEIPT"
  before delete
  on DOC_GAUGE_RECEIPT
  referencing old as old new as new
  for each row
/**
* Description
*    Contrôle que le gabarit Recptionnable ne figure pas dans les détails de position
* @author NGV
* @created 10.10.2003
* @version 2003
* @lastUpdate 10.10.2003
*/
declare
  intResult integer;
begin
  begin
    select 0
      into intResult
      from DOC_POSITION_DETAIL
     where DOC_GAUGE_RECEIPT_ID = :old.DOC_GAUGE_RECEIPT_ID
       and rownum = 1;
  exception
    when no_data_found then
      intResult  := 1;
  end;

  if intResult = 0 then
    raise_application_error
      (-20000
     , PCS.PC_FUNCTIONS.TranslateWord
                                 (SUBSTR('PCS - Effacement impossible, un lien de décharge de document existe pour ce gabarit!',1,80))
      );
    -- La longueur du champ pcs.pc_wordr.workeycontenant la clé de recherche d'un texte est de 80 caractères
    -- et voilà le pourquoi de l'utilisation du SUBSTR()
  end if;
end DOC_GAR_BD_GAUGE_RECEIPT;

ALTER TRIGGER "C_ITX"."DOC_GAR_BD_GAUGE_RECEIPT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_GAR_BI_DENORM"
  before insert
  on DOC_GAUGE_RECEIPT
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des champs dénormalisés de DOC_GAUGE_RECEIPT
* @author NGV
* @lastupdate
* @version 2011
*/
begin
  select DOC_GAUGE_FLOW_ID
    into :new.DOC_GAUGE_FLOW_ID
    from DOC_GAUGE_FLOW_DOCUM
   where DOC_GAUGE_FLOW_DOCUM_ID = :new.DOC_GAUGE_FLOW_DOCUM_ID;
end DOC_GAR_BI_DENORM;

ALTER TRIGGER "C_ITX"."DOC_GAR_BI_DENORM" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_GAS_AU_WEIGHT"
  before update of GAS_WEIGHT
  on DOC_GAUGE_STRUCTURED
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour du poids
* @author Fabrice Perotto
* @version 2003
* @lastUpdate
*/
begin
  update doc_gauge_position
     set gap_weight = :new.gas_weight
       , a_datemod = sysdate
       , a_idmod = PCS.PC_I_LIB_SESSION.GetUserIni
   where doc_gauge_id = :new.doc_gauge_id;
end DOC_GAS_AU_WEIGHT;

ALTER TRIGGER "C_ITX"."DOC_GAS_AU_WEIGHT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_GAS_BIU_BUDGET_CONTROL"
  before insert or update of GAS_BUDGET_CONTROL_STATUS_01, GAS_BUDGET_CONTROL_STATUS_02, GAS_BUDGET_CONTROL_STATUS_03, GAS_BUDGET_CONTROL_STATUS_04
  on DOC_GAUGE_STRUCTURED
  referencing old as old new as new
  for each row
/**
* Description
*     Mise à jour des status actifs pour le contrôle de budget
* @author Joffroy Christen
* @version 2003
* @created 12.06.2006
* @lastUpdate
*/
begin
  select decode(:new.GAS_BUDGET_CONTROL_STATUS_01, 1, '01,', '') ||
         decode(:new.GAS_BUDGET_CONTROL_STATUS_02, 1, '02,', '') ||
         decode(:new.GAS_BUDGET_CONTROL_STATUS_03, 1, '03,', '') ||
         decode(:new.GAS_BUDGET_CONTROL_STATUS_04, 1, '04,', '')
    into :new.GAS_DOC_STATUS_BUDGET_CONTROL
    from dual;

  if length(:new.GAS_DOC_STATUS_BUDGET_CONTROL) > 0 then
    select substr(:new.GAS_DOC_STATUS_BUDGET_CONTROL, 1, length(:new.GAS_DOC_STATUS_BUDGET_CONTROL) - 1)
      into :new.GAS_DOC_STATUS_BUDGET_CONTROL
      from dual;
  end if;
end DOC_GAS_BIU_BUDGET_CONTROL;

ALTER TRIGGER "C_ITX"."DOC_GAS_BIU_BUDGET_CONTROL" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_GAS_BIU_CREDIT_LIMIT"
  before insert or update of GAS_CREDIT_LIMIT_STATUS_01, GAS_CREDIT_LIMIT_STATUS_02, GAS_CREDIT_LIMIT_STATUS_03, GAS_CREDIT_LIMIT_STATUS_04
  on DOC_GAUGE_STRUCTURED
  referencing old as old new as new
  for each row
/**
* Description
*     Mise à jour des status actifs pour la limite de crédit
* @author Fabrice Perotto
* @version 2003
* @lastUpdate
*/
begin
  select decode(:new.GAS_CREDIT_LIMIT_STATUS_01, 1, '01', '') ||
         decode(:new.GAS_CREDIT_LIMIT_STATUS_02, 1, '02', '') ||
         decode(:new.GAS_CREDIT_LIMIT_STATUS_03, 1, '03', '') ||
         decode(:new.GAS_CREDIT_LIMIT_STATUS_04, 1, '04', '')
    into :new.GAS_DOC_STATUS_CREDIT_LIMIT
    from dual;
end DOC_GAS_BIU_CREDIT_LIMIT;

ALTER TRIGGER "C_ITX"."DOC_GAS_BIU_CREDIT_LIMIT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_GCP_BIU_CREATE_MODE"
  before insert or update
  on DOC_GAUGE_CREATE_PROC
  referencing old as old new as new
  for each row
begin
  -- On vérifie que le mode de création soit toujours renseigné selon le code DOC, POS ou PDE
  -- Mode de création Document
  if (:new.C_GROUP_CREATE_MODE = 'DOC') then
    if (:new.C_DOC_CREATE_MODE is null) then
      RAISE_APPLICATION_ERROR
        (-20000
       , PCS.PC_FUNCTIONS.TranslateWord
                                     ('Procédures d''initialisation - Le mode de création du document est obligatoire !')
        );
    end if;
  -- Mode de création Position
  elsif(:new.C_GROUP_CREATE_MODE = 'POS') then
    if (:new.C_POS_CREATE_MODE is null) then
      RAISE_APPLICATION_ERROR
        (-20000
       , PCS.PC_FUNCTIONS.TranslateWord
                                  ('Procédures d''initialisation - Le mode de création de la position est obligatoire !')
        );
    end if;
  -- Mode de création Détail
  elsif(:new.C_GROUP_CREATE_MODE = 'PDE') then
    if (:new.C_PDE_CREATE_MODE is null) then
      RAISE_APPLICATION_ERROR
        (-20000
       , PCS.PC_FUNCTIONS.TranslateWord
                                       ('Procédures d''initialisation - Le mode de création du détail est obligatoire !')
        );
    end if;
  end if;
end DOC_GCP_BIU_CREATE_MODE;

ALTER TRIGGER "C_ITX"."DOC_GCP_BIU_CREATE_MODE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_IED_BIU_LOCAL_CURRENCY"
  before insert or update of IED_MODIFY_RATE
                           , IED_NET_VALUE_EXCL
                           , IED_NET_VALUE_INCL
                           , IED_RET_DEPOSIT_NET_EXCL
                           , IED_RET_DEPOSIT_NET_INCL
  on DOC_INVOICE_EXPIRY_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Maj des montants en monnaie locale
* @created FPE 17.04.2008
* @lastUpdate
*/
declare
  vCurrencyId      DOC_DOCUMENT.ACS_FINANCIAL_CURRENCY_ID%type;
  vLocalCurrencyId DOC_DOCUMENT.ACS_FINANCIAL_CURRENCY_ID%type   := ACS_FUNCTION.GetLocalCurrencyId;
  vDocumentDate    DOC_DOCUMENT.DMT_DATE_DOCUMENT%type;
  vRateOfExchange  DOC_DOCUMENT.DMT_RATE_OF_EXCHANGE%type;
  vBasePrice       DOC_DOCUMENT.DMT_BASE_PRICE%type;
  vTmpAmountEur    DOC_POSITION.POS_NET_VALUE_EXCL_E%type;
begin
  -- recherche des informations nécessaires à la conversion dans la table DOC_DOCUMENT
  select DMT.ACS_FINANCIAL_CURRENCY_ID
       , DMT.DMT_DATE_DOCUMENT
       , DMT.DMT_RATE_OF_EXCHANGE
       , DMT.DMT_BASE_PRICE
    into vCurrencyId
       , vDocumentDate
       , vRateOfExchange
       , vBasePrice
    from DOC_INVOICE_EXPIRY INX,
         DOC_DOCUMENT DMT
   where INX.DOC_INVOICE_EXPIRY_ID = :new.DOC_INVOICE_EXPIRY_ID
     and DMT.DOC_DOCUMENT_ID = INX.DOC_DOCUMENT_ID;

  -- Monnaie base =  Monnaie Document
  if (vLocalCurrencyId = vCurrencyId) then   -- Cas n° 1 -> Ex : CHF - CHF
    :new.IED_NET_VALUE_EXCL_B        := :new.IED_NET_VALUE_EXCL;
    :new.IED_NET_VALUE_INCL_B        := :new.IED_NET_VALUE_INCL;
    :new.IED_RET_DEPOSIT_NET_EXCL_B  := :new.IED_RET_DEPOSIT_NET_EXCL;
    :new.IED_RET_DEPOSIT_NET_INCL_B  := :new.IED_RET_DEPOSIT_NET_INCL;
  -- Monnaie base <> Monnaie Document
  elsif(vCurrencyId <> vLocalCurrencyId) then   -- Cas n° 2 -> Ex : CHF - EUR
    -- Montant net HT
    ACS_FUNCTION.ConvertAmount(nvl(:new.IED_NET_VALUE_EXCL, 0)
                             , vCurrencyId
                             , vLocalCurrencyId
                             , vDocumentDate
                             , vRateOfExchange
                             , vBasePrice
                             , 0
                             , vTmpAmountEur
                             , :new.IED_NET_VALUE_EXCL_B
                              );
    -- Montant net TTC
    ACS_FUNCTION.ConvertAmount(nvl(:new.IED_NET_VALUE_INCL, 0)
                             , vCurrencyId
                             , vLocalCurrencyId
                             , vDocumentDate
                             , vRateOfExchange
                             , vBasePrice
                             , 0
                             , vTmpAmountEur
                             , :new.IED_NET_VALUE_INCL_B
                              );
    -- Montant de reprise d'acompte net HT
    ACS_FUNCTION.ConvertAmount(nvl(:new.IED_RET_DEPOSIT_NET_EXCL, 0)
                             , vCurrencyId
                             , vLocalCurrencyId
                             , vDocumentDate
                             , vRateOfExchange
                             , vBasePrice
                             , 0
                             , vTmpAmountEur
                             , :new.IED_RET_DEPOSIT_NET_EXCL_B
                              );
    -- Montant de reprise d'acompte net TTC
    ACS_FUNCTION.ConvertAmount(nvl(:new.IED_RET_DEPOSIT_NET_INCL, 0)
                             , vCurrencyId
                             , vLocalCurrencyId
                             , vDocumentDate
                             , vRateOfExchange
                             , vBasePrice
                             , 0
                             , vTmpAmountEur
                             , :new.IED_RET_DEPOSIT_NET_INCL_B
                              );
  end if;

  -- flag de modification du taux de change remis à 0
  :new.IED_MODIFY_RATE  := 0;
end DOC_IED_BIU_LOCAL_CURRENCY;

ALTER TRIGGER "C_ITX"."DOC_IED_BIU_LOCAL_CURRENCY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_INTERFACE_BIU_RECORD"
  before insert or update of DOC_GAUGE_ID
  on DOC_INTERFACE
  referencing old as old new as new
  for each row
/**
* Description
*    création du dossier dans l'interface
* @created SK
* @lastupdate fp 27.10.2005
* @version 2003
* 20030228 : RR : On prend en priorité le gabarit (DOC_GAUGE définit dans l'entête)
*/
declare
  CreatedRecordId       DOC_INTERFACE.DOC_RECORD_ID%type;
  DOC_CART_CONFIG_GAUGE DOC_GAUGE.GAU_DESCRIBE%type;
begin
  if (inserting and :new.C_DOC_INTERFACE_ORIGIN not in('301')) or updating then
    if (:new.DOC_GAUGE_ID is not null) then
      select GAU_DESCRIBE
        into DOC_CART_CONFIG_GAUGE
        from DOC_GAUGE
       where DOC_GAUGE.DOC_GAUGE_ID = :new.DOC_GAUGE_ID;
    else
      DOC_CART_CONFIG_GAUGE  := PCS.PC_CONFIG.GetConfig('DOC_CART_CONFIG_GAUGE');
    end if;

    if (:new.DOC_RECORD_ID is null) then
      CreatedRecordID  :=
        DOC_RECORD_MANAGEMENT.CreateRecord(0
                                         , DOC_CART_CONFIG_GAUGE
                                         , :new.DOC_RECORD_ID
                                         , :new.PAC_THIRD_ID
                                         , :new.DOI_NUMBER
                                          );

      if CreatedRecordId <> -1 then
        :new.DOC_RECORD_ID  := CreatedRecordId;
      end if;
    end if;
  end if;
end DOC_INTERFACE_BIU_RECORD;

ALTER TRIGGER "C_ITX"."DOC_INTERFACE_BIU_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_INX_BIUD_ISSUING_DATE"
  before insert or update of INX_ISSUING_DATE or delete
  on DOC_INVOICE_EXPIRY
  referencing old as old new as new
  for each row
/**
* Description
*    Maj des montants en monnaie locale
* @created AGA 21.08.2013
* @lastUpdate
*/
declare
  lDOC_INVOICE_EXPIRY_ID DOC_INVOICE_EXPIRY.DOC_INVOICE_EXPIRY_ID%type;
  lTableName             PCS.PC_TABLE.TABNAME%type;
  lFieldName             PCS.PC_FLDSC.FLDNAME%type;
  lObjName               PCS.PC_OBJECT.OBJ_NAME%type;
  lIdHisto               COM_UPDATE_HISTO.COM_UPDATE_HISTO_ID%type;
  lCdUpdate              COM_UPDATE_HISTO.CUH_CDUPDATE%type;
  lOldValue              varchar2(4000);
  lNewValue              varchar2(4000);
begin
  lTableName              := 'DOC_INVOICE_EXPIRY';
  lFieldName              := 'INX_ISSUING_DATE';
  lObjName                := PCS.PC_I_LIB_SESSION.getobjectname;
  lDOC_INVOICE_EXPIRY_ID  := :new.DOC_INVOICE_EXPIRY_ID;

  if deleting then
    delete from COM_UPDATE_HISTO
          where CUH_NAME_TABLE = lTableName
            and CUH_ID_TABLE = :old.DOC_INVOICE_EXPIRY_ID;
  else
    select pcs.init_id_seq.nextval
      into lIdHisto
      from dual;

    if inserting then
      lOldValue  := null;
      lNewValue  := to_char(:new.INX_ISSUING_DATE, 'DD.MM.YYYY');
      lCdUpdate  := 'INS';
    elsif updating then
      lOldValue  := to_char(:old.INX_ISSUING_DATE, 'DD.MM.YYYY');
      lNewValue  := to_char(:new.INX_ISSUING_DATE, 'DD.MM.YYYY');
      lCdUpdate  := 'UPD';
    end if;

    insert into com_update_histo
                (com_update_histo_id
               , cuh_name_table
               , cuh_id_table
               , cuh_obj_name
               , cuh_cdupdate
               , cuh_name_field
               , cuh_old_value
               , cuh_new_value
               , a_datecre
               , a_idcre
                )
         values (lIdHisto
               , lTableName
               , lDOC_INVOICE_EXPIRY_ID
               , lObjName
               , lCdUpdate
               , lFieldName
               , lOldValue
               , lNewValue
               , sysdate
               , PCS.PC_I_LIB_SESSION.GetUserIni
                );
  end if;
end DOC_INX_BIUD_ISSUING_DATE;

ALTER TRIGGER "C_ITX"."DOC_INX_BIUD_ISSUING_DATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_INX_BIU_LOCAL_CURRENCY"
  before insert or update of INX_MODIFY_RATE
                           , INX_NET_VALUE_EXCL
                           , INX_NET_VALUE_INCL
                           , INX_RET_DEPOSIT_NET_EXCL
                           , INX_RET_DEPOSIT_NET_INCL
  on DOC_INVOICE_EXPIRY
  referencing old as old new as new
  for each row
/**
* Description
*    Maj des montants en monnaie locale
* @created FPE 16.04.2008
* @lastUpdate
*/
declare
  vCurrencyId      DOC_DOCUMENT.ACS_FINANCIAL_CURRENCY_ID%type;
  vLocalCurrencyId DOC_DOCUMENT.ACS_FINANCIAL_CURRENCY_ID%type   := ACS_FUNCTION.GetLocalCurrencyId;
  vDocumentDate    DOC_DOCUMENT.DMT_DATE_DOCUMENT%type;
  vRateOfExchange  DOC_DOCUMENT.DMT_RATE_OF_EXCHANGE%type;
  vBasePrice       DOC_DOCUMENT.DMT_BASE_PRICE%type;
  vTmpAmountEur    DOC_POSITION.POS_NET_VALUE_EXCL_E%type;
begin
  -- recherche des informations nécessaires à la conversion dans la table DOC_DOCUMENT
  select ACS_FINANCIAL_CURRENCY_ID
       , DMT_DATE_DOCUMENT
       , DMT_RATE_OF_EXCHANGE
       , DMT_BASE_PRICE
    into vCurrencyId
       , vDocumentDate
       , vRateOfExchange
       , vBasePrice
    from DOC_DOCUMENT
   where DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID;

  -- Monnaie base =  Monnaie Document
  if (vLocalCurrencyId = vCurrencyId) then   -- Cas n° 1 -> Ex : CHF - CHF
    :new.INX_NET_VALUE_EXCL_B        := :new.INX_NET_VALUE_EXCL;
    :new.INX_NET_VALUE_INCL_B        := :new.INX_NET_VALUE_INCL;
    :new.INX_RET_DEPOSIT_NET_EXCL_B  := :new.INX_RET_DEPOSIT_NET_EXCL;
    :new.INX_RET_DEPOSIT_NET_INCL_B  := :new.INX_RET_DEPOSIT_NET_INCL;
  -- Monnaie base <> Monnaie Document
  elsif(vCurrencyId <> vLocalCurrencyId) then   -- Cas n° 2 -> Ex : CHF - EUR
    -- Montant net HT
    ACS_FUNCTION.ConvertAmount(nvl(:new.INX_NET_VALUE_EXCL, 0)
                             , vCurrencyId
                             , vLocalCurrencyId
                             , vDocumentDate
                             , vRateOfExchange
                             , vBasePrice
                             , 0
                             , vTmpAmountEur
                             , :new.INX_NET_VALUE_EXCL_B
                              );
    -- Montant net TTC
    ACS_FUNCTION.ConvertAmount(nvl(:new.INX_NET_VALUE_INCL, 0)
                             , vCurrencyId
                             , vLocalCurrencyId
                             , vDocumentDate
                             , vRateOfExchange
                             , vBasePrice
                             , 0
                             , vTmpAmountEur
                             , :new.INX_NET_VALUE_INCL_B
                              );
    -- Montant de reprise d'acompte net HT
    ACS_FUNCTION.ConvertAmount(nvl(:new.INX_RET_DEPOSIT_NET_EXCL, 0)
                             , vCurrencyId
                             , vLocalCurrencyId
                             , vDocumentDate
                             , vRateOfExchange
                             , vBasePrice
                             , 0
                             , vTmpAmountEur
                             , :new.INX_RET_DEPOSIT_NET_EXCL_B
                              );
    -- Montant de reprise d'acompte net TTC
    ACS_FUNCTION.ConvertAmount(nvl(:new.INX_RET_DEPOSIT_NET_INCL, 0)
                             , vCurrencyId
                             , vLocalCurrencyId
                             , vDocumentDate
                             , vRateOfExchange
                             , vBasePrice
                             , 0
                             , vTmpAmountEur
                             , :new.INX_RET_DEPOSIT_NET_INCL_B
                              );
  end if;

  -- flag de modification du taux de change remis à 0
  :new.INX_MODIFY_RATE  := 0;
end DOC_INX_BIU_LOCAL_CURRENCY;

ALTER TRIGGER "C_ITX"."DOC_INX_BIU_LOCAL_CURRENCY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PAD_BIU_SET_KEY"
before insert or update
of PC_YEAR_WEEK_ID,
   GCO_GOOD_ID,
   C_DOC_POS_STATUS,
   C_GAUGE_TYPE,
   PAC_THIRD_ID,
   GCO_CHARACTERIZATION_ID,
   GCO_GCO_CHARACTERIZATION_ID,
   GCO2_GCO_CHARACTERIZATION_ID,
   GCO3_GCO_CHARACTERIZATION_ID,
   GCO4_GCO_CHARACTERIZATION_ID,
   PAC_CHARACTERIZATION_VALUE_1,
   PAC_CHARACTERIZATION_VALUE_2,
   PAC_CHARACTERIZATION_VALUE_3,
   PAC_CHARACTERIZATION_VALUE_4,
   PAC_CHARACTERIZATION_VALUE_5
on DOC_POSI_ACCUMULATOR
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*   Triggers de mise à jour d'un champ permettant une recherche optimisée --
*   sur la table des totalisateurs de position.                           --
* @author Antoine Gabus
* @version DEVELOP
*/


begin
  :NEW.PAC_ALLKEY := TO_CHAR(:NEW.PC_YEAR_WEEK_ID) || '¦' ||
                     TO_CHAR(:NEW.GCO_GOOD_ID) || '¦' ||
                     :NEW.C_DOC_POS_STATUS || '¦' ||
                     :NEW.C_GAUGE_TYPE || '¦' ||
                     :NEW.DIC_GAUGE_TYPE_DOC_ID || '|' ||
                     TO_CHAR(:NEW.PAC_THIRD_ID) || '¦' ||
                     TO_CHAR(:NEW.GCO_CHARACTERIZATION_ID) || '¦' ||
                     TO_CHAR(:NEW.GCO_GCO_CHARACTERIZATION_ID) || '¦' ||
                     TO_CHAR(:NEW.GCO2_GCO_CHARACTERIZATION_ID) || '¦' ||
                     TO_CHAR(:NEW.GCO3_GCO_CHARACTERIZATION_ID) || '¦' ||
                     TO_CHAR(:NEW.GCO4_GCO_CHARACTERIZATION_ID) || '¦' ||
                     :NEW.PAC_CHARACTERIZATION_VALUE_1 || '¦' ||
                     :NEW.PAC_CHARACTERIZATION_VALUE_2 || '¦' ||
                     :NEW.PAC_CHARACTERIZATION_VALUE_3 || '¦' ||
                     :NEW.PAC_CHARACTERIZATION_VALUE_4 || '¦' ||
                     :NEW.PAC_CHARACTERIZATION_VALUE_5;
end DOC_PAD_BIU_SET_KEY;


ALTER TRIGGER "C_ITX"."DOC_PAD_BIU_SET_KEY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PAR_AI_DETAIL_TMP"
  after insert
  on DOC_PACKING_TMP_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour de la table temporaire en fonction des détails positions.
* @author JPZ
* @version 2003
*/
begin
  -- insertion des détails de la position insérée
  -- dans la table temporaire des détails de position
  insert into DOC_PACKING_TMP_POS_DETAIL
              (PAP_QUANTITY
             , DOC_PACKING_LIST_ID
             , DOC_POSITION_DETAIL_ID
             , DOC_GAUGE_FLOW_ID
             , DOC_POSITION_ID
             , DOC_DOC_POSITION_DETAIL_ID
             , DOC2_DOC_POSITION_DETAIL_ID
             , PDE_BASIS_DELAY
             , PDE_BASIS_DELAY_W
             , PDE_BASIS_DELAY_M
             , PDE_INTERMEDIATE_DELAY
             , PDE_INTERMEDIATE_DELAY_W
             , PDE_INTERMEDIATE_DELAY_M
             , PDE_FINAL_DELAY
             , PDE_FINAL_DELAY_W
             , PDE_FINAL_DELAY_M
             , PDE_BASIS_QUANTITY
             , PDE_INTERMEDIATE_QUANTITY
             , PDE_FINAL_QUANTITY
             , PDE_BALANCE_QUANTITY
             , PDE_MOVEMENT_QUANTITY
             , PDE_MOVEMENT_VALUE
             , PDE_CHARACTERIZATION_VALUE_1
             , PDE_CHARACTERIZATION_VALUE_2
             , PDE_CHARACTERIZATION_VALUE_3
             , PDE_CHARACTERIZATION_VALUE_4
             , PDE_CHARACTERIZATION_VALUE_5
             , GCO_CHARACTERIZATION_ID
             , GCO_GCO_CHARACTERIZATION_ID
             , GCO2_GCO_CHARACTERIZATION_ID
             , GCO3_GCO_CHARACTERIZATION_ID
             , GCO4_GCO_CHARACTERIZATION_ID
             , STM_LOCATION_ID
             , STM_STM_LOCATION_ID
             , A_DATECRE
             , A_DATEMOD
             , A_IDCRE
             , A_IDMOD
             , A_RECLEVEL
             , A_RECSTATUS
             , A_CONFIRM
             , PDE_BALANCE_QUANTITY_PARENT
             , DIC_PDE_FREE_TABLE_1_ID
             , DIC_PDE_FREE_TABLE_2_ID
             , DIC_PDE_FREE_TABLE_3_ID
             , PDE_DECIMAL_1
             , PDE_DECIMAL_2
             , PDE_DECIMAL_3
             , PDE_TEXT_1
             , PDE_TEXT_2
             , PDE_TEXT_3
             , PDE_DATE_1
             , PDE_DATE_2
             , PDE_DATE_3
             , DIC_DELAY_UPDATE_TYPE_ID
             , PDE_DELAY_UPDATE_TEXT
             , DOC_DOCUMENT_ID
             , PAC_THIRD_ID
             , PAC_THIRD_ACI_ID
             , PAC_THIRD_DELIVERY_ID
             , PAC_THIRD_TARIFF_ID
             , DOC_GAUGE_ID
             , FAL_SCHEDULE_STEP_ID
              )
    select 0
         , :new.DOC_PACKING_LIST_ID
         , DOC_POSITION_DETAIL_ID
         , DOC_GAUGE_FLOW_ID
         , DOC_POSITION_ID
         , DOC_DOC_POSITION_DETAIL_ID
         , DOC2_DOC_POSITION_DETAIL_ID
         , PDE_BASIS_DELAY
         , PDE_BASIS_DELAY_W
         , PDE_BASIS_DELAY_M
         , PDE_INTERMEDIATE_DELAY
         , PDE_INTERMEDIATE_DELAY_W
         , PDE_INTERMEDIATE_DELAY_M
         , PDE_FINAL_DELAY
         , PDE_FINAL_DELAY_W
         , PDE_FINAL_DELAY_M
         , PDE_BASIS_QUANTITY
         , PDE_INTERMEDIATE_QUANTITY
         , PDE_FINAL_QUANTITY
         , PDE_BALANCE_QUANTITY
         , PDE_MOVEMENT_QUANTITY
         , PDE_MOVEMENT_VALUE
         , PDE_CHARACTERIZATION_VALUE_1
         , PDE_CHARACTERIZATION_VALUE_2
         , PDE_CHARACTERIZATION_VALUE_3
         , PDE_CHARACTERIZATION_VALUE_4
         , PDE_CHARACTERIZATION_VALUE_5
         , GCO_CHARACTERIZATION_ID
         , GCO_GCO_CHARACTERIZATION_ID
         , GCO2_GCO_CHARACTERIZATION_ID
         , GCO3_GCO_CHARACTERIZATION_ID
         , GCO4_GCO_CHARACTERIZATION_ID
         , STM_LOCATION_ID
         , STM_STM_LOCATION_ID
         , A_DATECRE
         , A_DATEMOD
         , A_IDCRE
         , A_IDMOD
         , A_RECLEVEL
         , A_RECSTATUS
         , A_CONFIRM
         , PDE_BALANCE_QUANTITY_PARENT
         , DIC_PDE_FREE_TABLE_1_ID
         , DIC_PDE_FREE_TABLE_2_ID
         , DIC_PDE_FREE_TABLE_3_ID
         , PDE_DECIMAL_1
         , PDE_DECIMAL_2
         , PDE_DECIMAL_3
         , PDE_TEXT_1
         , PDE_TEXT_2
         , PDE_TEXT_3
         , PDE_DATE_1
         , PDE_DATE_2
         , PDE_DATE_3
         , DIC_DELAY_UPDATE_TYPE_ID
         , PDE_DELAY_UPDATE_TEXT
         , DOC_DOCUMENT_ID
         , PAC_THIRD_ID
         , PAC_THIRD_ACI_ID
         , PAC_THIRD_DELIVERY_ID
         , PAC_THIRD_TARIFF_ID
         , DOC_GAUGE_ID
         , FAL_SCHEDULE_STEP_ID
      from DOC_POSITION_DETAIL PDE
     where PDE.DOC_POSITION_ID = :new.DOC_POSITION_ID;
end DOC_PAR_AI_DETAIL_TMP;


ALTER TRIGGER "C_ITX"."DOC_PAR_AI_DETAIL_TMP" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PAY_BIU_FLAG_DOCUMENT"
  before insert or update of PAD_DATE_AMOUNT, PAD_DISCOUNT_AMOUNT, PAD_NET_DATE_AMOUNT
  on DOC_PAYMENT_DATE
  referencing old as old new as new
  for each row
/**
* Description
*    Activation du flag de regénération des no BVR
* @created fp 24.10.2003
* @version 2003
*/
declare
  generationMethod DOC_FOOT.C_BVR_GENERATION_METHOD%type;
begin
  if updating then
    select C_BVR_GENERATION_METHOD
      into generationMethod
      from DOC_FOOT
     where DOC_FOOT_ID = nvl(:new.DOC_FOOT_ID, :old.DOC_FOOT_ID);

    if generationMethod = '03' then
      :new.PAD_BVR_CODING_LINE  := null;

      update DOC_DOCUMENT
         set DMT_REDO_PAYMENT_BVR = 1
       where DOC_DOCUMENT_ID = nvl(:new.DOC_FOOT_ID, :old.DOC_FOOT_ID);
    end if;
  else
    update DOC_DOCUMENT
       set DMT_REDO_PAYMENT_BVR = 1
     where DOC_DOCUMENT_ID = nvl(:new.DOC_FOOT_ID, :old.DOC_FOOT_ID);
  end if;
end DOC_PAY_BIU_FLAG_DOCUMENT;

ALTER TRIGGER "C_ITX"."DOC_PAY_BIU_FLAG_DOCUMENT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PCH_AIUD_FLAG_POSITION"
  after insert or delete or update of pch_amount, pch_amount_b
  on DOC_POSITION_CHARGE
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour du flag de recalcul des montants de position suite
*    à une modif dans les remise/taxe de position
* @created fp 08.04.2003
* @version 2003
* @lastUpdate
*/
begin
  update DOC_POSITION
     set POS_RECALC_AMOUNTS = 1
       , POS_UPDATE_POSITION_CHARGE = 1
   where DOC_POSITION_ID = nvl(:new.DOC_POSITION_ID, :old.DOC_POSITION_ID);
exception
  -- dans ce cas c'est l'effacement en cascade d'une position qui provoque le déclenchement
  -- du trigger et il n'est pas nécessaire de faire de mise à jour
  when ex.TABLE_MUTATING then
    null;
end DOC_PCH_AIUD_FLAG_POSITION;

ALTER TRIGGER "C_ITX"."DOC_PCH_AIUD_FLAG_POSITION" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PCH_AU_DENORM"
  after update of DOC_DOCUMENT_ID
  on DOC_POSITION_CHARGE
  referencing old as old new as new
  for each row
/**
* Description
*    Controle la non nullité de DOC_DOCUMENT_ID dans DOC_POSITION_CHARGE
* @author Fabrice Perotto
* @version 2003
*/
begin
  Raise_Application_Error(-20021, 'PCS - DOC_POSITION_CHARGE->DOC_DOCUMENT_ID cannot be NULL or modified');
end DOC_PCH_AU_DENORM;

ALTER TRIGGER "C_ITX"."DOC_PCH_AU_DENORM" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PCH_AU_IMPUTATION"
  after update of PCH_IMPUTATION
  on DOC_POSITION_CHARGE
  referencing old as old new as new
  for each row
/**
* Description
*    Déclenche le traitement de mise à jour de la table des imputations position. Les règles suivantes doivent être respectées :
*
*    1. Aucune imputation ne doit exister si le flag PCH_IMPUTATION passe de 1 à 0.
*    2. Au moins une imputation position doit être créée si le flag PCH_IMPUTATION est à 1.
*    3. Les imputations créées se basent sur un modèle de répartition (imputations positions avec uniquement l'ID du
*       document qui est renseigné).
*
* @author VJ
* @created 18/09/2006
* @version 2003
*/
declare
  nRecord            number;
  nRefRecord         number;
  vPositionChargeRow DOC_POSITION_CHARGE%rowtype;
  docDocumentID      DOC_DOCUMENT.DOC_DOCUMENT_ID%type;
  pacThirdID         PAC_THIRD.PAC_THIRD_ID%type;
  docGaugeID         DOC_GAUGE.DOC_GAUGE_ID%type;
  cAdminDomain       DOC_GAUGE.C_ADMIN_DOMAIN%type;
  docDateDocument    DOC_DOCUMENT.DMT_DATE_DOCUMENT%type;
begin
  if (nvl(:old.PCH_IMPUTATION, 0) <> nvl(:new.PCH_IMPUTATION, 0) ) then
    -- Passage du flag de 1 à 0.
    if (nvl(:new.PCH_IMPUTATION, 0) = 0) then
      -- Supprime les éventuelles imputations lors du passage du flag d'imputation à 0
      DOC_IMPUTATION_FUNCTIONS.DeletePositionImputations(null, :new.DOC_POSITION_CHARGE_ID, null);
    -- Passage du flag de 0 à 1.
    elsif(nvl(:new.PCH_IMPUTATION, 0) = 1) then
      -- Vérifie l'existance d'une ou plusieurs imputations position.
      select count(POI.DOC_POSITION_IMPUTATION_ID)
        into nRecord
        from DOC_POSITION_IMPUTATION POI
       where POI.DOC_POSITION_CHARGE_ID = :new.DOC_POSITION_CHARGE_ID;

      -- Aucune imputation ne doit être créée s'il en existe déjà.
      if nRecord = 0 then
        -- Vérifie l'existance d'une ou plusieurs imputations positions. Les imputations positions se distinguent
        -- par le fait que les champs DOC_DOCUMENT_ID et DOC_POSITION_ID sont renseignés.
        select count(POI.DOC_POSITION_IMPUTATION_ID)
          into nRefRecord
          from DOC_POSITION_IMPUTATION POI
         where POI.DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID
           and POI.DOC_POSITION_ID = :new.DOC_POSITION_ID
           and POI.DOC_POSITION_CHARGE_ID is null
           and POI.DOC_FOOT_CHARGE_ID is null;

        if nRefRecord = 0 then
          -- Cas en principe impossible. Le contrôle effectué par le trigger DOC_PCH_BU_IMPUTATION doit exclure
          -- ce cas.
          raise_application_error(-20100, 'Imputation position not found !');
        end if;

        -- Recherche les comptes à appliquer
        begin
          select DMT.DOC_DOCUMENT_ID
               , DMT.PAC_THIRD_ID
               , GAU.DOC_GAUGE_ID
               , GAU.C_ADMIN_DOMAIN
               , DMT.DMT_DATE_DOCUMENT
            into docDocumentID
               , pacThirdID
               , docGaugeID
               , cAdminDomain
               , docDateDocument
            from DOC_DOCUMENT DMT
               , DOC_GAUGE GAU
           where DMT.DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID
             and GAU.DOC_GAUGE_ID = DMT.DOC_GAUGE_ID;
        exception
          when ex.TABLE_MUTATING then
            null;
          when NO_DATA_FOUND then
            null;
        end;

        if docDocumentID is not null then
          vPositionChargeRow.DOC_DOCUMENT_ID           := :new.DOC_DOCUMENT_ID;
          vPositionChargeRow.DOC_POSITION_ID           := :new.DOC_POSITION_ID;
          vPositionChargeRow.C_FINANCIAL_CHARGE        := :new.C_FINANCIAL_CHARGE;
          vPositionChargeRow.PTC_CHARGE_ID             := :new.PTC_CHARGE_ID;
          vPositionChargeRow.PTC_DISCOUNT_ID           := :new.PTC_DISCOUNT_ID;
          vPositionChargeRow.ACS_FINANCIAL_ACCOUNT_ID  := :new.ACS_FINANCIAL_ACCOUNT_ID;
          vPositionChargeRow.ACS_DIVISION_ACCOUNT_ID   := :new.ACS_DIVISION_ACCOUNT_ID;
          vPositionChargeRow.ACS_PJ_ACCOUNT_ID         := :new.ACS_PJ_ACCOUNT_ID;
          vPositionChargeRow.ACS_PF_ACCOUNT_ID         := :new.ACS_PF_ACCOUNT_ID;
          vPositionChargeRow.ACS_CDA_ACCOUNT_ID        := :new.ACS_CDA_ACCOUNT_ID;
          vPositionChargeRow.ACS_CPN_ACCOUNT_ID        := :new.ACS_CPN_ACCOUNT_ID;
          vPositionChargeRow.DIC_IMP_FREE1_ID          := :new.DIC_IMP_FREE1_ID;
          vPositionChargeRow.DIC_IMP_FREE2_ID          := :new.DIC_IMP_FREE2_ID;
          vPositionChargeRow.DIC_IMP_FREE3_ID          := :new.DIC_IMP_FREE3_ID;
          vPositionChargeRow.DIC_IMP_FREE4_ID          := :new.DIC_IMP_FREE4_ID;
          vPositionChargeRow.DIC_IMP_FREE5_ID          := :new.DIC_IMP_FREE5_ID;
          vPositionChargeRow.PCH_IMP_NUMBER_1          := :new.PCH_IMP_NUMBER_1;
          vPositionChargeRow.PCH_IMP_NUMBER_2          := :new.PCH_IMP_NUMBER_2;
          vPositionChargeRow.PCH_IMP_NUMBER_3          := :new.PCH_IMP_NUMBER_3;
          vPositionChargeRow.PCH_IMP_NUMBER_4          := :new.PCH_IMP_NUMBER_4;
          vPositionChargeRow.PCH_IMP_NUMBER_5          := :new.PCH_IMP_NUMBER_5;
          vPositionChargeRow.PCH_IMP_TEXT_1            := :new.PCH_IMP_TEXT_1;
          vPositionChargeRow.PCH_IMP_TEXT_2            := :new.PCH_IMP_TEXT_2;
          vPositionChargeRow.PCH_IMP_TEXT_3            := :new.PCH_IMP_TEXT_3;
          vPositionChargeRow.PCH_IMP_TEXT_4            := :new.PCH_IMP_TEXT_4;
          vPositionChargeRow.PCH_IMP_TEXT_5            := :new.PCH_IMP_TEXT_5;
          vPositionChargeRow.C_FAM_TRANSACTION_TYP     := :new.C_FAM_TRANSACTION_TYP;
          vPositionChargeRow.FAM_FIXED_ASSETS_ID       := :new.FAM_FIXED_ASSETS_ID;
          vPositionChargeRow.HRM_PERSON_ID             := :new.HRM_PERSON_ID;
          DOC_IMPUTATION_FUNCTIONS.CreateLikePositionImputations(:new.DOC_DOCUMENT_ID
                                                               , docGaugeID
                                                               , pacThirdID
                                                               , cAdminDomain
                                                               , docDateDocument
                                                               , :new.DOC_POSITION_ID
                                                               , null
                                                               , :new.DOC_POSITION_CHARGE_ID
                                                               , vPositionChargeRow
                                                               , null
                                                               , null
                                                                );
        end if;
      end if;

      -- Fonction de répartition du montant d'une remise ou taxe de position
      DOC_IMPUTATION_FUNCTIONS.imputePositionCharge(:new.DOC_POSITION_CHARGE_ID
                                                  , :new.PCH_AMOUNT
                                                  , :new.PCH_AMOUNT_B
                                                  , :new.PCH_AMOUNT_E
                                                  , :new.PCH_AMOUNT_V
                                                   );
    end if;
  end if;
end DOC_PCH_AU_IMPUTATION;

ALTER TRIGGER "C_ITX"."DOC_PCH_AU_IMPUTATION" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PCH_BI_DENORM"
  before insert
  on DOC_POSITION_CHARGE
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des champs dénormalisés de DOC_POSITION_CHARGE
* @author Fabrice Perotto
* @version 2003
*/
begin
  select DOC_DOCUMENT_ID
       , PAC_THIRD_ID
       , PAC_THIRD_ACI_ID
       , PAC_THIRD_DELIVERY_ID
       , PAC_THIRD_TARIFF_ID
    into :new.DOC_DOCUMENT_ID
       , :new.PAC_THIRD_ID
       , :new.PAC_THIRD_ACI_ID
       , :new.PAC_THIRD_DELIVERY_ID
       , :new.PAC_THIRD_TARIFF_ID
    from DOC_POSITION
   where DOC_POSITION_ID = :new.DOC_POSITION_ID;
end DOC_PCH_BI_DENORM;

ALTER TRIGGER "C_ITX"."DOC_PCH_BI_DENORM" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PCH_BIUD_CONSTRAINTS"
  before insert or update of "PCH_AMOUNT" or delete
  on DOC_POSITION_CHARGE
  referencing old as old new as new
  for each row
/**
* Description
*    Contraintes d'intégrité des remises et taxes de position
* @created fp 08.12.2003
* @version 2003
* @lastUpdate
*/
declare
  childId        DOC_POSITION_CHARGE.DOC_POSITION_CHARGE_ID%type;
  posStatus      DOC_POSITION.C_DOC_POS_STATUS%type;
begin
  if deleting then
    begin
      if :new.PCH_DISCHARGED = 1 then
        select C_DOC_POS_STATUS
          into posStatus
          from DOC_POSITION
         where DOC_POSITION_ID = :old.DOC_POSITION_ID;

        if posStatus = '03' then
          raise_application_error
            (-20000
           , PCS.PC_FUNCTIONS.TranslateWord
                                 ('PCS - Impossible d''effacer une remise/taxe si la position est partiellement soldée.')
            );
        elsif posStatus = '04' then
          raise_application_error
            (-20000
           , PCS.PC_FUNCTIONS.TranslateWord('PCS - Impossible d''effacer une remise/taxe si la position est liquidée.')
            );
        end if;
      end if;
    exception
      when ex.TABLE_MUTATING then
        null;   -- cas d'un effacement en cascade, le contrôle n'est pas effectué
    end;
  elsif updating then
    if :old.PCH_AMOUNT != :new.PCH_AMOUNT and :new.PCH_DISCHARGED = 1 and :new.PCH_TRANSFERT_PROP = 1 then
      select max(POS_CHILD.DOC_POSITION_ID)
        into childId
        from DOC_POSITION_DETAIL PDE
           , DOC_POSITION_DETAIL PDE_CHILD
           , DOC_POSITION POS_CHILD
       where PDE.DOC_POSITION_ID = :new.DOC_POSITION_ID
         and PDE_CHILD.DOC_DOC_POSITION_DETAIL_ID = PDE.DOC_POSITION_DETAIL_ID
         and PDE_CHILD.DOC_POSITION_ID = POS_CHILD.DOC_POSITION_ID
         and POS_CHILD.C_DOC_POS_STATUS in('01', '02', '03');

      if childId is not null then
        raise_application_error
          (-20000
         , PCS.PC_FUNCTIONS.TranslateWord
             ('PCS - Impossible de modifier une remise/taxe si il existe une position enfant à solder ou partiellement soldée.'
             )
          );
      end if;
    end if;
  end if;
end DOC_PCH_BIUD_CONSTRAINTS;

ALTER TRIGGER "C_ITX"."DOC_PCH_BIUD_CONSTRAINTS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PCH_BIU_LOCAL_CURRENCY"
  before insert or update of PCH_MODIFY_RATE, PCH_CALC_AMOUNT, PCH_LIABLED_AMOUNT, PCH_AMOUNT
  on DOC_POSITION_CHARGE
  referencing old as old new as new
  for each row
/**
* Description
*    calcul des montants en monnaie de base des  remises/taxes de position
* @author Fabrice Perotto
* @version 2003
* @lastUpdate 09.04.2002
*/
declare
  euro_rate            DOC_DOCUMENT.DMT_RATE_OF_EXCHANGE%type;
  curr_id              DOC_DOCUMENT.ACS_FINANCIAL_CURRENCY_ID%type;
  vat_curr_id          DOC_DOCUMENT.ACS_ACS_FINANCIAL_CURRENCY_ID%type;
  local_curr_id        DOC_DOCUMENT.ACS_FINANCIAL_CURRENCY_ID%type;
  document_date        DOC_DOCUMENT.DMT_DATE_DOCUMENT%type;
  rate_of_exchange     DOC_DOCUMENT.DMT_RATE_OF_EXCHANGE%type;
  base_price           DOC_DOCUMENT.DMT_BASE_PRICE%type;
  vat_rate_of_exchange DOC_DOCUMENT.DMT_VAT_EXCHANGE_RATE%type;
  vat_base_price       DOC_DOCUMENT.DMT_VAT_BASE_PRICE%type;
  bidon                DOC_POSITION.POS_NET_VALUE_EXCL_E%type;
  quantity             DOC_POSITION.POS_BASIS_QUANTITY%type;
  ValueQuantity        DOC_POSITION.POS_VALUE_QUANTITY%type;
  GestValueQuantity    DOC_GAUGE_POSITION.GAP_VALUE_QUANTITY%type;
begin
  -- recherche des informations nécessaires à la conversion dans la table DOC_DOCUMENT
  select ACS_FINANCIAL_CURRENCY_ID
       , ACS_ACS_FINANCIAL_CURRENCY_ID
       , DMT_DATE_DOCUMENT
       , DMT_RATE_OF_EXCHANGE
       , DMT_BASE_PRICE
       , DMT_VAT_EXCHANGE_RATE
       , DMT_VAT_BASE_PRICE
       , POS_BASIS_QUANTITY
       , POS_VALUE_QUANTITY
       , GAP_VALUE_QUANTITY
    into curr_id
       , vat_curr_id
       , document_date
       , rate_of_exchange
       , base_price
       , vat_rate_of_exchange
       , vat_base_price
       , quantity
       , ValueQuantity
       , GestValueQuantity
    from DOC_DOCUMENT
       , DOC_POSITION
       , DOC_GAUGE_POSITION GAP
   where DOC_DOCUMENT.DOC_DOCUMENT_ID = DOC_POSITION.DOC_DOCUMENT_ID
     and DOC_POSITION.DOC_POSITION_ID = :new.DOC_POSITION_ID
     and GAP.DOC_GAUGE_POSITION_ID = DOC_POSITION.DOC_GAUGE_POSITION_ID;

  local_curr_id         := ACS_FUNCTION.GetLocalCurrencyId;
  ACS_FUNCTION.ConvertAmount(nvl(:new.PCH_AMOUNT, 0)
                           , curr_id
                           , local_curr_id
                           , document_date
                           , rate_of_exchange
                           , base_price
                           , 0
                           , :new.PCH_AMOUNT_E
                           , :new.PCH_AMOUNT_B
                            );
  ACS_FUNCTION.ConvertAmount(nvl(:new.PCH_CALC_AMOUNT, 0)
                           , curr_id
                           , local_curr_id
                           , document_date
                           , rate_of_exchange
                           , base_price
                           , 0
                           , :new.PCH_CALC_AMOUNT_E
                           , :new.PCH_CALC_AMOUNT_B
                            );
  ACS_FUNCTION.ConvertAmount(nvl(:new.PCH_LIABLED_AMOUNT, 0)
                           , curr_id
                           , local_curr_id
                           , document_date
                           , rate_of_exchange
                           , base_price
                           , 0
                           , :new.PCH_LIABLED_AMOUNT_E
                           , :new.PCH_LIABLED_AMOUNT_B
                            );

  if :new.C_CALCULATION_MODE in('0', '1', '6') then
    -- calcul par rapport au montant fixe monnaie de base
    if inserting then
      if (GestValueQuantity = 1) then
        if     :new.PCH_IS_MULTIPLICATOR = 1
           and ValueQuantity = 0 then
          ACS_FUNCTION.ConvertAmount(nvl(:new.PCH_FIXED_AMOUNT_B, 0)
                                   , local_curr_id
                                   , curr_id
                                   , document_date
                                   , base_price
                                   , rate_of_exchange
                                   , 0
                                   , bidon
                                   , :new.PCH_FIXED_AMOUNT
                                    );
        elsif     :new.PCH_IS_MULTIPLICATOR = 1
              and ValueQuantity <> 0 then
          :new.PCH_FIXED_AMOUNT  := abs(:new.PCH_AMOUNT / ValueQuantity) * sign(:new.PCH_FIXED_AMOUNT_B);
        else
          :new.PCH_FIXED_AMOUNT  := abs(:new.PCH_AMOUNT) * sign(:new.PCH_FIXED_AMOUNT_B);
        end if;
      else
        if     :new.PCH_IS_MULTIPLICATOR = 1
           and quantity = 0 then
          ACS_FUNCTION.ConvertAmount(nvl(:new.PCH_FIXED_AMOUNT_B, 0)
                                   , local_curr_id
                                   , curr_id
                                   , document_date
                                   , base_price
                                   , rate_of_exchange
                                   , 0
                                   , bidon
                                   , :new.PCH_FIXED_AMOUNT
                                    );
        elsif     :new.PCH_IS_MULTIPLICATOR = 1
              and quantity <> 0 then
          :new.PCH_FIXED_AMOUNT  := abs(:new.PCH_AMOUNT / quantity) * sign(:new.PCH_FIXED_AMOUNT_B);
        else
          :new.PCH_FIXED_AMOUNT  := abs(:new.PCH_AMOUNT) * sign(:new.PCH_FIXED_AMOUNT_B);
        end if;
      end if;

      ACS_FUNCTION.ConvertAmount(nvl(:new.PCH_FIXED_AMOUNT_B, 0)
                               , local_curr_id
                               , curr_id
                               , document_date
                               , base_price
                               , rate_of_exchange
                               , 0
                               , :new.PCH_FIXED_AMOUNT_E
                               , bidon
                                );
    -- calcul par rapport au montant fixe monnaie document
    elsif updating then
      ACS_FUNCTION.ConvertAmount(nvl(:new.PCH_FIXED_AMOUNT, 0)
                               , curr_id
                               , local_curr_id
                               , document_date
                               , rate_of_exchange
                               , base_price
                               , 0
                               , :new.PCH_FIXED_AMOUNT_E
                               , :new.PCH_FIXED_AMOUNT_B
                                );
    end if;
  end if;

  -- monnaie tva
  if     (local_curr_id = curr_id)
     and (local_curr_id = vat_curr_id) then   -- Cas n°1 CHF - CHF - CHF
    :new.PCH_AMOUNT_V  := :new.PCH_AMOUNT_B;
  elsif     (local_curr_id <> curr_id)
        and (local_curr_id = vat_curr_id) then   -- Cas n°2 CHF - EUR - CHF
    ACS_FUNCTION.ConvertAmount(nvl(:new.PCH_AMOUNT, 0)
                             , vat_curr_id
                             , curr_id
                             , document_date
                             , vat_base_price
                             , vat_rate_of_exchange
                             , 0
                             , bidon
                             , :new.PCH_AMOUNT_V
                              );
  elsif     (local_curr_id <> curr_id)
        and (curr_id = vat_curr_id) then   -- Cas n°3 CHF - EUR - EUR
    :new.PCH_AMOUNT_V  := :new.PCH_AMOUNT;
  else
    -- Cas n°4 CHF - CHF - EUR
    -- Cas n°5 CHF - USD - EUR
    ACS_FUNCTION.ConvertAmount(nvl(:new.PCH_AMOUNT_B, 0)
                             , local_curr_id
                             , vat_curr_id
                             , document_date
                             , vat_rate_of_exchange
                             , vat_base_price
                             , 0
                             , bidon
                             , :new.PCH_AMOUNT_V
                              );
  end if;

  :new.PCH_MODIFY_RATE  := 0;
end DOC_PCH_BIU_LOCAL_CURRENCY;


ALTER TRIGGER "C_ITX"."DOC_PCH_BIU_LOCAL_CURRENCY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PCH_BU_IMPUTATION"
  before update of PCH_IMPUTATION
  on DOC_POSITION_CHARGE
  referencing old as old new as new
  for each row
/**
* Description
*    Vérifie si les imputations sont autorisée
*
* @author VJ
* @created 18/09/2006
* @version 2003
*/
declare
  nRecord    number;
  nRefRecord number;
begin
  if (nvl(:old.PCH_IMPUTATION, 0) <> nvl(:new.PCH_IMPUTATION, 0) ) then
    -- Passage du flag de 0 à 1.
    if (nvl(:new.PCH_IMPUTATION, 0) = 1) then
      -- Vérifie l'existance d'une ou plusieurs imputations position.
      select count(POI.DOC_POSITION_IMPUTATION_ID)
        into nRecord
        from DOC_POSITION_IMPUTATION POI
       where POI.DOC_POSITION_CHARGE_ID = :new.DOC_POSITION_CHARGE_ID;

      if nRecord = 0 then
        -- Vérifie l'existance d'une ou plusieurs imputations positions. Les imputations positions se distinguent
        -- par le fait que les champs DOC_DOCUMENT_ID et DOC_POSITION_ID sont renseignés.
        select count(POI.DOC_POSITION_IMPUTATION_ID)
          into nRefRecord
          from DOC_POSITION_IMPUTATION POI
         where POI.DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID
           and POI.DOC_POSITION_ID = :new.DOC_POSITION_ID
           and POI.DOC_POSITION_CHARGE_ID is null
           and POI.DOC_FOOT_CHARGE_ID is null;

        if nRefRecord = 0 then
          -- Imputation interdite
          :new.PCH_IMPUTATION  := 0;
        end if;
      end if;
    end if;
  end if;
end DOC_PCH_BU_IMPUTATION;

ALTER TRIGGER "C_ITX"."DOC_PCH_BU_IMPUTATION" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AD_FORNETWORK"
  after delete
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*   Trigger After Delete Record pour la table DOC_POSITION_DETAIL
*   Supprime le détail position
* @created EPI
* @version 2003
* @lastUpdate
*/
declare
  aC_GAUGE_TYPE_POS         DOC_POSITION.C_GAUGE_TYPE_POS%type;
  aPOS_TRANSFERT_PROPRIETOR DOC_POSITION.POS_TRANSFERT_PROPRIETOR%type;
  aPAC_REPRESENTATIVE_ID    PAC_REPRESENTATIVE.PAC_REPRESENTATIVE_ID%Type;
begin
  -- Vérifier que les réseaux Logiqistiques sont activés
  if not FAL_NETWORK_DOC.IsDOCNetWorkEnabled then
    return;
  end if;

  -- Tout le traitement a été déporté dans FAL_NETWORK_DOC.TRT_DOC_PDE_AD_FORNETWORK
  select POS.C_GAUGE_TYPE_POS
       , POS.POS_TRANSFERT_PROPRIETOR
       , POS.PAC_REPRESENTATIVE_ID
    into aC_GAUGE_TYPE_POS
       , aPOS_TRANSFERT_PROPRIETOR
       , aPAC_REPRESENTATIVE_ID
    from DOC_POSITION POS
   where POS.DOC_POSITION_ID = :old.DOC_POSITION_ID;

  FAL_NETWORK_DOC.TRT_DOC_PDE_AD_FORNETWORK(
      :old.DOC_POSITION_DETAIL_ID
    , aC_GAUGE_TYPE_POS
    , aPOS_TRANSFERT_PROPRIETOR
    , :old.STm_LOCATION_ID
    , :old.PDE_BASIS_DELAY
    , :old.PAC_THIRD_ID
    , :old.PDE_BALANCE_QUANTITY
    , :old.DOC_DOCUMENT_ID
    , :old.DOC_GAUGE_ID
    , :old.GCO_GOOD_ID
    , aPAC_REPRESENTATIVE_ID);

-- Si on passe dans cette exception, cela signifie que la mise à jour est faite à
-- partir du curseur DOC_POS_BD_FORNETWORK
exception
  when ex.TABLE_MUTATING then
    null;
end DOC_PDE_AD_FORNETWORK;

ALTER TRIGGER "C_ITX"."DOC_PDE_AD_FORNETWORK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AD_MULTISOURCING"
  after delete
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Déclenche le traitement de mise à jour du multi-sourcing réalisé. Les règles suivantes doivent être respectées :
*
*    1. Le bien doit gérer le multi-sourcing (GCO_PRODUCT.PDT_MULTI_SOURCING = 1).
*    2. Le gabarit doit gérer le multi-sourcing (DOC_GAUGE_STRUCTURED.GAS_MULTISOURCING_MGM = 1).
*    3. La quantité ou le produit fabriqué ont changé
*
* @author VJ
* @created 31/03/2005
* @version 2003
*/
declare
  posNetUnitValueExclB DOC_POSITION.POS_NET_UNIT_VALUE%type;
  gcoGoodID            GCO_GOOD.GCO_GOOD_ID%type;
  docDocumentID        DOC_DOCUMENT.DOC_DOCUMENT_ID%type;
  dmtNumber            DOC_DOCUMENT.DMT_NUMBER%type;
  strInfo              varchar2(2000);
begin
  if (nvl(:old.PDE_FINAL_QUANTITY_SU, 0) <> 0) then
    -- Recherche la valeur net
    begin
      select decode(nvl(POS.POS_FINAL_QUANTITY_SU, 0), 0, 0, POS.POS_NET_VALUE_EXCL_B / POS.POS_FINAL_QUANTITY_SU)
                                                                                              POS_NET_UNIT_VALUE_EXCL_B
           , POS.DOC_DOCUMENT_ID
           , POS.GCO_GOOD_ID
           , DMT.DMT_NUMBER
        into posNetUnitValueExclB
           , docDocumentID
           , gcoGoodID
           , dmtNumber
        from DOC_POSITION POS
           , DOC_DOCUMENT DMT
           , GCO_PRODUCT PDT
           , DOC_GAUGE_STRUCTURED GAS
       where POS.DOC_POSITION_ID = :old.DOC_POSITION_ID
         and PDT.GCO_GOOD_ID = POS.GCO_GOOD_ID
         and DMT.DOC_DOCUMENT_ID = POS.DOC_DOCUMENT_ID
         and nvl(PDT.PDT_MULTI_SOURCING, 0) = 1
         and GAS.DOC_GAUGE_ID = POS.DOC_GAUGE_ID
         and nvl(GAS.GAS_MULTISOURCING_MGM, 0) = 1;
    exception
      when no_data_found then
        posNetUnitValueExclB  := null;
    end;

    if posNetUnitValueExclB is not null then
      if false then
        strInfo  :=
          'DOC_PDE_AD_MULTISOURCING' ||
          chr(13) ||
          chr(13) ||
          'Document : ' ||
          docDocumentID ||
          chr(13) ||
          'Bien : ' ||
          gcoGoodID ||
          chr(13) ||
          'Prix unitaire net ht : ' ||
          posNetUnitValueExclB ||
          chr(13) ||
          'Quantité : ' ||
          :old.PDE_FINAL_QUANTITY_SU ||
          chr(13) ||
          'Montant : ' ||
          posNetUnitValueExclB * :old.PDE_FINAL_QUANTITY_SU;
        DOC_FUNCTIONS.CreateHistoryInformation(:old.DOC_DOCUMENT_ID
                                             , :old.DOC_POSITION_ID   -- DOC_POSITION_ID
                                             , dmtNumber   -- no de document
                                             , 'PLSQL'   -- DUH_TYPE
                                             , 'Getting detail informations DOC_PDE_AD_MULTISOURCING : ' ||
                                               :old.DOC_POSITION_DETAIL_ID
                                             , strInfo   -- description libre
                                             , null   -- status document
                                             , null   -- status position
                                              );
      end if;

      --
      -- Mise à jour du réalisé en multi-sourcing
      --
      FAL_MSOURCING_FUNCTIONS.UpdateMultiSourcingRealized(docDocumentID
                                                        , gcoGoodID
                                                        , :old.GCO_GCO_GOOD_ID
                                                        , null
                                                        , 0
                                                        , :old.PDE_FINAL_QUANTITY_SU
                                                        , 0
                                                        , posNetUnitValueExclB
                                                         );
    end if;
  end if;
exception
  -- Si on passe dans cette exception, cela signifie que l'effacement du détail courant s'effectue à partir d'un
  -- trigger de la table des positions
  when ex.TABLE_MUTATING then
    null;
end DOC_PDE_AD_MULTISOURCING;

ALTER TRIGGER "C_ITX"."DOC_PDE_AD_MULTISOURCING" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AD_NO_MORPH_CHAR"
  after delete
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour de la table des numéros (pièce, lot et chronologique) lors de
*    l'effacement d'un détail
*    de position.
* @author VJ
* @created 08.05.2002
* @version 2003
* @lastUpdate 30.01.2002
*/
declare
  vMovementSort     STM_MOVEMENT_KIND.C_MOVEMENT_SORT%type;
  vMovementKindID   STM_MOVEMENT_KIND.STM_MOVEMENT_KIND_ID%type;
  vTypePos          DOC_POSITION.C_GAUGE_TYPE_POS%type;
  vDesignation      DOC_GAUGE_POSITION.GAP_DESIGNATION%type;
  vElementNumberID1 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vElementNumberID2 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vElementNumberID3 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  lQualityStatusId  STM_ELEMENT_NUMBER.GCO_QUALITY_STATUS_ID%type;
  vUpdateMode       varchar2(2);
  lAllChar          DOC_GAUGE_STRUCTURED.GAS_ALL_CHARACTERIZATION%type;
begin
  /* Recherche du genre de mouvement de la position. Si le trigger est
     déclenché depuis en dessus (mise à jour depuis un trigger d'effacement de
     la position ou du document), on part dans l'exception. La mise à jour devra
     être faite dans le trigger de la position ou du document. */
  select POS.STM_MOVEMENT_KIND_ID
       , POS.C_GAUGE_TYPE_POS
       , GAP.GAP_DESIGNATION
    into vMovementKindID
       , vTypePos
       , vDesignation
    from DOC_POSITION POS
       , DOC_GAUGE_POSITION GAP
   where POS.DOC_POSITION_ID = :old.DOC_POSITION_ID
     and GAP.DOC_GAUGE_POSITION_ID = POS.DOC_GAUGE_POSITION_ID;

  -- Le genre de mouvement est inexistant et
  -- l'on traite une position bien qui gère les caratérisations
  if     (   vMovementKindID is null
          or :old.PDE_MOVEMENT_QUANTITY = 0)
     and (vTypePos in('1', '2', '3', '7', '8', '71', '81', '91', '101') ) then
    -- Recherche du type de mouvement en fonction du domaine
    select decode(GAU.C_ADMIN_DOMAIN, '1', 'ENT',   -- Achat
                  '2', 'SOR',   -- Vente
                  '')
         , GAS_ALL_CHARACTERIZATION
      into vMovementSort
         , lAllChar
      from DOC_GAUGE GAU
         , DOC_GAUGE_STRUCTURED GAS
     where GAU.DOC_GAUGE_ID = :old.DOC_GAUGE_ID
       and GAS.DOC_GAUGE_ID = GAU.DOC_GAUGE_ID;

    -- traitement effectué seulement dans le cas ou l'on gère les caractérisations non-morphologiques
    if lAllChar = 1 then
      /**
      * Recherche du mode de mise à jour des élements.
      *
      * On différentie l'effacement simple de l'effacement de position obtenue
      * par copie ou décharge.
      *
      *   DD = effacement d'un détail lié (détail fils ou cible),
      *   D  = effacement d'un détail non lié
      */
      if :old.DOC_GAUGE_RECEIPT_ID is not null then   -- Le détail de position est issu d'une décharge
        select max(GAP.STM_MOVEMENT_KIND_ID)
          into vMovementKindID
          from DOC_GAUGE_POSITION GAP
             , DOC_GAUGE_RECEIPT GAR
         where GAR.DOC_GAUGE_RECEIPT_ID = :old.DOC_GAUGE_RECEIPT_ID
           and GAP.DOC_GAUGE_ID = GAR.DOC_DOC_GAUGE_ID
           and GAP.C_GAUGE_TYPE_POS = vTypePos
           and GAP.GAP_DESIGNATION = vDesignation;

        if vMovementKindID is not null then   /* Le détail parent est lié à un genre de mouvement */
          vUpdateMode  := 'DD';
        else
          /* Remarque : J'effectue une nouvelle fois le teste sur la configuration,
             car je ne suis pas certain que le test initial sera conservé. */
          if     (lAllChar = 1)
             and (PCS.PC_CONFIG.GetConfig('DOC_CHARACTERIZATION_MODE') = '1') then   -- Le gabarit parent et la configuration gèrent tous les types de carctérisation
            vUpdateMode  := 'DD';
          else
            vUpdateMode  := 'D';
          end if;
        end if;
      elsif :old.DOC_GAUGE_COPY_ID is not null then   /* Le détail de position est issu d'une copie */
        select max(GAP.STM_MOVEMENT_KIND_ID)
          into vMovementKindID
          from DOC_GAUGE_POSITION GAP
             , DOC_GAUGE_COPY GAC
         where GAC.DOC_GAUGE_COPY_ID = :old.DOC_GAUGE_COPY_ID
           and GAP.DOC_GAUGE_ID = GAC.DOC_DOC_GAUGE_ID
           and GAP.C_GAUGE_TYPE_POS = vTypePos
           and GAP.GAP_DESIGNATION = vDesignation;

        if vMovementKindID is not null then   /* Le détail source est lié à un genre de mouvement */
          vUpdateMode  := 'DD';
        else
          /* Remarque : J'effectue une nouvelle fois le teste sur la configuration,
             car je ne suis pas certain que le test initial sera conservé. */
          if     (lAllChar = 1)
             and (PCS.PC_CONFIG.GetConfig('DOC_CHARACTERIZATION_MODE') = '1') then   /* Le gabarit parent et la configuration gèrent tous les types de carctérisation */
            vUpdateMode  := 'DD';
          else
            vUpdateMode  := 'D';
          end if;
        end if;
      else
        vUpdateMode  := 'D';
      end if;

      /**
      * Mise à jour de la table element_number et récupération des ID
      *
      * Remarques :
      *
      *  Le status de l'élement est définit dans la fonction (null transmis).
      *
      *  Il faut transmettre les ID et les valeurs de caractérisation sans
      *  tenir compte de l'éventuel non gestion en stock de celles-ci.
      */
      STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => :old.GCO_GOOD_ID   -- Bien
                                              , iUpdateMode               => vUpdateMode   -- Mode de mise à jour
                                              , iMovementSort             => vMovementSort   -- Type de mouvement 'ENT' = Entrée 'SOR' = Sortie
                                              , iCharacterizationId       => :old.GCO_CHARACTERIZATION_ID   -- Caractérisation 1
                                              , iCharacterization2Id      => :old.GCO_GCO_CHARACTERIZATION_ID
                                              , iCharacterization3Id      => :old.GCO2_GCO_CHARACTERIZATION_ID
                                              , iCharacterization4Id      => :old.GCO3_GCO_CHARACTERIZATION_ID
                                              , iCharacterization5Id      => :old.GCO4_GCO_CHARACTERIZATION_ID
                                              , iCharacterizationValue1   => :old.PDE_CHARACTERIZATION_VALUE_1   -- Valeur de caractérisation 1
                                              , iCharacterizationValue2   => :old.PDE_CHARACTERIZATION_VALUE_2
                                              , iCharacterizationValue3   => :old.PDE_CHARACTERIZATION_VALUE_3
                                              , iCharacterizationValue4   => :old.PDE_CHARACTERIZATION_VALUE_4
                                              , iCharacterizationValue5   => :old.PDE_CHARACTERIZATION_VALUE_5
                                              , iVerifyChar               => 1   -- Vérification de l'unicité des valeurs de caract.
                                              , iElementStatus            => null   -- Statut de l'élement après mise à jour
                                              , ioElementNumberId1        => vElementNumberID1   -- Elément 1 en sortie
                                              , ioElementNumberId2        => vElementNumberID2   -- Elément 2 en sortie
                                              , ioElementNumberId3        => vElementNumberID3   -- Elément 3 en sortie
                                              , ioQualityStatusId         => lQualityStatusId
                                               );
    end if;
  end if;
exception
  -- Si on passe dans cette exception, cela signifie que la mise à jour est faite à
  -- partir du trigger DOC_DMT_AD_NO_MORPH ou DOC_POS_AD_NO_MORPH
  when ex.TABLE_MUTATING then
    null;
end DOC_PDE_AD_NO_MORPH_CHAR;

ALTER TRIGGER "C_ITX"."DOC_PDE_AD_NO_MORPH_CHAR" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AD_PACKING_PARCEL"
  after delete
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Trigger d'effacement de toutes les positions colis liées avec le
*    du doc_position_detail_id. Mise à jour préalable des colis.
*
* @author Jean-Philippe Zuttel
* @created 25/10/2000
* @version 2003
*/
begin
  -- Mise à jour des colis.
  doc_packing.UpdateParcels(:old.DOC_POSITION_DETAIL_ID);
  -- Suppression des positions du colis.
  doc_packing.DeleteParcelPositions(:old.DOC_POSITION_DETAIL_ID);
end DOC_PDE_AD_PACKING_PARCEL;

ALTER TRIGGER "C_ITX"."DOC_PDE_AD_PACKING_PARCEL" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AD_POSI_ACCU"
  after delete
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des totalisateurs de position
* @author Fabrice Perotto
* @version 2003
*/
declare
  -- Curseur de détail des positions du document
  cursor detail_position_cursor(doc_pos_id number)
  is
    select POS.GCO_GOOD_ID
         , DOC.PAC_THIRD_ID
         , DOC.DIC_GAUGE_TYPE_DOC_ID
         , GPO.GAP_DELAY
         , DOC.DMT_DATE_DOCUMENT
         , POS.POS_NET_VALUE_EXCL_B
         , POS.C_DOC_POS_STATUS
         , GST.GAS_BALANCE_STATUS
         , GAU.C_GAUGE_TYPE
      from DOC_DOCUMENT DOC
         , DOC_POSITION POS
         , DOC_GAUGE_POSITION GPO
         , DOC_GAUGE_STRUCTURED GST
         , DOC_GAUGE GAU
     where POS.DOC_DOCUMENT_ID = DOC.DOC_DOCUMENT_ID
       and GPO.DOC_GAUGE_POSITION_ID = POS.DOC_GAUGE_POSITION_ID
       and POS.DOC_POSITION_ID = doc_pos_id
       and GST.DOC_GAUGE_ID = DOC.DOC_GAUGE_ID
       and GAU.DOC_GAUGE_ID = GST.DOC_GAUGE_ID
       and POS.C_GAUGE_TYPE_POS in('1', '2', '3', '7', '8', '91', '101', '21');

  detail_position_tuple DETAIL_POSITION_CURSOR%rowtype;
begin
  -- pas de mise à jour des totalisateurs (possible uniquement par recalcul global)
  if PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '0' then
    null;
  -- mise à jour instantannée des totalisateurs de position
  elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '1' then
    -- Ouverture du curseur de détail du document
    open DETAIL_POSITION_CURSOR(:old.DOC_POSITION_ID);

    -- Première position de détail
    fetch DETAIL_POSITION_CURSOR
     into detail_position_tuple;

    if DETAIL_POSITION_CURSOR%found then
      DOC_ACCUMULATOR.DOC_TOTAL_POSITION(detail_position_tuple.GCO_GOOD_ID
                                       , detail_position_tuple.PAC_THIRD_ID
                                       , detail_position_tuple.DIC_GAUGE_TYPE_DOC_ID
                                       , :old.GCO_CHARACTERIZATION_ID
                                       , :old.GCO_GCO_CHARACTERIZATION_ID
                                       , :old.GCO2_GCO_CHARACTERIZATION_ID
                                       , :old.GCO3_GCO_CHARACTERIZATION_ID
                                       , :old.GCO4_GCO_CHARACTERIZATION_ID
                                       , :old.PDE_CHARACTERIZATION_VALUE_1
                                       , :old.PDE_CHARACTERIZATION_VALUE_2
                                       , :old.PDE_CHARACTERIZATION_VALUE_3
                                       , :old.PDE_CHARACTERIZATION_VALUE_4
                                       , :old.PDE_CHARACTERIZATION_VALUE_5
                                       , detail_position_tuple.GAP_DELAY
                                       , nvl(:old.PDE_FINAL_DELAY, detail_position_tuple.DMT_DATE_DOCUMENT)
                                       , detail_position_tuple.DMT_DATE_DOCUMENT
                                       , :old.PDE_FINAL_QUANTITY
                                       , :old.PDE_BALANCE_QUANTITY
                                       , detail_position_tuple.POS_NET_VALUE_EXCL_B
                                       , detail_position_tuple.C_DOC_POS_STATUS
                                       , detail_position_tuple.GAS_BALANCE_STATUS
                                       , detail_position_tuple.C_GAUGE_TYPE
                                       , -1
                                       , 0
                                        );
    end if;

    close DETAIL_POSITION_CURSOR;
  -- insertion dans le buffer des totalisateurs de position (maj différée)
  elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '2' then
    insert into DOC_POSI_ACCU_BUFFER
                (DOC_POSI_ACCU_BUFFER_ID
               , ABU_SIGN
               , C_DOC_POS_STATUS
               , C_GAUGE_TYPE
               , GCO_GOOD_ID
               , PAC_THIRD_ID
               , DIC_GAUGE_TYPE_DOC_ID
               , GCO_CHARACTERIZATION_ID
               , GCO_GCO_CHARACTERIZATION_ID
               , GCO2_GCO_CHARACTERIZATION_ID
               , GCO3_GCO_CHARACTERIZATION_ID
               , GCO4_GCO_CHARACTERIZATION_ID
               , ABU_CHARACTERIZATION_VALUE_1
               , ABU_CHARACTERIZATION_VALUE_2
               , ABU_CHARACTERIZATION_VALUE_3
               , ABU_CHARACTERIZATION_VALUE_4
               , ABU_CHARACTERIZATION_VALUE_5
               , ABU_DELAY
               , ABU_FINAL_DELAY
               , ABU_DOCUMENT_DATE
               , ABU_FINAL_QUANTITY
               , ABU_BALANCE_QUANTITY
               , ABU_NET_VALUE_EXCL
               , ABU_BALANCE_STATUS
                )
      select INIT_ID_SEQ.nextval
           , -1
           , POS.C_DOC_POS_STATUS
           , GAU.C_GAUGE_TYPE
           , POS.GCO_GOOD_ID
           , DOC.PAC_THIRD_ID
           , DOC.DIC_GAUGE_TYPE_DOC_ID
           , :old.GCO_CHARACTERIZATION_ID
           , :old.GCO_GCO_CHARACTERIZATION_ID
           , :old.GCO2_GCO_CHARACTERIZATION_ID
           , :old.GCO3_GCO_CHARACTERIZATION_ID
           , :old.GCO4_GCO_CHARACTERIZATION_ID
           , :old.PDE_CHARACTERIZATION_VALUE_1
           , :old.PDE_CHARACTERIZATION_VALUE_2
           , :old.PDE_CHARACTERIZATION_VALUE_3
           , :old.PDE_CHARACTERIZATION_VALUE_4
           , :old.PDE_CHARACTERIZATION_VALUE_5
           , GPO.GAP_DELAY
           , nvl(:old.PDE_FINAL_DELAY, DOC.DMT_DATE_DOCUMENT)
           , DOC.DMT_DATE_DOCUMENT
           , :old.PDE_FINAL_QUANTITY
           , :old.PDE_BALANCE_QUANTITY
           , POS.POS_NET_VALUE_EXCL_B
           , GST.GAS_BALANCE_STATUS
        from DOC_DOCUMENT DOC
           , DOC_POSITION POS
           , DOC_GAUGE_POSITION GPO
           , DOC_GAUGE_STRUCTURED GST
           , DOC_GAUGE GAU
       where POS.DOC_DOCUMENT_ID = DOC.DOC_DOCUMENT_ID
         and GPO.DOC_GAUGE_POSITION_ID = POS.DOC_GAUGE_POSITION_ID
         and POS.DOC_POSITION_ID = :old.DOC_POSITION_ID
         and GST.DOC_GAUGE_ID = DOC.DOC_GAUGE_ID
         and GAU.DOC_GAUGE_ID = GST.DOC_GAUGE_ID
         and POS.C_GAUGE_TYPE_POS in('1', '2', '3', '7', '8', '91', '101', '21');
  end if;
-- Si on passe dans cette exception, cela signifie que la mise à jour est faite à
-- partir du curseur DOC_DOC_BU  ou DOC_POS_BU
exception
  when ex.TABLE_MUTATING then
    null;
end DOC_PDE_AD_POSI_ACCU;

ALTER TRIGGER "C_ITX"."DOC_PDE_AD_POSI_ACCU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AD_PROV_QTY"
  after delete
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des quantités provisoires à l'effacement d'un détail de position
* @created fpe 01.01.1998
* @updated fpe 17.06.2014 - DEVERP-20671 Documents de transfert: Pas de quantité sortie provisoire si stock cible vide
*/
declare
  -- recherche du type de mouvement de stock et de l'id du bien d'aprSs la table des positions
  cursor crMovementKind(aCrPositionId number)
  is
    select MOK.C_MOVEMENT_SORT
         , MOK.MOK_STANDARD_SIGN
         , POS.GCO_GOOD_ID
         , MOK.STM_MOVEMENT_KIND_ID
         , MOK.STM_STM_MOVEMENT_KIND_ID
         , POS.POS_GENERATE_MOVEMENT
         , MOK.MOK_VERIFY_CHARACTERIZATION
         , POS.C_GAUGE_TYPE_POS
         , GAP.GAP_DESIGNATION
         , POS.STM_STOCK_ID
         , POS.STM_STM_STOCK_ID
         , POS.POS_CONVERT_FACTOR
         , GAS.GAS_ALL_CHARACTERIZATION
      from STM_MOVEMENT_KIND MOK
         , DOC_POSITION POS
         , DOC_GAUGE_POSITION GAP
         , DOC_GAUGE_STRUCTURED GAS
     where MOK.STM_MOVEMENT_KIND_ID = POS.STM_MOVEMENT_KIND_ID
       and POS.DOC_POSITION_ID = aCrPositionId
       and GAS.DOC_GAUGE_ID = POS.DOC_GAUGE_ID
       and POS.DOC_GAUGE_POSITION_ID = GAP.DOC_GAUGE_POSITION_ID
       and POS.C_GAUGE_TYPE_POS in('1', '2', '3', '7', '8', '71', '81', '91', '101')
       and POS.POS_GENERATE_MOVEMENT = 0;

  cursor crExtourneMovement(aCrParentDetailId number, aCrGaugeDetailId number)
  is
    select A.GCO_GOOD_ID
         , A.GCO_CHARACTERIZATION_ID
         , A.GCO_GCO_CHARACTERIZATION_ID
         , A.GCO2_GCO_CHARACTERIZATION_ID
         , A.GCO3_GCO_CHARACTERIZATION_ID
         , A.GCO4_GCO_CHARACTERIZATION_ID
         , A.SMO_CHARACTERIZATION_VALUE_1
         , A.SMO_CHARACTERIZATION_VALUE_2
         , A.SMO_CHARACTERIZATION_VALUE_3
         , A.SMO_CHARACTERIZATION_VALUE_4
         , A.SMO_CHARACTERIZATION_VALUE_5
         , A.STM_STOCK_ID
         , A.STM_LOCATION_ID
         , A.SMO_MOVEMENT_QUANTITY
         , C.C_MOVEMENT_SORT
         , C.MOK_STANDARD_SIGN
         , C.MOK_VERIFY_CHARACTERIZATION
         , C.STM_MOVEMENT_KIND_ID
         , C.STM_STM_MOVEMENT_KIND_ID
      from STM_STOCK_MOVEMENT A
         , DOC_GAUGE_RECEIPT B
         , STM_MOVEMENT_KIND C
     where B.DOC_GAUGE_RECEIPT_ID = aCrGaugeDetailId
       and B.GAR_EXTOURNE_MVT = 1
       and nvl(A.SMO_EXTOURNE_MVT, 0) = 0
       and A.DOC_POSITION_DETAIL_ID = aCrParentDetailId
       and C.STM_MOVEMENT_KIND_ID = A.STM_MOVEMENT_KIND_ID
       and C.C_MOVEMENT_TYPE <> 'EXE';

  vTplMovementKind           crMovementKind%rowtype;
  vTplOldExtourneMovement    crExtourneMovement%rowtype;
  vUpdateMode                varchar2(2);
  vMainStockId               STM_STOCK.STM_STOCK_ID%type;
  vTransStockId              STM_STOCK.STM_STOCK_ID%type;
  vDeleteProvisoryQuantities number(1);
  vMovementKindID            STM_MOVEMENT_KIND.STM_MOVEMENT_KIND_ID%type;
  vUseAllCharacterization    DOC_GAUGE_STRUCTURED.GAS_ALL_CHARACTERIZATION%type;
  vNoMove                    boolean                                              := false;
begin
  if :old.STM_LOCATION_ID is not null then
    -- recherche du type de mouvement de stock et de l'id du bien d'après la table des positions
    -- si le trigger est déclenché depuis en dessous, on part dans l'exception
    -- La mise à jour est déjà faite dans ce cas
    for vTplMovementKind in crMovementKind(:old.DOC_POSITION_ID) loop
      if     (nvl(vTplMovementKind.STM_STM_MOVEMENT_KIND_ID, 0) <> 0)
         and :old.STM_STM_LOCATION_ID is not null then   /* Mouvement de transfert (peux valoir 0) */
        if :old.STM_STM_LOCATION_ID is not null then   /* L'emplacement cible initial n'était pas vide avant l'effacement */
          if :old.STM_LOCATION_ID = :old.STM_STM_LOCATION_ID then
            vDeleteProvisoryQuantities  := 0;
          else   /* Pas de position assemblage */
            vDeleteProvisoryQuantities  := 1;
          end if;
        else   /* L'emplacement cible initial était vide avant l'effacement */
          vDeleteProvisoryQuantities  := 0;
        end if;
      else   /* Pas de mouvement de transfert */
        vDeleteProvisoryQuantities  := 1;
      end if;

      /**
      * Retrait des anciennes valeurs
      */
      if (vDeleteProvisoryQuantities = 1) then
        /* Recherche les stocks en fonction des emplacements. */
        select STM_STOCK_ID
          into vMainStockId
          from STM_LOCATION
         where STM_LOCATION_ID = :old.STM_LOCATION_ID;

        select max(STM_STOCK_ID)
          into vTransStockId
          from STM_LOCATION
         where STM_LOCATION_ID = :old.STM_STM_LOCATION_ID;

        -- Eventuellement traitement de l'extourne
        open crExtourneMovement(:old.DOC_DOC_POSITION_DETAIL_ID, :old.DOC_GAUGE_RECEIPT_ID);

        fetch crExtourneMovement
         into vTplOldExtourneMovement;

        /**
        * On différentie l'effacement simple de l'effacement de position obtenue
        * par copie ou décharge.
        *
        *   DD = effacement d'un détail lié (détail fils ou cible),
        *   D  = effacement d'un détail non lié
        */
        if :old.DOC_GAUGE_RECEIPT_ID is not null then   /* Le détail de position est issu d'une décharge */
          select max(GAP.STM_MOVEMENT_KIND_ID)
               , nvl(max(GAS.GAS_ALL_CHARACTERIZATION), 0)
            into vMovementKindID
               , vUseAllCharacterization
            from DOC_GAUGE_POSITION GAP
               , DOC_GAUGE_RECEIPT GAR
               , DOC_GAUGE_STRUCTURED GAS
           where GAR.DOC_GAUGE_RECEIPT_ID = :old.DOC_GAUGE_RECEIPT_ID
             and GAP.DOC_GAUGE_ID = GAR.DOC_DOC_GAUGE_ID
             and GAP.C_GAUGE_TYPE_POS = vTplMovementKind.C_GAUGE_TYPE_POS
             and GAP.GAP_DESIGNATION = vTplMovementKind.GAP_DESIGNATION
             and GAS.DOC_GAUGE_ID = GAP.DOC_GAUGE_ID;

          if vMovementKindID is not null then   /* Le détail parent est lié à un genre de mouvement */
            if vTplOldExtourneMovement.GCO_GOOD_ID = vTplMovementKind.GCO_GOOD_ID then
              vUpdateMode  := 'DD';
            else
              vUpdateMode  := 'D';
            end if;
          else
            if     (vUseAllCharacterization = 1)
               and (PCS.PC_CONFIG.GetConfig('DOC_CHARACTERIZATION_MODE') = '1') then   /* Le gabarit parent et la configuration gèrent tous les types de carctérisation */
              vUpdateMode  := 'DD';
            else
              vUpdateMode  := 'D';
            end if;
          end if;
        else
          vUpdateMode  := 'D';
        end if;

        -- en cas d'extourne sur le même emplacement avec le même genre de mouvement, on ne fait aucune mise à jour
        vNoMove  :=
              crExtourneMovement%found
          and (vTplOldExtourneMovement.C_MOVEMENT_SORT = vTplMovementKind.C_MOVEMENT_SORT)
          and (vTplOldExtourneMovement.MOK_STANDARD_SIGN = vTplMovementKind.MOK_STANDARD_SIGN)
          and (vTplOldExtourneMovement.STM_LOCATION_ID = :old.STM_LOCATION_ID)
          and (vTplOldExtourneMovement.GCO_GOOD_ID = vTplMovementKind.GCO_GOOD_ID)
          and vTplOldExtourneMovement.STM_STM_MOVEMENT_KIND_ID is null
          and (:old.PDE_MOVEMENT_QUANTITY =
                 sign(:old.PDE_MOVEMENT_QUANTITY) *
                 least(abs(:old.PDE_MOVEMENT_QUANTITY +(nvl(:old.PDE_BALANCE_QUANTITY_PARENT, 0) * vTplMovementKind.POS_CONVERT_FACTOR) )
                     , abs(vTplOldExtourneMovement.SMO_MOVEMENT_QUANTITY)
                      )
              );

        if not vNoMove then
          DOC_INIT_MOVEMENT.DOC_PROV_QTY(vTplMovementKind.GCO_GOOD_ID
                                       , vUpdateMode   -- Mode effacement (D ou DD)
                                       , vTplMovementKind.C_MOVEMENT_SORT
                                       , vTplMovementKind.MOK_VERIFY_CHARACTERIZATION
                                       , vTplMovementKind.STM_STM_MOVEMENT_KIND_ID
                                       , :old.GCO_CHARACTERIZATION_ID
                                       , :old.GCO_GCO_CHARACTERIZATION_ID
                                       , :old.GCO2_GCO_CHARACTERIZATION_ID
                                       , :old.GCO3_GCO_CHARACTERIZATION_ID
                                       , :old.GCO4_GCO_CHARACTERIZATION_ID
                                       , :old.PDE_CHARACTERIZATION_VALUE_1
                                       , :old.PDE_CHARACTERIZATION_VALUE_2
                                       , :old.PDE_CHARACTERIZATION_VALUE_3
                                       , :old.PDE_CHARACTERIZATION_VALUE_4
                                       , :old.PDE_CHARACTERIZATION_VALUE_5
                                       , vMainStockId
                                       , :old.STM_LOCATION_ID
                                       , vTransStockId
                                       , :old.STM_STM_LOCATION_ID
                                       , :old.PDE_MOVEMENT_QUANTITY *(-1)
                                        );

          -- Eventuellement traitement de l'extourne
          if crExtourneMovement%found then
            -- Retrait des quantités provisoires de l'extourne
            DOC_INIT_MOVEMENT.DOC_PROV_QTY(vTplOldExtourneMovement.GCO_GOOD_ID
                                         , vUpdateMode   -- Mode effacement (D ou DD)
                                         , vTplOldExtourneMovement.C_MOVEMENT_SORT
                                         , vTplOldExtourneMovement.MOK_VERIFY_CHARACTERIZATION
                                         , vTplOldExtourneMovement.STM_STM_MOVEMENT_KIND_ID
                                         , vTplOldExtourneMovement.GCO_CHARACTERIZATION_ID
                                         , vTplOldExtourneMovement.GCO_GCO_CHARACTERIZATION_ID
                                         , vTplOldExtourneMovement.GCO2_GCO_CHARACTERIZATION_ID
                                         , vTplOldExtourneMovement.GCO3_GCO_CHARACTERIZATION_ID
                                         , vTplOldExtourneMovement.GCO4_GCO_CHARACTERIZATION_ID
                                         , vTplOldExtourneMovement.SMO_CHARACTERIZATION_VALUE_1
                                         , vTplOldExtourneMovement.SMO_CHARACTERIZATION_VALUE_2
                                         , vTplOldExtourneMovement.SMO_CHARACTERIZATION_VALUE_3
                                         , vTplOldExtourneMovement.SMO_CHARACTERIZATION_VALUE_4
                                         , vTplOldExtourneMovement.SMO_CHARACTERIZATION_VALUE_5
                                         , vTplOldExtourneMovement.STM_STOCK_ID
                                         , vTplOldExtourneMovement.STM_LOCATION_ID
                                         , null
                                         , null
                                         , sign(:old.PDE_MOVEMENT_QUANTITY) *
                                           least(abs(:old.PDE_MOVEMENT_QUANTITY
                                                     +(nvl(:old.PDE_BALANCE_QUANTITY_PARENT, 0) * vTplMovementKind.POS_CONVERT_FACTOR) )
                                               , abs(vTplOldExtourneMovement.SMO_MOVEMENT_QUANTITY)
                                                )
                                          );
          end if;
        end if;

        close crExtourneMovement;
      end if;
    end loop;
  end if;
/**
* Si on passe dans cette exception, cela signifie que la mise à jour est faite à
* partir du trigger DOC_DMT_BD_PROV_QTY ou DOC_POS_BD_PROV_QTY
*/
exception
  when ex.TABLE_MUTATING then
    null;
end DOC_PDE_AD_PROV_QTY;

ALTER TRIGGER "C_ITX"."DOC_PDE_AD_PROV_QTY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AI_FORNETWORK"
  after insert
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
declare
  aPositionStatus           DOC_POSITION.C_DOC_POS_STATUS%type;
  aPositionType             DOC_POSITION.C_GAUGE_TYPE_POS%type;
  aConvertFactor            DOC_POSITION.POS_CONVERT_FACTOR%type;
  aGaugeType                DOC_GAUGE.C_GAUGE_TYPE%type;
  aPOS_TRANSFERT_PROPRIETOR DOC_POSITION.POS_TRANSFERT_PROPRIETOR%type;
  aGCO_GOOD_ID              GCO_GOOD.GCO_GOOD_ID%type;
  aPAC_REPRESENTATIVE_ID    PAC_REPRESENTATIVE.PAC_REPRESENTATIVE_ID%type;
  aPAC_THIRD_ID             PAC_THIRD.PAC_THIRD_ID%type;
  aDIC_PIC_GROUP_ID         DIC_PIC_GROUP.DIC_PIC_GROUP_ID%type;
  aGasUpdatePicOrderQty     DOC_GAUGE_STRUCTURED.GAS_UPDATE_PIC_ORDER_QTY%type;

  cursor CurPAC_CUSTOM_PARTNER(PrmPAC_THIRD_ID PAC_THIRD.PAC_THIRD_ID%type)
  is
    select DIC_PIC_GROUP_ID
      from PAC_CUSTOM_PARTNER
     where PAC_CUSTOM_PARTNER_ID = PrmPAC_THIRD_ID;

  aNEW                      DOC_POSITION_DETAIL%rowtype;
  aOLD                      DOC_POSITION_DETAIL%rowtype;
  aDateValue                date;
  lvFanDescr                FAL_NETWORK_SUPPLY.FAN_DESCRIPTION%type;
  lnNumberOfDecimal         GCO_GOOD.GOO_NUMBER_OF_DECIMAL%type;
  lnBalanceQtySU            DOC_POSITION_DETAIL.PDE_FINAL_QUANTITY_SU%type;
begin
  -- Vérifier que les réseaux Logiqistiques sont activés
  if not FAL_NETWORK_DOC.IsDOCNetWorkEnabled then
    return;
  end if;

  -- Récupérer le status, le type et le facteur de conversion, le produit, le representant, le tiers de la position maître
  select POS.C_DOC_POS_STATUS
       , POS.C_GAUGE_TYPE_POS
       , POS.POS_CONVERT_FACTOR
       , POS.GCO_GOOD_ID
       , POS.PAC_REPRESENTATIVE_ID
       , POS.PAC_THIRD_ID
       , POS.POS_TRANSFERT_PROPRIETOR
       , DMT.DMT_NUMBER || ' / ' || POS.POS_NUMBER
    into aPositionStatus
       , aPositionType
       , aConvertFactor
       , aGCO_GOOD_ID
       , aPAC_REPRESENTATIVE_ID
       , aPAC_THIRD_ID
       , aPOS_TRANSFERT_PROPRIETOR
       , lvFanDescr
    from DOC_POSITION POS
       , DOC_DOCUMENT DMT
   where POS.DOC_POSITION_ID = :new.DOC_POSITION_ID
     and DMT.DOC_DOCUMENT_ID = POS.DOC_DOCUMENT_ID;

  -- Récupérer le type de gabarit du document, ainsi que le Flag de MAJ de la Qté commande PIC
  begin
    select GAU.C_GAUGE_TYPE
         , GAS.GAS_UPDATE_PIC_ORDER_QTY
      into aGaugeType
         , aGasUpdatePicOrderQty
      from DOC_GAUGE_STRUCTURED GAS
         , DOC_GAUGE GAU
     where GAU.DOC_GAUGE_ID = :new.DOC_GAUGE_ID
       and GAU.DOC_GAUGE_ID = GAS.DOC_GAUGE_ID;
  exception
    when no_data_found then
      begin
        aGaugeType             := '';
        aGasUpdatePicOrderQty  := 0;
      end;
  end;

  -- Récupération du DIC_PIC_GROUP_ID via le PAC_THIRD_ID
  aDIC_PIC_GROUP_ID  := null;

  if aPAC_THIRD_ID is not null then
    open CurPAC_CUSTOM_PARTNER(aPAC_THIRD_ID);

    fetch CurPAC_CUSTOM_PARTNER
     into aDIC_PIC_GROUP_ID;

    close CurPAC_CUSTOM_PARTNER;
  end if;

  -- Prise en compte des document de type Autre (standard BL_non-confirmés) dans
  -- la quantité en commande PIC
  if     aGaugeType = '3'
     and aPositionStatus = '01'
     and to_number(PCS.PC_CONFIG.GetConfig('FAL_PIC') ) in(2, 3)
     and FAL_TOOLS.IsLocationOnStockNeedPic(:new.STM_LOCATION_ID)
     and aGasUpdatePicOrderQty = 1
     and aPositionType in('1', '2', '3', '71', '81', '91', '101') then
    -- Ce n'est pas le le PDE_BASIS_DELAY dans ce cas mais la date valeur du document
    select dmt_date_value
      into aDateValue
      from doc_document
     where doc_document_id = :new.doc_document_id;

    FAL_PLAN_DIRECTEUR.ProcessusMajQteCmdPicLine(aGCO_GOOD_ID
                                               , aDateValue
                                               , :new.PAC_THIRD_ID
                                               , aPAC_REPRESENTATIVE_ID
                                               , :new.PDE_BALANCE_QUANTITY
                                               , aDIC_PIC_GROUP_ID
                                                );
  end if;

  -- Vérifier que le status de la position maître est Solder (02) ou SolderPartiellement (03)
  if    (aPositionStatus = '02')
     or (aPositionStatus = '03') then
    -- Vérifier que le type de la position maître est Bien (1), Bien avec nomenclature informative (2),
    -- ou Bien avec nomenclature active (3) ansi que tous les types de position kit ou assemblage
    if (aPositionType in('1', '2', '3', '7', '8', '9', '10', '71', '81', '91', '101') ) then
      -- Copier :NEW dans un record pour le passer en paramètres aux procédures
      aNEW.DOC_POSITION_DETAIL_ID        := :new.DOC_POSITION_DETAIL_ID;
      aNEW.DOC_GAUGE_FLOW_ID             := :new.DOC_GAUGE_FLOW_ID;
      aNEW.DOC_POSITION_ID               := :new.DOC_POSITION_ID;
      aNEW.DOC_DOC_POSITION_DETAIL_ID    := :new.DOC_DOC_POSITION_DETAIL_ID;
      aNEW.DOC2_DOC_POSITION_DETAIL_ID   := :new.DOC2_DOC_POSITION_DETAIL_ID;
      aNEW.PDE_BASIS_DELAY               := :new.PDE_BASIS_DELAY;
      aNEW.PDE_BASIS_DELAY_W             := :new.PDE_BASIS_DELAY_W;
      aNEW.PDE_BASIS_DELAY_M             := :new.PDE_BASIS_DELAY_M;
      aNEW.PDE_INTERMEDIATE_DELAY        := :new.PDE_INTERMEDIATE_DELAY;
      aNEW.PDE_INTERMEDIATE_DELAY_W      := :new.PDE_INTERMEDIATE_DELAY_W;
      aNEW.PDE_INTERMEDIATE_DELAY_M      := :new.PDE_INTERMEDIATE_DELAY_M;
      aNEW.PDE_FINAL_DELAY               := :new.PDE_FINAL_DELAY;
      aNEW.PDE_FINAL_DELAY_W             := :new.PDE_FINAL_DELAY_W;
      aNEW.PDE_FINAL_DELAY_M             := :new.PDE_FINAL_DELAY_M;
      aNEW.PDE_BASIS_QUANTITY            := :new.PDE_BASIS_QUANTITY;
      aNEW.PDE_INTERMEDIATE_QUANTITY     := :new.PDE_INTERMEDIATE_QUANTITY;
      aNEW.PDE_FINAL_QUANTITY            := :new.PDE_FINAL_QUANTITY;
      aNEW.PDE_BASIS_QUANTITY_SU         := :new.PDE_BASIS_QUANTITY_SU;
      aNEW.PDE_INTERMEDIATE_QUANTITY_SU  := :new.PDE_INTERMEDIATE_QUANTITY_SU;
      aNEW.PDE_FINAL_QUANTITY_SU         := :new.PDE_FINAL_QUANTITY_SU;
      aNEW.PDE_BALANCE_QUANTITY          := :new.PDE_BALANCE_QUANTITY;
      aNEW.PDE_MOVEMENT_QUANTITY         := :new.PDE_MOVEMENT_QUANTITY;
      aNEW.PDE_MOVEMENT_VALUE            := :new.PDE_MOVEMENT_VALUE;
      aNEW.PDE_CHARACTERIZATION_VALUE_1  := :new.PDE_CHARACTERIZATION_VALUE_1;
      aNEW.PDE_CHARACTERIZATION_VALUE_2  := :new.PDE_CHARACTERIZATION_VALUE_2;
      aNEW.PDE_CHARACTERIZATION_VALUE_3  := :new.PDE_CHARACTERIZATION_VALUE_3;
      aNEW.PDE_CHARACTERIZATION_VALUE_4  := :new.PDE_CHARACTERIZATION_VALUE_4;
      aNEW.PDE_CHARACTERIZATION_VALUE_5  := :new.PDE_CHARACTERIZATION_VALUE_5;
      aNEW.GCO_CHARACTERIZATION_ID       := :new.GCO_CHARACTERIZATION_ID;
      aNEW.GCO_GCO_CHARACTERIZATION_ID   := :new.GCO_GCO_CHARACTERIZATION_ID;
      aNEW.GCO2_GCO_CHARACTERIZATION_ID  := :new.GCO2_GCO_CHARACTERIZATION_ID;
      aNEW.GCO3_GCO_CHARACTERIZATION_ID  := :new.GCO3_GCO_CHARACTERIZATION_ID;
      aNEW.GCO4_GCO_CHARACTERIZATION_ID  := :new.GCO4_GCO_CHARACTERIZATION_ID;
      aNEW.STM_LOCATION_ID               := :new.STM_LOCATION_ID;
      aNEW.STM_STM_LOCATION_ID           := :new.STM_STM_LOCATION_ID;
      aNEW.GCO_GOOD_ID                   := :new.GCO_GOOD_ID;

      if (aPositionType in('7', '8', '9', '10') ) then
        -- Vérifier que le type de gabarit est approvisionnement (2)
        if aGaugeType = '2' then
          -- Empecher la création de réseaux avec Qtés négatives ou nulles.
          if nvl(aNEW.PDE_BALANCE_QUANTITY, 0) > 0 then
            -- Processus : Création RéseauxLogAppro
            FAL_NETWORK_DOC.ReseauApproDOC_Creation(aPositionDetail     => aNEW
                                                  , pDocumentID         => null
                                                  , pGoodID             => null
                                                  , pDocRecordID        => null
                                                  , pConversionFactor   => null
                                                  , iDescription        => lvFanDescr
                                                   );
          end if;
        end if;

        -- Vérifier que le type de gabarit est besoin (1)
        if aGaugeType = '1' then
          -- Empecher la création de réseaux avec Qtés négatives ou nulles.
          if nvl(aNEW.PDE_BALANCE_QUANTITY, 0) > 0 then
            -- Processus : Création RéseauxLogBesoin
            FAL_NETWORK_DOC.ReseauBesoinDOC_Creation(aPositionDetail          => aNEW
                                                   , pDocumentID              => null
                                                   , pGoodID                  => null
                                                   , pDocRecordID             => null
                                                   , pConversionFactor        => null
                                                   , pPAC_REPRESENTATIVE_ID   => null
                                                   , iDescription             => lvFanDescr
                                                    );
            -- Processus : Création RéseauxLogAppro
            aNEW.PDE_FINAL_DELAY  := aNEW.PDE_BASIS_DELAY;
            FAL_NETWORK_DOC.ReseauApproDOC_Creation(aPositionDetail     => aNEW
                                                  , pDocumentID         => null
                                                  , pGoodID             => null
                                                  , pDocRecordID        => null
                                                  , pConversionFactor   => null
                                                  , iDescription        => lvFanDescr
                                                   );
            -- Déterminer la quantité solde en unité de stockage
            -- Recherche également le nombre de décimal sur le bien pour arrondir supérieure la quantité solde en unité de stockage
            lnNumberOfDecimal     := GCO_I_LIB_FUNCTIONS.GetNumberOfDecimal(:new.GCO_GOOD_ID);
            lnBalanceQtySU        := ACS_FUNCTION.RoundNear(:new.PDE_BALANCE_QUANTITY * aConvertFactor, 1 / power(10, lnNumberOfDecimal), 1);
            -- Graphe : Création Attribution Besoin/Appro ou Appro/Besoin
            FAl_NETWORK.CreateAttribBesoinAppro(FAL_NETWORK_DOC.glbNewBesoinID, FAL_NETWORK_DOC.glbNewApproID, lnBalanceQtySU);
          end if;

          if     to_number(PCS.PC_CONFIG.GetConfig('FAL_PIC') ) in(2, 3)
             and FAL_TOOLS.IsLocationOnStockNeedPic(:new.STM_LOCATION_ID)
             and aGasUpdatePicOrderQty = 1 then
            -- Ce n'est pas le PDE_FINAL_DELAY qu'il faut prendre mais le PDE_BASIS_DELAY
            FAL_PLAN_DIRECTEUR.ProcessusMajQteCmdPicLine(aGCO_GOOD_ID
                                                       , :new.PDE_BASIS_DELAY
                                                       , :new.PAC_THIRD_ID
                                                       , aPAC_REPRESENTATIVE_ID
                                                       , :new.PDE_BALANCE_QUANTITY
                                                       , aDIC_PIC_GROUP_ID
                                                        );
          end if;
        end if;
      end if;

      if aPositionType in('1', '2', '3', '71', '81', '91', '101') then
        -- Est-ce un bien et la position a t'elle une durée pour le transfert du stock propriétaire
        -- Note il faut bien entendu faire ce test en premier
        if     (aGaugeType = '1')
           and (aPOS_TRANSFERT_PROPRIETOR = 1) then
          -- Empecher la création de réseaux avec Qtés négatives ou nulles.
          if nvl(aNEW.PDE_BALANCE_QUANTITY, 0) > 0 then
            -- Processus : Création RéseauxLogBesoin
            FAL_NETWORK_DOC.ReseauBesoinDOC_Creation(aPositionDetail          => aNEW
                                                   , pDocumentID              => null
                                                   , pGoodID                  => null
                                                   , pDocRecordID             => null
                                                   , pConversionFactor        => null
                                                   , pPAC_REPRESENTATIVE_ID   => null
                                                   , iDescription             => lvFanDescr
                                                    );
            -- Processus : Création RéseauxLogAppro
            -- Pour ce cas , l'appro doit être sur le stock de transfert, c'est une exception
            aNEW.STM_LOCATION_ID  := aNEW.STM_STM_LOCATION_ID;
            FAL_NETWORK_DOC.ReseauApproDOC_Creation(aPositionDetail     => aNEW
                                                  , pDocumentID         => null
                                                  , pGoodID             => null
                                                  , pDocRecordID        => null
                                                  , pConversionFactor   => null
                                                  , iDescription        => lvFanDescr
                                                   );
          end if;
        -- Pour permettre la création de position 7 et 8 en achat
        elsif    (aGaugeType = 1)
              or (     (aGaugeType = 2)
                  and (aPositionType in('71', '81') ) ) then
          -- Empecher la création de réseaux avec Qtés négatives ou nulles.
          if nvl(aNEW.PDE_BALANCE_QUANTITY, 0) > 0 then
            -- Processus : Création RéseauxLogBesoin
            FAL_NETWORK_DOC.ReseauBesoinDOC_Creation(aPositionDetail          => aNEW
                                                   , pDocumentID              => null
                                                   , pGoodID                  => null
                                                   , pDocRecordID             => null
                                                   , pConversionFactor        => null
                                                   , pPAC_REPRESENTATIVE_ID   => null
                                                   , iDescription             => lvFanDescr
                                                    );
          end if;

          -- Seulement si le type de gabarit est besoin (1)
          if     aGaugeType = '1'
             and to_number(PCS.PC_CONFIG.GetConfig('FAL_PIC') ) in(2, 3)
             and FAL_TOOLS.IsLocationOnStockNeedPic(:new.STM_LOCATION_ID)
             and aGasUpdatePicOrderQty = 1 then
            -- Ce n'est pas le PDE_FINAL_DELAY qu'il faut prendre mais le PDE_BASIS_DELAY
            FAL_PLAN_DIRECTEUR.ProcessusMajQteCmdPicLine(aGCO_GOOD_ID
                                                       , :new.PDE_BASIS_DELAY
                                                       , :new.PAC_THIRD_ID
                                                       , aPAC_REPRESENTATIVE_ID
                                                       , :new.PDE_BALANCE_QUANTITY
                                                       , aDIC_PIC_GROUP_ID
                                                        );
          end if;
        elsif     (aGaugeType = '2')
              and (aPositionType not in('71', '81') ) then
          -- Empecher la création de réseaux avec Qtés négatives ou nulles.
          if nvl(aNEW.PDE_BALANCE_QUANTITY, 0) > 0 then
            -- Processus : Création RéseauxLogAppro
            FAL_NETWORK_DOC.ReseauApproDOC_Creation(aPositionDetail     => aNEW
                                                  , pDocumentID         => null
                                                  , pGoodID             => null
                                                  , pDocRecordID        => null
                                                  , pConversionFactor   => null
                                                  , iDescription        => lvFanDescr
                                                   );
          end if;
        end if;
      end if;
    end if;
  end if;
end DOC_PDE_AI_FORNETWORK;

ALTER TRIGGER "C_ITX"."DOC_PDE_AI_FORNETWORK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AI_MULTISOURCING"
  after insert
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Déclenche le traitement de mise à jour du multi-sourcing réalisé. Les règles suivantes doivent être respectées :
*
*    1. Le bien doit gérer le multi-sourcing (GCO_PRODUCT.PDT_MULTI_SOURCING = 1).
*    2. Le gabarit doit gérer le multi-sourcing (DOC_GAUGE_STRUCTURED.GAS_MULTISOURCING_MGM = 1).
*    3. La quantité ou le produit fabriqué ont changé
*
* @author VJ
* @created 15/03/2005
* @version 2003
*/
declare
  posNetUnitValueExclB DOC_POSITION.POS_NET_UNIT_VALUE%type;
  gcoGoodID            GCO_GOOD.GCO_GOOD_ID%type;
  docDocumentID        DOC_DOCUMENT.DOC_DOCUMENT_ID%type;
  dmtNumber            DOC_DOCUMENT.DMT_NUMBER%type;
  strInfo              varchar2(2000);
begin
  if (nvl(:new.PDE_FINAL_QUANTITY_SU, 0) <> 0) then
    -- Recherche la valeur net
    begin
      select decode(nvl(POS.POS_FINAL_QUANTITY_SU, 0), 0, 0, POS.POS_NET_VALUE_EXCL_B / POS.POS_FINAL_QUANTITY_SU)
                                                                                              POS_NET_UNIT_VALUE_EXCL_B
           , POS.DOC_DOCUMENT_ID
           , POS.GCO_GOOD_ID
           , DMT.DMT_NUMBER
        into posNetUnitValueExclB
           , docDocumentID
           , gcoGoodID
           , dmtNumber
        from DOC_POSITION POS
           , DOC_DOCUMENT DMT
           , GCO_PRODUCT PDT
           , DOC_GAUGE_STRUCTURED GAS
       where POS.DOC_POSITION_ID = :new.DOC_POSITION_ID
         and PDT.GCO_GOOD_ID = POS.GCO_GOOD_ID
         and DMT.DOC_DOCUMENT_ID = POS.DOC_DOCUMENT_ID
         and nvl(PDT.PDT_MULTI_SOURCING, 0) = 1
         and GAS.DOC_GAUGE_ID = POS.DOC_GAUGE_ID
         and nvl(GAS.GAS_MULTISOURCING_MGM, 0) = 1;
    exception
      when no_data_found then
        posNetUnitValueExclB  := null;
    end;

    if posNetUnitValueExclB is not null then
      if false then
        strInfo  :=
          'DOC_PDE_AI_MULTISOURCING' ||
          chr(13) ||
          chr(13) ||
          'Document : ' ||
          docDocumentID ||
          chr(13) ||
          'Bien : ' ||
          gcoGoodID ||
          chr(13) ||
          'Prix unitaire net ht : ' ||
          posNetUnitValueExclB ||
          chr(13) ||
          'Quantité : ' ||
          :new.PDE_FINAL_QUANTITY_SU ||
          chr(13) ||
          'Montant : ' ||
          posNetUnitValueExclB * :new.PDE_FINAL_QUANTITY_SU;
        DOC_FUNCTIONS.CreateHistoryInformation(:new.DOC_DOCUMENT_ID
                                             , :new.DOC_POSITION_ID   -- DOC_POSITION_ID
                                             , dmtNumber   -- no de document
                                             , 'PLSQL'   -- DUH_TYPE
                                             , 'Getting detail informations DOC_PDE_AI_MULTISOURCING : ' ||
                                               :new.DOC_POSITION_DETAIL_ID
                                             , strInfo   -- description libre
                                             , null   -- status document
                                             , null   -- status position
                                              );
      end if;

      --
      -- Mise à jour du réalisé en multi-sourcing
      --
      FAL_MSOURCING_FUNCTIONS.UpdateMultiSourcingRealized(docDocumentID
                                                        , gcoGoodID
                                                        , :new.GCO_GCO_GOOD_ID
                                                        , null
                                                        , :new.PDE_FINAL_QUANTITY_SU
                                                        , 0
                                                        , posNetUnitValueExclB
                                                        , 0
                                                         );
    end if;
  end if;
end DOC_PDE_AI_MULTISOURCING;


ALTER TRIGGER "C_ITX"."DOC_PDE_AI_MULTISOURCING" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AI_NO_MORPH_CHAR"
  after insert
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour de la table des numéros (pièce, lot et chronologique) et contrôle
*    éventuel de l'unicité des caractérisations lors de la création d'un détail
*    de position.
* @author VJ
* @created 07.05.2002
* @version 2003
* @lastUpdate
*/
declare
  vMovementSort     STM_MOVEMENT_KIND.C_MOVEMENT_SORT%type;
  vMovementKindID   STM_MOVEMENT_KIND.STM_MOVEMENT_KIND_ID%type;
  vElementNumberID1 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vElementNumberID2 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vElementNumberID3 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  lQualityStatusId  STM_ELEMENT_NUMBER.GCO_QUALITY_STATUS_ID%type;
  vRecordElemNbrID  STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  lAllChar          DOC_GAUGE_STRUCTURED.GAS_ALL_CHARACTERIZATION%type;
begin
  select POS.STM_MOVEMENT_KIND_ID
    into vMovementKindID
    from DOC_POSITION POS
   where POS.DOC_POSITION_ID = :new.DOC_POSITION_ID;

  if (    :new.STM_LOCATION_ID is not null
      and (   vMovementKindID is null
           or :new.PDE_MOVEMENT_QUANTITY = 0) ) then
    -- Recherche du type de mouvement en fonction du domaine
    select decode(GAU.C_ADMIN_DOMAIN, '1', 'ENT',   -- Achat
                  '2', 'SOR',   -- Vente
                  '')
         , GAS_ALL_CHARACTERIZATION
      into vMovementSort
         , lAllChar
      from DOC_GAUGE GAU
         , DOC_GAUGE_STRUCTURED GAS
     where GAU.DOC_GAUGE_ID = :new.DOC_GAUGE_ID
       and GAS.DOC_GAUGE_ID = GAU.DOC_GAUGE_ID;

    -- traitement effectué seulement dans le cas ou l'on gère les caractérisations non-morphologiques
    if lAllChar = 1 then
      /**
      * Mise à jour de la table element_number et récupération des ID
      *
      * Remarques :
      *
      *  Le status de l'élement est définit dans la fonction (null transmis).
      *
      *  Il faut transmettre les ID et les valeurs de caractérisation sans
      *  tenir compte de l'éventuel non gestion en stock de celles-ci.
      */
      STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => :new.GCO_GOOD_ID   -- Bien
                                              , iUpdateMode               => 'I'   -- Mode de mise à jour
                                              , iMovementSort             => vMovementSort   -- Type de mouvement 'ENT' = Entrée 'SOR' = Sortie
                                              , iCharacterizationId       => :new.GCO_CHARACTERIZATION_ID   -- Caractérisation 1
                                              , iCharacterization2Id      => :new.GCO_GCO_CHARACTERIZATION_ID
                                              , iCharacterization3Id      => :new.GCO2_GCO_CHARACTERIZATION_ID
                                              , iCharacterization4Id      => :new.GCO3_GCO_CHARACTERIZATION_ID
                                              , iCharacterization5Id      => :new.GCO4_GCO_CHARACTERIZATION_ID
                                              , iCharacterizationValue1   => :new.PDE_CHARACTERIZATION_VALUE_1   -- Valeur de caractérisation 1
                                              , iCharacterizationValue2   => :new.PDE_CHARACTERIZATION_VALUE_2
                                              , iCharacterizationValue3   => :new.PDE_CHARACTERIZATION_VALUE_3
                                              , iCharacterizationValue4   => :new.PDE_CHARACTERIZATION_VALUE_4
                                              , iCharacterizationValue5   => :new.PDE_CHARACTERIZATION_VALUE_5
                                              , iVerifyChar               => 1   -- Vérification de l'unicité des valeurs de caract.
                                              , iElementStatus            => null   -- Statut de l'élement après mise à jour
                                              , ioElementNumberId1        => vElementNumberID1   -- Elément 1 en sortie
                                              , ioElementNumberId2        => vElementNumberID2   -- Elément 2 en sortie
                                              , ioElementNumberId3        => vElementNumberID3   -- Elément 3 en sortie
                                              , ioQualityStatusId         => lQualityStatusId
                                               );

      -- Si le dossier est renseigné et qu'il y a une valeur de caractérisation
      -- il faut màj le dossier avec le numéro de série du détail
      if     (:new.DOC_RECORD_ID is not null)
         and (    (vElementNumberID1 is not null)
              or (vElementNumberID2 is not null)
              or (vElementNumberID3 is not null) ) then
        -- Màj du dossier avec le numéro de série du détail
        -- Vérifier s'il y a déjà un num de série sur le dossier
        begin
          select STM_ELEMENT_NUMBER_ID
            into vRecordElemNbrID
            from DOC_RECORD
           where DOC_RECORD_ID = :new.DOC_RECORD_ID;
        exception
          when no_data_found then
            vRecordElemNbrID  := -1;
        end;

        -- Si pas de numero de série sur le dossier
        if vRecordElemNbrID is null then
          -- Màj du dossier avec le numéro de série du détail
          select max(STM_ELEMENT_NUMBER_ID)
            into vRecordElemNbrID
            from STM_ELEMENT_NUMBER
           where GCO_GOOD_ID = :new.GCO_GOOD_ID
             and C_ELEMENT_TYPE = '02'
             and STM_ELEMENT_NUMBER_ID in(vElementNumberID1, vElementNumberID2, vElementNumberID3);

          if vRecordElemNbrID is not null then
            update DOC_RECORD
               set STM_ELEMENT_NUMBER_ID = vRecordElemNbrID
             where DOC_RECORD_ID = :new.DOC_RECORD_ID;
          end if;
        end if;
      end if;
    end if;
  end if;
end DOC_PDE_AI_NO_MORPH_CHAR;

ALTER TRIGGER "C_ITX"."DOC_PDE_AI_NO_MORPH_CHAR" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AI_POSI_ACCU"
  after insert
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    mise à jour de la table des détails de position
* @author Fabrice Perotto
* @version 2003
*/
declare
  -- Curseur de détail des positions du document
  cursor DETAIL_POSITION_CURSOR(doc_pos_id number)
  is
    select POS.GCO_GOOD_ID
         , DOC.PAC_THIRD_ID
         , DOC.DIC_GAUGE_TYPE_DOC_ID
         , GPO.GAP_DELAY
         , DOC.DMT_DATE_DOCUMENT
         , POS.POS_NET_VALUE_EXCL_B
         , POS.C_DOC_POS_STATUS
         , POS.C_GAUGE_TYPE_POS
         , GST.GAS_BALANCE_STATUS
         , GAU.C_GAUGE_TYPE
      from DOC_DOCUMENT DOC
         , DOC_POSITION POS
         , DOC_GAUGE_POSITION GPO
         , DOC_GAUGE_STRUCTURED GST
         , DOC_GAUGE GAU
     where POS.DOC_DOCUMENT_ID = DOC.DOC_DOCUMENT_ID
       and GPO.DOC_GAUGE_POSITION_ID = POS.DOC_GAUGE_POSITION_ID
       and POS.DOC_POSITION_ID = doc_pos_id
       and GST.DOC_GAUGE_ID = DOC.DOC_GAUGE_ID
       and GAU.DOC_GAUGE_ID = GST.DOC_GAUGE_ID
       and POS.C_GAUGE_TYPE_POS in('1', '2', '3', '7', '8', '91', '101', '21');

  detail_position_tuple DETAIL_POSITION_CURSOR%rowtype;
begin
  -- pas de mise à jour des totalisateurs (possible uniquement par recalcul global)
  if PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '0' then
    null;
  -- mise à jour instantannée des totalisateurs de position
  elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '1' then
    -- Ouverture du curseur de détail du document
    open DETAIL_POSITION_CURSOR(:new.DOC_POSITION_ID);

    -- Première position de détail
    fetch detail_position_cursor
     into detail_position_tuple;

    if DETAIL_POSITION_CURSOR%found then
      DOC_ACCUMULATOR.DOC_TOTAL_POSITION(detail_position_tuple.GCO_GOOD_ID
                                       , detail_position_tuple.PAC_THIRD_ID
                                       , detail_position_tuple.DIC_GAUGE_TYPE_DOC_ID
                                       , :new.GCO_CHARACTERIZATION_ID
                                       , :new.GCO_GCO_CHARACTERIZATION_ID
                                       , :new.GCO2_GCO_CHARACTERIZATION_ID
                                       , :new.GCO3_GCO_CHARACTERIZATION_ID
                                       , :new.GCO4_GCO_CHARACTERIZATION_ID
                                       , :new.PDE_CHARACTERIZATION_VALUE_1
                                       , :new.PDE_CHARACTERIZATION_VALUE_2
                                       , :new.PDE_CHARACTERIZATION_VALUE_3
                                       , :new.PDE_CHARACTERIZATION_VALUE_4
                                       , :new.PDE_CHARACTERIZATION_VALUE_5
                                       , detail_position_tuple.GAP_DELAY
                                       , nvl(:new.PDE_FINAL_DELAY, detail_position_tuple.DMT_DATE_DOCUMENT)
                                       , detail_position_tuple.DMT_DATE_DOCUMENT
                                       , :new.PDE_FINAL_QUANTITY
                                       , :new.PDE_BALANCE_QUANTITY
                                       , detail_position_tuple.POS_NET_VALUE_EXCL_B
                                       , detail_position_tuple.C_DOC_POS_STATUS
                                       , detail_position_tuple.GAS_BALANCE_STATUS
                                       , detail_position_tuple.C_GAUGE_TYPE
                                       , 1
                                       , 0
                                        );
    end if;

    close DETAIL_POSITION_CURSOR;
  -- insertion dans le buffer des totalisateurs de position (maj différée)
  elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '2' then
    insert into DOC_POSI_ACCU_BUFFER
                (DOC_POSI_ACCU_BUFFER_ID
               , ABU_SIGN
               , C_DOC_POS_STATUS
               , C_GAUGE_TYPE
               , GCO_GOOD_ID
               , PAC_THIRD_ID
               , DIC_GAUGE_TYPE_DOC_ID
               , GCO_CHARACTERIZATION_ID
               , GCO_GCO_CHARACTERIZATION_ID
               , GCO2_GCO_CHARACTERIZATION_ID
               , GCO3_GCO_CHARACTERIZATION_ID
               , GCO4_GCO_CHARACTERIZATION_ID
               , ABU_CHARACTERIZATION_VALUE_1
               , ABU_CHARACTERIZATION_VALUE_2
               , ABU_CHARACTERIZATION_VALUE_3
               , ABU_CHARACTERIZATION_VALUE_4
               , ABU_CHARACTERIZATION_VALUE_5
               , ABU_DELAY
               , ABU_FINAL_DELAY
               , ABU_DOCUMENT_DATE
               , ABU_FINAL_QUANTITY
               , ABU_BALANCE_QUANTITY
               , ABU_NET_VALUE_EXCL
               , ABU_BALANCE_STATUS
                )
      select INIT_ID_SEQ.nextval
           , 1
           , POS.C_DOC_POS_STATUS
           , GAU.C_GAUGE_TYPE
           , POS.GCO_GOOD_ID
           , DOC.PAC_THIRD_ID
           , DOC.DIC_GAUGE_TYPE_DOC_ID
           , :new.GCO_CHARACTERIZATION_ID
           , :new.GCO_GCO_CHARACTERIZATION_ID
           , :new.GCO2_GCO_CHARACTERIZATION_ID
           , :new.GCO3_GCO_CHARACTERIZATION_ID
           , :new.GCO4_GCO_CHARACTERIZATION_ID
           , :new.PDE_CHARACTERIZATION_VALUE_1
           , :new.PDE_CHARACTERIZATION_VALUE_2
           , :new.PDE_CHARACTERIZATION_VALUE_3
           , :new.PDE_CHARACTERIZATION_VALUE_4
           , :new.PDE_CHARACTERIZATION_VALUE_5
           , GPO.GAP_DELAY
           , nvl(:new.PDE_FINAL_DELAY, DOC.DMT_DATE_DOCUMENT)
           , DOC.DMT_DATE_DOCUMENT
           , :new.PDE_FINAL_QUANTITY
           , :new.PDE_BALANCE_QUANTITY
           , POS.POS_NET_VALUE_EXCL_B
           , GST.GAS_BALANCE_STATUS
        from DOC_DOCUMENT DOC
           , DOC_POSITION POS
           , DOC_GAUGE_POSITION GPO
           , DOC_GAUGE_STRUCTURED GST
           , DOC_GAUGE GAU
       where POS.DOC_DOCUMENT_ID = DOC.DOC_DOCUMENT_ID
         and GPO.DOC_GAUGE_POSITION_ID = POS.DOC_GAUGE_POSITION_ID
         and POS.DOC_POSITION_ID = :new.DOC_POSITION_ID
         and GST.DOC_GAUGE_ID = DOC.DOC_GAUGE_ID
         and GAU.DOC_GAUGE_ID = GST.DOC_GAUGE_ID
         and POS.C_GAUGE_TYPE_POS in('1', '2', '3', '7', '8', '91', '101', '21');
  end if;
end DOC_PDE_AI_POSI_ACCU;

ALTER TRIGGER "C_ITX"."DOC_PDE_AI_POSI_ACCU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AI_PROV_QTY"
  after insert
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des quantités provisoires à la création d'un détail de position
* @created fpe 01.01.1998
* @updated fpe 17.06.2014 - DEVERP-20671 Documents de transfert: Pas de quantité sortie provisoire si stock cible vide
*/
declare
  -- C_ELEMENT_TYPE
  cElementTypeSet     constant char(2)                                         := '01';
  cElementTypePiece   constant char(2)                                         := '02';
  cElementTypeVersion constant char(2)                                         := '03';

  -- recherche du type de mouvement de stock et de l'id du bien d'aprSs la table des positions
  cursor crMovementKind(aCrPositionId DOC_POSITION.DOC_POSITION_ID%type)
  is
    select MOK.C_MOVEMENT_SORT
         , MOK.MOK_STANDARD_SIGN
         , POS.GCO_GOOD_ID
         , MOK.STM_MOVEMENT_KIND_ID
         , MOK.STM_STM_MOVEMENT_KIND_ID
         , POS.POS_GENERATE_MOVEMENT
         , MOK.MOK_VERIFY_CHARACTERIZATION
         , MOK.MOK_RETURN
         , POS.C_GAUGE_TYPE_POS
         , POS.STM_STOCK_ID
         , POS.STM_STM_STOCK_ID
         , POS.STM_LOCATION_ID
         , POS.POS_CONVERT_FACTOR
      from STM_MOVEMENT_KIND MOK
         , DOC_POSITION POS
     where MOK.STM_MOVEMENT_KIND_ID = POS.STM_MOVEMENT_KIND_ID
       and POS.DOC_POSITION_ID = aCrPositionId
       and POS.C_GAUGE_TYPE_POS in('1', '2', '3', '7', '8', '71', '81', '91', '101')
       and POS.POS_GENERATE_MOVEMENT = 0;

  cursor crExtourneMovement(aCrParentDetailId DOC_POSITION_DETAIL.DOC_POSITION_DETAIL_ID%type, aCrGaugeReceiptId DOC_GAUGE_RECEIPT.DOC_GAUGE_RECEIPT_Id%type)
  is
    select A.GCO_GOOD_ID
         , A.GCO_CHARACTERIZATION_ID
         , A.GCO_GCO_CHARACTERIZATION_ID
         , A.GCO2_GCO_CHARACTERIZATION_ID
         , A.GCO3_GCO_CHARACTERIZATION_ID
         , A.GCO4_GCO_CHARACTERIZATION_ID
         , A.SMO_CHARACTERIZATION_VALUE_1
         , A.SMO_CHARACTERIZATION_VALUE_2
         , A.SMO_CHARACTERIZATION_VALUE_3
         , A.SMO_CHARACTERIZATION_VALUE_4
         , A.SMO_CHARACTERIZATION_VALUE_5
         , A.STM_STOCK_ID
         , A.STM_LOCATION_ID
         , A.SMO_MOVEMENT_QUANTITY
         , C.C_MOVEMENT_SORT
         , C.MOK_STANDARD_SIGN
         , C.MOK_VERIFY_CHARACTERIZATION
         , C.STM_MOVEMENT_KIND_ID
         , C.STM_STM_MOVEMENT_KIND_ID
      from STM_STOCK_MOVEMENT A
         , DOC_GAUGE_RECEIPT B
         , STM_MOVEMENT_KIND C
     where B.DOC_GAUGE_RECEIPT_ID = aCrGaugeReceiptId
       and B.GAR_EXTOURNE_MVT = 1
       and nvl(A.SMO_EXTOURNE_MVT, 0) = 0
       and A.DOC_POSITION_DETAIL_ID = aCrParentDetailId
       and C.STM_MOVEMENT_KIND_ID = A.STM_MOVEMENT_KIND_ID
       and C.C_MOVEMENT_TYPE <> 'EXE';

  vTplMovementKind             crMovementKind%rowtype;
  vTplExtourneMvt              crExtourneMovement%rowtype;
  vPositionId                  DOC_POSITION.DOC_POSITION_ID%type;
  vVerifyCharacterization      number(1);
  vMainStockId                 STM_STOCK.STM_STOCK_ID%type;
  vTransStockId                STM_STOCK.STM_STOCK_ID%type;
  vCreateProvisoryQuantities   number(1);
  vUpdateMode                  varchar2(2);
  vExtourneBefore              boolean;
  vRecordElemNbrID             STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vNoMove                      boolean                                         := false;
begin
  if :new.STM_LOCATION_ID is not null then
    -- controle que la valeur de doc_position_id existe bel et bien dans la table DOC_POSITION
    -- car ce trigger remplace la contrainte d'intégrité entre les deux table
    -- En cas d'échec, on passe dans l'exception à la fin du trigger
    select DOC_POSITION_ID
      into vPositionId
      from DOC_POSITION
     where DOC_POSITION_ID = :new.DOC_POSITION_ID;

    -- recherche du type de mouvement de stock et de l'id du bien d'après la table des positions
    for vTplMovementKind in crMovementKind(:new.DOC_POSITION_ID) loop
      if     (nvl(vTplMovementKind.STM_STM_MOVEMENT_KIND_ID, 0) <> 0)
         and :new.STM_STM_LOCATION_ID is not null then   /* Mouvement de transfert (peux valoir 0) */
        if :new.STM_STM_LOCATION_ID is not null then   /* Le nouvel emplacement cible n'est pas vide */
          if :new.STM_LOCATION_ID = :new.STM_STM_LOCATION_ID then
            vCreateProvisoryQuantities  := 0;
          else
            vCreateProvisoryQuantities  := 1;
          end if;
        else   /* Le nouvel emplacement cible est vide */
          vCreateProvisoryQuantities  := 0;
        end if;
      else   /* Pas de mouvement de transfert */
        vCreateProvisoryQuantities  := 1;
      end if;

      /**
      * Ajout des nouvelles valeurs
      */
      if (vCreateProvisoryQuantities = 1) then
        vVerifyCharacterization  := vTplMovementKind.MOK_VERIFY_CHARACTERIZATION;

        -- Eventuellement traitement de l'extourne
        open crExtourneMovement(:new.DOC_DOC_POSITION_DETAIL_ID, :new.DOC_GAUGE_RECEIPT_ID);

        fetch crExtourneMovement
         into vTplExtourneMvt;

        if not(    vTplMovementKind.C_GAUGE_TYPE_POS in('7', '8', '9', '10')
               and nvl(vTplExtourneMvt.STM_STM_MOVEMENT_KIND_ID, 0) <> 0) then
          -- Force de ne pas effectuer le contrôle des valeurs de caractérisation
          -- si la quantité du mouvement est égal à zéro et que le détail est issu
          -- d'une décharge ou que la décharge demande l'extourne du mouvement parent.
          if    (     (:new.PDE_MOVEMENT_QUANTITY = 0)
                 and :new.DOC_DOC_POSITION_DETAIL_ID is not null)
             or (crExtourneMovement%found) then
            vVerifyCharacterization  := 0;
          end if;

          /* Recherche les stocks en fonction des emplacements. */
          select STM_STOCK_ID
            into vMainStockId
            from STM_LOCATION
           where STM_LOCATION_ID = :new.STM_LOCATION_ID;

          select max(STM_STOCK_ID)
            into vTransStockId
            from STM_LOCATION
           where STM_LOCATION_ID = :new.STM_STM_LOCATION_ID;

          if vTplMovementKind.MOK_RETURN = 1 then
            vUpdateMode  := 'IR';   -- mouvement de retour
          else
            vUpdateMode  := 'I';
          end if;

          -- flag indiquant si l'extourne doit se faire avant le movement principal ou après
          vExtourneBefore  :=
            (    (    vTplExtourneMvt.C_MOVEMENT_SORT = 'ENT'
                  and :new.PDE_MOVEMENT_QUANTITY > 0)
             or ( (    vTplExtourneMvt.C_MOVEMENT_SORT = 'SOR'
                   and :new.PDE_MOVEMENT_QUANTITY < 0) )
            );
          -- en cas d'extourne sur le même emplacement avec le même genre de mouvement et la même quantité on ne fait aucune mise à jour
          vNoMove          :=
                crExtourneMovement%found
            and (vTplExtourneMvt.C_MOVEMENT_SORT = vTplMovementKind.C_MOVEMENT_SORT)
            and (vTplExtourneMvt.MOK_STANDARD_SIGN = vTplMovementKind.MOK_STANDARD_SIGN)
            and (vTplExtourneMvt.STM_LOCATION_ID = :new.STM_LOCATION_ID)
            and (vTplExtourneMvt.GCO_GOOD_ID = vTplMovementKind.GCO_GOOD_ID)
            and vTplExtourneMvt.STM_STM_MOVEMENT_KIND_ID is null
            and (sign(:new.PDE_MOVEMENT_QUANTITY) *
                 least(abs(:new.PDE_MOVEMENT_QUANTITY +(vTplMovementKind.POS_CONVERT_FACTOR * nvl(:new.PDE_BALANCE_QUANTITY_PARENT, 0) ) )
                     , abs(vTplExtourneMvt.SMO_MOVEMENT_QUANTITY)
                      ) = :new.PDE_MOVEMENT_QUANTITY
                );

          if not vNoMove then
            -- Eventuellement traitement de l'extourne
            -- si l'extourne provoque une sortie, on la traîte avant le mouvement principal (pour éviter les doublons de no de série)
            if     crExtourneMovement%found
               and vExtourneBefore then
              -- Ajout des quantités provisoires
              DOC_INIT_MOVEMENT.DOC_PROV_QTY(good_id               => vTplExtourneMvt.GCO_GOOD_ID
                                           , update_mode           => vUpdateMode   -- mode création
                                           , move_sort             => vTplExtourneMvt.C_MOVEMENT_SORT
                                           , verify_char           => 0   --vTplExtourneMvt.mok_verify_characterization,
                                           , parity_move_kind_id   => vTplExtourneMvt.STM_STM_MOVEMENT_KIND_ID
                                           , charact_id_1          => vTplExtourneMvt.GCO_CHARACTERIZATION_ID
                                           , charact_id_2          => vTplExtourneMvt.GCO_GCO_CHARACTERIZATION_ID
                                           , charact_id_3          => vTplExtourneMvt.GCO2_GCO_CHARACTERIZATION_ID
                                           , charact_id_4          => vTplExtourneMvt.GCO3_GCO_CHARACTERIZATION_ID
                                           , charact_id_5          => vTplExtourneMvt.GCO4_GCO_CHARACTERIZATION_ID
                                           , charact_val_1         => vTplExtourneMvt.SMO_CHARACTERIZATION_VALUE_1
                                           , charact_val_2         => vTplExtourneMvt.SMO_CHARACTERIZATION_VALUE_2
                                           , charact_val_3         => vTplExtourneMvt.SMO_CHARACTERIZATION_VALUE_3
                                           , charact_val_4         => vTplExtourneMvt.SMO_CHARACTERIZATION_VALUE_4
                                           , charact_val_5         => vTplExtourneMvt.SMO_CHARACTERIZATION_VALUE_5
                                           , stock_id              => vTplExtourneMvt.STM_STOCK_ID
                                           , location_id           => vTplExtourneMvt.STM_LOCATION_ID
                                           , trans_stock_id        => null
                                           , trans_location_id     => null
                                           , movement_quantity     => -sign(:new.PDE_MOVEMENT_QUANTITY) *
                                                                      least(abs(:new.PDE_MOVEMENT_QUANTITY +
                                                                                (vTplMovementKind.POS_CONVERT_FACTOR * nvl(:new.PDE_BALANCE_QUANTITY_PARENT, 0)
                                                                                )
                                                                               )
                                                                          , abs(vTplExtourneMvt.SMO_MOVEMENT_QUANTITY)
                                                                           )
                                            );
            end if;

            DOC_INIT_MOVEMENT.DOC_PROV_QTY(good_id               => vTplMovementKind.GCO_GOOD_ID
                                         , update_mode           => vUpdateMode
                                         , move_sort             => vTplMovementKind.C_MOVEMENT_SORT
                                         , verify_char           => vVerifyCharacterization
                                         , parity_move_kind_id   => vTplMovementKind.STM_STM_MOVEMENT_KIND_ID
                                         , charact_id_1          => :new.GCO_CHARACTERIZATION_ID
                                         , charact_id_2          => :new.GCO_GCO_CHARACTERIZATION_ID
                                         , charact_id_3          => :new.GCO2_GCO_CHARACTERIZATION_ID
                                         , charact_id_4          => :new.GCO3_GCO_CHARACTERIZATION_ID
                                         , charact_id_5          => :new.GCO4_GCO_CHARACTERIZATION_ID
                                         , charact_val_1         => :new.PDE_CHARACTERIZATION_VALUE_1
                                         , charact_val_2         => :new.PDE_CHARACTERIZATION_VALUE_2
                                         , charact_val_3         => :new.PDE_CHARACTERIZATION_VALUE_3
                                         , charact_val_4         => :new.PDE_CHARACTERIZATION_VALUE_4
                                         , charact_val_5         => :new.PDE_CHARACTERIZATION_VALUE_5
                                         , stock_id              => vMainStockId
                                         , location_id           => :new.STM_LOCATION_ID
                                         , trans_stock_id        => vTransStockId
                                         , trans_location_id     => :new.STM_STM_LOCATION_ID
                                         , movement_quantity     => :new.PDE_MOVEMENT_QUANTITY
                                          );

            -- Eventuellement traitement de l'extourne
            -- si l'extourne provoque une entrée, on la traîte après le mouvement principal (pour éviter les doublons de no de série)
            if     crExtourneMovement%found
               and not vExtourneBefore then
              -- Ajout des quantités provisoires
              DOC_INIT_MOVEMENT.DOC_PROV_QTY(good_id               => vTplExtourneMvt.GCO_GOOD_ID
                                           , update_mode           => vUpdateMode   -- mode création
                                           , move_sort             => vTplExtourneMvt.C_MOVEMENT_SORT
                                           , verify_char           => 0   --vTplExtourneMvt.mok_verify_characterization,
                                           , parity_move_kind_id   => vTplExtourneMvt.STM_STM_MOVEMENT_KIND_ID
                                           , charact_id_1          => vTplExtourneMvt.GCO_CHARACTERIZATION_ID
                                           , charact_id_2          => vTplExtourneMvt.GCO_GCO_CHARACTERIZATION_ID
                                           , charact_id_3          => vTplExtourneMvt.GCO2_GCO_CHARACTERIZATION_ID
                                           , charact_id_4          => vTplExtourneMvt.GCO3_GCO_CHARACTERIZATION_ID
                                           , charact_id_5          => vTplExtourneMvt.GCO4_GCO_CHARACTERIZATION_ID
                                           , charact_val_1         => vTplExtourneMvt.SMO_CHARACTERIZATION_VALUE_1
                                           , charact_val_2         => vTplExtourneMvt.SMO_CHARACTERIZATION_VALUE_2
                                           , charact_val_3         => vTplExtourneMvt.SMO_CHARACTERIZATION_VALUE_3
                                           , charact_val_4         => vTplExtourneMvt.SMO_CHARACTERIZATION_VALUE_4
                                           , charact_val_5         => vTplExtourneMvt.SMO_CHARACTERIZATION_VALUE_5
                                           , stock_id              => vTplExtourneMvt.STM_STOCK_ID
                                           , location_id           => vTplExtourneMvt.STM_LOCATION_ID
                                           , trans_stock_id        => null
                                           , trans_location_id     => null
                                           , movement_quantity     => -sign(:new.PDE_MOVEMENT_QUANTITY) *
                                                                      least(abs(:new.PDE_MOVEMENT_QUANTITY +
                                                                                (vTplMovementKind.POS_CONVERT_FACTOR * nvl(:new.PDE_BALANCE_QUANTITY_PARENT, 0)
                                                                                )
                                                                               )
                                                                          , abs(vTplExtourneMvt.SMO_MOVEMENT_QUANTITY)
                                                                           )
                                            );
            end if;
          end if;
        end if;

        close crExtourneMovement;
      end if;

      -- Si l'installation est renseignée et qu'une valeur de caract aussi
      -- il faut màj le numéro de série de l'installation
      if     (:new.DOC_RECORD_ID is not null)
         and (    (:new.PDE_CHARACTERIZATION_VALUE_1 is not null)
              or (:new.PDE_CHARACTERIZATION_VALUE_2 is not null)
              or (:new.PDE_CHARACTERIZATION_VALUE_3 is not null)
              or (:new.PDE_CHARACTERIZATION_VALUE_4 is not null)
              or (:new.PDE_CHARACTERIZATION_VALUE_5 is not null)
             ) then
        select RCO.STM_ELEMENT_NUMBER_ID
          into vRecordElemNbrID
          from DOC_RECORD RCO
         where RCO.DOC_RECORD_ID = :new.DOC_RECORD_ID;

        -- Si pas de numero de série sur le dossier
        -- Màj du dossier avec le numéro de série du détail
        if vRecordElemNbrID is null then
          select max(STM_ELEMENT_NUMBER_ID)
            into vRecordElemNbrID
            from STM_ELEMENT_NUMBER
           where GCO_GOOD_ID = :new.GCO_GOOD_ID
             and C_ELEMENT_TYPE = cElementTypePiece
             and SEM_VALUE in
                   (:new.PDE_CHARACTERIZATION_VALUE_1
                  , :new.PDE_CHARACTERIZATION_VALUE_2
                  , :new.PDE_CHARACTERIZATION_VALUE_3
                  , :new.PDE_CHARACTERIZATION_VALUE_4
                  , :new.PDE_CHARACTERIZATION_VALUE_5
                   );

          if vRecordElemNbrID is not null then
            update DOC_RECORD
               set STM_ELEMENT_NUMBER_ID = vRecordElemNbrID
             where DOC_RECORD_ID = :new.DOC_RECORD_ID;
          end if;
        end if;
      end if;
    end loop;
  end if;
end DOC_PDE_AI_PROV_QTY;

ALTER TRIGGER "C_ITX"."DOC_PDE_AI_PROV_QTY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AIUD_FLAG_POSITION"
  after insert or delete or update of FAL_SCHEDULE_STEP_ID, PDE_FINAL_DELAY, PDE_FINAL_QUANTITY
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour du flag de recalcul des montants de position et mise à jour du flag de mise à jour de l'opération suite
*    à une modif dans les détails de position
* @created fp 29.06.2004
* @version 2003
* @lastUpdate
*/
declare
  vUpdateOP         boolean;
  posUpdateOP       DOC_POSITION.POS_UPDATE_OP%type;
  falScheduleStepID FAL_TASK_LINK.FAL_SCHEDULE_STEP_ID%type;
begin
  vUpdateOP  := false;

  if    (    inserting
         and :new.FAL_SCHEDULE_STEP_ID is not null)
     or (    deleting
         and :old.FAL_SCHEDULE_STEP_ID is not null)
     or updating then
    -- Modification des délais d'un détail lié à une opération de sous-traitance ou assignation de l'opération
    -- sur le détail courant.
    if     updating
       and :new.FAL_SCHEDULE_STEP_ID is not null then
      -- Assignation du lien de l'opération
      -- ou modification du délai final d'un détail de position déjà lié
      -- ou modification de la quantité d'un détail qui possède un lien sur l'opération (garantit le basculement du flag
      -- de mise à jour de l'opération dans le cas de l'effacement d'un détail avec un lien d'opération).
      if (    (nvl(:old.FAL_SCHEDULE_STEP_ID, 0) <> nvl(:new.FAL_SCHEDULE_STEP_ID, 0) )
          or (nvl(:old.PDE_FINAL_DELAY, to_date('31.12.2999', 'DD.MM.YYYY') ) <> nvl(:new.PDE_FINAL_DELAY, to_date('31.12.2999', 'DD.MM.YYYY') ) )
          or (:old.PDE_FINAL_QUANTITY <> :new.PDE_FINAL_QUANTITY)
         ) then
        -- Vérifie l'application de la demande de mise à jour de l'opération et la mise en place du lien avec l'opération
        -- sur la position (dénormalisation).
        select FAL_SCHEDULE_STEP_ID
             , nvl(POS_UPDATE_OP, 0)
          into falScheduleStepID
             , posUpdateOP
          from DOC_POSITION
         where DOC_POSITION_ID = :new.DOC_POSITION_ID;

        -- Mise à jour du flag de demande de mise à jour de l'opération suite à la modification du délai
        if    (posUpdateOP = 0)   -- aucune maj
           or (posUpdateOP = 2)   -- montant
           or falScheduleStepID is null then
          update DOC_POSITION
             set POS_UPDATE_OP = decode(posUpdateOP, 0, 1,   -- Aucune maj => delai
                                        2, 3, 3)   -- montant => delai + montant
               , FAL_SCHEDULE_STEP_ID = nvl(FAL_SCHEDULE_STEP_ID, :new.FAL_SCHEDULE_STEP_ID)
           where DOC_POSITION_ID = :new.DOC_POSITION_ID;

          vUpdateOp  := true;
        end if;
      end if;
    end if;

    -- Mise en place des flags de recalcul des montants et des remises et taxes de position. Mais uniquement dans la cas
    -- ou il n'y a pas de demande de mise à jour de l'opération. Pourquoi redemander une mise à jour des montants dans
    -- ce contexte, je l'ignore ????
    if not vUpdateOP then
      update DOC_POSITION
         set POS_RECALC_AMOUNTS = 1
           , POS_UPDATE_POSITION_CHARGE = 1
           , FAL_SCHEDULE_STEP_ID = nvl(FAL_SCHEDULE_STEP_ID, :new.FAL_SCHEDULE_STEP_ID)
       where DOC_POSITION_ID = nvl(:new.DOC_POSITION_ID, :old.DOC_POSITION_ID);
    end if;
  end if;

  -- Modification des délais d'un détail lié à une opération de sous-traitance d'achat
  -- Modification du délai final d'un détail de position déjà lié
  -- ou modification de la quantité d'un détail qui possède un lien sur l'opération (garantit le basculement du flag)
  if     updating
     and :new.FAL_LOT_ID is not null
     and (    (nvl(:old.PDE_FINAL_DELAY, to_date('31.12.2999', 'DD.MM.YYYY') ) <> nvl(:new.PDE_FINAL_DELAY, to_date('31.12.2999', 'DD.MM.YYYY') ) )
          or (:old.PDE_FINAL_QUANTITY <> :new.PDE_FINAL_QUANTITY)
         ) then
    -- Mise à jour du flag de demande de mise à jour de l'opération suite à la modification du délai
    update DOC_POSITION
       set POS_UPDATE_OP = decode(nvl(POS_UPDATE_OP, 0), 0, 1,   -- aucune maj => delai
                                  2, 3, 3)   -- montant =>  delai + montant
     where DOC_POSITION_ID = :new.DOC_POSITION_ID;
  end if;
exception
  -- dans ce cas c'est l'effacement en cascade d'une position qui provoque le déclenchement
  -- du trigger et il n'est pas nécessaire de faire de mise à jour
  when ex.TABLE_MUTATING then
    null;
end DOC_PDE_AIUD_FLAG_POSITION;

ALTER TRIGGER "C_ITX"."DOC_PDE_AIUD_FLAG_POSITION" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AU_DENORM"
  after update of DOC_DOCUMENT_ID, DOC_GAUGE_ID
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Controle la non nullité de DOC_DOCUMENT_ID dans DOC_POSITION_DETAIL
* @author Fabrice Perotto
* @version 2003
*/
begin
  if :new.DOC_DOCUMENT_ID <> :old.DOC_DOCUMENT_ID then
    Raise_Application_Error(-20020, 'PCS - DOC_POSITION_DETAIL->DOC_DOCUMENT_ID cannot be NULL or modified');
  elsif :new.DOC_GAUGE_ID <> :old.DOC_GAUGE_ID then
    Raise_Application_Error(-20022, 'PCS - DOC_POSITION_DETAIL->DOC_GAUGE_ID cannot be NULL or modified');
  end if;
end DOC_PDE_AU_DENORM;

ALTER TRIGGER "C_ITX"."DOC_PDE_AU_DENORM" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AUI_CTRL_CHARACT"
/**
* Description
*    Trigger de contrôle des valeurs de caractérisation avec une qté à 0
*      La valeur de caractérisation ne doit pas être renseignée lorsque
*      la qté du détail est à 0, sauf pour les caractérisations de type
*      2 "caractéristiques"
*
* @author Nuno Gomes Vieira
* @created 12/12/2001
* @version 2003
* @lastUpdate
*/
after insert or update of PDE_CHARACTERIZATION_VALUE_1
                        , PDE_CHARACTERIZATION_VALUE_2
                        , PDE_CHARACTERIZATION_VALUE_3
                        , PDE_CHARACTERIZATION_VALUE_4
                        , PDE_CHARACTERIZATION_VALUE_5
                        , PDE_BASIS_QUANTITY
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
declare
  CTRL_OK number(1);
begin
  -- on vérifie que ce triggers soit déclenche par une modif d'un des champs ci-dessous
  -- et non pas par un autre trigger instead of
  if    nvl(:old.PDE_CHARACTERIZATION_VALUE_1, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_1, 'null')
     or nvl(:old.PDE_CHARACTERIZATION_VALUE_2, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_2, 'null')
     or nvl(:old.PDE_CHARACTERIZATION_VALUE_3, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_3, 'null')
     or nvl(:old.PDE_CHARACTERIZATION_VALUE_4, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_4, 'null')
     or nvl(:old.PDE_CHARACTERIZATION_VALUE_5, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_5, 'null')
     or nvl(:old.PDE_BASIS_QUANTITY, -1) <> nvl(:new.PDE_BASIS_QUANTITY, -1) then
    CTRL_OK  := 1;

    -- Lorsque que l'on a la qté du détail à 0, on doit vérifier que seules
    -- les valeurs des caractérisation de type 2 (Caractéristiques) sont renseignées.
    if :new.PDE_BASIS_QUANTITY = 0 then
      -- Valeur de la caractérisation 1 pas vide et caractérisation autre que caractéristique
      if     (CTRL_OK = 1)
         and (:new.PDE_CHARACTERIZATION_VALUE_1 is not null)
         and (GCO_FUNCTIONS.GetCharacType(:new.GCO_CHARACTERIZATION_ID) <> '2') then
        CTRL_OK  := 0;
      end if;

      -- Valeur de la caractérisation 2 pas vide et caractérisation autre que caractéristique
      if     (CTRL_OK = 1)
         and (:new.PDE_CHARACTERIZATION_VALUE_2 is not null)
         and (GCO_FUNCTIONS.GetCharacType(:new.GCO_GCO_CHARACTERIZATION_ID) <> '2') then
        CTRL_OK  := 0;
      end if;

      -- Valeur de la caractérisation 3 pas vide et caractérisation autre que caractéristique
      if     (CTRL_OK = 1)
         and (:new.PDE_CHARACTERIZATION_VALUE_3 is not null)
         and (GCO_FUNCTIONS.GetCharacType(:new.GCO2_GCO_CHARACTERIZATION_ID) <> '2') then
        CTRL_OK  := 0;
      end if;

      -- Valeur de la caractérisation 4 pas vide et caractérisation autre que caractéristique
      if     (CTRL_OK = 1)
         and (:new.PDE_CHARACTERIZATION_VALUE_4 is not null)
         and (GCO_FUNCTIONS.GetCharacType(:new.GCO3_GCO_CHARACTERIZATION_ID) <> '2') then
        CTRL_OK  := 0;
      end if;

      -- Valeur de la caractérisation 5 pas vide et caractérisation autre que caractéristique
      if     (CTRL_OK = 1)
         and (:new.PDE_CHARACTERIZATION_VALUE_5 is not null)
         and (GCO_FUNCTIONS.GetCharacType(:new.GCO4_GCO_CHARACTERIZATION_ID) <> '2') then
        CTRL_OK  := 0;
      end if;
    end if;

    -- Si une valeur de caractérisation est renseigné comme indique le texte ci-dessus
    if (CTRL_OK = 0) then
      RAISE_APPLICATION_ERROR
        (-20045
       , PCS.PC_FUNCTIONS.TranslateWord
           ('PCS - Si la quantité d''un détail est égale à 0, la saisie de valeurs de caractérisation n''est autorisée que pour les caratérisations de type 2 (caractéristique).'
           )
        );
    end if;
  end if;
end DOC_PDE_AUI_CTRL_CHARACT;

ALTER TRIGGER "C_ITX"."DOC_PDE_AUI_CTRL_CHARACT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AUI_DELAY"
  after insert or update of PDE_BASIS_QUANTITY, PDE_BASIS_DELAY, PDE_INTERMEDIATE_DELAY, PDE_FINAL_DELAY, DIC_DELAY_UPDATE_TYPE_ID
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Trigger de mise à jour de l'historique des délais
* @author PYV/FP
* @created 12/07/2000
* @version 2003
*/
declare
  delay            number(1);
  dhi_values       doc_delay_history%rowtype;
  generate_history boolean;
begin
  -- on vérifie que ce triggers soit déclenche par une modif d'un des champs ci-dessous
  -- et non pas par un autre trigger instead of
  if    nvl(to_char(:old.PDE_BASIS_QUANTITY), 'NULL') <> nvl(to_char(:new.PDE_BASIS_QUANTITY), 'NULL')
     or nvl(:old.PDE_BASIS_DELAY, to_date('31.12.2999', 'DD.MM.YYYY') ) <> nvl(:new.PDE_BASIS_DELAY, to_date('31.12.2999', 'DD.MM.YYYY') )
     or nvl(:old.PDE_INTERMEDIATE_DELAY, to_date('31.12.2999', 'DD.MM.YYYY') ) <> nvl(:new.PDE_INTERMEDIATE_DELAY, to_date('31.12.2999', 'DD.MM.YYYY') )
     or nvl(:old.PDE_FINAL_DELAY, to_date('31.12.2999', 'DD.MM.YYYY') ) <> nvl(:new.PDE_FINAL_DELAY, to_date('31.12.2999', 'DD.MM.YYYY') )
     or nvl(:old.PDE_SQM_ACCEPTED_DELAY, to_date('31.12.2999', 'DD.MM.YYYY') ) <> nvl(:new.PDE_SQM_ACCEPTED_DELAY, to_date('31.12.2999', 'DD.MM.YYYY') )
     or nvl(:old.DIC_DELAY_UPDATE_TYPE_ID, 'null') <> nvl(:new.DIC_DELAY_UPDATE_TYPE_ID, 'null') then
    -- init
    generate_history  := false;

    -- Vérifier s'il y a eu une modif de la qté du détail
    if nvl(to_char(:old.PDE_BASIS_QUANTITY), 'NULL') <> nvl(to_char(:new.PDE_BASIS_QUANTITY), 'NULL') then
      generate_history                   := true;
      dhi_values.doc_position_detail_id  := :new.doc_position_detail_id;

      if inserting then
        dhi_values.dhi_basis_qty_modified  := 0;
      else
        dhi_values.dhi_basis_qty_modified  := 1;
      end if;

      dhi_values.dhi_basis_quantity      := :new.PDE_BASIS_QUANTITY;
    end if;

    begin
      -- recherche si on gère les délais
      select GAP_DELAY
        into delay
        from DOC_GAUGE_POSITION
           , DOC_POSITION
       where DOC_POSITION.DOC_POSITION_ID = :new.DOC_POSITION_ID
         and DOC_GAUGE_POSITION.DOC_GAUGE_POSITION_ID = DOC_POSITION.DOC_GAUGE_POSITION_ID;
    exception
      when no_data_found then
        delay  := 0;
    end;

    -- si gestion des délais
    if (delay = 1) then
      -- copie des valeurs à insérer
      dhi_values.doc_position_detail_id    := :new.doc_position_detail_id;
      dhi_values.dic_delay_update_type_id  := :new.dic_delay_update_type_id;
      dhi_values.dhi_basis_delay           := :new.pde_basis_delay;
      dhi_values.dhi_intermediate_delay    := :new.pde_intermediate_delay;
      dhi_values.dhi_final_delay           := :new.pde_final_delay;
      dhi_values.dhi_delay_update_text     := :new.pde_delay_update_text;
      dhi_values.dhi_accept_delay          := :new.pde_sqm_accepted_delay;

      -- on s'assure d'être en insertion à l'aide du test "if inserting...."
      if inserting then
        begin
          generate_history                      := true;
          -- les flags de modification sont mis à faux....
          dhi_values.dhi_bas_delay_modified     := 0;
          dhi_values.dhi_int_delay_modified     := 0;
          dhi_values.dhi_fin_delay_modified     := 0;
          dhi_values.dhi_dic_delay_modified     := 0;
          dhi_values.dhi_accept_delay_modified  := 0;
          dhi_values.dhi_basis_qty_modified     := 0;
        end;
      -- dans l'autre cas nous sommes en modification
      -- on vérifie qu'il y ait eu modification
      elsif    (nvl(trunc(:old.pde_basis_delay), trunc(to_date('01/01/1800', 'DD/MM/YYYY') ) ) <>
                                                                                  nvl(trunc(:new.pde_basis_delay), trunc(to_date('01/01/1800', 'DD/MM/YYYY') ) )
               )
            or (nvl(trunc(:old.pde_intermediate_delay), trunc(to_date('01/01/1800', 'DD/MM/YYYY') ) ) <>
                                                                           nvl(trunc(:new.pde_intermediate_delay), trunc(to_date('01/01/1800', 'DD/MM/YYYY') ) )
               )
            or (nvl(trunc(:old.pde_final_delay), trunc(to_date('01/01/1800', 'DD/MM/YYYY') ) ) <>
                                                                                  nvl(trunc(:new.pde_final_delay), trunc(to_date('01/01/1800', 'DD/MM/YYYY') ) )
               )
            or (nvl(trunc(:old.pde_sqm_accepted_delay), trunc(to_date('01/01/1800', 'DD/MM/YYYY') ) ) <>
                                                                           nvl(trunc(:new.pde_sqm_accepted_delay), trunc(to_date('01/01/1800', 'DD/MM/YYYY') ) )
               )
            or (nvl(:old.dic_delay_update_type_id, '#EMPTY#') <> nvl(:new.dic_delay_update_type_id, '#EMPTY#') ) then
        begin
          generate_history                      := true;
          -- les flags de modification sont mis en fonction des diverses modifications...
          -- un trunc est utilisé pour générer le flag de modification des dates, on calcule la différence entre les 2 dates (old - new)
          -- et on prend la valeur absolue du signe du résultat -> abs( 1, 0 , -1)....
          dhi_values.dhi_bas_delay_modified     :=
            abs(sign(nvl(trunc(:old.pde_basis_delay), trunc(to_date('01/01/1800', 'DD/MM/YYYY') ) ) -
                     nvl(trunc(:new.pde_basis_delay), trunc(to_date('01/01/1800', 'DD/MM/YYYY') ) )
                    )
               );
          dhi_values.dhi_int_delay_modified     :=
            abs(sign(nvl(trunc(:old.pde_intermediate_delay), trunc(to_date('01/01/1800', 'DD/MM/YYYY') ) ) -
                     nvl(trunc(:new.pde_intermediate_delay), trunc(to_date('01/01/1800', 'DD/MM/YYYY') ) )
                    )
               );
          dhi_values.dhi_fin_delay_modified     :=
            abs(sign(nvl(trunc(:old.pde_final_delay), trunc(to_date('01/01/1800', 'DD/MM/YYYY') ) ) -
                     nvl(trunc(:new.pde_final_delay), trunc(to_date('01/01/1800', 'DD/MM/YYYY') ) )
                    )
               );
          dhi_values.dhi_accept_delay_modified  :=
            abs(sign(nvl(trunc(:old.pde_sqm_accepted_delay), trunc(to_date('01/01/1800', 'DD/MM/YYYY') ) ) -
                     nvl(trunc(:new.pde_sqm_accepted_delay), trunc(to_date('01/01/1800', 'DD/MM/YYYY') ) )
                    )
               );

          -- test de la modification du dico
          if (nvl(:old.dic_delay_update_type_id, '#EMPTY#') <> nvl(:new.dic_delay_update_type_id, '#EMPTY#') ) then
            dhi_values.dhi_dic_delay_modified  := 1;
          else
            dhi_values.dhi_dic_delay_modified  := 0;
          end if;
        end;
      end if;
    end if;

    --
    if generate_history then
      insert into DOC_DELAY_HISTORY
                  (DOC_DELAY_HISTORY_ID
                 , DOC_POSITION_DETAIL_ID
                 , DIC_DELAY_UPDATE_TYPE_ID
                 , DHI_BASIS_DELAY
                 , DHI_INTERMEDIATE_DELAY
                 , DHI_FINAL_DELAY
                 , DHI_DELAY_UPDATE_TEXT
                 , DHI_ACCEPT_DELAY
                 , DHI_BAS_DELAY_MODIFIED
                 , DHI_INT_DELAY_MODIFIED
                 , DHI_FIN_DELAY_MODIFIED
                 , DHI_DIC_DELAY_MODIFIED
                 , DHI_ACCEPT_DELAY_MODIFIED
                 , DHI_BASIS_QUANTITY
                 , DHI_BASIS_QTY_MODIFIED
                 , A_DATECRE
                 , A_IDCRE
                  )
           values (init_id_seq.nextval
                 , dhi_values.doc_position_detail_id
                 , dhi_values.dic_delay_update_type_id
                 , dhi_values.dhi_basis_delay
                 , dhi_values.dhi_intermediate_delay
                 , dhi_values.dhi_final_delay
                 , dhi_values.dhi_delay_update_text
                 , dhi_values.dhi_accept_delay
                 , dhi_values.dhi_bas_delay_modified
                 , dhi_values.dhi_int_delay_modified
                 , dhi_values.dhi_fin_delay_modified
                 , dhi_values.dhi_dic_delay_modified
                 , dhi_values.dhi_accept_delay_modified
                 , dhi_values.dhi_basis_quantity
                 , dhi_values.dhi_basis_qty_modified
                 , sysdate
                 , PCS.PC_I_LIB_SESSION.GetUserIni
                  );
    end if;
  end if;
end DOC_PDE_AUI_DELAY;

ALTER TRIGGER "C_ITX"."DOC_PDE_AUI_DELAY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AUI_VERIFY_CHAR"
  after insert or update of GCO_CHARACTERIZATION_ID
                          , GCO_GCO_CHARACTERIZATION_ID
                          , GCO2_GCO_CHARACTERIZATION_ID
                          , GCO3_GCO_CHARACTERIZATION_ID
                          , GCO4_GCO_CHARACTERIZATION_ID
                          , PDE_CHARACTERIZATION_VALUE_1
                          , PDE_CHARACTERIZATION_VALUE_2
                          , PDE_CHARACTERIZATION_VALUE_3
                          , PDE_CHARACTERIZATION_VALUE_4
                          , PDE_CHARACTERIZATION_VALUE_5
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Contrôle de l'intégrité des caractérisations
* @author FP
* @created 17.10.2002
* @version 2003
* @lastUpdate
*/
declare
begin
  -- on vérifie que ce triggers soit déclenche par une modif d'un des champs ci-dessous
  -- et non pas par un autre triggr instead of
  if    nvl(:old.GCO_CHARACTERIZATION_ID, -1) <> nvl(:new.GCO_CHARACTERIZATION_ID, -1)
     or nvl(:old.GCO_GCO_CHARACTERIZATION_ID, -1) <> nvl(:new.GCO_GCO_CHARACTERIZATION_ID, -1)
     or nvl(:old.GCO2_GCO_CHARACTERIZATION_ID, -1) <> nvl(:new.GCO2_GCO_CHARACTERIZATION_ID, -1)
     or nvl(:old.GCO3_GCO_CHARACTERIZATION_ID, -1) <> nvl(:new.GCO3_GCO_CHARACTERIZATION_ID, -1)
     or nvl(:old.GCO4_GCO_CHARACTERIZATION_ID, -1) <> nvl(:new.GCO4_GCO_CHARACTERIZATION_ID, -1)
     or nvl(:old.PDE_CHARACTERIZATION_VALUE_1, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_1, 'null')
     or nvl(:old.PDE_CHARACTERIZATION_VALUE_2, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_2, 'null')
     or nvl(:old.PDE_CHARACTERIZATION_VALUE_3, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_3, 'null')
     or nvl(:old.PDE_CHARACTERIZATION_VALUE_4, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_4, 'null')
     or nvl(:old.PDE_CHARACTERIZATION_VALUE_5, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_5, 'null') then
    if :new.GCO_CHARACTERIZATION_ID is not null then
      DOC_FUNCTIONS.CheckDetailCharParity(:new.DOC_DOCUMENT_ID
                                        , :new.DOC_POSITION_ID
                                        , :new.GCO_CHARACTERIZATION_ID
                                        , :new.GCO_GCO_CHARACTERIZATION_ID
                                        , :new.GCO2_GCO_CHARACTERIZATION_ID
                                        , :new.GCO3_GCO_CHARACTERIZATION_ID
                                        , :new.GCO4_GCO_CHARACTERIZATION_ID
                                        , :new.PDE_CHARACTERIZATION_VALUE_1
                                        , :new.PDE_CHARACTERIZATION_VALUE_2
                                        , :new.PDE_CHARACTERIZATION_VALUE_3
                                        , :new.PDE_CHARACTERIZATION_VALUE_4
                                        , :new.PDE_CHARACTERIZATION_VALUE_5
                                         );
    end if;
  end if;
end DOC_PDE_AUI_VERIFY_CHAR;

ALTER TRIGGER "C_ITX"."DOC_PDE_AUI_VERIFY_CHAR" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AU_MOVEMENT"
  after update of PDE_GENERATE_MOVEMENT
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*      Trigger de mise à jour du PIC et des info de sous-traitance lors de la génération des
*      mouvements du document.
* @author Fabrice Perotto
* @created 13.02.2001
* @version 2003
*/
declare
  lnUpdateOperation         STM_MOVEMENT_KIND.MOK_UPDATE_OP%type;
  strDocumentNumber         DOC_DOCUMENT.DMT_NUMBER%type;
  datDocumentDate           DOC_DOCUMENT.DMT_DATE_DOCUMENT%type;
  vErrorMsg                 varchar2(4000);
  lnBatchReceipt            STM_MOVEMENT_KIND.MOK_BATCH_RECEIPT%type;
  lnLotID                   FAL_LOT.FAL_LOT_ID%type;
  lnTaskID                  FAL_TASK_LINK.FAL_SCHEDULE_STEP_ID%type;
  lnTaskAmount              number;
  lnBalanceQtyParentSU      DOC_POSITION_DETAIL.PDE_BALANCE_QUANTITY_PARENT%type   := 0;
  lnBalanceQtyGrandParentSU DOC_POSITION_DETAIL.PDE_BALANCE_QUANTITY_PARENT%type   := 0;
  lnSuppQty                 DOC_POSITION_DETAIL.PDE_BALANCE_QUANTITY_PARENT%type   := 0;
  lnRejectQty               DOC_POSITION_DETAIL.PDE_BALANCE_QUANTITY_PARENT%type   := 0;
  lnSuppQtyParent           DOC_POSITION_DETAIL.PDE_BALANCE_QUANTITY_PARENT%type   := 0;
  lnRejectQtyParent         DOC_POSITION_DETAIL.PDE_BALANCE_QUANTITY_PARENT%type   := 0;
  lnSTPtReject              DOC_POSITION_DETAIL.PDE_ST_PT_REJECT%type              := :new.PDE_ST_PT_REJECT;
  lnSTCptReject             DOC_POSITION_DETAIL.PDE_ST_CPT_REJECT%type             := :new.PDE_ST_CPT_REJECT;
  lnSTPtRejectParent        DOC_POSITION_DETAIL.PDE_ST_PT_REJECT%type;
  lnSTCptRejectParent       DOC_POSITION_DETAIL.PDE_ST_CPT_REJECT%type;
  lnUpdateOperationParent   STM_MOVEMENT_KIND.MOK_UPDATE_OP%type                   := 0;
  lnConvertFactor           DOC_POSITION.POS_CONVERT_FACTOR%type                   := 1;
  lnGooNumberOfDecimal      GCO_GOOD.GOO_NUMBER_OF_DECIMAL%type                    := 0;
begin
  -- on vérifie que ce triggers soit déclenche par une modif d'un des champs ci-dessous
  -- et non pas par un autre trigger instead of
  if nvl(:old.PDE_GENERATE_MOVEMENT, -1) <> nvl(:new.PDE_GENERATE_MOVEMENT, -1) then
    -- si le flag de génération du mouvement a passé de 0 à 1
    if     :old.PDE_GENERATE_MOVEMENT = 0
       and :new.PDE_GENERATE_MOVEMENT = 1
       and (   :new.FAL_SCHEDULE_STEP_ID is not null
            or :new.FAL_LOT_ID is not null) then
      -- recherche le flag de mise à jour des opérations dans le genre de mouvement
      -- en recherchant le genre de mouvement du gabarit position. Cela corrige
      -- temporairement le problème du remplacement du genre de mouvement pour les
      -- bien sans gestion de stock.
      select nvl(max(MOK.MOK_UPDATE_OP), 0)
           , nvl(max(MOK.MOK_BATCH_RECEIPT), 0)
        into lnUpdateOperation
           , lnBatchReceipt
        from DOC_POSITION POS
           , DOC_GAUGE_POSITION GAP
           , STM_MOVEMENT_KIND MOK
       where POS.DOC_POSITION_ID = :new.DOC_POSITION_ID
         and GAP.DOC_GAUGE_POSITION_ID = POS.DOC_GAUGE_POSITION_ID
         and MOK.STM_MOVEMENT_KIND_ID = GAP.STM_MOVEMENT_KIND_ID;

      -- Recherche l'opération de sous-traitance du lot lié à la position, respectivement au détail, qui génére un mouvement
      -- avec mise à jour de l'opération et qui autorise la réception du lot.
      if     (lnBatchReceipt = 1)
         and :new.FAL_SCHEDULE_STEP_ID is null
         and :new.FAL_LOT_ID is not null then
        select max(TAL.FAL_SCHEDULE_STEP_ID)
          into lnTaskID
          from FAL_TASK_LINK TAL
         where TAL.FAL_LOT_ID = :new.FAL_LOT_ID;
      elsif :new.FAL_SCHEDULE_STEP_ID is not null then
        lnTaskID  := :new.FAL_SCHEDULE_STEP_ID;
      end if;

      lnLotID  := :new.FAL_LOT_ID;

      -- Mise à jour de l'opération courante. Suivi, mouvement de composant, etc
      if     (lnUpdateOperation = 1)
         and lnTaskID is not null then
        -- Calcul et retourne les informations de solde du parent et en particulier la quantité soldée en unité de stockage en fonction du
        -- facteur de conversion de la position.
        --
        -- Attention : Cette méthode peut s'utiliser à l'intérieur d'un trigger de création ou de mise à jour de la position ou
        -- du détail de position. Cela grace à l'utilisation du pragma autonomous_transaction. Mais attention, il
        -- faut être sur que la session dans laquel est déclenché le trigger n'effectue pas de mise à jour sur les
        -- enregistrements recherchés par la fonction.
        --
        if (nvl(:new.DOC_DOC_POSITION_DETAIL_ID, 0) <> 0) then
          DOC_LIB_POSITION_DETAIL.GetRejectInfoAT(iPositionDetailID           => :new.DOC_DOC_POSITION_DETAIL_ID
                                                , ioBalanceQuantityParentSU   => lnBalanceQtyGrandParentSU
                                                , ioSTPtReject                => lnSTPtRejectParent
                                                , ioSTCptReject               => lnSTCptRejectParent
                                                , ioUpdateOperation           => lnUpdateOperationParent
                                                , ioConvertFactor             => lnConvertFactor
                                                , ioGooNumberOfDecimal        => lnGooNumberOfDecimal
                                                 );

          -- Détermine la méthode de rebut à utiliser. Si du rebut était demandé sur la position père et que la mise à jour de l'opération
          -- n'était pas demandé, on utilise la méthode définie sur la position père, dans le cas contraire, on utilise la méthode du détail
          -- de position courant.
          if     (lnBalanceQtyGrandParentSU > 0)
             and (lnUpdateOperationParent = 0) then
            lnSTPtReject   := lnSTPtRejectParent;
            lnSTCptReject  := lnSTCptRejectParent;
          elsif (lnUpdateOperationParent = 1) then
            -- Il ne faut pas utilisé les informations de la position père si l'opération a déjà été mise à jour sur le père.
            lnBalanceQtyGrandParentSU := 0;
          end if;
        end if;

        /* Détermine la quantité supplémentaire. C'est la somme des quantités soldées du document courant et du
           document père. On utilise les informations du document père si celui-ci ne met pas à jour l'opération. Attention, une quatité
           négative représente un dépassement de quantité, alors qu'une quantité positive, représente une diminution de la quantité.
           Il faut donc prendre en compte que les quantité négative */
        lnSuppQty          := 0;
        lnRejectQty        := 0;

        -- Exprime la quantité soldée sur parent en unité de stockage
        if (nvl(:new.PDE_BALANCE_QUANTITY_PARENT, 0) <> 0) then
          lnBalanceQtyParentSU  := ACS_FUNCTION.RoundNear(nvl(:new.PDE_BALANCE_QUANTITY_PARENT, 0) * lnConvertFactor, 1 / power(10, lnGooNumberOfDecimal), 1);
        end if;

        if (lnBalanceQtyParentSU < 0) then
          lnSuppQty  := lnBalanceQtyParentSU;
        elsif(lnBalanceQtyParentSU > 0) then
          lnRejectQty  := lnBalanceQtyParentSU;
        end if;

        lnSuppQtyParent    := 0;
        lnRejectQtyParent  := 0;

        if (lnBalanceQtyGrandParentSU < 0) then
          lnSuppQtyParent  := lnBalanceQtyGrandParentSU;
        elsif(lnBalanceQtyGrandParentSU > 0) then
          lnRejectQtyParent  := lnBalanceQtyGrandParentSU;
        end if;

        lnSuppQty          := lnSuppQtyParent + lnSuppQty;
        lnRejectQty        := lnRejectQtyParent + lnRejectQty;

        if    (lnSuppQty <> 0)
           or (lnRejectQty <> 0) then
          select DMT_NUMBER
               , DMT_DATE_DOCUMENT
            into strDocumentNumber
               , datDocumentDate
            from DOC_DOCUMENT
           where DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID;
        end if;

        -- Réservation du lot si l'on doit mettre à jour les opérations
        if    (nvl(:new.PDE_MOVEMENT_QUANTITY, 0) > 0)
           or (    (lnSuppQty <> 0)
               or (lnRejectQty <> 0) )
           or (nvl(:new.PDE_MOVEMENT_VALUE, 0) > 0) then
          if lnLotID is null then
            -- Recherche du lot par l'opération pour la réservation du lot et la mise à jour du suivi.
            select FAL_LOT_ID
              into lnLotID
              from FAL_TASK_LINK
             where FAL_SCHEDULE_STEP_ID = lnTaskID;
          end if;

          if lnLotID is not null then
            FAL_BATCH_RESERVATION.BatchReservation(aFAL_LOT_ID => lnLotID, aErrorMsg => vErrorMsg);

            if vErrorMsg is not null then
              -- Voir package DOC_INIT_MOVEMENT
              raise_application_error(-20910, vErrorMsg);
            end if;
          end if;
        end if;

        -- Du rebut existe ?
        if lnRejectQty > 0 then
          -- Diminution de la quantité avec mise en rebut éventuel du solde (si iPdeStPtReject ou iPdeStCptReject est égal à 1) ou
          -- éventuellement, si ces deux paramètres sont à 0, d'une annulation de la quantité restante sur la CST et donc d'une remise
          -- en disponible de cette quantité sur l'opération.
          --
          -- Mise à jour de l'opération suite au solde d'un détail de position.
          --
          -- 1. Création d'un suivi d'opération
          -- 2. Mouvement automatique des composants si requis
          --
          FAL_PRC_SUBCONTRACTO.updateOpAtPosBalance(iDocumentNumber      => strDocumentNumber
                                                  , iDocumentDate        => datDocumentDate
                                                  , iBalanceQty          => lnRejectQty
                                                  , iScheduleStepID      => lnTaskID
                                                  , iDocPosDetailID      => :new.DOC_POSITION_DETAIL_ID
                                                  , iDocPosID            => :new.DOC_POSITION_ID
                                                  , iPdeStPtReject       => lnSTPtReject
                                                  , iPdeStCptReject      => lnSTCptReject
                                                  , iDocGaugeReceiptId   => :new.DOC_GAUGE_RECEIPT_ID
                                                   );
        end if;

        -- Montant à mettre à jour sur l'opération liée. On garantit un prix indépendament du flux.
        lnTaskAmount       := nvl(:new.PDE_MOVEMENT_VALUE, 0);

        if    (nvl(:new.PDE_MOVEMENT_QUANTITY, 0) > 0)
           or (lnSuppQty < 0)   -- Dépassement de quantité demandé
           or (lnTaskAmount > 0) then
          -- Mise à jour des opérations de réception
          --
          -- 1. Création d'un suivi d'opération
          -- 2. Mise à jour des éléments de coût sous traitance si requis
          -- 3. Mouvements automatiques des composants si requis
          FAL_PRC_SUBCONTRACTO.updateOpAtPosRecept(iDocumentID            => :new.DOC_DOCUMENT_ID
                                                 , iScheduleStepID        => lnTaskID
                                                 , iDocPosDetailID        => :new.DOC_POSITION_DETAIL_ID
                                                 , iDocPosID              => :new.DOC_POSITION_ID
                                                 , iPdeBalanceQtyParent   => lnSuppQty
                                                 , iQty                   => nvl(:new.PDE_MOVEMENT_QUANTITY, 0)
                                                 , iAmount                => lnTaskAmount
                                                 , iPdeFinalQty           => :new.PDE_FINAL_QUANTITY_SU
                                                 , iDocGaugeReceiptId     => :new.DOC_GAUGE_RECEIPT_ID
                                                  );
        end if;

        if lnLotID is not null then
          -- Libération du lot
          FAL_BATCH_RESERVATION.ReleaseBatch(lnLotID);
        end if;
      end if;
    end if;
  end if;
end DOC_PDE_AU_MOVEMENT;

ALTER TRIGGER "C_ITX"."DOC_PDE_AU_MOVEMENT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AU_MULTISOURCING"
  after update of GCO_GCO_GOOD_ID, PDE_FINAL_QUANTITY_SU
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Déclenche le traitement de mise à jour du multi-sourcing réalisé. Les règles suivantes doivent être respectées :
*
*    1. Le bien doit gérer le multi-sourcing (GCO_PRODUCT.PDT_MULTI_SOURCING = 1).
*    2. Le gabarit doit gérer le multi-sourcing (DOC_GAUGE_STRUCTURED.GAS_MULTISOURCING_MGM = 1).
*    3. La quantité ou le produit fabriqué ont changé
*
* @author VJ
* @created 14/03/2005
* @version 2003
*/
declare
  posNetUnitValueExclB DOC_POSITION.POS_NET_UNIT_VALUE%type;
  gcoGoodID            GCO_GOOD.GCO_GOOD_ID%type;
  docDocumentID        DOC_DOCUMENT.DOC_DOCUMENT_ID%type;
  dmtNumber            DOC_DOCUMENT.DMT_NUMBER%type;
  strInfo              varchar2(2000);
begin
  if     :new.GCO_GOOD_ID is not null
     and (    (nvl(:old.PDE_FINAL_QUANTITY_SU, 0) <> nvl(:new.PDE_FINAL_QUANTITY_SU, 0) )
          or (nvl(:old.GCO_GCO_GOOD_ID, 0) <> nvl(:new.GCO_GCO_GOOD_ID, 0) )
         ) then
    -- Recherche la valeur net
    begin
      select decode(nvl(POS.POS_FINAL_QUANTITY_SU, 0), 0, 0, POS.POS_NET_VALUE_EXCL_B / POS.POS_FINAL_QUANTITY_SU)
                                                                                              POS_NET_UNIT_VALUE_EXCL_B
           , POS.DOC_DOCUMENT_ID
           , POS.GCO_GOOD_ID
           , DMT.DMT_NUMBER
        into posNetUnitValueExclB
           , docDocumentID
           , gcoGoodID
           , dmtNumber
        from DOC_POSITION POS
           , DOC_DOCUMENT DMT
           , GCO_PRODUCT PDT
           , DOC_GAUGE_STRUCTURED GAS
       where POS.DOC_POSITION_ID = :new.DOC_POSITION_ID
         and PDT.GCO_GOOD_ID = POS.GCO_GOOD_ID
         and DMT.DOC_DOCUMENT_ID = POS.DOC_DOCUMENT_ID
         and nvl(PDT.PDT_MULTI_SOURCING, 0) = 1
         and GAS.DOC_GAUGE_ID = POS.DOC_GAUGE_ID
         and nvl(GAS.GAS_MULTISOURCING_MGM, 0) = 1;
    exception
      when no_data_found then
        posNetUnitValueExclB  := null;
    end;

    if posNetUnitValueExclB is not null then
      if false then
        strInfo  :=
          'DOC_PDE_AU_MULTISOURCING' ||
          chr(13) ||
          chr(13) ||
          'Document : ' ||
          docDocumentID ||
          chr(13) ||
          'Bien : ' ||
          gcoGoodID ||
          chr(13) ||
          'Prix unitaire net ht : ' ||
          posNetUnitValueExclB ||
          chr(13) ||
          'Ancienne quantité : ' ||
          :old.PDE_FINAL_QUANTITY_SU ||
          chr(13) ||
          'Nouvelle quantité : ' ||
          :new.PDE_FINAL_QUANTITY_SU ||
          chr(13) ||
          'Ancien montant : ' ||
          posNetUnitValueExclB * :old.PDE_FINAL_QUANTITY_SU ||
          chr(13) ||
          'Nouveau montant : ' ||
          posNetUnitValueExclB * :new.PDE_FINAL_QUANTITY_SU;
        DOC_FUNCTIONS.CreateHistoryInformation(:new.DOC_DOCUMENT_ID
                                             , :new.DOC_POSITION_ID   -- DOC_POSITION_ID
                                             , dmtNumber   -- no de document
                                             , 'PLSQL'   -- DUH_TYPE
                                             , 'Getting detail informations DOC_PDE_AU_MULTISOURCING : ' ||
                                               :new.DOC_POSITION_DETAIL_ID
                                             , strInfo   -- description libre
                                             , null   -- status document
                                             , null   -- status position
                                              );
      end if;

      --
      -- Mise à jour du réalisé en multi-sourcing
      --
      FAL_MSOURCING_FUNCTIONS.UpdateMultiSourcingRealized(:new.DOC_DOCUMENT_ID
                                                        , :new.GCO_GOOD_ID
                                                        , :new.GCO_GCO_GOOD_ID
                                                        , :old.GCO_GCO_GOOD_ID
                                                        , nvl(:new.PDE_FINAL_QUANTITY_SU, 0)
                                                        , nvl(:old.PDE_FINAL_QUANTITY_SU, 0)
                                                        , posNetUnitValueExclB
                                                        , posNetUnitValueExclB
                                                         );
    end if;
  end if;
end DOC_PDE_AU_MULTISOURCING;


ALTER TRIGGER "C_ITX"."DOC_PDE_AU_MULTISOURCING" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AU_NO_MORPH_CHAR"
  after update of DOC_POSITION_DETAIL_ID
                , GCO_GOOD_ID
                , PDE_CHARACTERIZATION_VALUE_1
                , PDE_CHARACTERIZATION_VALUE_2
                , PDE_CHARACTERIZATION_VALUE_3
                , PDE_CHARACTERIZATION_VALUE_4
                , PDE_CHARACTERIZATION_VALUE_5
                , DOC_RECORD_ID
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour de la table des numéros (pièce, lot et chronologique) et contrôle
*    éventuel de l'unicité des caractérisations lors de la création d'un détail
*    de position.
* @author VJ
* @created 07.05.2002
* @version 2003
* @lastUpdate
*/
declare
  vMovementSort     STM_MOVEMENT_KIND.C_MOVEMENT_SORT%type;
  vMovementKindID   STM_MOVEMENT_KIND.STM_MOVEMENT_KIND_ID%type;
  vTypePos          DOC_POSITION.C_GAUGE_TYPE_POS%type;
  vDesignation      DOC_GAUGE_POSITION.GAP_DESIGNATION%type;
  vUpdateMode       varchar2(2);
  vElementNumberID1 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vElementNumberID2 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vElementNumberID3 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  lQualityStatusId  STM_ELEMENT_NUMBER.GCO_QUALITY_STATUS_ID%type;
  vRecordElemNbrID  STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  lAllChar          DOC_GAUGE_STRUCTURED.GAS_ALL_CHARACTERIZATION%type;
begin
  if GCO_CHARACTERIZATION_FUNCTIONS.gCharManagementMode = 0 then
    -- Recherche du type de mouvement en fonction du domaine
    select decode(GAU.C_ADMIN_DOMAIN, '1', 'ENT',   -- Achat
                  '2', 'SOR',   -- Vente
                  '')
         , GAS_ALL_CHARACTERIZATION
      into vMovementSort
         , lAllChar
      from DOC_GAUGE GAU
         , DOC_GAUGE_STRUCTURED GAS
     where GAU.DOC_GAUGE_ID = :old.DOC_GAUGE_ID
       and GAS.DOC_GAUGE_ID = GAU.DOC_GAUGE_ID;

    -- traitement effectué seulement dans le cas ou l'on gère les caractérisations non-morphologiques
    if lAllChar = 1 then
      -- on vérifie que ce trigger soit déclenche par une modif d'un des champs ci-dessous
      -- et non pas par un autre triggr instead of
      if    nvl(:old.DOC_POSITION_DETAIL_ID, -1) <> nvl(:new.DOC_POSITION_DETAIL_ID, -1)
         or nvl(:old.GCO_GOOD_ID, -1) <> nvl(:new.GCO_GOOD_ID, -1)
         or nvl(:old.PDE_CHARACTERIZATION_VALUE_1, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_1, 'null')
         or nvl(:old.PDE_CHARACTERIZATION_VALUE_2, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_2, 'null')
         or nvl(:old.PDE_CHARACTERIZATION_VALUE_3, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_3, 'null')
         or nvl(:old.PDE_CHARACTERIZATION_VALUE_4, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_4, 'null')
         or nvl(:old.PDE_CHARACTERIZATION_VALUE_5, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_5, 'null') then
        -- Recherche du genre de mouvement de la position.
        select POS.STM_MOVEMENT_KIND_ID
             , POS.C_GAUGE_TYPE_POS
             , GAP.GAP_DESIGNATION
          into vMovementKindID
             , vTypePos
             , vDesignation
          from DOC_POSITION POS
             , DOC_GAUGE_POSITION GAP
         where POS.DOC_POSITION_ID = :old.DOC_POSITION_ID
           and GAP.DOC_GAUGE_POSITION_ID = POS.DOC_GAUGE_POSITION_ID
           and POS.C_GAUGE_TYPE_POS in('1', '2', '3', '7', '8', '71', '81', '91', '101', '21');

        if (    :old.STM_LOCATION_ID is not null
            and (   vMovementKindID is null
                 or :old.PDE_MOVEMENT_QUANTITY = 0) ) then
          /**
          * Recherche du mode de mise à jour des élements.
          *
          * On différentie l'effacement simple de l'effacement de position obtenue
          * par copie ou décharge.
          *
          *   DD = effacement d'un détail lié (détail fils ou cible),
          *   D  = effacement d'un détail non lié
          */
          if :old.DOC_GAUGE_RECEIPT_ID is not null then   /* Le détail de position est issu d'une décharge */
            select max(GAP.STM_MOVEMENT_KIND_ID)
              into vMovementKindID
              from DOC_GAUGE_POSITION GAP
                 , DOC_GAUGE_RECEIPT GAR
             where GAR.DOC_GAUGE_RECEIPT_ID = :old.DOC_GAUGE_RECEIPT_ID
               and GAP.DOC_GAUGE_ID = GAR.DOC_DOC_GAUGE_ID
               and GAP.C_GAUGE_TYPE_POS = vTypePos
               and GAP.GAP_DESIGNATION = vDesignation;

            if vMovementKindID is not null then   /* Le détail parent est lié à un genre de mouvement */
              vUpdateMode  := 'DD';
            else
              -- Remarque : J'effectue une nouvelle fois le teste sur la configuration,
              --   car je ne suis pas certain que le test initial sera conservé.
              if     (lAllChar = 1)
                 and (PCS.PC_CONFIG.GetConfig('DOC_CHARACTERIZATION_MODE') = '1') then   -- Le gabarit parent et la configuration gèrent tous les types de carctérisation
                vUpdateMode  := 'DD';
              else
                vUpdateMode  := 'D';
              end if;
            end if;
          elsif :old.DOC_GAUGE_COPY_ID is not null then   -- Le détail de position est issu d'une copie
            select max(GAP.STM_MOVEMENT_KIND_ID)
              into vMovementKindID
              from DOC_GAUGE_POSITION GAP
                 , DOC_GAUGE_COPY GAC
             where GAC.DOC_GAUGE_COPY_ID = :old.DOC_GAUGE_COPY_ID
               and GAP.DOC_GAUGE_ID = GAC.DOC_DOC_GAUGE_ID
               and GAP.C_GAUGE_TYPE_POS = vTypePos
               and GAP.GAP_DESIGNATION = vDesignation;

            if vMovementKindID is not null then   -- Le détail source est lié à un genre de mouvement
              vUpdateMode  := 'DD';
            else
              -- Remarque : J'effectue une nouvelle fois le teste sur la configuration,
              --   car je ne suis pas certain que le test initial sera conservé.
              if     (lAllChar = 1)
                 and (PCS.PC_CONFIG.GetConfig('DOC_CHARACTERIZATION_MODE') = '1') then   -- Le gabarit parent et la configuration gèrent tous les types de carctérisation
                vUpdateMode  := 'DD';
              else
                vUpdateMode  := 'D';
              end if;
            end if;
          else
            vUpdateMode  := 'D';
          end if;

          /**
          * Mise à jour de la table element_number et récupération des ID
          *
          * Remarques :
          *
          *  Le status de l'élement est définit dans la fonction (null transmis).
          *
          *  Il faut transmettre les ID et les valeurs de caractérisation sans
          *  tenir compte de l'éventuel non gestion en stock de celles-ci.
          */
          STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => :old.GCO_GOOD_ID   -- Bien
                                                  , iUpdateMode               => vUpdateMode   -- Mode de mise à jour
                                                  , iMovementSort             => vMovementSort   -- Type de mouvement 'ENT' = Entrée 'SOR' = Sortie
                                                  , iCharacterizationId       => :old.GCO_CHARACTERIZATION_ID   -- Caractérisation 1
                                                  , iCharacterization2Id      => :old.GCO_GCO_CHARACTERIZATION_ID
                                                  , iCharacterization3Id      => :old.GCO2_GCO_CHARACTERIZATION_ID
                                                  , iCharacterization4Id      => :old.GCO3_GCO_CHARACTERIZATION_ID
                                                  , iCharacterization5Id      => :old.GCO4_GCO_CHARACTERIZATION_ID
                                                  , iCharacterizationValue1   => :old.PDE_CHARACTERIZATION_VALUE_1   -- Valeur de caractérisation 1
                                                  , iCharacterizationValue2   => :old.PDE_CHARACTERIZATION_VALUE_2
                                                  , iCharacterizationValue3   => :old.PDE_CHARACTERIZATION_VALUE_3
                                                  , iCharacterizationValue4   => :old.PDE_CHARACTERIZATION_VALUE_4
                                                  , iCharacterizationValue5   => :old.PDE_CHARACTERIZATION_VALUE_5
                                                  , iVerifyChar               => 1   -- Vérification de l'unicité des valeurs de caract.
                                                  , iElementStatus            => null   -- Statut de l'élement après mise à jour
                                                  , ioElementNumberId1        => vElementNumberID1   -- Elément 1 en sortie
                                                  , ioElementNumberId2        => vElementNumberID2   -- Elément 2 en sortie
                                                  , ioElementNumberId3        => vElementNumberID3   -- Elément 3 en sortie
                                                  , ioQualityStatusId         => lQualityStatusId
                                                   );
        end if;

        select POS.STM_MOVEMENT_KIND_ID
          into vMovementKindID
          from DOC_POSITION POS
         where POS.DOC_POSITION_ID = :new.DOC_POSITION_ID;

        if (    :new.STM_LOCATION_ID is not null
            and (   vMovementKindID is null
                 or :new.PDE_MOVEMENT_QUANTITY = 0) ) then
          /* Recherche du type de mouvement en fonction du domaine */
          select decode(GAU.C_ADMIN_DOMAIN, '1', 'ENT',   /* Achat */
                        '2', 'SOR',   /* Vente */
                        '')
            into vMovementSort
            from DOC_GAUGE GAU
           where GAU.DOC_GAUGE_ID = :new.DOC_GAUGE_ID;

          /**
          * Mise à jour de la table element_number et récupération des ID
          *
          * Remarques :
          *
          *  Le status de l'élement est définit dans la fonction (null transmis).
          *
          *  Il faut transmettre les ID et les valeurs de caractérisation sans
          *  tenir compte de l'éventuel non gestion en stock de celles-ci.
          */
          STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => :new.GCO_GOOD_ID   -- Bien
                                                  , iUpdateMode               => 'I'   -- Mode de mise à jour
                                                  , iMovementSort             => vMovementSort   -- Type de mouvement 'ENT' = Entrée 'SOR' = Sortie
                                                  , iCharacterizationId       => :new.GCO_CHARACTERIZATION_ID   -- Caractérisation 1
                                                  , iCharacterization2Id      => :new.GCO_GCO_CHARACTERIZATION_ID
                                                  , iCharacterization3Id      => :new.GCO2_GCO_CHARACTERIZATION_ID
                                                  , iCharacterization4Id      => :new.GCO3_GCO_CHARACTERIZATION_ID
                                                  , iCharacterization5Id      => :new.GCO4_GCO_CHARACTERIZATION_ID
                                                  , iCharacterizationValue1   => :new.PDE_CHARACTERIZATION_VALUE_1   -- Valeur de caractérisation 1
                                                  , iCharacterizationValue2   => :new.PDE_CHARACTERIZATION_VALUE_2
                                                  , iCharacterizationValue3   => :new.PDE_CHARACTERIZATION_VALUE_3
                                                  , iCharacterizationValue4   => :new.PDE_CHARACTERIZATION_VALUE_4
                                                  , iCharacterizationValue5   => :new.PDE_CHARACTERIZATION_VALUE_5
                                                  , iVerifyChar               => 1   -- Vérification de l'unicité des valeurs de caract.
                                                  , iElementStatus            => null   -- Statut de l'élement après mise à jour
                                                  , ioElementNumberId1        => vElementNumberID1   -- Elément 1 en sortie
                                                  , ioElementNumberId2        => vElementNumberID2   -- Elément 2 en sortie
                                                  , ioElementNumberId3        => vElementNumberID3   -- Elément 3 en sortie
                                                  , ioQualityStatusId         => lQualityStatusId
                                                   );
        end if;
      end if;

      -- Si l'installation est renseignée et qu'une valeur de caract aussi
      -- il faut màj le numéro de série de l'installation
      if :new.DOC_RECORD_ID is not null then
        select POS.STM_MOVEMENT_KIND_ID
             , RCO.STM_ELEMENT_NUMBER_ID
          into vMovementKindID
             , vRecordElemNbrID
          from DOC_POSITION POS
             , DOC_RECORD RCO
         where POS.DOC_POSITION_ID = :new.DOC_POSITION_ID
           and RCO.DOC_RECORD_ID = :new.DOC_RECORD_ID;

        -- Màj du dossier avec le numéro de série du détail
        -- Vérifier s'il y a déjà un num de série sur le dossier
        if     (vMovementKindID is null)
           and (vRecordElemNbrID is null) then
          if    nvl(:old.DOC_RECORD_ID, -1) <> nvl(:new.DOC_RECORD_ID, -1)
             or nvl(:old.PDE_CHARACTERIZATION_VALUE_1, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_1, 'null')
             or nvl(:old.PDE_CHARACTERIZATION_VALUE_2, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_2, 'null')
             or nvl(:old.PDE_CHARACTERIZATION_VALUE_3, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_3, 'null')
             or nvl(:old.PDE_CHARACTERIZATION_VALUE_4, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_4, 'null')
             or nvl(:old.PDE_CHARACTERIZATION_VALUE_5, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_5, 'null') then
            -- Si pas de numero de série sur le dossier
              -- Màj du dossier avec le numéro de série du détail
            select max(STM_ELEMENT_NUMBER_ID)
              into vRecordElemNbrID
              from STM_ELEMENT_NUMBER
             where GCO_GOOD_ID = :new.GCO_GOOD_ID
               and C_ELEMENT_TYPE = '02'
               and SEM_VALUE in
                     (:new.PDE_CHARACTERIZATION_VALUE_1
                    , :new.PDE_CHARACTERIZATION_VALUE_2
                    , :new.PDE_CHARACTERIZATION_VALUE_3
                    , :new.PDE_CHARACTERIZATION_VALUE_4
                    , :new.PDE_CHARACTERIZATION_VALUE_5
                     );

            if vRecordElemNbrID is not null then
              update DOC_RECORD
                 set STM_ELEMENT_NUMBER_ID = vRecordElemNbrID
               where DOC_RECORD_ID = :new.DOC_RECORD_ID;
            end if;
          end if;
        end if;
      end if;
    end if;
  end if;
end DOC_PDE_AU_NO_MORPH_CHAR;

ALTER TRIGGER "C_ITX"."DOC_PDE_AU_NO_MORPH_CHAR" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AU_PACKING_PARCEL"
  after update of PDE_FINAL_QUANTITY
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Trigger d'effacement de toutes les positions colis liées avec le
*    du doc_position_detail_id avec mise à jour préalable des colis.
*    Ces modifications sont effectués si les quantités old new diffèrent.
* @author Jean-Philippe Zuttel
* @created 25/10/2000
* @version 2003
*/
begin
  -- on vérifie que ce triggers soit déclenche par une modif d'un des champs ci-dessous
  -- et non pas par un autre trigger instead of
  if nvl(:old.PDE_FINAL_QUANTITY, -1) <> nvl(:new.PDE_FINAL_QUANTITY, -1) then
    -- Mise à jour des colis.
    doc_packing.UpdateParcels(:old.DOC_POSITION_DETAIL_ID);
    -- Suppression des positions du colis.
    doc_packing.DeleteParcelPositions(:old.DOC_POSITION_DETAIL_ID);
  end if;
end DOC_PDE_AU_PACKING_PARCEL;

ALTER TRIGGER "C_ITX"."DOC_PDE_AU_PACKING_PARCEL" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AU_POSI_ACCU"
  after update of GCO_CHARACTERIZATION_ID
                , GCO_GCO_CHARACTERIZATION_ID
                , GCO2_GCO_CHARACTERIZATION_ID
                , GCO3_GCO_CHARACTERIZATION_ID
                , GCO4_GCO_CHARACTERIZATION_ID
                , PDE_CHARACTERIZATION_VALUE_1
                , PDE_CHARACTERIZATION_VALUE_2
                , PDE_CHARACTERIZATION_VALUE_3
                , PDE_CHARACTERIZATION_VALUE_4
                , PDE_CHARACTERIZATION_VALUE_5
                , PDE_FINAL_DELAY
                , PDE_FINAL_QUANTITY
                , PDE_BALANCE_QUANTITY
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des totalisateurs de position
* @author Fabrice Perotto
* @version 2003
*/
declare
  -- Curseur de détail des positions du document
  cursor DETAIL_POSITION_CURSOR(doc_pos_id number)
  is
    select POS.GCO_GOOD_ID
         , DOC.PAC_THIRD_ID
         , DOC.DIC_GAUGE_TYPE_DOC_ID
         , GPO.GAP_DELAY
         , DOC.DMT_DATE_DOCUMENT
         , DOC.DMT_RATE_OF_EXCHANGE
         , DOC.DMT_BASE_PRICE
         , POS.POS_NET_VALUE_EXCL_B
         , POS.C_DOC_POS_STATUS
         , POS.C_GAUGE_TYPE_POS
         , GST.GAS_BALANCE_STATUS
         , GAU.C_GAUGE_TYPE
      from DOC_DOCUMENT DOC
         , DOC_POSITION POS
         , DOC_GAUGE_POSITION GPO
         , DOC_GAUGE_STRUCTURED GST
         , DOC_GAUGE GAU
     where POS.DOC_DOCUMENT_ID = DOC.DOC_DOCUMENT_ID
       and GPO.DOC_GAUGE_POSITION_ID = POS.DOC_GAUGE_POSITION_ID
       and POS.DOC_POSITION_ID = doc_pos_id
       and GST.DOC_GAUGE_ID = DOC.DOC_GAUGE_ID
       and GAU.DOC_GAUGE_ID = GST.DOC_GAUGE_ID
       and POS.C_GAUGE_TYPE_POS in('1', '2', '3', '7', '8', '91', '101', '21');

  detail_position_tuple DETAIL_POSITION_CURSOR%rowtype;
begin
  -- on vérifie que ce triggers soit déclenche par une modif d'un des champs ci-dessous
  -- et non pas par un autre trigger instead of
  if    nvl(:old.GCO_CHARACTERIZATION_ID, -1) <> nvl(:new.GCO_CHARACTERIZATION_ID, -1)
     or nvl(:old.GCO_GCO_CHARACTERIZATION_ID, -1) <> nvl(:new.GCO_GCO_CHARACTERIZATION_ID, -1)
     or nvl(:old.GCO2_GCO_CHARACTERIZATION_ID, -1) <> nvl(:new.GCO2_GCO_CHARACTERIZATION_ID, -1)
     or nvl(:old.GCO3_GCO_CHARACTERIZATION_ID, -1) <> nvl(:new.GCO3_GCO_CHARACTERIZATION_ID, -1)
     or nvl(:old.GCO4_GCO_CHARACTERIZATION_ID, -1) <> nvl(:new.GCO4_GCO_CHARACTERIZATION_ID, -1)
     or nvl(:old.PDE_CHARACTERIZATION_VALUE_1, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_1, 'null')
     or nvl(:old.PDE_CHARACTERIZATION_VALUE_2, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_2, 'null')
     or nvl(:old.PDE_CHARACTERIZATION_VALUE_3, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_3, 'null')
     or nvl(:old.PDE_CHARACTERIZATION_VALUE_4, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_4, 'null')
     or nvl(:old.PDE_CHARACTERIZATION_VALUE_5, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_5, 'null')
     or nvl(:old.PDE_FINAL_DELAY, to_date('31.12.2999', 'DD.MM.YYYY') ) <>
                                                         nvl(:new.PDE_FINAL_DELAY, to_date('31.12.2999', 'DD.MM.YYYY') )
     or nvl(:old.PDE_FINAL_QUANTITY, -1) <> nvl(:new.PDE_FINAL_QUANTITY, -1)
     or nvl(:old.PDE_BALANCE_QUANTITY, -1) <> nvl(:new.PDE_BALANCE_QUANTITY, -1) then
    -- pas de mise à jour des totalisateurs (possible uniquement par recalcul global)
    if PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '0' then
      null;
    -- mise à jour instantannée des totalisateurs de position
    elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '1' then
      -- Ouverture du curseur de détail du document
      open detail_position_cursor(:old.DOC_POSITION_ID);

      -- Première position de détail
      fetch detail_position_cursor
       into detail_position_tuple;

      if detail_position_cursor%found then
        -- retrait des anciennes valeurs
        DOC_ACCUMULATOR.DOC_TOTAL_POSITION(detail_position_tuple.GCO_GOOD_ID
                                         , detail_position_tuple.PAC_THIRD_ID
                                         , detail_position_tuple.DIC_GAUGE_TYPE_DOC_ID
                                         , :old.GCO_CHARACTERIZATION_ID
                                         , :old.GCO_GCO_CHARACTERIZATION_ID
                                         , :old.GCO2_GCO_CHARACTERIZATION_ID
                                         , :old.GCO3_GCO_CHARACTERIZATION_ID
                                         , :old.GCO4_GCO_CHARACTERIZATION_ID
                                         , :old.PDE_CHARACTERIZATION_VALUE_1
                                         , :old.PDE_CHARACTERIZATION_VALUE_2
                                         , :old.PDE_CHARACTERIZATION_VALUE_3
                                         , :old.PDE_CHARACTERIZATION_VALUE_4
                                         , :old.PDE_CHARACTERIZATION_VALUE_5
                                         , detail_position_tuple.GAP_DELAY
                                         , nvl(:old.PDE_FINAL_DELAY, detail_position_tuple.DMT_DATE_DOCUMENT)
                                         , detail_position_tuple.DMT_DATE_DOCUMENT
                                         , :old.PDE_FINAL_QUANTITY
                                         , :old.PDE_BALANCE_QUANTITY
                                         , detail_position_tuple.POS_NET_VALUE_EXCL_B
                                         , detail_position_tuple.C_DOC_POS_STATUS
                                         , detail_position_tuple.GAS_BALANCE_STATUS
                                         , detail_position_tuple.C_GAUGE_TYPE
                                         , -1
                                         , 0
                                          );
        -- Ajout des nouvelles valeurs
        DOC_ACCUMULATOR.DOC_TOTAL_POSITION(detail_position_tuple.GCO_GOOD_ID
                                         , detail_position_tuple.PAC_THIRD_ID
                                         , detail_position_tuple.DIC_GAUGE_TYPE_DOC_ID
                                         , :new.GCO_CHARACTERIZATION_ID
                                         , :new.GCO_GCO_CHARACTERIZATION_ID
                                         , :new.GCO2_GCO_CHARACTERIZATION_ID
                                         , :new.GCO3_GCO_CHARACTERIZATION_ID
                                         , :new.GCO4_GCO_CHARACTERIZATION_ID
                                         , :new.PDE_CHARACTERIZATION_VALUE_1
                                         , :new.PDE_CHARACTERIZATION_VALUE_2
                                         , :new.PDE_CHARACTERIZATION_VALUE_3
                                         , :new.PDE_CHARACTERIZATION_VALUE_4
                                         , :new.PDE_CHARACTERIZATION_VALUE_5
                                         , detail_position_tuple.GAP_DELAY
                                         , nvl(:new.PDE_FINAL_DELAY, detail_position_tuple.DMT_DATE_DOCUMENT)
                                         , detail_position_tuple.DMT_DATE_DOCUMENT
                                         , :new.PDE_FINAL_QUANTITY
                                         , :new.PDE_BALANCE_QUANTITY
                                         , detail_position_tuple.POS_NET_VALUE_EXCL_B
                                         , detail_position_tuple.C_DOC_POS_STATUS
                                         , detail_position_tuple.GAS_BALANCE_STATUS
                                         , detail_position_tuple.C_GAUGE_TYPE
                                         , 1
                                         , 0
                                          );
      end if;

      close detail_position_cursor;
    -- insertion dans le buffer des totalisateurs de position (maj différée)
    elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '2' then
      insert into DOC_POSI_ACCU_BUFFER
                  (DOC_POSI_ACCU_BUFFER_ID
                 , ABU_SIGN
                 , C_DOC_POS_STATUS
                 , C_GAUGE_TYPE
                 , GCO_GOOD_ID
                 , PAC_THIRD_ID
                 , DIC_GAUGE_TYPE_DOC_ID
                 , GCO_CHARACTERIZATION_ID
                 , GCO_GCO_CHARACTERIZATION_ID
                 , GCO2_GCO_CHARACTERIZATION_ID
                 , GCO3_GCO_CHARACTERIZATION_ID
                 , GCO4_GCO_CHARACTERIZATION_ID
                 , ABU_CHARACTERIZATION_VALUE_1
                 , ABU_CHARACTERIZATION_VALUE_2
                 , ABU_CHARACTERIZATION_VALUE_3
                 , ABU_CHARACTERIZATION_VALUE_4
                 , ABU_CHARACTERIZATION_VALUE_5
                 , ABU_DELAY
                 , ABU_FINAL_DELAY
                 , ABU_DOCUMENT_DATE
                 , ABU_FINAL_QUANTITY
                 , ABU_BALANCE_QUANTITY
                 , ABU_NET_VALUE_EXCL
                 , ABU_BALANCE_STATUS
                  )
        select INIT_ID_SEQ.nextval
             , -1
             , POS.C_DOC_POS_STATUS
             , GAU.C_GAUGE_TYPE
             , POS.GCO_GOOD_ID
             , DOC.PAC_THIRD_ID
             , DOC.DIC_GAUGE_TYPE_DOC_ID
             , :old.GCO_CHARACTERIZATION_ID
             , :old.GCO_GCO_CHARACTERIZATION_ID
             , :old.GCO2_GCO_CHARACTERIZATION_ID
             , :old.GCO3_GCO_CHARACTERIZATION_ID
             , :old.GCO4_GCO_CHARACTERIZATION_ID
             , :old.PDE_CHARACTERIZATION_VALUE_1
             , :old.PDE_CHARACTERIZATION_VALUE_2
             , :old.PDE_CHARACTERIZATION_VALUE_3
             , :old.PDE_CHARACTERIZATION_VALUE_4
             , :old.PDE_CHARACTERIZATION_VALUE_5
             , GPO.GAP_DELAY
             , nvl(:old.PDE_FINAL_DELAY, DOC.DMT_DATE_DOCUMENT)
             , DOC.DMT_DATE_DOCUMENT
             , :old.PDE_FINAL_QUANTITY
             , :old.PDE_BALANCE_QUANTITY
             , POS.POS_NET_VALUE_EXCL_B
             , GST.GAS_BALANCE_STATUS
          from DOC_DOCUMENT DOC
             , DOC_POSITION POS
             , DOC_GAUGE_POSITION GPO
             , DOC_GAUGE_STRUCTURED GST
             , DOC_GAUGE GAU
         where POS.DOC_DOCUMENT_ID = DOC.DOC_DOCUMENT_ID
           and GPO.DOC_GAUGE_POSITION_ID = POS.DOC_GAUGE_POSITION_ID
           and POS.DOC_POSITION_ID = :old.DOC_POSITION_ID
           and GST.DOC_GAUGE_ID = DOC.DOC_GAUGE_ID
           and GAU.DOC_GAUGE_ID = GST.DOC_GAUGE_ID
           and POS.C_GAUGE_TYPE_POS in('1', '2', '3', '7', '8', '91', '101', '21');

      -- Ajout des nouvelles valeurs
      insert into DOC_POSI_ACCU_BUFFER
                  (DOC_POSI_ACCU_BUFFER_ID
                 , ABU_SIGN
                 , C_DOC_POS_STATUS
                 , C_GAUGE_TYPE
                 , GCO_GOOD_ID
                 , PAC_THIRD_ID
                 , DIC_GAUGE_TYPE_DOC_ID
                 , GCO_CHARACTERIZATION_ID
                 , GCO_GCO_CHARACTERIZATION_ID
                 , GCO2_GCO_CHARACTERIZATION_ID
                 , GCO3_GCO_CHARACTERIZATION_ID
                 , GCO4_GCO_CHARACTERIZATION_ID
                 , ABU_CHARACTERIZATION_VALUE_1
                 , ABU_CHARACTERIZATION_VALUE_2
                 , ABU_CHARACTERIZATION_VALUE_3
                 , ABU_CHARACTERIZATION_VALUE_4
                 , ABU_CHARACTERIZATION_VALUE_5
                 , ABU_DELAY
                 , ABU_FINAL_DELAY
                 , ABU_DOCUMENT_DATE
                 , ABU_FINAL_QUANTITY
                 , ABU_BALANCE_QUANTITY
                 , ABU_NET_VALUE_EXCL
                 , ABU_BALANCE_STATUS
                  )
        select INIT_ID_SEQ.nextval
             , 1
             , POS.C_DOC_POS_STATUS
             , GAU.C_GAUGE_TYPE
             , POS.GCO_GOOD_ID
             , DOC.PAC_THIRD_ID
             , DOC.DIC_GAUGE_TYPE_DOC_ID
             , :new.GCO_CHARACTERIZATION_ID
             , :new.GCO_GCO_CHARACTERIZATION_ID
             , :new.GCO2_GCO_CHARACTERIZATION_ID
             , :new.GCO3_GCO_CHARACTERIZATION_ID
             , :new.GCO4_GCO_CHARACTERIZATION_ID
             , :new.PDE_CHARACTERIZATION_VALUE_1
             , :new.PDE_CHARACTERIZATION_VALUE_2
             , :new.PDE_CHARACTERIZATION_VALUE_3
             , :new.PDE_CHARACTERIZATION_VALUE_4
             , :new.PDE_CHARACTERIZATION_VALUE_5
             , GPO.GAP_DELAY
             , nvl(:new.PDE_FINAL_DELAY, DOC.DMT_DATE_DOCUMENT)
             , DOC.DMT_DATE_DOCUMENT
             , :new.PDE_FINAL_QUANTITY
             , :new.PDE_BALANCE_QUANTITY
             , POS.POS_NET_VALUE_EXCL_B
             , GST.GAS_BALANCE_STATUS
          from DOC_DOCUMENT DOC
             , DOC_POSITION POS
             , DOC_GAUGE_POSITION GPO
             , DOC_GAUGE_STRUCTURED GST
             , DOC_GAUGE GAU
         where POS.DOC_DOCUMENT_ID = DOC.DOC_DOCUMENT_ID
           and GPO.DOC_GAUGE_POSITION_ID = POS.DOC_GAUGE_POSITION_ID
           and POS.DOC_POSITION_ID = :new.DOC_POSITION_ID
           and GST.DOC_GAUGE_ID = DOC.DOC_GAUGE_ID
           and GAU.DOC_GAUGE_ID = GST.DOC_GAUGE_ID
           and POS.C_GAUGE_TYPE_POS in('1', '2', '3', '7', '8', '91', '101', '21');
    end if;
  end if;
end DOC_PDE_AU_POSI_ACCU;

ALTER TRIGGER "C_ITX"."DOC_PDE_AU_POSI_ACCU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_AU_PROV_QTY"
  after update of DOC_POSITION_DETAIL_ID
                , DOC_POSITION_ID
                , GCO_CHARACTERIZATION_ID
                , GCO_GCO_CHARACTERIZATION_ID
                , GCO2_GCO_CHARACTERIZATION_ID
                , GCO3_GCO_CHARACTERIZATION_ID
                , GCO4_GCO_CHARACTERIZATION_ID
                , PDE_BASIS_QUANTITY
                , PDE_CHARACTERIZATION_VALUE_1
                , PDE_CHARACTERIZATION_VALUE_2
                , PDE_CHARACTERIZATION_VALUE_3
                , PDE_CHARACTERIZATION_VALUE_4
                , PDE_CHARACTERIZATION_VALUE_5
                , PDE_FINAL_QUANTITY
                , PDE_MOVEMENT_QUANTITY
                , STM_LOCATION_ID
                , STM_STM_LOCATION_ID
                , DOC_GAUGE_RECEIPT_ID
                , DOC_RECORD_ID
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des quantités provisoires à la modification d'un détail de position
* @created fpe 01.01.1998
* @updated fpe 17.06.2014 - DEVERP-20671 Documents de transfert: Pas de quantité sortie provisoire si stock cible vide
*/
declare
  -- recherche du type de mouvement de stock et de l'id du bien d'aprSs la table des positions
  cursor crMovementKind(aCrPositionId number)
  is
    select MOK.C_MOVEMENT_SORT
         , MOK.MOK_STANDARD_SIGN
         , POS.GCO_GOOD_ID
         , MOK.STM_MOVEMENT_KIND_ID
         , MOK.STM_STM_MOVEMENT_KIND_ID
         , POS.C_DOC_POS_STATUS
         , POS.POS_GENERATE_MOVEMENT
         , MOK.MOK_VERIFY_CHARACTERIZATION
         , MOK.MOK_RETURN
         , POS.C_GAUGE_TYPE_POS
         , POS.STM_STOCK_ID
         , POS.STM_STM_STOCK_ID
         , POS.POS_CONVERT_FACTOR
      from STM_MOVEMENT_KIND MOK
         , DOC_POSITION POS
     where MOK.STM_MOVEMENT_KIND_ID = POS.STM_MOVEMENT_KIND_ID
       and POS.DOC_POSITION_ID = aCrPositionId
       and POS.C_GAUGE_TYPE_POS in('1', '2', '3', '7', '8', '71', '81', '91', '101')
       and POS.POS_GENERATE_MOVEMENT = 0;

  cursor crExtourneMovement(aCrParentDetailId number, aCrGaugeReceiptId number)
  is
    select SMO.GCO_GOOD_ID
         , SMO.GCO_CHARACTERIZATION_ID
         , SMO.GCO_GCO_CHARACTERIZATION_ID
         , SMO.GCO2_GCO_CHARACTERIZATION_ID
         , SMO.GCO3_GCO_CHARACTERIZATION_ID
         , SMO.GCO4_GCO_CHARACTERIZATION_ID
         , SMO.SMO_CHARACTERIZATION_VALUE_1
         , SMO.SMO_CHARACTERIZATION_VALUE_2
         , SMO.SMO_CHARACTERIZATION_VALUE_3
         , SMO.SMO_CHARACTERIZATION_VALUE_4
         , SMO.SMO_CHARACTERIZATION_VALUE_5
         , SMO.STM_STOCK_ID
         , SMO.STM_LOCATION_ID
         , SMO.SMO_MOVEMENT_QUANTITY
         , MOK.C_MOVEMENT_SORT
         , MOK.MOK_STANDARD_SIGN
         , MOK.MOK_VERIFY_CHARACTERIZATION
         , MOK.STM_MOVEMENT_KIND_ID
         , MOK.STM_STM_MOVEMENT_KIND_ID
      from STM_STOCK_MOVEMENT SMO
         , DOC_GAUGE_RECEIPT DGR
         , STM_MOVEMENT_KIND MOK
     where DGR.DOC_GAUGE_RECEIPT_ID = aCrGaugeReceiptId
       and DGR.GAR_EXTOURNE_MVT = 1
       and nvl(SMO.SMO_EXTOURNE_MVT, 0) = 0
       and SMO.DOC_POSITION_DETAIL_ID = aCrParentDetailId
       and MOK.STM_MOVEMENT_KIND_ID = SMO.STM_MOVEMENT_KIND_ID
       and MOK.C_MOVEMENT_TYPE <> 'EXE';

  vTplMovementKind           crMovementKind%rowtype;
  vTplOldExtourneMvt         crExtourneMovement%rowtype;
  vTplNewExtourneMvt         crExtourneMovement%rowtype;
  vVerifyCharacterization    number(1);
  vMainStockId               STM_STOCK.STM_STOCK_ID%type;
  vTransStockId              STM_STOCK.STM_STOCK_ID%type;
  vDeleteProvisoryQuantities number(1);
  vCreateProvisoryQuantities number(1);
  vUpdateMode                varchar2(2);
  vMovementKindID            STM_MOVEMENT_KIND.STM_MOVEMENT_KIND_ID%type;
  vRecordElemNbrID           STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vFlagAtLeastOneChar        boolean
    :=(    (:new.PDE_CHARACTERIZATION_VALUE_1 is not null)
       or (:new.PDE_CHARACTERIZATION_VALUE_2 is not null)
       or (:new.PDE_CHARACTERIZATION_VALUE_3 is not null)
       or (:new.PDE_CHARACTERIZATION_VALUE_4 is not null)
       or (:new.PDE_CHARACTERIZATION_VALUE_5 is not null)
      );
  vFlagUseRecord             boolean                                         :=(:new.DOC_RECORD_ID is not null);
  vFlagStockInfoModified     boolean
    :=    nvl(:old.DOC_POSITION_DETAIL_ID, -1) <> nvl(:new.DOC_POSITION_DETAIL_ID, -1)
       or nvl(:old.GCO_CHARACTERIZATION_ID, -1) <> nvl(:new.GCO_CHARACTERIZATION_ID, -1)
       or nvl(:old.GCO_GCO_CHARACTERIZATION_ID, -1) <> nvl(:new.GCO_GCO_CHARACTERIZATION_ID, -1)
       or nvl(:old.GCO2_GCO_CHARACTERIZATION_ID, -1) <> nvl(:new.GCO2_GCO_CHARACTERIZATION_ID, -1)
       or nvl(:old.GCO3_GCO_CHARACTERIZATION_ID, -1) <> nvl(:new.GCO3_GCO_CHARACTERIZATION_ID, -1)
       or nvl(:old.GCO4_GCO_CHARACTERIZATION_ID, -1) <> nvl(:new.GCO4_GCO_CHARACTERIZATION_ID, -1)
       or nvl(:old.PDE_BASIS_QUANTITY, -1) <> nvl(:new.PDE_BASIS_QUANTITY, -1)
       or nvl(:old.PDE_CHARACTERIZATION_VALUE_1, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_1, 'null')
       or nvl(:old.PDE_CHARACTERIZATION_VALUE_2, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_2, 'null')
       or nvl(:old.PDE_CHARACTERIZATION_VALUE_3, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_3, 'null')
       or nvl(:old.PDE_CHARACTERIZATION_VALUE_4, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_4, 'null')
       or nvl(:old.PDE_CHARACTERIZATION_VALUE_5, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_5, 'null')
       or nvl(:old.PDE_FINAL_QUANTITY, -1) <> nvl(:new.PDE_FINAL_QUANTITY, -1)
       or nvl(:old.PDE_MOVEMENT_QUANTITY, -1) <> nvl(:new.PDE_MOVEMENT_QUANTITY, -1)
       or nvl(:old.STM_LOCATION_ID, -1) <> nvl(:new.STM_LOCATION_ID, -1)
       or nvl(:old.STM_STM_LOCATION_ID, -1) <> nvl(:new.STM_STM_LOCATION_ID, -1)
       or nvl(:old.DOC_GAUGE_RECEIPT_ID, -1) <> nvl(:new.DOC_GAUGE_RECEIPT_ID, -1);
  vNoMove                    boolean                                         := false;
begin
  -- integrity constraint
  if :old.DOC_POSITION_ID <> :new.DOC_POSITION_ID then
    raise_application_error(-20005, 'PCS - column DOC_POSITION_ID of table DOC_DETAIL_POSITION cannot be changed');
  end if;

  -- on vérifie que ce trigger soit déclenche par une modif touchant la quantité en stock
  if vFlagStockInfoModified then
    -- Mise à jour des quantitées provisoires en stock lors
    -- d'une modification du détail des positions

    -- recherche du type de mouvement de stock et de l'id du bien d'aprss la table des positions
    for vTplMovementKind in crMovementKind(:old.DOC_POSITION_ID) loop
      if :old.STM_LOCATION_ID is null then
        vDeleteProvisoryQuantities  := 0;
      else   /* Emplacement source existant lors de la création ou à la modification précédente */
        if     (nvl(vTplMovementKind.STM_STM_MOVEMENT_KIND_ID, 0) <> 0)
           and :old.STM_STM_LOCATION_ID is not null then   /* Mouvement de transfert (peux valoir 0) */
          if :old.STM_STM_LOCATION_ID is not null then   /* L'emplacement cible initiale n'était pas vide avant la modification */
            if :old.STM_LOCATION_ID = :old.STM_STM_LOCATION_ID then
              vDeleteProvisoryQuantities  := 0;
            else
              vDeleteProvisoryQuantities  := 1;
            end if;
          else   /* L'emplacement cible initiale était vide avant la modification */
            vDeleteProvisoryQuantities  := 0;
          end if;
        else   /* Pas de mouvement de transfert */
          vDeleteProvisoryQuantities  := 1;
        end if;
      end if;

      /**
      * Retrait des anciennes valeurs
      */
      if (vDeleteProvisoryQuantities = 1) then
        /* Recherche les stocks en fonction des emplacements. */
        select STM_STOCK_ID
          into vMainStockId
          from STM_LOCATION
         where STM_LOCATION_ID = :old.STM_LOCATION_ID;

        select max(STM_STOCK_ID)
          into vTransStockId
          from STM_LOCATION
         where STM_LOCATION_ID = :old.STM_STM_LOCATION_ID;

        if :new.PDE_FINAL_QUANTITY = :old.PDE_FINAL_QUANTITY then
          vUpdateMode  := 'DU';
        else
          vUpdateMode  := 'D';
        end if;

        -- Eventuellement traitement de l'extourne
        open crExtourneMovement(:old.DOC_DOC_POSITION_DETAIL_ID, :old.DOC_GAUGE_RECEIPT_ID);

        fetch crExtourneMovement
         into vTplOldExtourneMvt;

        -- en cas d'extourne sur le même emplacement avec le même genre de mouvement, on ne fait aucune mise à jour
        vNoMove  :=
              crExtourneMovement%found
          and (vTplOldExtourneMvt.C_MOVEMENT_SORT = vTplMovementKind.C_MOVEMENT_SORT)
          and (vTplOldExtourneMvt.MOK_STANDARD_SIGN = vTplMovementKind.MOK_STANDARD_SIGN)
          and (vTplOldExtourneMvt.STM_LOCATION_ID = :old.STM_LOCATION_ID)
          and (vTplOldExtourneMvt.GCO_GOOD_ID = vTplMovementKind.GCO_GOOD_ID)
          and vTplOldExtourneMvt.STM_STM_MOVEMENT_KIND_ID is null
          and (:old.PDE_MOVEMENT_QUANTITY =
                 sign(:old.PDE_MOVEMENT_QUANTITY) *
                 least(abs(:old.PDE_MOVEMENT_QUANTITY +(nvl(:old.PDE_BALANCE_QUANTITY_PARENT, 0) * vTplMovementKind.POS_CONVERT_FACTOR) )
                     , abs(vTplOldExtourneMvt.SMO_MOVEMENT_QUANTITY)
                      )
              );

        if not vNoMove then
          DOC_INIT_MOVEMENT.DOC_PROV_QTY(good_id                       => vTplMovementKind.GCO_GOOD_ID
                                       , update_mode                   => vUpdateMode   -- Mode suppression
                                       , move_sort                     => vTplMovementKind.C_MOVEMENT_SORT
                                       , verify_char                   => vTplMovementKind.MOK_VERIFY_CHARACTERIZATION
                                       , parity_move_kind_id           => vTplMovementKind.STM_STM_MOVEMENT_KIND_ID
                                       , charact_id_1                  => :old.GCO_CHARACTERIZATION_ID
                                       , charact_id_2                  => :old.GCO_GCO_CHARACTERIZATION_ID
                                       , charact_id_3                  => :old.GCO2_GCO_CHARACTERIZATION_ID
                                       , charact_id_4                  => :old.GCO3_GCO_CHARACTERIZATION_ID
                                       , charact_id_5                  => :old.GCO4_GCO_CHARACTERIZATION_ID
                                       , charact_val_1                 => :old.PDE_CHARACTERIZATION_VALUE_1
                                       , charact_val_2                 => :old.PDE_CHARACTERIZATION_VALUE_2
                                       , charact_val_3                 => :old.PDE_CHARACTERIZATION_VALUE_3
                                       , charact_val_4                 => :old.PDE_CHARACTERIZATION_VALUE_4
                                       , charact_val_5                 => :old.PDE_CHARACTERIZATION_VALUE_5
                                       , stock_id                      => vMainStockId
                                       , location_id                   => :old.STM_LOCATION_ID
                                       , trans_stock_id                => vTransStockId
                                       , trans_location_id             => :old.STM_STM_LOCATION_ID
                                       , movement_quantity             => :old.PDE_MOVEMENT_QUANTITY *(-1)
                                       , iCharacterizationTwinValue1   => :new.PDE_CHARACTERIZATION_VALUE_1
                                       , iCharacterizationTwinValue2   => :new.PDE_CHARACTERIZATION_VALUE_2
                                       , iCharacterizationTwinValue3   => :new.PDE_CHARACTERIZATION_VALUE_3
                                       , iCharacterizationTwinValue4   => :new.PDE_CHARACTERIZATION_VALUE_4
                                       , iCharacterizationTwinValue5   => :new.PDE_CHARACTERIZATION_VALUE_5
                                        );

          if crExtourneMovement%found then
            -- Retrait des quantités provisoires de l'extourne
            DOC_INIT_MOVEMENT.DOC_PROV_QTY(good_id               => vTplOldExtourneMvt.GCO_GOOD_ID
                                         , update_mode           => vUpdateMode   -- Mode suppression
                                         , move_sort             => vTplOldExtourneMvt.C_MOVEMENT_SORT
                                         , verify_char           => vTplOldExtourneMvt.MOK_VERIFY_CHARACTERIZATION
                                         , parity_move_kind_id   => vTplOldExtourneMvt.STM_STM_MOVEMENT_KIND_ID
                                         , charact_id_1          => vTplOldExtourneMvt.GCO_CHARACTERIZATION_ID
                                         , charact_id_2          => vTplOldExtourneMvt.GCO_GCO_CHARACTERIZATION_ID
                                         , charact_id_3          => vTplOldExtourneMvt.GCO2_GCO_CHARACTERIZATION_ID
                                         , charact_id_4          => vTplOldExtourneMvt.GCO3_GCO_CHARACTERIZATION_ID
                                         , charact_id_5          => vTplOldExtourneMvt.GCO4_GCO_CHARACTERIZATION_ID
                                         , charact_val_1         => vTplOldExtourneMvt.SMO_CHARACTERIZATION_VALUE_1
                                         , charact_val_2         => vTplOldExtourneMvt.SMO_CHARACTERIZATION_VALUE_2
                                         , charact_val_3         => vTplOldExtourneMvt.SMO_CHARACTERIZATION_VALUE_3
                                         , charact_val_4         => vTplOldExtourneMvt.SMO_CHARACTERIZATION_VALUE_4
                                         , charact_val_5         => vTplOldExtourneMvt.SMO_CHARACTERIZATION_VALUE_5
                                         , stock_id              => vTplOldExtourneMvt.STM_STOCK_ID
                                         , location_id           => vTplOldExtourneMvt.STM_LOCATION_ID
                                         , trans_stock_id        => null
                                         , trans_location_id     => null
                                         , movement_quantity     => sign(:old.PDE_MOVEMENT_QUANTITY) *
                                                                    least(abs(:old.PDE_MOVEMENT_QUANTITY +
                                                                              (nvl(:old.PDE_BALANCE_QUANTITY_PARENT, 0) * vTplMovementKind.POS_CONVERT_FACTOR
                                                                              )
                                                                             )
                                                                        , abs(vTplOldExtourneMvt.SMO_MOVEMENT_QUANTITY)
                                                                         )
                                          );
          end if;
        end if;

        close crExtourneMovement;
      end if;

      if :new.STM_LOCATION_ID is null then
        vCreateProvisoryQuantities  := 0;
      else   /* Emplacement source existant lors de la modification courante */
        if     (nvl(vTplMovementKind.STM_STM_MOVEMENT_KIND_ID, 0) <> 0)
           and :new.STM_STM_LOCATION_ID is not null then   /* Mouvement de transfert (peux valoir 0) */
          if :new.STM_STM_LOCATION_ID is not null then   /* Le nouvel emplacement cible n'est pas vide */
            if :new.STM_LOCATION_ID = :new.STM_STM_LOCATION_ID then
              vCreateProvisoryQuantities  := 0;
            else
              vCreateProvisoryQuantities  := 1;
            end if;
          else   /* Le nouvel emplacement cible est vide */
            vCreateProvisoryQuantities  := 0;
          end if;
        else   /* Pas de mouvement de transfert */
          vCreateProvisoryQuantities  := 1;
        end if;
      end if;

      /**
      * Ajout des nouvelles valeurs
      */
      if (vCreateProvisoryQuantities = 1) then
        vVerifyCharacterization  := vTplMovementKind.mok_verify_characterization;

        -- Eventuellement traitement de l'extourne
        open crExtourneMovement(:new.DOC_DOC_POSITION_DETAIL_ID, :new.DOC_GAUGE_RECEIPT_ID);

        fetch crExtourneMovement
         into vTplNewExtourneMvt;

        -- en cas d'extourne sur le même emplacement avec le même genre de mouvement, on ne fait aucune mise à jour
        vNoMove                  :=
              crExtourneMovement%found
          and (vTplNewExtourneMvt.C_MOVEMENT_SORT = vTplMovementKind.C_MOVEMENT_SORT)
          and (vTplNewExtourneMvt.MOK_STANDARD_SIGN = vTplMovementKind.MOK_STANDARD_SIGN)
          and (vTplNewExtourneMvt.STM_LOCATION_ID = :new.STM_LOCATION_ID)
          and (vTplNewExtourneMvt.GCO_GOOD_ID = vTplMovementKind.GCO_GOOD_ID)
          and (:new.PDE_MOVEMENT_QUANTITY =
                 sign(:new.PDE_MOVEMENT_QUANTITY) *
                 least(abs(:new.PDE_MOVEMENT_QUANTITY +(nvl(:new.PDE_BALANCE_QUANTITY_PARENT, 0) * vTplMovementKind.POS_CONVERT_FACTOR) )
                     , abs(vTplNewExtourneMvt.SMO_MOVEMENT_QUANTITY)
                      )
              );

        if not vNoMove then
          -- Force de ne pas effectuer le contrôle des valeurs de caractérisation
          -- si la quantité du mouvement est égal à zéro et que le détail est issu
          -- d'une décharge ou que la décharge demande l'extourne du mouvement parent.
          if    (     (:new.PDE_MOVEMENT_QUANTITY = 0)
                 and :new.DOC_DOC_POSITION_DETAIL_ID is not null)
             or (crExtourneMovement%found) then
            vVerifyCharacterization  := 0;
          end if;

          /* Recherche les stocks en fonction des emplacements. */
          select STM_STOCK_ID
            into vMainStockId
            from STM_LOCATION
           where STM_LOCATION_ID = :new.STM_LOCATION_ID;

          select max(STM_STOCK_ID)
            into vTransStockId
            from STM_LOCATION
           where STM_LOCATION_ID = :new.STM_STM_LOCATION_ID;

          if vTplMovementKind.MOK_RETURN = 1 then
            vUpdateMode  := 'IR';   -- mouvement de retour
          else
            vUpdateMode  := 'I';
          end if;

          DOC_INIT_MOVEMENT.DOC_PROV_QTY(good_id               => vTplMovementKind.GCO_GOOD_ID
                                       , update_mode           => vUpdateMode   -- Mode création
                                       , move_sort             => vTplMovementKind.C_MOVEMENT_SORT
                                       , verify_char           => vVerifyCharacterization
                                       , parity_move_kind_id   => vTplMovementKind.STM_STM_MOVEMENT_KIND_ID
                                       , charact_id_1          => :new.GCO_CHARACTERIZATION_ID
                                       , charact_id_2          => :new.GCO_GCO_CHARACTERIZATION_ID
                                       , charact_id_3          => :new.GCO2_GCO_CHARACTERIZATION_ID
                                       , charact_id_4          => :new.GCO3_GCO_CHARACTERIZATION_ID
                                       , charact_id_5          => :new.GCO4_GCO_CHARACTERIZATION_ID
                                       , charact_val_1         => :new.PDE_CHARACTERIZATION_VALUE_1
                                       , charact_val_2         => :new.PDE_CHARACTERIZATION_VALUE_2
                                       , charact_val_3         => :new.PDE_CHARACTERIZATION_VALUE_3
                                       , charact_val_4         => :new.PDE_CHARACTERIZATION_VALUE_4
                                       , charact_val_5         => :new.PDE_CHARACTERIZATION_VALUE_5
                                       , stock_id              => vMainStockId
                                       , location_id           => :new.STM_LOCATION_ID
                                       , trans_stock_id        => vTransStockId
                                       , trans_location_id     => :new.STM_STM_LOCATION_ID
                                       , movement_quantity     => :new.PDE_MOVEMENT_QUANTITY
                                        );

          if crExtourneMovement%found then
            -- Ajout des quantités provisoires
            DOC_INIT_MOVEMENT.DOC_PROV_QTY(good_id               => vTplNewExtourneMvt.GCO_GOOD_ID
                                         , update_mode           => vUpdateMode   -- mode création
                                         , move_sort             => vTplNewExtourneMvt.C_MOVEMENT_SORT
                                         , verify_char           => 0   --vTplNewExtourneMvt.MOK_VERIFY_CHARACTERIZATION,
                                         , parity_move_kind_id   => vTplNewExtourneMvt.STM_STM_MOVEMENT_KIND_ID
                                         , charact_id_1          => vTplNewExtourneMvt.GCO_CHARACTERIZATION_ID
                                         , charact_id_2          => vTplNewExtourneMvt.GCO_GCO_CHARACTERIZATION_ID
                                         , charact_id_3          => vTplNewExtourneMvt.GCO2_GCO_CHARACTERIZATION_ID
                                         , charact_id_4          => vTplNewExtourneMvt.GCO3_GCO_CHARACTERIZATION_ID
                                         , charact_id_5          => vTplNewExtourneMvt.GCO4_GCO_CHARACTERIZATION_ID
                                         , charact_val_1         => vTplNewExtourneMvt.SMO_CHARACTERIZATION_VALUE_1
                                         , charact_val_2         => vTplNewExtourneMvt.SMO_CHARACTERIZATION_VALUE_2
                                         , charact_val_3         => vTplNewExtourneMvt.SMO_CHARACTERIZATION_VALUE_3
                                         , charact_val_4         => vTplNewExtourneMvt.SMO_CHARACTERIZATION_VALUE_4
                                         , charact_val_5         => vTplNewExtourneMvt.SMO_CHARACTERIZATION_VALUE_5
                                         , stock_id              => vTplNewExtourneMvt.STM_STOCK_ID
                                         , location_id           => vTplNewExtourneMvt.STM_LOCATION_ID
                                         , trans_stock_id        => null
                                         , trans_location_id     => null
                                         , movement_quantity     => -sign(:new.PDE_MOVEMENT_QUANTITY) *
                                                                    least(abs(:new.PDE_MOVEMENT_QUANTITY +
                                                                              (nvl(:new.PDE_BALANCE_QUANTITY_PARENT, 0) * vTplMovementKind.POS_CONVERT_FACTOR
                                                                              )
                                                                             )
                                                                        , abs(vTplNewExtourneMvt.SMO_MOVEMENT_QUANTITY)
                                                                         )
                                          );
          end if;
        end if;

        close crExtourneMovement;
      end if;
    end loop;
  end if;

  -- Si l'installation est renseignée et qu'une valeur de caract aussi
  -- il faut màj le numéro de série de l'installation
  if     vFlagUseRecord
     and vFlagAtLeastOneChar then
    -- Vérifier qu'il y ai un type de mouvement
    -- et que le num. de série ne soit pas encore renseigné sur l'installation
    select POS.STM_MOVEMENT_KIND_ID
         , RCO.STM_ELEMENT_NUMBER_ID
      into vMovementKindID
         , vRecordElemNbrID
      from DOC_POSITION POS
         , DOC_RECORD RCO
     where POS.DOC_POSITION_ID = :new.DOC_POSITION_ID
       and RCO.DOC_RECORD_ID = :new.DOC_RECORD_ID;

    if     (vMovementKindID is not null)
       and (vRecordElemNbrID is null) then
      -- Si pas de numero de série sur le dossier
        -- Màj du dossier avec le numéro de série du détail
      select max(STM_ELEMENT_NUMBER_ID)
        into vRecordElemNbrID
        from STM_ELEMENT_NUMBER
       where GCO_GOOD_ID = :new.GCO_GOOD_ID
         and C_ELEMENT_TYPE = '02'
         and SEM_VALUE in
               (:new.PDE_CHARACTERIZATION_VALUE_1
              , :new.PDE_CHARACTERIZATION_VALUE_2
              , :new.PDE_CHARACTERIZATION_VALUE_3
              , :new.PDE_CHARACTERIZATION_VALUE_4
              , :new.PDE_CHARACTERIZATION_VALUE_5
               );

      if vRecordElemNbrID is not null then
        update DOC_RECORD
           set STM_ELEMENT_NUMBER_ID = vRecordElemNbrID
         where DOC_RECORD_ID = :new.DOC_RECORD_ID;
      end if;
    end if;
  end if;
end DOC_PDE_AU_PROV_QTY;

ALTER TRIGGER "C_ITX"."DOC_PDE_AU_PROV_QTY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_BD_SQM_PENALTY"
before delete on DOC_POSITION_DETAIL
referencing old as old new as new
for each row
/**
* Description
*    suppression des criticités du détail
* @author DSA
* @created 21.07.2003
* @version 2003
* @lastUpdate 21.07.2003
*/
begin
  DELETE FROM SQM_PENALTY
  WHERE DOC_POSITION_DETAIL_ID = :OLD.DOC_POSITION_DETAIL_ID;

end DOC_PDE_BD_SQM_PENALTY;


ALTER TRIGGER "C_ITX"."DOC_PDE_BD_SQM_PENALTY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_BD_SUPPLY_REQUEST"
  before delete
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour du lien sur les demandes d'approvisionnements sur les détails de position
* @author Vincent Jeanfavre
* @created 27/12/2004
* @version 2003
* @lastUpdate 27/12/2004
*/
begin
  -- Mise à jour du statut de la Demande d'appro à la valeur 4 (Annulée) à l'effacement du détail de position
  if :old.FAL_SUPPLY_REQUEST_ID is not null then
    update FAL_SUPPLY_REQUEST
       set C_REQUEST_STATUS = '4'
         , A_DATEMOD = sysdate
         , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
     where FAL_SUPPLY_REQUEST_ID = :old.FAL_SUPPLY_REQUEST_ID;
  end if;
end DOC_PDE_BD_SUPPLY_REQUEST;

ALTER TRIGGER "C_ITX"."DOC_PDE_BD_SUPPLY_REQUEST" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_BD_TRANSFER_ATTRIB"
  before delete
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Effacement des enregistrement de transfer d'attributions STM_TRANSFER_ATTRIB.
* @author Antoine Gabus
* @created 28/03/2011
* @version 2011
* @lastUpdate 28/02/2011
*/
begin
  if :old.STM_STOCK_MOVEMENT_ID is not null then
    delete STM_TRANSFER_ATTRIB where STM_STOCK_MOVEMENT_ID = :old.STM_STOCK_MOVEMENT_ID;
  end if;
end DOC_PDE_BD_TRANSFER_ATTRIB;

ALTER TRIGGER "C_ITX"."DOC_PDE_BD_TRANSFER_ATTRIB" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_BI_DENORM"
  before insert
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des champs dénormalisés de DOC_POSITION_DETAIL
* @author Fabrice Perotto
* @lastupdate fp 15.08.2007
* @version 2003
*/
begin
  select DOC_DOCUMENT_ID
       , PAC_THIRD_ID
       , PAC_THIRD_ACI_ID
       , PAC_THIRD_DELIVERY_ID
       , PAC_THIRD_TARIFF_ID
       , PAC_THIRD_VAT_ID
       , PAC_THIRD_CDA_ID
       , DOC_GAUGE_ID
       , GCO_GOOD_ID
       , POS_TRANSFERT_PROPRIETOR
       , C_GAUGE_TYPE_POS
    into :new.DOC_DOCUMENT_ID
       , :new.PAC_THIRD_ID
       , :new.PAC_THIRD_ACI_ID
       , :new.PAC_THIRD_DELIVERY_ID
       , :new.PAC_THIRD_TARIFF_ID
       , :new.PAC_THIRD_VAT_ID
       , :new.PAC_THIRD_CDA_ID
       , :new.DOC_GAUGE_ID
       , :new.GCO_GOOD_ID
       , :new.PDE_TRANSFERT_PROPRIETOR
       , :new.C_GAUGE_TYPE_POS
    from DOC_POSITION
   where DOC_POSITION_ID = :new.DOC_POSITION_ID;
end DOC_PDE_BI_DENORM;

ALTER TRIGGER "C_ITX"."DOC_PDE_BI_DENORM" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_BI_INSTALLATION"
  before insert
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Création du dossier de type installation si gabarit spécifie création auto
*    Effectue la màj du numero de série sur le dossier de type installation
*
* @author NGV
* @created 24.02.2006
* @version 2003
*/
declare
  cursor crInfo(cPosID in number)
  is
    select DMT.DMT_DATE_DOCUMENT
         , DMT.DMT_RATE_OF_EXCHANGE
         , DMT.DMT_BASE_PRICE
         , DMT.ACS_FINANCIAL_CURRENCY_ID
         , GAU.C_ADMIN_DOMAIN
         , GAS.GAS_INSTALLATION_MGM
         , GAS.GAS_INSTALLATION_AUTO_GEN
         , decode(GAU.C_ADMIN_DOMAIN
                , '1', SUP.DIC_COMPLEMENTARY_DATA_ID
                , '2', CUS.DIC_COMPLEMENTARY_DATA_ID
                , '5', SUP.DIC_COMPLEMENTARY_DATA_ID
                , nvl(CUS.DIC_COMPLEMENTARY_DATA_ID, SUP.DIC_COMPLEMENTARY_DATA_ID)
                 ) DIC_COMPLEMENTARY_DATA_ID
         , POS.GCO_GOOD_ID
         , POS.POS_NET_UNIT_VALUE
         , POS.POS_UNIT_COST_PRICE
         , POS.POS_LONG_DESCRIPTION
         , POS.POS_FREE_DESCRIPTION
         , (select count(*)
              from GCO_COMPL_DATA_EXTERNAL_ASA
             where GCO_GOOD_ID = POS.GCO_GOOD_ID) EXT_ASA_COUNT
         , (select min(GCO_CHARACTERIZATION_ID)
              from GCO_CHARACTERIZATION
             where GCO_GOOD_ID = POS.GCO_GOOD_ID
               and C_CHARACT_TYPE = '3') GOOD_SERIAL_NBR_CHAR_ID
      from DOC_DOCUMENT DMT
         , DOC_POSITION POS
         , DOC_GAUGE GAU
         , DOC_GAUGE_STRUCTURED GAS
         , PAC_CUSTOM_PARTNER CUS
         , PAC_SUPPLIER_PARTNER SUP
     where POS.DOC_POSITION_ID = cPosID
       and DMT.DOC_DOCUMENT_ID = POS.DOC_DOCUMENT_ID
       and GAU.DOC_GAUGE_ID = DMT.DOC_GAUGE_ID
       and GAU.DOC_GAUGE_ID = GAS.DOC_GAUGE_ID
       and DMT.PAC_THIRD_ID = CUS.PAC_CUSTOM_PARTNER_ID(+)
       and DMT.PAC_THIRD_ID = SUP.PAC_SUPPLIER_PARTNER_ID(+);

  tplInfo               crInfo%rowtype;
  vPosNetUnitValueExclB DOC_POSITION.POS_NET_UNIT_VALUE%type;
  vRecordMachineID      DOC_RECORD.DOC_RECORD_ID%type;
  vSemValue             STM_ELEMENT_NUMBER.SEM_VALUE%type;
  vRcoTitle             DOC_RECORD.RCO_TITLE%type;
  vCharValue            DOC_POSITION_DETAIL.PDE_CHARACTERIZATION_VALUE_1%type;
begin
  open crInfo(:new.DOC_POSITION_ID);

  fetch crInfo
   into tplInfo;

  -- Gabarit gère les Installations ET bien a des données compl. de SAV externe
  -- Création d'un dossier si gabarit demande la création automatique
  -- et que dossier pas encore renseigné
  -- Et que si le bien est géré avec caract. n° série la qté doit être = 1
  if     (tplInfo.GCO_GOOD_ID is not null)
     and (tplInfo.GAS_INSTALLATION_MGM = 1)
     and (tplInfo.GAS_INSTALLATION_AUTO_GEN = 1)
     and (tplInfo.EXT_ASA_COUNT > 0)
     and (    (tplInfo.GOOD_SERIAL_NBR_CHAR_ID is null)
          or (    tplInfo.GOOD_SERIAL_NBR_CHAR_ID is not null
              and (:new.PDE_BASIS_QUANTITY = 1) )
         )
     and (:new.DOC_RECORD_ID is null) then
    -- si le document est en monnaie étrangère, on converti le prix unitaire net en monnaie de base
    if tplInfo.ACS_FINANCIAL_CURRENCY_ID <> ACS_FUNCTION.GetLocalCurrencyId then
      vPosNetUnitValueExclB  :=
        ACS_FUNCTION.ConvertAmountForView(tplInfo.POS_NET_UNIT_VALUE
                                        , tplInfo.ACS_FINANCIAL_CURRENCY_ID
                                        , ACS_FUNCTION.GetLocalCurrencyId
                                        , tplInfo.DMT_DATE_DOCUMENT
                                        , tplInfo.DMT_RATE_OF_EXCHANGE
                                        , tplInfo.DMT_BASE_PRICE
                                        , 0
                                         );
    else
      vPosNetUnitValueExclB  := tplInfo.POS_NET_UNIT_VALUE;
    end if;

    -- Création du dossier Installation
    DOC_RECORD_FUNCTIONS.CreateRecordMachine(tplInfo.GCO_GOOD_ID
                                           , tplInfo.C_ADMIN_DOMAIN
                                           , tplInfo.DIC_COMPLEMENTARY_DATA_ID
                                           , tplInfo.POS_LONG_DESCRIPTION
                                           , tplInfo.POS_FREE_DESCRIPTION
                                           , vPosNetUnitValueExclB
                                           , tplInfo.POS_UNIT_COST_PRICE
                                           , vRecordMachineID
                                           , '200'
                                            );
    -- Màj du détail avec le nouveau dossier créé
    :new.DOC_RECORD_ID  := vRecordMachineID;
  end if;

  -- Init du numéro de série du détail si bien possède n° série
  if     (:new.DOC_RECORD_ID is not null)
     and (tplInfo.GOOD_SERIAL_NBR_CHAR_ID is not null) then
    -- Vérifier si la valeur de caract n'est pas encore saisie
    if    (     (nvl(:new.GCO_CHARACTERIZATION_ID, -1) = tplInfo.GOOD_SERIAL_NBR_CHAR_ID)
           and (:new.PDE_CHARACTERIZATION_VALUE_1 is null)
          )
       or (     (nvl(:new.GCO_GCO_CHARACTERIZATION_ID, -1) = tplInfo.GOOD_SERIAL_NBR_CHAR_ID)
           and (:new.PDE_CHARACTERIZATION_VALUE_2 is null)
          )
       or (     (nvl(:new.GCO2_GCO_CHARACTERIZATION_ID, -1) = tplInfo.GOOD_SERIAL_NBR_CHAR_ID)
           and (:new.PDE_CHARACTERIZATION_VALUE_3 is null)
          )
       or (     (nvl(:new.GCO3_GCO_CHARACTERIZATION_ID, -1) = tplInfo.GOOD_SERIAL_NBR_CHAR_ID)
           and (:new.PDE_CHARACTERIZATION_VALUE_4 is null)
          )
       or (     (nvl(:new.GCO4_GCO_CHARACTERIZATION_ID, -1) = tplInfo.GOOD_SERIAL_NBR_CHAR_ID)
           and (:new.PDE_CHARACTERIZATION_VALUE_5 is null)
          ) then
      -- Rechercher le N° de série de l'installation et le titre
      select SEM.SEM_VALUE
           , RCO.RCO_TITLE
        into vSemValue
           , vRcoTitle
        from DOC_RECORD RCO
           , STM_ELEMENT_NUMBER SEM
       where RCO.DOC_RECORD_ID = :new.DOC_RECORD_ID
         and RCO.STM_ELEMENT_NUMBER_ID = SEM.STM_ELEMENT_NUMBER_ID(+);

      -- En Achat et si config ASA_EXT_INIT_CHAR_VALUE = 1
      -- On utilise le titre du dossier comme n° de série si l'installation
      -- ne possède pas encore de n° de série
      if     (tplInfo.C_ADMIN_DOMAIN = '1')
         and (nvl(PCS.PC_CONFIG.GETCONFIG('ASA_EXT_INIT_CHAR_VALUE'), '0') = '1') then
        vCharValue  := nvl(vSemValue, vRcoTitle);
      else
        -- Utiliser le n° de série défini sur l'installation
        vCharValue  := vSemValue;
      end if;

      -- Vérifier à quelle caract du détail correspond la caract type piece
      if vCharValue is not null then
        if (tplInfo.GOOD_SERIAL_NBR_CHAR_ID = :new.GCO_CHARACTERIZATION_ID) then
          :new.PDE_CHARACTERIZATION_VALUE_1  := vCharValue;
        elsif(tplInfo.GOOD_SERIAL_NBR_CHAR_ID = :new.GCO_GCO_CHARACTERIZATION_ID) then
          :new.PDE_CHARACTERIZATION_VALUE_2  := vCharValue;
        elsif(tplInfo.GOOD_SERIAL_NBR_CHAR_ID = :new.GCO2_GCO_CHARACTERIZATION_ID) then
          :new.PDE_CHARACTERIZATION_VALUE_3  := vCharValue;
        elsif(tplInfo.GOOD_SERIAL_NBR_CHAR_ID = :new.GCO3_GCO_CHARACTERIZATION_ID) then
          :new.PDE_CHARACTERIZATION_VALUE_4  := vCharValue;
        elsif(tplInfo.GOOD_SERIAL_NBR_CHAR_ID = :new.GCO4_GCO_CHARACTERIZATION_ID) then
          :new.PDE_CHARACTERIZATION_VALUE_5  := vCharValue;
        end if;
      end if;
    end if;
  end if;

  close crInfo;
end DOC_PDE_BI_INSTALLATION;

ALTER TRIGGER "C_ITX"."DOC_PDE_BI_INSTALLATION" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_BIU_CHARAC_VALUES"
  before insert or update of PDE_CHARACTERIZATION_VALUE_1
                           , PDE_CHARACTERIZATION_VALUE_2
                           , PDE_CHARACTERIZATION_VALUE_3
                           , PDE_CHARACTERIZATION_VALUE_4
                           , PDE_CHARACTERIZATION_VALUE_5
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*   Suppression des espace à la fin des valeurs de caractérisation
* @author Fabrice Perotto
* @version 2003
*/
begin
  :new.PDE_CHARACTERIZATION_VALUE_1  := CleanStr(:new.PDE_CHARACTERIZATION_VALUE_1);
  :new.PDE_CHARACTERIZATION_VALUE_2  := CleanStr(:new.PDE_CHARACTERIZATION_VALUE_2);
  :new.PDE_CHARACTERIZATION_VALUE_3  := CleanStr(:new.PDE_CHARACTERIZATION_VALUE_3);
  :new.PDE_CHARACTERIZATION_VALUE_4  := CleanStr(:new.PDE_CHARACTERIZATION_VALUE_4);
  :new.PDE_CHARACTERIZATION_VALUE_5  := CleanStr(:new.PDE_CHARACTERIZATION_VALUE_5);
end DOC_PDE_BIU_CHARAC_VALUES;

ALTER TRIGGER "C_ITX"."DOC_PDE_BIU_CHARAC_VALUES" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_BIU_DENORM_CHAR"
  before insert or update of GCO_CHARACTERIZATION_ID
                           , GCO_GCO_CHARACTERIZATION_ID
                           , GCO2_GCO_CHARACTERIZATION_ID
                           , GCO3_GCO_CHARACTERIZATION_ID
                           , GCO4_GCO_CHARACTERIZATION_ID
                           , PDE_CHARACTERIZATION_VALUE_1
                           , PDE_CHARACTERIZATION_VALUE_2
                           , PDE_CHARACTERIZATION_VALUE_3
                           , PDE_CHARACTERIZATION_VALUE_4
                           , PDE_CHARACTERIZATION_VALUE_5
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Dénormalisation des caractérisations dans l'événement before insert/update
* @author FP
* @created 11.12.2001
* @version 2003
* @lastUpdate 22.09.2003
*/
begin
  -- on vérifie que ce triggers soit déclenche par une modif d'un des champs ci-dessous
  -- et non pas par un autre trigger instead of
  if    nvl(:old.GCO_CHARACTERIZATION_ID, -1) <> nvl(:new.GCO_CHARACTERIZATION_ID, -1)
     or nvl(:old.GCO_GCO_CHARACTERIZATION_ID, -1) <> nvl(:new.GCO_GCO_CHARACTERIZATION_ID, -1)
     or nvl(:old.GCO2_GCO_CHARACTERIZATION_ID, -1) <> nvl(:new.GCO2_GCO_CHARACTERIZATION_ID, -1)
     or nvl(:old.GCO3_GCO_CHARACTERIZATION_ID, -1) <> nvl(:new.GCO3_GCO_CHARACTERIZATION_ID, -1)
     or nvl(:old.GCO4_GCO_CHARACTERIZATION_ID, -1) <> nvl(:new.GCO4_GCO_CHARACTERIZATION_ID, -1)
     or nvl(:old.PDE_CHARACTERIZATION_VALUE_1, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_1, 'null')
     or nvl(:old.PDE_CHARACTERIZATION_VALUE_2, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_2, 'null')
     or nvl(:old.PDE_CHARACTERIZATION_VALUE_3, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_3, 'null')
     or nvl(:old.PDE_CHARACTERIZATION_VALUE_4, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_4, 'null')
     or nvl(:old.PDE_CHARACTERIZATION_VALUE_5, 'null') <> nvl(:new.PDE_CHARACTERIZATION_VALUE_5, 'null') then
    -- vérifie qu'on ait au moins une caractérisation
    if :new.GCO_CHARACTERIZATION_ID is not null then
      -- Mise à jour des champs dénormalisé d'affichage des caractérisations
      GCO_LIB_CHARACTERIZATION.ClassifyCharacterizations(:new.GCO_CHARACTERIZATION_ID
                                                       , :new.GCO_GCO_CHARACTERIZATION_ID
                                                       , :new.GCO2_GCO_CHARACTERIZATION_ID
                                                       , :new.GCO3_GCO_CHARACTERIZATION_ID
                                                       , :new.GCO4_GCO_CHARACTERIZATION_ID
                                                       , :new.PDE_CHARACTERIZATION_VALUE_1
                                                       , :new.PDE_CHARACTERIZATION_VALUE_2
                                                       , :new.PDE_CHARACTERIZATION_VALUE_3
                                                       , :new.PDE_CHARACTERIZATION_VALUE_4
                                                       , :new.PDE_CHARACTERIZATION_VALUE_5
                                                       , :new.PDE_PIECE
                                                       , :new.PDE_SET
                                                       , :new.PDE_VERSION
                                                       , :new.PDE_CHRONOLOGICAL
                                                       , :new.PDE_STD_CHAR_1
                                                       , :new.PDE_STD_CHAR_2
                                                       , :new.PDE_STD_CHAR_3
                                                       , :new.PDE_STD_CHAR_4
                                                       , :new.PDE_STD_CHAR_5
                                                        );
    end if;
  end if;
end DOC_PDE_BIU_DENORM_CHAR;

ALTER TRIGGER "C_ITX"."DOC_PDE_BIU_DENORM_CHAR" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_BIU_FINANCIAL_ACCOUNT"
  before insert or update of STM_LOCATION_ID
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des comptes financiers (Table DOC_POSITION_DETAIL) before insert or update
* @author JHE
* @created 24.05.2006
*/
declare
  vAccountInfo      ACS_I_LIB_LOGISTIC_FINANCIAL.TAccountInfo;
  vAccountInfo2     ACS_I_LIB_LOGISTIC_FINANCIAL.TAccountInfo;
  vFinancial        STM_MOVEMENT_KIND.MOK_FINANCIAL_IMPUTATION%type;
  vAnalytical       STM_MOVEMENT_KIND.MOK_ANAL_IMPUTATION%type;
  vInfoCompl        STM_MOVEMENT_KIND.MOK_USE_MANAGED_DATA%type;
  docDocumentID     DOC_DOCUMENT.DOC_DOCUMENT_ID%type;
  gcoGoodID         GCO_GOOD.GCO_GOOD_ID%type;
  stmMovementKindID STM_MOVEMENT_KIND.STM_MOVEMENT_KIND_ID%type;
  pacThirdAciID     PAC_THIRD.PAC_THIRD_ID%type;
  stmStockID        STM_STOCK.STM_STOCK_ID%type;
  posStockID        STM_STOCK.STM_STOCK_ID%type;
begin
  if nvl(:old.STM_LOCATION_ID, 0) <> nvl(:new.STM_LOCATION_ID, 0) then
    begin
      select POS.DOC_DOCUMENT_ID
           , PDT.GCO_GOOD_ID
           , POS.STM_MOVEMENT_KIND_ID
           , POS.PAC_THIRD_ACI_ID
           , POS.STM_STOCK_ID
        into docDocumentID
           , gcoGoodID
           , stmMovementKindID
           , pacThirdAciID
           , posStockID
        from DOC_POSITION POS
           , GCO_PRODUCT PDT
       where POS.DOC_POSITION_ID = :new.DOC_POSITION_ID
         and PDT.GCO_GOOD_ID = POS.GCO_GOOD_ID
         and PDT.PDT_CONTINUOUS_INVENTAR = 1;
    exception
      when no_data_found then
        null;
    end;

    if     gcoGoodID is not null
       and stmMovementKindID is not null then
      :new.ACS_FINANCIAL_ACCOUNT_BS_ID     := null;
      :new.ACS_DIVISION_ACCOUNT_BS_ID      := null;
      :new.ACS_CPN_ACCOUNT_BS_ID           := null;
      :new.ACS_CDA_ACCOUNT_BS_ID           := null;
      :new.ACS_PF_ACCOUNT_BS_ID            := null;
      :new.ACS_PJ_ACCOUNT_BS_ID            := null;
      :new.ACS_FINANCIAL_ACCOUNT_PL_ID     := null;
      :new.ACS_DIVISION_ACCOUNT_PL_ID      := null;
      :new.ACS_CPN_ACCOUNT_PL_ID           := null;
      :new.ACS_CDA_ACCOUNT_PL_ID           := null;
      :new.ACS_PF_ACCOUNT_PL_ID            := null;
      :new.ACS_PJ_ACCOUNT_PL_ID            := null;
      vAccountInfo.DEF_HRM_PERSON          := ACS_I_LIB_LOGISTIC_FINANCIAL.GetEmpNumber(:new.HRM_PERSON_ID);
      vAccountInfo.FAM_FIXED_ASSETS_ID     := :new.FAM_FIXED_ASSETS_ID;
      vAccountInfo.C_FAM_TRANSACTION_TYP   := :new.C_FAM_TRANSACTION_TYP;
      vAccountInfo.DEF_DIC_IMP_FREE1       := :new.DIC_IMP_FREE1_ID;
      vAccountInfo.DEF_DIC_IMP_FREE2       := :new.DIC_IMP_FREE2_ID;
      vAccountInfo.DEF_DIC_IMP_FREE3       := :new.DIC_IMP_FREE3_ID;
      vAccountInfo.DEF_DIC_IMP_FREE4       := :new.DIC_IMP_FREE4_ID;
      vAccountInfo.DEF_DIC_IMP_FREE5       := :new.DIC_IMP_FREE5_ID;
      vAccountInfo.DEF_TEXT1               := :new.PDE_IMF_TEXT_1;
      vAccountInfo.DEF_TEXT2               := :new.PDE_IMF_TEXT_2;
      vAccountInfo.DEF_TEXT3               := :new.PDE_IMF_TEXT_3;
      vAccountInfo.DEF_TEXT4               := :new.PDE_IMF_TEXT_4;
      vAccountInfo.DEF_TEXT5               := :new.PDE_IMF_TEXT_5;
      vAccountInfo.DEF_NUMBER1             := to_char(:new.PDE_IMF_NUMBER_1);
      vAccountInfo.DEF_NUMBER2             := to_char(:new.PDE_IMF_NUMBER_2);
      vAccountInfo.DEF_NUMBER3             := to_char(:new.PDE_IMF_NUMBER_3);
      vAccountInfo.DEF_NUMBER4             := to_char(:new.PDE_IMF_NUMBER_4);
      vAccountInfo.DEF_NUMBER5             := to_char(:new.PDE_IMF_NUMBER_5);
      vAccountInfo2.DEF_HRM_PERSON         := ACS_I_LIB_LOGISTIC_FINANCIAL.GetEmpNumber(:new.HRM_PERSON_ID);
      vAccountInfo2.FAM_FIXED_ASSETS_ID    := :new.FAM_FIXED_ASSETS_ID;
      vAccountInfo2.C_FAM_TRANSACTION_TYP  := :new.C_FAM_TRANSACTION_TYP;
      vAccountInfo2.DEF_DIC_IMP_FREE1      := :new.DIC_IMP_FREE1_ID;
      vAccountInfo2.DEF_DIC_IMP_FREE2      := :new.DIC_IMP_FREE2_ID;
      vAccountInfo2.DEF_DIC_IMP_FREE3      := :new.DIC_IMP_FREE3_ID;
      vAccountInfo2.DEF_DIC_IMP_FREE4      := :new.DIC_IMP_FREE4_ID;
      vAccountInfo2.DEF_DIC_IMP_FREE5      := :new.DIC_IMP_FREE5_ID;
      vAccountInfo2.DEF_TEXT1              := :new.PDE_IMF_TEXT_1;
      vAccountInfo2.DEF_TEXT2              := :new.PDE_IMF_TEXT_2;
      vAccountInfo2.DEF_TEXT3              := :new.PDE_IMF_TEXT_3;
      vAccountInfo2.DEF_TEXT4              := :new.PDE_IMF_TEXT_4;
      vAccountInfo2.DEF_TEXT5              := :new.PDE_IMF_TEXT_5;
      vAccountInfo2.DEF_NUMBER1            := to_char(:new.PDE_IMF_NUMBER_1);
      vAccountInfo2.DEF_NUMBER2            := to_char(:new.PDE_IMF_NUMBER_2);
      vAccountInfo2.DEF_NUMBER3            := to_char(:new.PDE_IMF_NUMBER_3);
      vAccountInfo2.DEF_NUMBER4            := to_char(:new.PDE_IMF_NUMBER_4);
      vAccountInfo2.DEF_NUMBER5            := to_char(:new.PDE_IMF_NUMBER_5);

      begin
        select STM_STOCK_ID
          into stmStockID
          from STM_LOCATION
         where STM_LOCATION_ID = :new.STM_LOCATION_ID;
      exception
        when no_data_found then
          stmStockID  := posStockID;
      end;

      ACS_I_LIB_LOGISTIC_FINANCIAL.GetMvtAccounts(gcoGoodID
                                                , :new.STM_LOCATION_ID
                                                , stmStockID
                                                , stmMovementKindID
                                                , :new.DOC_POSITION_ID
                                                , docDocumentID
                                                , :new.PDE_MOVEMENT_DATE
                                                , :new.ACS_FINANCIAL_ACCOUNT_BS_ID
                                                , :new.ACS_DIVISION_ACCOUNT_BS_ID
                                                , :new.ACS_CPN_ACCOUNT_BS_ID
                                                , :new.ACS_CDA_ACCOUNT_BS_ID
                                                , :new.ACS_PF_ACCOUNT_BS_ID
                                                , :new.ACS_PJ_ACCOUNT_BS_ID
                                                , :new.ACS_FINANCIAL_ACCOUNT_PL_ID
                                                , :new.ACS_DIVISION_ACCOUNT_PL_ID
                                                , :new.ACS_CPN_ACCOUNT_PL_ID
                                                , :new.ACS_CDA_ACCOUNT_PL_ID
                                                , :new.ACS_PF_ACCOUNT_PL_ID
                                                , :new.ACS_PJ_ACCOUNT_PL_ID
                                                , vAccountInfo
                                                , vAccountInfo2
                                                , vFinancial
                                                , vAnalytical
                                                , vInfoCompl
                                                , pacThirdAciID
                                                 );
      :new.FAM_FIXED_ASSETS_ID             := vAccountInfo.FAM_FIXED_ASSETS_ID;
      :new.C_FAM_TRANSACTION_TYP           := vAccountInfo.C_FAM_TRANSACTION_TYP;
      :new.HRM_PERSON_ID                   := ACS_I_LIB_LOGISTIC_FINANCIAL.GetHrmPerson(vAccountInfo.DEF_HRM_PERSON);
      :new.DIC_IMP_FREE1_ID                := vAccountInfo.DEF_DIC_IMP_FREE1;
      :new.DIC_IMP_FREE2_ID                := vAccountInfo.DEF_DIC_IMP_FREE2;
      :new.DIC_IMP_FREE3_ID                := vAccountInfo.DEF_DIC_IMP_FREE3;
      :new.DIC_IMP_FREE4_ID                := vAccountInfo.DEF_DIC_IMP_FREE4;
      :new.DIC_IMP_FREE5_ID                := vAccountInfo.DEF_DIC_IMP_FREE5;
      :new.PDE_IMF_TEXT_1                  := vAccountInfo.DEF_TEXT1;
      :new.PDE_IMF_TEXT_2                  := vAccountInfo.DEF_TEXT2;
      :new.PDE_IMF_TEXT_3                  := vAccountInfo.DEF_TEXT3;
      :new.PDE_IMF_TEXT_4                  := vAccountInfo.DEF_TEXT4;
      :new.PDE_IMF_TEXT_5                  := vAccountInfo.DEF_TEXT5;
      :new.PDE_IMF_NUMBER_1                := to_number(vAccountInfo.DEF_NUMBER1);
      :new.PDE_IMF_NUMBER_2                := to_number(vAccountInfo.DEF_NUMBER2);
      :new.PDE_IMF_NUMBER_3                := to_number(vAccountInfo.DEF_NUMBER3);
      :new.PDE_IMF_NUMBER_4                := to_number(vAccountInfo.DEF_NUMBER4);
      :new.PDE_IMF_NUMBER_5                := to_number(vAccountInfo.DEF_NUMBER5);
    end if;
  end if;
end DOC_PDE_BIU_FINANCIAL_ACCOUNT;

ALTER TRIGGER "C_ITX"."DOC_PDE_BIU_FINANCIAL_ACCOUNT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_BIU_INSTALL_QTY"
  before insert or update of DOC_RECORD_ID, PDE_BASIS_QUANTITY
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*   Vérifie que les biens avec gestion n° série et donc l'installation est
*   renseignée ne puisse pas avoir de quantités supérieures à 1 sur le détail
* @created  NGV
* @version 2003
*/
declare
  vCharID GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
begin
  -- Si l'installation est renseignée et que la qté du détail > 1
  -- Vérifier que le bien ne gére pas les caract de type n° série
  if     (:new.DOC_RECORD_ID is not null)
     and abs(:new.PDE_BASIS_QUANTITY) > 1 then
    select min(CHA.GCO_CHARACTERIZATION_ID)
      into vCharID
      from GCO_CHARACTERIZATION CHA
         , DOC_POSITION POS
     where POS.DOC_POSITION_ID = :new.DOC_POSITION_ID
       and CHA.GCO_GOOD_ID = POS.GCO_GOOD_ID
       and CHA.C_CHARACT_TYPE = '3';

    if vCharID is not null then
      raise_application_error
        (-20111
       , PCS.PC_FUNCTIONS.TranslateWord
           ('Si le bien gére les numéros de pièce et que l''installation est renseignée, la quantité du détail doit être unitaire !'
           )
        );
    end if;
  end if;
end DOC_PDE_BIU_INSTALL_QTY;

ALTER TRIGGER "C_ITX"."DOC_PDE_BIU_INSTALL_QTY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_BU_FORNETWORK"
  before update of DOC_POSITION_DETAIL_ID
                 , DOC_GAUGE_FLOW_ID
                 , DOC_POSITION_ID
                 , PDE_BASIS_DELAY
                 , PDE_BASIS_DELAY_W
                 , PDE_BASIS_DELAY_M
                 , PDE_INTERMEDIATE_DELAY
                 , PDE_INTERMEDIATE_DELAY_W
                 , PDE_INTERMEDIATE_DELAY_M
                 , PDE_FINAL_DELAY
                 , PDE_FINAL_DELAY_W
                 , PDE_FINAL_DELAY_M
                 , PDE_BASIS_QUANTITY
                 , PDE_INTERMEDIATE_QUANTITY
                 , PDE_FINAL_QUANTITY
                 , PDE_BASIS_QUANTITY_SU
                 , PDE_INTERMEDIATE_QUANTITY_SU
                 , PDE_FINAL_QUANTITY_SU
                 , PDE_BALANCE_QUANTITY
                 , PDE_CHARACTERIZATION_VALUE_1
                 , PDE_CHARACTERIZATION_VALUE_2
                 , PDE_CHARACTERIZATION_VALUE_3
                 , PDE_CHARACTERIZATION_VALUE_4
                 , PDE_CHARACTERIZATION_VALUE_5
                 , GCO_CHARACTERIZATION_ID
                 , GCO_GCO_CHARACTERIZATION_ID
                 , GCO2_GCO_CHARACTERIZATION_ID
                 , GCO3_GCO_CHARACTERIZATION_ID
                 , GCO4_GCO_CHARACTERIZATION_ID
                 , STM_LOCATION_ID
                 , STM_STM_LOCATION_ID
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
declare
  aPositionStatus           DOC_POSITION.C_DOC_POS_STATUS%type;
  aPositionType             DOC_POSITION.C_GAUGE_TYPE_POS%type;
  aConvertFactor            DOC_POSITION.POS_CONVERT_FACTOR%type;
  aGaugeType                DOC_GAUGE.C_GAUGE_TYPE%type;
  aPOS_TRANSFERT_PROPRIETOR DOC_POSITION.POS_TRANSFERT_PROPRIETOR%type;
  aGCO_GOOD_ID              GCO_GOOD.GCO_GOOD_ID%type;
  aPAC_REPRESENTATIVE_ID    PAC_REPRESENTATIVE.PAC_REPRESENTATIVE_ID%type;
  aDIC_PIC_GROUP_ID         DIC_PIC_GROUP.DIC_PIC_GROUP_ID%type;
  aPAC_THIRD_ID             PAC_THIRD.PAC_THIRD_ID%type;
  aGasUpdatePicOrderQty     DOC_GAUGE_STRUCTURED.GAS_UPDATE_PIC_ORDER_QTY%type;

  cursor CurPAC_CUSTOM_PARTNER(PrmPAC_THIRD_ID PAC_THIRD.PAC_THIRD_ID%type)
  is
    select DIC_PIC_GROUP_ID
      from PAC_CUSTOM_PARTNER
     where PAC_CUSTOM_PARTNER_ID = PrmPAC_THIRD_ID;

  aNEW                      DOC_POSITION_DETAIL%rowtype;
  aOLD                      DOC_POSITION_DETAIL%rowtype;
  bDoProcessUpdatePicLine   boolean;
  nOLD_PDE_BALANCE_QTY      DOC_POSITION_DETAIL.PDE_BALANCE_QUANTITY%type;
  nNEW_PDE_BALANCE_QTY      DOC_POSITION_DETAIL.PDE_BALANCE_QUANTITY%type;
  bOldLocationWithPic       boolean;
  bNewLocationWithPic       boolean;
  aDateValue                date;
  lvFanDescr                FAL_NETWORK_SUPPLY.FAN_DESCRIPTION%type;
  lnNumberOfDecimal         GCO_GOOD.GOO_NUMBER_OF_DECIMAL%type;
  lnBalanceQtySU            DOC_POSITION_DETAIL.PDE_FINAL_QUANTITY_SU%type;
begin
  -- Vérifier que les réseaux Logiqistiques sont activés
  if not FAL_NETWORK_DOC.IsDOCNetWorkEnabled then
    return;
  end if;

  -- Récupérer le status, le type et le facteur de conversion, le produit, le representant, le tiers  de la position maître
  select POS.C_DOC_POS_STATUS
       , POS.C_GAUGE_TYPE_POS
       , POS.POS_CONVERT_FACTOR
       , POS.GCO_GOOD_ID
       , POS.PAC_REPRESENTATIVE_ID
       , POS.PAC_THIRD_ID
       , POS.POS_TRANSFERT_PROPRIETOR
       , DMT.DMT_NUMBER || ' / ' || POS.POS_NUMBER
    into aPositionStatus
       , aPositionType
       , aConvertFactor
       , aGCO_GOOD_ID
       , aPAC_REPRESENTATIVE_ID
       , aPAC_THIRD_ID
       , aPOS_TRANSFERT_PROPRIETOR
       , lvFanDescr
    from DOC_POSITION POS
       , DOC_DOCUMENT DMT
   where POS.DOC_POSITION_ID = :new.DOC_POSITION_ID
     and DMT.DOC_DOCUMENT_ID = POS.DOC_DOCUMENT_ID;

  -- Récupération du DIC_PIC_GROUP_ID via le PAC_THIRD_ID
  aDIC_PIC_GROUP_ID         := null;

  if aPAC_THIRD_ID is not null then
    open CurPAC_CUSTOM_PARTNER(aPAC_THIRD_ID);

    fetch CurPAC_CUSTOM_PARTNER
     into aDIC_PIC_GROUP_ID;

    close CurPAC_CUSTOM_PARTNER;
  end if;

  -- Récupérer le type de gabarit du document, ainsi que le Flag de MAJ de la Qté commande PIC
  begin
    select GAU.C_GAUGE_TYPE
         , GAS.GAS_UPDATE_PIC_ORDER_QTY
      into aGaugeType
         , aGasUpdatePicOrderQty
      from DOC_GAUGE_STRUCTURED GAS
         , DOC_GAUGE GAU
     where GAU.DOC_GAUGE_ID = :new.DOC_GAUGE_ID
       and GAU.DOC_GAUGE_ID = GAS.DOC_GAUGE_ID;
  exception
    when no_data_found then
      begin
        aGaugeType             := '';
        aGasUpdatePicOrderQty  := 0;
      end;
  end;

  -- Est-ce que les stocks (avant - Après) sont gérés PIC.
  bOldLocationWithPic       := FAL_TOOLS.IsLocationOnStockNeedPic(:old.STM_LOCATION_ID);
  bNewLocationWithPic       := FAL_TOOLS.IsLocationOnStockNeedPic(:new.STM_LOCATION_ID);

  -- MAJ de la qté commande PIC, pour les gabarits de type "autre", flagué
  -- "mise à jour commande PIC"
  if (aPositionStatus = '01') then
    if     (aGaugeType = '3')
       and aPositionType in('1', '2', '3', '71', '81', '91', '101')
       and aGasUpdatePicOrderQty = 1
       and to_number(PCS.PC_CONFIG.GetConfig('FAL_PIC') ) in(2, 3)
       and (   bOldLocationWithPic
            or bNewLocationWithPic) then
      -- Dans le cas de gabarit de type autre, c'est la date valeur du document qui est prise en compte
      select DMT_DATE_VALUE
        into aDateValue
        from DOC_DOCUMENT
       where DOC_DOCUMENT_ID = :old.DOC_DOCUMENT_ID;

      -- Qté solde négative ou = 0
      if (    :new.PDE_BALANCE_QUANTITY <= 0
          and bNewLocationWithPic) then
        FAL_PLAN_DIRECTEUR.ProcessusMajQteCmdPicLine(aGCO_GOOD_ID
                                                   , aDateValue
                                                   , :old.PAC_THIRD_ID
                                                   , aPAC_REPRESENTATIVE_ID
                                                   , -:old.PDE_BALANCE_QUANTITY   -- ???
                                                   , aDIC_PIC_GROUP_ID
                                                    );
      -- Qté solde positive
      elsif(    :old.PDE_BALANCE_QUANTITY <= 0
            and bNewLocationWithPic) then
        FAL_PLAN_DIRECTEUR.ProcessusMajQteCmdPicLine(aGCO_GOOD_ID
                                                   , aDateValue
                                                   , :new.PAC_THIRD_ID
                                                   , aPAC_REPRESENTATIVE_ID
                                                   , :new.PDE_BALANCE_QUANTITY   -- ???
                                                   , aDIC_PIC_GROUP_ID
                                                    );
      else
        nOLD_PDE_BALANCE_QTY  := :old.PDE_BALANCE_QUANTITY;
        nNEW_PDE_BALANCE_QTY  := :new.PDE_BALANCE_QUANTITY;

        -- Le nouveau détailPosition porte sur un emplacement d'un stock "En-Cours PIC"
        if bNewLocationWithPIC then
          -- L'ancien emplacement de stock du détail n'était pas en-cours PIC (le nouveau l'est)
          -- On force (Doc_Position_Detail -> Old.PDE_Balance_Quantity  ) = 0
          if not bOldLocationWithPIC then
            nOLD_PDE_BALANCE_QTY  := 0;
          end if;
        else
          -- L'ancien emplacement de stock du détail était en-cours PIC (le nouveau ne l'est pas)
          -- On force (Doc_Position_Detail -> New.PDE_Balance_Quantity  ) = 0
          if not bOldLocationWithPIC then
            nNEW_PDE_BALANCE_QTY  := 0;
          end if;
        end if;

        FAL_PLAN_DIRECTEUR.ProcessusMajQteCmdPicLine(aGCO_GOOD_ID
                                                   , aDateValue
                                                   , :old.PAC_THIRD_ID
                                                   , aPAC_REPRESENTATIVE_ID
                                                   , nNEW_PDE_BALANCE_QTY - nOLD_PDE_BALANCE_QTY   -- ???
                                                   , aDIC_PIC_GROUP_ID
                                                    );
      end if;
    end if;
  end if;

  -- Vérifier que le status de la position maître est Solder (02) ou SolderPartiellement (03) ou Liquidé (04)
  if    (aPositionStatus = '02')
     or (aPositionStatus = '03')
     or (aPositionStatus = '04') then
    -- Vérifier que le type de la position maître est Bien (1), Bien avec nomenclature informative (2),
    -- ou Bien avec nomenclature active (3) ansi que tous les types de position kit ou assemblage
    if    (aPositionType = '1')
       or (aPositionType = '2')
       or (aPositionType = '3')
       or (aPositionType = '7')
       or (aPositionType = '8')
       or (aPositionType = '9')
       or (aPositionType = '10')
       or (aPositionType = '71')
       or (aPositionType = '81')
       or (aPositionType = '91')
       or (aPositionType = '101') then
      -- Copier :NEW dans un record pour le passer en paramètres aux procédures
      aNEW.DOC_POSITION_DETAIL_ID        := :new.DOC_POSITION_DETAIL_ID;
      aNEW.DOC_GAUGE_FLOW_ID             := :new.DOC_GAUGE_FLOW_ID;
      aNEW.DOC_POSITION_ID               := :new.DOC_POSITION_ID;
      aNEW.DOC_DOC_POSITION_DETAIL_ID    := :new.DOC_DOC_POSITION_DETAIL_ID;
      aNEW.DOC2_DOC_POSITION_DETAIL_ID   := :new.DOC2_DOC_POSITION_DETAIL_ID;
      aNEW.PDE_BASIS_DELAY               := :new.PDE_BASIS_DELAY;
      aNEW.PDE_BASIS_DELAY_W             := :new.PDE_BASIS_DELAY_W;
      aNEW.PDE_BASIS_DELAY_M             := :new.PDE_BASIS_DELAY_M;
      aNEW.PDE_INTERMEDIATE_DELAY        := :new.PDE_INTERMEDIATE_DELAY;
      aNEW.PDE_INTERMEDIATE_DELAY_W      := :new.PDE_INTERMEDIATE_DELAY_W;
      aNEW.PDE_INTERMEDIATE_DELAY_M      := :new.PDE_INTERMEDIATE_DELAY_M;
      aNEW.PDE_FINAL_DELAY               := :new.PDE_FINAL_DELAY;
      aNEW.PDE_FINAL_DELAY_W             := :new.PDE_FINAL_DELAY_W;
      aNEW.PDE_FINAL_DELAY_M             := :new.PDE_FINAL_DELAY_M;
      aNEW.PDE_BASIS_QUANTITY            := :new.PDE_BASIS_QUANTITY;
      aNEW.PDE_INTERMEDIATE_QUANTITY     := :new.PDE_INTERMEDIATE_QUANTITY;
      aNEW.PDE_FINAL_QUANTITY            := :new.PDE_FINAL_QUANTITY;
      aNEW.PDE_BASIS_QUANTITY_SU         := :new.PDE_BASIS_QUANTITY_SU;
      aNEW.PDE_INTERMEDIATE_QUANTITY_SU  := :new.PDE_INTERMEDIATE_QUANTITY_SU;
      aNEW.PDE_FINAL_QUANTITY_SU         := :new.PDE_FINAL_QUANTITY_SU;
      aNEW.PDE_BALANCE_QUANTITY          := :new.PDE_BALANCE_QUANTITY;
      aNEW.PDE_MOVEMENT_QUANTITY         := :new.PDE_MOVEMENT_QUANTITY;
      aNEW.PDE_MOVEMENT_VALUE            := :new.PDE_MOVEMENT_VALUE;
      aNEW.PDE_CHARACTERIZATION_VALUE_1  := CleanStr(:new.PDE_CHARACTERIZATION_VALUE_1);
      aNEW.PDE_CHARACTERIZATION_VALUE_2  := CleanStr(:new.PDE_CHARACTERIZATION_VALUE_2);
      aNEW.PDE_CHARACTERIZATION_VALUE_3  := CleanStr(:new.PDE_CHARACTERIZATION_VALUE_3);
      aNEW.PDE_CHARACTERIZATION_VALUE_4  := CleanStr(:new.PDE_CHARACTERIZATION_VALUE_4);
      aNEW.PDE_CHARACTERIZATION_VALUE_5  := CleanStr(:new.PDE_CHARACTERIZATION_VALUE_5);
      aNEW.GCO_CHARACTERIZATION_ID       := :new.GCO_CHARACTERIZATION_ID;
      aNEW.GCO_GCO_CHARACTERIZATION_ID   := :new.GCO_GCO_CHARACTERIZATION_ID;
      aNEW.GCO2_GCO_CHARACTERIZATION_ID  := :new.GCO2_GCO_CHARACTERIZATION_ID;
      aNEW.GCO3_GCO_CHARACTERIZATION_ID  := :new.GCO3_GCO_CHARACTERIZATION_ID;
      aNEW.GCO4_GCO_CHARACTERIZATION_ID  := :new.GCO4_GCO_CHARACTERIZATION_ID;
      aNEW.STM_LOCATION_ID               := :new.STM_LOCATION_ID;
      aNEW.STM_STM_LOCATION_ID           := :new.STM_STM_LOCATION_ID;
      aNEW.FAL_NETWORK_LINK_ID           := :new.FAL_NETWORK_LINK_ID;
      -- Copier :OLD dans un record pour le passer en paramètres aux procédures
      aOLD.DOC_POSITION_DETAIL_ID        := :old.DOC_POSITION_DETAIL_ID;
      aOLD.DOC_GAUGE_FLOW_ID             := :old.DOC_GAUGE_FLOW_ID;
      aOLD.DOC_POSITION_ID               := :old.DOC_POSITION_ID;
      aOLD.DOC_DOC_POSITION_DETAIL_ID    := :old.DOC_DOC_POSITION_DETAIL_ID;
      aOLD.DOC2_DOC_POSITION_DETAIL_ID   := :old.DOC2_DOC_POSITION_DETAIL_ID;
      aOLD.PDE_BASIS_DELAY               := :old.PDE_BASIS_DELAY;
      aOLD.PDE_BASIS_DELAY_W             := :old.PDE_BASIS_DELAY_W;
      aOLD.PDE_BASIS_DELAY_M             := :old.PDE_BASIS_DELAY_M;
      aOLD.PDE_INTERMEDIATE_DELAY        := :old.PDE_INTERMEDIATE_DELAY;
      aOLD.PDE_INTERMEDIATE_DELAY_W      := :old.PDE_INTERMEDIATE_DELAY_W;
      aOLD.PDE_INTERMEDIATE_DELAY_M      := :old.PDE_INTERMEDIATE_DELAY_M;
      aOLD.PDE_FINAL_DELAY               := :old.PDE_FINAL_DELAY;
      aOLD.PDE_FINAL_DELAY_W             := :old.PDE_FINAL_DELAY_W;
      aOLD.PDE_FINAL_DELAY_M             := :old.PDE_FINAL_DELAY_M;
      aOLD.PDE_BASIS_QUANTITY            := :old.PDE_BASIS_QUANTITY;
      aOLD.PDE_INTERMEDIATE_QUANTITY     := :old.PDE_INTERMEDIATE_QUANTITY;
      aOLD.PDE_FINAL_QUANTITY            := :old.PDE_FINAL_QUANTITY;
      aOLD.PDE_BASIS_QUANTITY_SU         := :old.PDE_BASIS_QUANTITY_SU;
      aOLD.PDE_INTERMEDIATE_QUANTITY_SU  := :old.PDE_INTERMEDIATE_QUANTITY_SU;
      aOLD.PDE_FINAL_QUANTITY_SU         := :old.PDE_FINAL_QUANTITY_SU;
      aOLD.PDE_BALANCE_QUANTITY          := :old.PDE_BALANCE_QUANTITY;
      aOLD.PDE_MOVEMENT_QUANTITY         := :old.PDE_MOVEMENT_QUANTITY;
      aOLD.PDE_MOVEMENT_VALUE            := :old.PDE_MOVEMENT_VALUE;
      aOLD.PDE_CHARACTERIZATION_VALUE_1  := :old.PDE_CHARACTERIZATION_VALUE_1;
      aOLD.PDE_CHARACTERIZATION_VALUE_2  := :old.PDE_CHARACTERIZATION_VALUE_2;
      aOLD.PDE_CHARACTERIZATION_VALUE_3  := :old.PDE_CHARACTERIZATION_VALUE_3;
      aOLD.PDE_CHARACTERIZATION_VALUE_4  := :old.PDE_CHARACTERIZATION_VALUE_4;
      aOLD.PDE_CHARACTERIZATION_VALUE_5  := :old.PDE_CHARACTERIZATION_VALUE_5;
      aOLD.GCO_CHARACTERIZATION_ID       := :old.GCO_CHARACTERIZATION_ID;
      aOLD.GCO_GCO_CHARACTERIZATION_ID   := :old.GCO_GCO_CHARACTERIZATION_ID;
      aOLD.GCO2_GCO_CHARACTERIZATION_ID  := :old.GCO2_GCO_CHARACTERIZATION_ID;
      aOLD.GCO3_GCO_CHARACTERIZATION_ID  := :old.GCO3_GCO_CHARACTERIZATION_ID;
      aOLD.GCO4_GCO_CHARACTERIZATION_ID  := :old.GCO4_GCO_CHARACTERIZATION_ID;
      aOLD.STM_LOCATION_ID               := :old.STM_LOCATION_ID;
      aOLD.STM_STM_LOCATION_ID           := :old.STM_STM_LOCATION_ID;
      aOLD.FAL_NETWORK_LINK_ID           := :old.FAL_NETWORK_LINK_ID;

      -- Repère Graph (Z0)
      if     (aGaugeType = '2')
         and (aPositionType not in('71', '81') ) then
        -- Repère graph (E1)
        -- le < est justifié pour Empecher la création de réseaux avec Qtés négatives ou nulles.
        if :new.PDE_BALANCE_QUANTITY <= 0 then
          -- Processus : Suppression des Réseaux Logistiques Appro(avec historisation)
          FAL_NETWORK_DOC.ReseauApproDOC_Suppr(:new.DOC_POSITION_DETAIL_ID, true);
        else
          -- Repère graph (E2)
          if :old.PDE_BALANCE_QUANTITY <= 0 then
            -- S il existe une appro pour le détail de la position alors on la supprime sans historisation
            -- Processus : Suppresion RéseauxLogAppro (sans historisation)
            FAL_NETWORK_DOC.ReseauApproDOC_Suppr(:new.DOC_POSITION_DETAIL_ID, false);
            -- Processus : Création RéseauxLogAppro
            FAL_NETWORK_DOC.ReseauApproDOC_Creation(aPositionDetail     => aNEW
                                                  , pDocumentID         => null
                                                  , pGoodID             => null
                                                  , pDocRecordID        => null
                                                  , pConversionFactor   => null
                                                  , iDescription        => lvFanDescr
                                                   );
          else
            -- Processus : Mise à jour RéseauxLogAppro
            FAL_NETWORK_DOC.ReseauApproDOC_MAJ(aNEW, aOLD);
          end if;
        end if;
      end if;

      -- Repère graph (Z1)
      if    (aGaugeType = '1')
         or (     (aGaugeType = '2')
             and (aPositionType in('71', '81') ) ) then
        -- Repère graph (A1)
        -- le < est justifié pour Empecher la création de réseaux avec Qtés négatives ou nulles.
        if :new.PDE_BALANCE_QUANTITY <= 0 then
          -- Repère graph (A2)
          -- Est-ce un bien et la position a t'elle une durée pour le transfert du stock propriétaire
          if     (aPositionType = '1')
             and (aPOS_TRANSFERT_PROPRIETOR = '1') then
            -- Processus : Suppresion RéseauxLogBesoin (avec historisation)
            FAL_NETWORK_DOC.ReseauBesoinDOC_Suppr(:new.DOC_POSITION_DETAIL_ID, true);
            -- Processus : Suppresion RéseauxLogAppro (avec historisation)
            FAL_NETWORK_DOC.ReseauApproDOC_Suppr(:new.DOC_POSITION_DETAIL_ID, true);
          elsif aPositionType in('7', '8', '9', '10') then
            -- Processus : Suppresion RéseauxLogBesoin (avec historisation)
            FAL_NETWORK_DOC.ReseauBesoinDOC_Suppr(:new.DOC_POSITION_DETAIL_ID, true);
            -- Processus : Suppresion RéseauxLogAppro (avec historisation)
            FAL_NETWORK_DOC.ReseauApproDOC_Suppr(:new.DOC_POSITION_DETAIL_ID, true);

            if     aGasUpdatePicOrderQty = 1
               and to_number(PCS.PC_CONFIG.GetConfig('FAL_PIC') ) in(2, 3)
               and bNewLocationWithPic then
              -- Ce n'est pas le PDE_FINAL_DELAY qu'il faut prendre mais le PDE_BASIS_DELAY
              FAL_PLAN_DIRECTEUR.ProcessusMajQteCmdPicLine(aGCO_GOOD_ID
                                                         , :old.PDE_BASIS_DELAY
                                                         , :old.PAC_THIRD_ID
                                                         , aPAC_REPRESENTATIVE_ID
                                                         , -:old.PDE_BALANCE_QUANTITY   -- ???
                                                         , aDIC_PIC_GROUP_ID
                                                          );
            end if;
          elsif aPositionType not in('7', '8', '9', '10') then
            -- Processus : Suppression des Réseaux Logistiques Besoin
            FAL_NETWORK_DOC.ReseauBesoinDOC_Suppr(:new.DOC_POSITION_DETAIL_ID, true);

            -- Dans ce cas le processus de maj ligne de pic n'est appelé que si le type de gabarit est besoin (1)
            if     aGaugeType = '1'
               and aGasUpdatePicOrderQty = 1
               and to_number(PCS.PC_CONFIG.GetConfig('FAL_PIC') ) in(2, 3)
               and bNewLocationWithPic then
              -- Ce n'est pas le PDE_FINAL_DELAY qu'il faut prendre mais le PDE_BASIS_DELAY
              FAL_PLAN_DIRECTEUR.ProcessusMajQteCmdPicLine(aGCO_GOOD_ID
                                                         , :old.PDE_BASIS_DELAY
                                                         , :old.PAC_THIRD_ID
                                                         , aPAC_REPRESENTATIVE_ID
                                                         , -:old.PDE_BALANCE_QUANTITY   -- ???
                                                         , aDIC_PIC_GROUP_ID
                                                          );
            end if;
          end if;
        else
          -- Repère graph (B1)
          if :old.PDE_BALANCE_QUANTITY <= 0 then
            -- S il existe un besoin pour le détail de la position alors on le supprime sans historisation
            FAL_NETWORK_DOC.ReseauBesoinDOC_Suppr(:new.DOC_POSITION_DETAIL_ID, false);
            -- S'il existe une appro pour le détail de la position alors on la supprime sans historisation
            -- Processus : Suppresion RéseauxLogAppro (sans historisation)
            FAL_NETWORK_DOC.ReseauApproDOC_Suppr(:new.DOC_POSITION_DETAIL_ID, false);
            -- Processus : Création RéseauxLogBesoin
            FAL_NETWORK_DOC.ReseauBesoinDOC_Creation(aPositionDetail          => aNEW
                                                   , pDocumentID              => null
                                                   , pGoodID                  => null
                                                   , pDocRecordID             => null
                                                   , pConversionFactor        => null
                                                   , pPAC_REPRESENTATIVE_ID   => null
                                                   , iDescription             => lvFanDescr
                                                    );

            -- Repère graph (B2)
            -- Est-ce un bien et la position a t'elle une durée pour le transfert du stock propriétaire
            if     (aPositionType = '1')
               and (aPOS_TRANSFERT_PROPRIETOR = '1') then
              -- Pour ce cas , l'appro doit être sur le stock de transfert, c'est une exception
              aNEW.STM_LOCATION_ID  := aNEW.STM_STM_LOCATION_ID;
              -- Processus : Création RéseauxLogAppro
              FAL_NETWORK_DOC.ReseauApproDOC_Creation(aPositionDetail     => aNEW
                                                    , pDocumentID         => null
                                                    , pGoodID             => null
                                                    , pDocRecordID        => null
                                                    , pConversionFactor   => null
                                                    , iDescription        => lvFanDescr
                                                     );
            elsif(aPositionType in('7', '8', '9', '10') ) then
              -- Processus : Création RéseauxLogAppro
              aNEW.PDE_FINAL_DELAY  := aNEW.PDE_BASIS_DELAY;
              FAL_NETWORK_DOC.ReseauApproDOC_Creation(aPositionDetail     => aNEW
                                                    , pDocumentID         => null
                                                    , pGoodID             => null
                                                    , pDocRecordID        => null
                                                    , pConversionFactor   => null
                                                    , iDescription        => lvFanDescr
                                                     );
              -- Déterminer la quantité solde en unité de stockage
              -- Recherche également le nombre de décimal sur le bien pour arrondir supérieure la quantité solde en unité de stockage
              lnNumberOfDecimal     := GCO_I_LIB_FUNCTIONS.GetNumberOfDecimal(:new.GCO_GOOD_ID);
              lnBalanceQtySU        := ACS_FUNCTION.RoundNear(:new.PDE_BALANCE_QUANTITY * aConvertFactor, 1 / power(10, lnNumberOfDecimal), 1);
              -- Graphe : Création Attribution Besoin/Appro ou Appro/Besoin
              FAl_NETWORK.CreateAttribBesoinAppro(FAL_NETWORK_DOC.glbNewBesoinID, FAL_NETWORK_DOC.glbNewApproID, lnBalanceQtySU);

              -- Il ne faut faire la mise à jour qu'ici.
              if     aGasUpdatePicOrderQty = 1
                 and to_number(PCS.PC_CONFIG.GetConfig('FAL_PIC') ) in(2, 3)
                 and bNewLocationWithPic then
                -- Ce n'est pas le PDE_FINAL_DELAY qu'il faut prendre mais le PDE_BASIS_DELAY
                FAL_PLAN_DIRECTEUR.ProcessusMajQteCmdPicLine(aGCO_GOOD_ID
                                                           , :new.PDE_BASIS_DELAY
                                                           , :new.PAC_THIRD_ID
                                                           , aPAC_REPRESENTATIVE_ID
                                                           , :new.PDE_BALANCE_QUANTITY   -- ???
                                                           , aDIC_PIC_GROUP_ID
                                                            );
              end if;
            elsif(aPositionType not in('7', '8', '9', '10') ) then
              -- Dans ce cas les processus de maj ligne de pic ne sont appelés que si le type de gabarit est besoin (1)
              if     aGaugeType = '1'
                 and aGasUpdatePicOrderQty = 1
                 and to_number(PCS.PC_CONFIG.GetConfig('FAL_PIC') ) in(2, 3)
                 and bNewLocationWithPic then
                -- Ce n'est pas le PDE_FINAL_DELAY qu'il faut prendre mais le PDE_BASIS_DELAY
                FAL_PLAN_DIRECTEUR.ProcessusMajQteCmdPicLine(aGCO_GOOD_ID
                                                           , :new.PDE_BASIS_DELAY
                                                           , :new.PAC_THIRD_ID
                                                           , aPAC_REPRESENTATIVE_ID
                                                           , :new.PDE_BALANCE_QUANTITY   -- ???
                                                           , aDIC_PIC_GROUP_ID
                                                            );
              end if;
            end if;
          else
            bDoProcessUpdatePicLine  := false;

            -- Repère graph (C1)
            -- Est-ce un bien et la position a t'elle une durée pour le transfert du stock propriétaire
            if     (aPositionType = '1')
               and (aPOS_TRANSFERT_PROPRIETOR = '1') then
              FAL_NETWORK_DOC.ReseauBesoinDOC_MAJ(aNEW, aOLD);
              -- Pour ce cas , l'appro doit être sur le stock de transfert, c'est une exception
              aNEW.STM_LOCATION_ID  := aNEW.STM_STM_LOCATION_ID;
              -- Processus : Mise à jour RéseauxLogAppro
              FAL_NETWORK_DOC.ReseauApproDOC_MAJ(aNEW, aOLD);
            elsif(aPositionType in('7', '8', '9', '10') ) then
              -- Processus : Mise à jour RéseauxLogBesoin
              FAL_NETWORK_DOC.ReseauBesoinDOC_MAJ_78910(aNEW, aOLD);
              -- Processus : Mise à jour RéseauxLogAppro
              aNEW.PDE_FINAL_DELAY     := aNEW.PDE_BASIS_DELAY;
              FAL_NETWORK_DOC.ReseauApproDOC_MAJ_78910(aNEW, aOLD);
              -- Processus : Mise à jour Attribution
              FAL_NETWORK_DOC.Attribution_MAJ_78910(:new.DOC_POSITION_DETAIL_ID);
              bDoProcessUpdatePicLine  := true;
            elsif(aPositionType not in('7', '8', '9', '10') ) then
              -- Processus : Mise à jour RéseauxLogBesoin
              FAL_NETWORK_DOC.ReseauBesoinDOC_MAJ(aNEW, aOLD);

              -- Dans ce cas les processus de maj ligne de pic ne sont appelés que si le type de gabarit est besoin (1)
              if aGaugeType = '1' then
                bDoProcessUpdatePicLine  := true;
              end if;
            end if;

            if     bDoProcessUpdatePicLine
               and (to_number(PCS.PC_CONFIG.GetConfig('FAL_PIC') ) in(2, 3) ) then
              nOLD_PDE_BALANCE_QTY  := :old.PDE_BALANCE_QUANTITY;
              nNEW_PDE_BALANCE_QTY  := :new.PDE_BALANCE_QUANTITY;

              -- Si aucun des ancien ou nouveau stock ne sont gérés PIC, il n'y a rien à faire
              if    bOldLocationWithPic
                 or bNewLocationWithPic then
                if bNewLocationWithPic then
                  -- Le nouveau détailPosition porte sur un emplacement d'un stock "En-Cours PIC"
                  if not bOldLocationWithPic then
                    -- L'ancien emplacement de stock du détail n'était pas en-cours PIC (le nouveau l'est)
                    -- On force (Doc_Position_Detail -> Old.PDE_Balance_Quantity  ) = 0
                    nOLD_PDE_BALANCE_QTY  := 0;
                  end if;
                else
                  -- L'ancien emplacement de stock du détail était en-cours PIC (le nouveau ne l'est pas)
                  -- On force (Doc_Position_Detail -> New.PDE_Balance_Quantity  ) = 0
                  nNEW_PDE_BALANCE_QTY  := 0;
                end if;

                if     :old.PDE_BASIS_DELAY <> :new.PDE_BASIS_DELAY
                   and aGasUpdatePicOrderQty = 1 then
                  -- Changement de délai OUI --2--

                  -- Ce n'est pas le PDE_FINAL_DELAY qu'il faut prendre mais le PDE_BASIS_DELAY
                  FAL_PLAN_DIRECTEUR.ProcessusMajQteCmdPicLine(aGCO_GOOD_ID
                                                             , :old.PDE_BASIS_DELAY
                                                             , :old.PAC_THIRD_ID
                                                             , aPAC_REPRESENTATIVE_ID
                                                             , -nOLD_PDE_BALANCE_QTY   -- ???
                                                             , aDIC_PIC_GROUP_ID
                                                              );
                  FAL_PLAN_DIRECTEUR.ProcessusMajQteCmdPicLine(aGCO_GOOD_ID
                                                             , :new.PDE_BASIS_DELAY
                                                             , :new.PAC_THIRD_ID
                                                             , aPAC_REPRESENTATIVE_ID
                                                             , nNEW_PDE_BALANCE_QTY   -- ???
                                                             , aDIC_PIC_GROUP_ID
                                                              );
                else
                  -- Changement de délai NON --1--
                  if aGasUpdatePicOrderQty = 1 then
                    -- Ce n'est pas le PDE_FINAL_DELAY qu'il faut prendre mais le PDE_BASIS_DELAY
                    FAL_PLAN_DIRECTEUR.ProcessusMajQteCmdPicLine(aGCO_GOOD_ID
                                                               , :old.PDE_BASIS_DELAY
                                                               , :old.PAC_THIRD_ID
                                                               , aPAC_REPRESENTATIVE_ID
                                                               , nNEW_PDE_BALANCE_QTY - nOLD_PDE_BALANCE_QTY   -- ???
                                                               , aDIC_PIC_GROUP_ID
                                                                );
                  end if;
                end if;
              end if;
            end if;
          end if;
        end if;
      end if;
    end if;
  end if;

  /**
  *  VJ20030303-0664
  *
  *  Supprime l'éventuelle lien temporaire avec une attribution. Cela évite
  *  l'utilisation de ce champ hors de son cadre d'application. Ce cadre est
  *  la mise à jour de la quantité solde d'un détail de position parent dont le
  *  fils a été crée en se basant sur les attributions sur stock. }
  *
  */
  :new.FAL_NETWORK_LINK_ID  := null;
end DOC_PDE_BU_FORNETWORK;

ALTER TRIGGER "C_ITX"."DOC_PDE_BU_FORNETWORK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PDE_BU_UPDATE_ATTRIB"
  before update of PDE_FINAL_QUANTITY
                 , PDE_CHARACTERIZATION_VALUE_1
                 , PDE_CHARACTERIZATION_VALUE_2
                 , PDE_CHARACTERIZATION_VALUE_3
                 , PDE_CHARACTERIZATION_VALUE_4
                 , PDE_CHARACTERIZATION_VALUE_5
  on DOC_POSITION_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Basculer le flag POS_UPDATE_ATTRIB sur la DOC_POSITION lors de la
*    modif de la qté ou des valeurs de caractérisation d'un détail.
* @created NGV 21.10.2008
* @version 2003
*/
begin
  update DOC_POSITION
     set POS_UPDATE_ATTRIB = 1
   where DOC_POSITION_ID = :new.DOC_POSITION_ID;
end DOC_PDE_BU_UPDATE_ATTRIB;

ALTER TRIGGER "C_ITX"."DOC_PDE_BU_UPDATE_ATTRIB" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PJD_BI_COPY_SUPPL"
  before insert
  on DOC_PRINT_JOB_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour du nombre de copie supplémentaire par document
* @version 2003
*/
begin
  select DOC_LIB_GAUGE.GetCopySupp(DOC_GAUGE_ID, DMT_NUMBER, 0, 'DOC')
       , DOC_LIB_GAUGE.GetCopySupp(DOC_GAUGE_ID, DMT_NUMBER, 1, 'DOC')
       , DOC_LIB_GAUGE.GetCopySupp(DOC_GAUGE_ID, DMT_NUMBER, 2, 'DOC')
       , DOC_LIB_GAUGE.GetCopySupp(DOC_GAUGE_ID, DMT_NUMBER, 3, 'DOC')
       , DOC_LIB_GAUGE.GetCopySupp(DOC_GAUGE_ID, DMT_NUMBER, 4, 'DOC')
       , DOC_LIB_GAUGE.GetCopySupp(DOC_GAUGE_ID, DMT_NUMBER, 5, 'DOC')
       , DOC_LIB_GAUGE.GetCopySupp(DOC_GAUGE_ID, DMT_NUMBER, 6, 'DOC')
       , DOC_LIB_GAUGE.GetCopySupp(DOC_GAUGE_ID, DMT_NUMBER, 7, 'DOC')
       , DOC_LIB_GAUGE.GetCopySupp(DOC_GAUGE_ID, DMT_NUMBER, 8, 'DOC')
       , DOC_LIB_GAUGE.GetCopySupp(DOC_GAUGE_ID, DMT_NUMBER, 9, 'DOC')
       , DOC_LIB_GAUGE.GetCopySupp(DOC_GAUGE_ID, DMT_NUMBER, 10, 'DOC')
    into :new.PJD_COPY_SUPPL0
       , :new.PJD_COPY_SUPPL1
       , :new.PJD_COPY_SUPPL2
       , :new.PJD_COPY_SUPPL3
       , :new.PJD_COPY_SUPPL4
       , :new.PJD_COPY_SUPPL5
       , :new.PJD_COPY_SUPPL6
       , :new.PJD_COPY_SUPPL7
       , :new.PJD_COPY_SUPPL8
       , :new.PJD_COPY_SUPPL9
       , :new.PJD_COPY_SUPPL10
    from DOC_DOCUMENT DOC
   where DOC.DMT_NUMBER = :new.DMT_NUMBER;
end DOC_PJD_BI_COPY_SUPPL;

ALTER TRIGGER "C_ITX"."DOC_PJD_BI_COPY_SUPPL" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_PJO_BD_CONSTRAINTS"
  before delete
  on DOC_PRINT_JOB
  referencing old as old new as new
  for each row
/**
* Description
*    Suppression de tous les détails du travail d'impression
* @version 2003
*/
begin
  delete from DOC_PRINT_JOB_DETAIL
        where DOC_PRINT_JOB_ID = :old.DOC_PRINT_JOB_ID;
end DOC_PJO_BD_CONSTRAINTS;

ALTER TRIGGER "C_ITX"."DOC_PJO_BD_CONSTRAINTS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POI_AIUD_RECORD_LINK"
  before insert or update of "DOC_RECORD_ID" or delete
  on DOC_POSITION_IMPUTATION
  referencing old as old new as new
  for each row
/**
* Description
*    Maintenance des liens entre dossiers
* @created fp 01.11.2007
* @version 2003
* @lastUpdate
*/
declare
  vIsGaugeOk number(1);
begin
  if PCS.PC_CONFIG.GetBooleanConfig('GAL_PROJECT_MANAGEMENT') then
    select sign(count(*) )
      into vIsgaugeOk
      from DOC_DOCUMENT DMT
         , DOC_GAUGE GAU
     where DMT.DOC_DOCUMENT_ID = nvl(:old.DOC_DOCUMENT_ID, :new.DOC_DOCUMENT_ID)
       and GAU.DOC_GAUGE_ID = DMT.DOC_GAUGE_ID
       and instr(';' || PCS.PC_CONFIG.GetConfig('GAL_GAUGE_BALANCE_ORDER') || ';', ';' || GAU.GAU_DESCRIBE || ';') > 0;

    if vIsGaugeOk = 1 then
      -- ne passe que si le dossier est renseigné ou si le statut de la position à changé
      if     nvl(:old.DOC_POSITION_ID, :new.DOC_POSITION_ID) is not null
         and nvl(:old.DOC_RECORD_ID, :new.DOC_RECORD_ID) is not null then
        -- mode ajout des valeurs
        if     (   inserting
                or updating)
           and :new.DOC_RECORD_Id is not null then
          declare
            vPosStatus  DOC_POSITION.C_DOC_POS_STATUS%type   default '01';
            vImputation DOC_POSITION.POS_IMPUTATION%type     default 1;
          begin   /* NEW */
            if updating then
              select C_DOC_POS_STATUS
                   , POS_IMPUTATION
                into vPosStatus
                   , vImputation
                from DOC_POSITION
               where DOC_POSITION_ID = :new.DOC_POSITION_ID;
            end if;

            if     vPosStatus <> '05'
               and vImputation = 1 then
              -- création du lien dans DOC_RECORD_LINK
              DOC_RECORD_FUNCTIONS.linkProjectRecord(:new.DOC_DOCUMENT_ID, :new.DOC_RECORD_ID, 1);
            end if;
          end;   /* NEW */
        end if;

        -- Mode suppression anciennes valeurs
        if     (   deleting
                or updating)
           and :old.DOC_RECORD_ID is not null then
          declare
            vPosStatus DOC_POSITION.C_DOC_POS_STATUS%type;
          begin
            select C_DOC_POS_STATUS
              into vPosStatus
              from DOC_POSITION
             where DOC_POSITION_ID = :old.DOC_POSITION_ID;

            if vPosStatus <> '05' then
              -- création du lien dans DOC_RECORD_LINK
              DOC_RECORD_FUNCTIONS.linkProjectRecord(:old.DOC_DOCUMENT_ID, :old.DOC_RECORD_ID, -1);
            end if;
          exception
            when ex.TABLE_MUTATING then
              null;
          end;
        end if;
      end if;
    end if;
  end if;
end DOC_POI_AIUD_RECORD_LINK;

ALTER TRIGGER "C_ITX"."DOC_POI_AIUD_RECORD_LINK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POI_BIU_FINANCIAL_ACCOUNT"
  before insert or update of DOC_RECORD_ID
  on DOC_POSITION_IMPUTATION
  referencing old as old new as new
  for each row
/**
* Description
*    Initialisation des comptes financiers sur la table DOC_POSITION_IMPUTATION en insert et recherche
*    des nouveaux comptes suite à la modification du dossier de l'imputation
* @author VJE
* @created 05.09.2006
*/
declare
  vAccountInfo                ACS_I_LIB_LOGISTIC_FINANCIAL.TAccountInfo;
  vFinancial                  STM_MOVEMENT_KIND.MOK_FINANCIAL_IMPUTATION%type;
  vAnalytical                 STM_MOVEMENT_KIND.MOK_ANAL_IMPUTATION%type;
  vInfoCompl                  STM_MOVEMENT_KIND.MOK_USE_MANAGED_DATA%type;
  docDocumentID               DOC_DOCUMENT.DOC_DOCUMENT_ID%type;
  gcoGoodID                   GCO_GOOD.GCO_GOOD_ID%type;
  pacThirdID                  PAC_THIRD.PAC_THIRD_ID%type;
  posACS_FINANCIAL_ACCOUNT_ID DOC_POSITION.ACS_FINANCIAL_ACCOUNT_ID%type;
  posACS_DIVISION_ACCOUNT_ID  DOC_POSITION.ACS_DIVISION_ACCOUNT_ID%type;
  posACS_CPN_ACCOUNT_ID       DOC_POSITION.ACS_CPN_ACCOUNT_ID%type;
  posACS_CDA_ACCOUNT_ID       DOC_POSITION.ACS_CDA_ACCOUNT_ID%type;
  posACS_PF_ACCOUNT_ID        DOC_POSITION.ACS_PF_ACCOUNT_ID%type;
  posACS_PJ_ACCOUNT_ID        DOC_POSITION.ACS_PJ_ACCOUNT_ID%type;
  docGaugeID                  DOC_GAUGE.DOC_GAUGE_ID%type;
  cAdminDomain                DOC_GAUGE.C_ADMIN_DOMAIN%type;
  docDateDocument             DOC_DOCUMENT.DMT_DATE_DOCUMENT%type;
  vPositionRow                DOC_POSITION%rowtype;
  vPositionChargeRow          DOC_POSITION_CHARGE%rowtype;
  vFootChargeRow              DOC_FOOT_CHARGE%rowtype;
  vPositionImputationRow      DOC_POSITION_IMPUTATION%rowtype;
begin
  -- Recherche des comptes financiers en création ou lors de la modification du dossier de l'imputation.
  if    (    inserting
         and :new.ACS_FINANCIAL_ACCOUNT_ID is null
         and :new.ACS_DIVISION_ACCOUNT_ID is null)
     or (    updating
         and (nvl(:old.DOC_RECORD_ID, 0) <> nvl(:new.DOC_RECORD_ID, 0) ) ) then
    if not(    :new.DOC_POSITION_ID is null
           and :new.DOC_POSITION_CHARGE_ID is null
           and :new.DOC_FOOT_CHARGE_ID is null) then
      begin
        select DMT.DOC_DOCUMENT_ID
             , DMT.PAC_THIRD_ID
             , GAU.DOC_GAUGE_ID
             , GAU.C_ADMIN_DOMAIN
             , DMT.DMT_DATE_DOCUMENT
          into docDocumentID
             , pacThirdID
             , docGaugeID
             , cAdminDomain
             , docDateDocument
          from DOC_POSITION POS
             , DOC_DOCUMENT DMT
             , DOC_GAUGE GAU
         where POS.DOC_POSITION_ID = :new.DOC_POSITION_ID
           and DMT.DOC_DOCUMENT_ID = POS.DOC_DOCUMENT_ID
           and GAU.DOC_GAUGE_ID = DMT.DOC_GAUGE_ID;

        if :new.DOC_POSITION_CHARGE_ID is not null then
          select *
            into vPositionChargeRow
            from DOC_POSITION_CHARGE
           where DOC_POSITION_CHARGE_ID = :new.DOC_POSITION_CHARGE_ID;
        elsif :new.DOC_FOOT_CHARGE_ID is not null then
          select *
            into vFootChargeRow
            from DOC_FOOT_CHARGE
           where DOC_FOOT_CHARGE_ID = :new.DOC_FOOT_CHARGE_ID;
        else
          select *
            into vPositionRow
            from DOC_POSITION
           where DOC_POSITION_ID = :new.DOC_POSITION_ID;
        end if;
      exception
        when ex.TABLE_MUTATING then
          null;
        when no_data_found then
          null;
      end;

      if docDocumentID is not null then
        -- Recherche des comptes des imputations position, remise et taxe de position et remise, taxe et frais de pied.
        DOC_IMPUTATION_FUNCTIONS.GetImputationAccounts(docDocumentID
                                                     , docGaugeID
                                                     , pacThirdID
                                                     , :new.DOC_RECORD_ID
                                                     , cAdminDomain
                                                     , docDateDocument
                                                     , :new.DOC_POSITION_ID
                                                     , vPositionRow
                                                     , :new.DOC_POSITION_CHARGE_ID
                                                     , vPositionChargeRow
                                                     , :new.DOC_FOOT_CHARGE_ID
                                                     , vFootChargeRow
                                                     , vPositionImputationRow
                                                      );

        -- Utilisation des comptes par défaut et des déplacements uniquement si la configuration le permet.
        if    :new.DOC_POSITION_CHARGE_ID is null
           or not(    (    vPositionChargeRow.C_FINANCIAL_CHARGE = '02'
                       and PCS.PC_CONFIG.GetConfig('FIN_DSCT_GOOD') = '1')
                  or (    vPositionChargeRow.C_FINANCIAL_CHARGE = '03'
                      and PCS.PC_CONFIG.GetConfig('FIN_TAXE_GOOD') = '1')
                 ) then
          :new.ACS_FINANCIAL_ACCOUNT_ID  := vPositionImputationRow.ACS_FINANCIAL_ACCOUNT_ID;
        end if;

        if    :new.DOC_POSITION_CHARGE_ID is null
           or not(    (    vPositionChargeRow.C_FINANCIAL_CHARGE = '02'
                       and PCS.PC_CONFIG.GetConfig('FIN_DSCT_GOOD_DIV') = '1'
                      )
                  or (    vPositionChargeRow.C_FINANCIAL_CHARGE = '03'
                      and PCS.PC_CONFIG.GetConfig('FIN_TAXE_GOOD_DIV') = '1'
                     )
                 ) then
          :new.ACS_DIVISION_ACCOUNT_ID  := vPositionImputationRow.ACS_DIVISION_ACCOUNT_ID;
        end if;

        if    :new.DOC_POSITION_CHARGE_ID is null
           or not(    (    vPositionChargeRow.C_FINANCIAL_CHARGE = '02'
                       and PCS.PC_CONFIG.GetConfig('FIN_DSCT_GOOD_CPN') = '1'
                      )
                  or (    vPositionChargeRow.C_FINANCIAL_CHARGE = '03'
                      and PCS.PC_CONFIG.GetConfig('FIN_TAXE_GOOD_CPN') = '1'
                     )
                 ) then
          :new.ACS_CPN_ACCOUNT_ID  := vPositionImputationRow.ACS_CPN_ACCOUNT_ID;
        end if;

        if    :new.DOC_POSITION_CHARGE_ID is null
           or not(    (    vPositionChargeRow.C_FINANCIAL_CHARGE = '02'
                       and PCS.PC_CONFIG.GetConfig('FIN_DSCT_GOOD_CDA') = '1'
                      )
                  or (    vPositionChargeRow.C_FINANCIAL_CHARGE = '03'
                      and PCS.PC_CONFIG.GetConfig('FIN_TAXE_GOOD_CDA') = '1'
                     )
                 ) then
          :new.ACS_CDA_ACCOUNT_ID  := vPositionImputationRow.ACS_CDA_ACCOUNT_ID;
        end if;

        if    :new.DOC_POSITION_CHARGE_ID is null
           or not(    (    vPositionChargeRow.C_FINANCIAL_CHARGE = '02'
                       and PCS.PC_CONFIG.GetConfig('FIN_DSCT_GOOD_PF') = '1'
                      )
                  or (    vPositionChargeRow.C_FINANCIAL_CHARGE = '03'
                      and PCS.PC_CONFIG.GetConfig('FIN_TAXE_GOOD_PF') = '1'
                     )
                 ) then
          :new.ACS_PF_ACCOUNT_ID  := vPositionImputationRow.ACS_PF_ACCOUNT_ID;
        end if;

        if    :new.DOC_POSITION_CHARGE_ID is null
           or not(    (    vPositionChargeRow.C_FINANCIAL_CHARGE = '02'
                       and PCS.PC_CONFIG.GetConfig('FIN_DSCT_GOOD_PJ') = '1'
                      )
                  or (    vPositionChargeRow.C_FINANCIAL_CHARGE = '03'
                      and PCS.PC_CONFIG.GetConfig('FIN_TAXE_GOOD_PJ') = '1'
                     )
                 ) then
          :new.ACS_PJ_ACCOUNT_ID  := vPositionImputationRow.ACS_PJ_ACCOUNT_ID;
        end if;

        :new.DIC_IMP_FREE1_ID       := nvl(:new.DIC_IMP_FREE1_ID, vPositionImputationRow.DIC_IMP_FREE1_ID);
        :new.DIC_IMP_FREE2_ID       := nvl(:new.DIC_IMP_FREE2_ID, vPositionImputationRow.DIC_IMP_FREE2_ID);
        :new.DIC_IMP_FREE3_ID       := nvl(:new.DIC_IMP_FREE3_ID, vPositionImputationRow.DIC_IMP_FREE3_ID);
        :new.DIC_IMP_FREE4_ID       := nvl(:new.DIC_IMP_FREE4_ID, vPositionImputationRow.DIC_IMP_FREE4_ID);
        :new.DIC_IMP_FREE5_ID       := nvl(:new.DIC_IMP_FREE5_ID, vPositionImputationRow.DIC_IMP_FREE5_ID);
        :new.POI_IMF_TEXT_1         := nvl(:new.POI_IMF_TEXT_1, vPositionImputationRow.POI_IMF_TEXT_1);
        :new.POI_IMF_TEXT_2         := nvl(:new.POI_IMF_TEXT_2, vPositionImputationRow.POI_IMF_TEXT_2);
        :new.POI_IMF_TEXT_3         := nvl(:new.POI_IMF_TEXT_3, vPositionImputationRow.POI_IMF_TEXT_3);
        :new.POI_IMF_TEXT_4         := nvl(:new.POI_IMF_TEXT_4, vPositionImputationRow.POI_IMF_TEXT_4);
        :new.POI_IMF_TEXT_5         := nvl(:new.POI_IMF_TEXT_5, vPositionImputationRow.POI_IMF_TEXT_5);
        :new.POI_IMF_NUMBER_1       := nvl(:new.POI_IMF_NUMBER_1, vPositionImputationRow.POI_IMF_NUMBER_1);
        :new.POI_IMF_NUMBER_2       := nvl(:new.POI_IMF_NUMBER_2, vPositionImputationRow.POI_IMF_NUMBER_2);
        :new.POI_IMF_NUMBER_3       := nvl(:new.POI_IMF_NUMBER_3, vPositionImputationRow.POI_IMF_NUMBER_3);
        :new.POI_IMF_NUMBER_4       := nvl(:new.POI_IMF_NUMBER_4, vPositionImputationRow.POI_IMF_NUMBER_4);
        :new.POI_IMF_NUMBER_5       := nvl(:new.POI_IMF_NUMBER_5, vPositionImputationRow.POI_IMF_NUMBER_5);
        :new.FAM_FIXED_ASSETS_ID    := nvl(:new.FAM_FIXED_ASSETS_ID, vPositionImputationRow.FAM_FIXED_ASSETS_ID);
        :new.C_FAM_TRANSACTION_TYP  := nvl(:new.C_FAM_TRANSACTION_TYP, vPositionImputationRow.C_FAM_TRANSACTION_TYP);
        :new.HRM_PERSON_ID          := nvl(:new.HRM_PERSON_ID, vPositionImputationRow.HRM_PERSON_ID);
      end if;
    end if;
  end if;
end DOC_POI_BIU_FINANCIAL_ACCOUNT;

ALTER TRIGGER "C_ITX"."DOC_POI_BIU_FINANCIAL_ACCOUNT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POI_BIU_LOCAL_CURRENCY"
  before insert or update of POI_AMOUNT
  on DOC_POSITION_IMPUTATION
  referencing old as old new as new
  for each row
/**
* Description
*    Maj des montants en monnaie locale
* @author fp 23.08.2006
* @version 2003
* @lastUpdate
*/
declare
  vEuroRate          DOC_DOCUMENT.DMT_RATE_OF_EXCHANGE%type;
  vCurrencyId        DOC_DOCUMENT.ACS_FINANCIAL_CURRENCY_ID%type;
  vVatCurrId         DOC_DOCUMENT.ACS_ACS_FINANCIAL_CURRENCY_ID%type;
  vLocalCurrId       DOC_DOCUMENT.ACS_FINANCIAL_CURRENCY_ID%type;
  vDocumentDate      DOC_DOCUMENT.DMT_DATE_DOCUMENT%type;
  vRateOfExchange    DOC_DOCUMENT.DMT_RATE_OF_EXCHANGE%type;
  vBasePrice         DOC_DOCUMENT.DMT_BASE_PRICE%type;
  vVatRateOfExchange DOC_DOCUMENT.DMT_VAT_EXCHANGE_RATE%type;
  vVatBasePrice      DOC_DOCUMENT.DMT_VAT_BASE_PRICE%type;
  vDetAccountId      DOC_VAT_DET_ACCOUNT.DOC_VAT_DET_ACCOUNT_ID%type;
  vBidon             DOC_POSITION.POS_NET_VALUE_EXCL_E%type;
  vTaxTransaction    ACS_ACCOUNT.ACC_INTEREST%type;
  vRefDate           DOC_DOCUMENT.DMT_DATE_DELIVERY%type;
begin
  -- recherche des informations nécessaires à la conversion dans la table DOC_DOCUMENT
  select ACS_FINANCIAL_CURRENCY_ID
       , ACS_ACS_FINANCIAL_CURRENCY_ID
       , DMT_DATE_DOCUMENT
       , DMT_RATE_OF_EXCHANGE
       , DMT_BASE_PRICE
       , DMT_VAT_EXCHANGE_RATE
       , DMT_VAT_BASE_PRICE
    into vCurrencyId
       , vVatCurrId
       , vDocumentDate
       , vRateOfExchange
       , vBasePrice
       , vVatRateOfExchange
       , vVatBasePrice
    from DOC_DOCUMENT
   where DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID;

  vLocalCurrId  := ACS_FUNCTION.GetLocalCurrencyId;

  -- Les différents cas possibles
  -- n°   Monnaie base    Monnaie Document    Monnaie TVA
  -- 1.   CHF             CHF                 CHF
  -- 2.   CHF             EUR                 CHF
  -- 3.   CHF             EUR                 EUR
  -- 4.   CHF             CHF                 EUR
  -- 5.   CHF             USD                 EUR
  if     (vLocalCurrId = vVatCurrId)
     and (vCurrencyId = vVatCurrId) then   -- Cas n° 1 -> Ex : CHF - CHF - CHF
    :new.POI_AMOUNT_B  := :new.POI_AMOUNT;
    :new.POI_AMOUNT_V  := :new.POI_AMOUNT;
    ACS_FUNCTION.ConvertAmount(aAmount          => nvl(:new.POI_AMOUNT, 0)
                             , aFromFinCurrId   => vCurrencyId
                             , aToFinCurrId     => vLocalCurrId
                             , aDate            => vDocumentDate
                             , aExchangeRate    => vRateOfExchange
                             , aBasePrice       => vBasePrice
                             , aRound           => 0
                             , aAmountEUR       => :new.POI_AMOUNT_E
                             , aAmountConvert   => vBidon
                              );
  elsif     (vLocalCurrId = vVatCurrId)
        and (vCurrencyId <> vLocalCurrId) then   -- Cas n° 2 -> Ex : CHF - EUR - CHF
    -- ATTENTION : Les paramètres vVatBasePrice et vVatRateOfExchange
    --             ont été inversés exprès dans l'appel ConvertAmount()
    --             pour le cas n°2 car le cours TVA stocké est le cours
    --             entre Monnaie TVA et Monnaie Document

    -- Cas n° 2 -> Ex : CHF - EUR - CHF

    -- Les montants en monnaie TVA sont convertis depuis les montants document avec le cours inversé stocké pour la monnaie TVA
    -- Valeur Nette TTC en monnaie TVA
    ACS_FUNCTION.ConvertAmount(aAmount          => nvl(:new.POI_AMOUNT, 0)
                             , aFromFinCurrId   => vVatCurrId
                             , aToFinCurrId     => vCurrencyId
                             , aDate            => vDocumentDate
                             , aExchangeRate    => vVatBasePrice
                             , aBasePrice       => vVatRateOfExchange
                             , aRound           => 0
                             , aAmountEUR       => vBidon
                             , aAmountConvert   => :new.POI_AMOUNT_V
                              );
    ACS_FUNCTION.ConvertAmount(aAmount          => nvl(:new.POI_AMOUNT, 0)
                             , aFromFinCurrId   => vCurrencyId
                             , aToFinCurrId     => vLocalCurrId
                             , aDate            => vDocumentDate
                             , aExchangeRate    => vRateOfExchange
                             , aBasePrice       => vBasePrice
                             , aRound           => 0
                             , aAmountEUR       => :new.POI_AMOUNT_E
                             , aAmountConvert   => :new.POI_AMOUNT_B
                              );
  elsif     (vCurrencyId = vVatCurrId)
        and (vCurrencyId <> vLocalCurrId) then   -- Cas n° 3 -> Ex : CHF - EUR - EUR
    -- Cas n° 3 -> Ex : CHF - EUR - EUR

    -- Montant en monnaie TVA = Montant en monnaie Document
    :new.POI_AMOUNT_V  := :new.POI_AMOUNT;
    ACS_FUNCTION.ConvertAmount(aAmount          => nvl(:new.POI_AMOUNT, 0)
                             , aFromFinCurrId   => vCurrencyId
                             , aToFinCurrId     => vLocalCurrId
                             , aDate            => vDocumentDate
                             , aExchangeRate    => vRateOfExchange
                             , aBasePrice       => vBasePrice
                             , aRound           => 0
                             , aAmountEUR       => :new.POI_AMOUNT_E
                             , aAmountConvert   => :new.POI_AMOUNT_B
                              );
  else
    -- Cas n° 4 -> Ex : CHF - CHF - EUR
    -- Cas n° 5 -> Ex : CHF - USD - EUR
    ACS_FUNCTION.ConvertAmount(aAmount          => nvl(:new.POI_AMOUNT, 0)
                             , aFromFinCurrId   => vCurrencyId
                             , aToFinCurrId     => vLocalCurrId
                             , aDate            => vDocumentDate
                             , aExchangeRate    => vRateOfExchange
                             , aBasePrice       => vBasePrice
                             , aRound           => 0
                             , aAmountEUR       => :new.POI_AMOUNT_E
                             , aAmountConvert   => :new.POI_AMOUNT_B
                              );
    ACS_FUNCTION.ConvertAmount(aAmount          => nvl(:new.POI_AMOUNT_B, 0)
                             , aFromFinCurrId   => vLocalCurrId
                             , aToFinCurrId     => vVatCurrId
                             , aDate            => vDocumentDate
                             , aExchangeRate    => vVatRateOfExchange
                             , aBasePrice       => vVatBasePrice
                             , aRound           => 0
                             , aAmountEUR       => vBidon
                             , aAmountConvert   => :new.POI_AMOUNT_V
                              );
  end if;
end DOC_POI_BIU_LOCAL_CURRENCY;

ALTER TRIGGER "C_ITX"."DOC_POI_BIU_LOCAL_CURRENCY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_AD_CONSTRAINTS"
  after delete
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Ce trigger remplace une contrainte entre les tables DOC_POSITION et DOC_POSITION_DETAIL
* @author Fabrice Perotto
* @version 2003
* @lastUpdate vj 30.01.2002
*/
declare
  -- curseur sur détail de position
  cursor pde_cursor(pos_id number)
  is
    select DOC_POSITION_DETAIL_ID
      from DOC_POSITION_DETAIL
     where DOC_POSITION_DETAIL.DOC_POSITION_ID = pos_id;

  pde_tuple pde_cursor%rowtype;
begin
  -- Ouverture du curseur sur les details de position
  open pde_cursor(:old.DOC_POSITION_ID);

  fetch pde_cursor
   into pde_tuple;

  while pde_cursor%found loop
    -- Mise en place de la contrainte set null sur le lien de décharge.
    update DOC_POSITION_DETAIL
       set DOC_DOC_POSITION_DETAIL_ID = null
         , A_RECSTATUS = 1
         , A_DATEMOD = sysdate
         , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
     where DOC_DOC_POSITION_DETAIL_ID = pde_tuple.DOC_POSITION_DETAIL_ID;

    -- Mise en place de la contrainte set null sur le lien d'origine en tant que copie.
    update DOC_POSITION_DETAIL
       set DOC2_DOC_POSITION_DETAIL_ID = null
         , A_RECSTATUS = nvl(A_RECSTATUS, 0) + 2
         , A_DATEMOD = sysdate
         , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
     where DOC2_DOC_POSITION_DETAIL_ID = pde_tuple.DOC_POSITION_DETAIL_ID;

    fetch pde_cursor
     into pde_tuple;
  end loop;

  close pde_cursor;

  -- Effacement des détails de position liés à la position
  delete from DOC_POSITION_DETAIL
        where DOC_POSITION_ID = :old.DOC_POSITION_ID;
end DOC_POS_AD_CONSTRAINTS;

ALTER TRIGGER "C_ITX"."DOC_POS_AD_CONSTRAINTS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_AD_JOURNAL"
  after delete
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Journaliser la position
*
* @author Nuno Gomes Vieira
* @created 11/10/2005
* @version 2003
*/
declare
  ltplOld DOC_POSITION%rowtype;
begin
  if DOC_JOURNAL_FUNCTIONS.MustPosJournalize(:old.DOC_DOCUMENT_ID
                                           , :old.DOC_GAUGE_ID
                                           , :old.C_GAUGE_TYPE_POS
                                           , :old.DOC_GAUGE_POSITION_ID
                                           , :old.DOC_DOC_POSITION_ID
                                            ) = 1 then
    -- Assignation de TOUS les champs de la table DOC_POSITION
    --   Champs triés par ordre alphabetique
    ltplOld.ACS_CDA_ACCOUNT_ID            := :old.ACS_CDA_ACCOUNT_ID;
    ltplOld.ACS_CPN_ACCOUNT_ID            := :old.ACS_CPN_ACCOUNT_ID;
    ltplOld.ACS_DIVISION_ACCOUNT_ID       := :old.ACS_DIVISION_ACCOUNT_ID;
    ltplOld.ACS_FINANCIAL_ACCOUNT_ID      := :old.ACS_FINANCIAL_ACCOUNT_ID;
    ltplOld.ACS_PF_ACCOUNT_ID             := :old.ACS_PF_ACCOUNT_ID;
    ltplOld.ACS_PJ_ACCOUNT_ID             := :old.ACS_PJ_ACCOUNT_ID;
    ltplOld.ACS_TAX_CODE_ID               := :old.ACS_TAX_CODE_ID;
    ltplOld.ASA_INTERVENTION_DETAIL_ID    := :old.ASA_INTERVENTION_DETAIL_ID;
    ltplOld.ASA_RECORD_COMP_ID            := :old.ASA_RECORD_COMP_ID;
    ltplOld.ASA_RECORD_ID                 := :old.ASA_RECORD_ID;
    ltplOld.ASA_RECORD_TASK_ID            := :old.ASA_RECORD_TASK_ID;
    ltplOld.ASA_RECORD_TASK_IMPUT_ID      := :old.ASA_RECORD_TASK_IMPUT_ID;
    ltplOld.A_CONFIRM                     := :old.A_CONFIRM;
    ltplOld.A_DATECRE                     := :old.A_DATECRE;
    ltplOld.A_DATEMOD                     := :old.A_DATEMOD;
    ltplOld.A_IDCRE                       := :old.A_IDCRE;
    ltplOld.A_IDMOD                       := :old.A_IDMOD;
    ltplOld.A_RECLEVEL                    := :old.A_RECLEVEL;
    ltplOld.A_RECSTATUS                   := :old.A_RECSTATUS;
    ltplOld.CML_EVENTS_ID                 := :old.CML_EVENTS_ID;
    ltplOld.CML_POSITION_ID               := :old.CML_POSITION_ID;
    ltplOld.C_DOC_LOT_TYPE                := :old.C_DOC_LOT_TYPE;
    ltplOld.C_DOC_POS_STATUS              := :old.C_DOC_POS_STATUS;
    ltplOld.C_FAM_TRANSACTION_TYP         := :old.C_FAM_TRANSACTION_TYP;
    ltplOld.C_GAUGE_TYPE_POS              := :old.C_GAUGE_TYPE_POS;
    ltplOld.C_INVOICE_EXPIRY_INPUT_TYPE   := :old.C_INVOICE_EXPIRY_INPUT_TYPE;
    ltplOld.C_POS_CREATE_MODE             := :old.C_POS_CREATE_MODE;
    ltplOld.C_POS_DELIVERY_TYP            := :old.C_POS_DELIVERY_TYP;
    ltplOld.DIC_DIC_UNIT_OF_MEASURE_ID    := :old.DIC_DIC_UNIT_OF_MEASURE_ID;
    ltplOld.DIC_IMP_FREE1_ID              := :old.DIC_IMP_FREE1_ID;
    ltplOld.DIC_IMP_FREE2_ID              := :old.DIC_IMP_FREE2_ID;
    ltplOld.DIC_IMP_FREE3_ID              := :old.DIC_IMP_FREE3_ID;
    ltplOld.DIC_IMP_FREE4_ID              := :old.DIC_IMP_FREE4_ID;
    ltplOld.DIC_IMP_FREE5_ID              := :old.DIC_IMP_FREE5_ID;
    ltplOld.DIC_POS_FREE_TABLE_1_ID       := :old.DIC_POS_FREE_TABLE_1_ID;
    ltplOld.DIC_POS_FREE_TABLE_2_ID       := :old.DIC_POS_FREE_TABLE_2_ID;
    ltplOld.DIC_POS_FREE_TABLE_3_ID       := :old.DIC_POS_FREE_TABLE_3_ID;
    ltplOld.DIC_TARIFF_ID                 := :old.DIC_TARIFF_ID;
    ltplOld.DIC_UNIT_OF_MEASURE_ID        := :old.DIC_UNIT_OF_MEASURE_ID;
    ltplOld.DOC_DOCUMENT_ID               := :old.DOC_DOCUMENT_ID;
    ltplOld.DOC_DOC_POSITION_ID           := :old.DOC_DOC_POSITION_ID;
    ltplOld.DOC_DOC_RECORD_ID             := :old.DOC_DOC_RECORD_ID;
    ltplOld.DOC_EXTRACT_COMMISSION_ID     := :old.DOC_EXTRACT_COMMISSION_ID;
    ltplOld.DOC_GAUGE_ID                  := :old.DOC_GAUGE_ID;
    ltplOld.DOC_GAUGE_POSITION_ID         := :old.DOC_GAUGE_POSITION_ID;
    ltplOld.DOC_INVOICE_EXPIRY_DETAIL_ID  := :old.DOC_INVOICE_EXPIRY_DETAIL_ID;
    ltplOld.DOC_INVOICE_EXPIRY_ID         := :old.DOC_INVOICE_EXPIRY_ID;
    ltplOld.DOC_POSITION_ID               := :old.DOC_POSITION_ID;
    ltplOld.DOC_POS_LITIG_ID              := :old.DOC_POS_LITIG_ID;
    ltplOld.DOC_RECORD_ID                 := :old.DOC_RECORD_ID;
    ltplOld.FAL_LOT_ID                    := :old.FAL_LOT_ID;
    ltplOld.FAL_SCHEDULE_STEP_ID          := :old.FAL_SCHEDULE_STEP_ID;
    ltplOld.FAL_SUPPLY_REQUEST_ID         := :old.FAL_SUPPLY_REQUEST_ID;
    ltplOld.FAM_FIXED_ASSETS_ID           := :old.FAM_FIXED_ASSETS_ID;
    ltplOld.GCO_COMPL_DATA_ID             := :old.GCO_COMPL_DATA_ID;
    ltplOld.GCO_GOOD_ID                   := :old.GCO_GOOD_ID;
    ltplOld.GCO_MANUFACTURED_GOOD_ID      := :old.GCO_MANUFACTURED_GOOD_ID;
    ltplOld.HRM_PERSON_ID                 := :old.HRM_PERSON_ID;
    ltplOld.PAC_PERSON_ID                 := :old.PAC_PERSON_ID;
    ltplOld.PAC_REPRESENTATIVE_ID         := :old.PAC_REPRESENTATIVE_ID;
    ltplOld.PAC_REPR_ACI_ID               := :old.PAC_REPR_ACI_ID;
    ltplOld.PAC_REPR_DELIVERY_ID          := :old.PAC_REPR_DELIVERY_ID;
    ltplOld.PAC_THIRD_ACI_ID              := :old.PAC_THIRD_ACI_ID;
    ltplOld.PAC_THIRD_CDA_ID              := :old.PAC_THIRD_CDA_ID;
    ltplOld.PAC_THIRD_DELIVERY_ID         := :old.PAC_THIRD_DELIVERY_ID;
    ltplOld.PAC_THIRD_ID                  := :old.PAC_THIRD_ID;
    ltplOld.PAC_THIRD_TARIFF_ID           := :old.PAC_THIRD_TARIFF_ID;
    ltplOld.PAC_THIRD_VAT_ID              := :old.PAC_THIRD_VAT_ID;
    ltplOld.PC_APPLTXT_ID                 := :old.PC_APPLTXT_ID;
    ltplOld.POS_ADDENDUM_QTY_BALANCED     := :old.POS_ADDENDUM_QTY_BALANCED;
    ltplOld.POS_ADDENDUM_SRC_POS_ID       := :old.POS_ADDENDUM_SRC_POS_ID;
    ltplOld.POS_ADDENDUM_VALUE_QTY        := :old.POS_ADDENDUM_VALUE_QTY;
    ltplOld.POS_BALANCED                  := :old.POS_BALANCED;
    ltplOld.POS_BALANCE_QTY_VALUE         := :old.POS_BALANCE_QTY_VALUE;
    ltplOld.POS_BALANCE_QUANTITY          := :old.POS_BALANCE_QUANTITY;
    ltplOld.POS_BASIS_QUANTITY            := :old.POS_BASIS_QUANTITY;
    ltplOld.POS_BASIS_QUANTITY_SU         := :old.POS_BASIS_QUANTITY_SU;
    ltplOld.POS_BODY_TEXT                 := :old.POS_BODY_TEXT;
    ltplOld.POS_BUDGET_ACCEPT_DATE        := :old.POS_BUDGET_ACCEPT_DATE;
    ltplOld.POS_BUDGET_COMMENT            := :old.POS_BUDGET_COMMENT;
    ltplOld.POS_BUDGET_EXCEEDED           := :old.POS_BUDGET_EXCEEDED;
    ltplOld.POS_BUDGET_USER_ID            := :old.POS_BUDGET_USER_ID;
    ltplOld.POS_CALC_BUDGET_AMOUNT_MB     := :old.POS_CALC_BUDGET_AMOUNT_MB;
    ltplOld.POS_CHARGE_AMOUNT             := :old.POS_CHARGE_AMOUNT;
    ltplOld.POS_CONVERT_FACTOR            := :old.POS_CONVERT_FACTOR;
    ltplOld.POS_CONVERT_FACTOR2           := :old.POS_CONVERT_FACTOR2;
    ltplOld.POS_CREATE_MAT                := :old.POS_CREATE_MAT;
    ltplOld.POS_CREATE_POSITION_CHARGE    := :old.POS_CREATE_POSITION_CHARGE;
    ltplOld.POS_CUMULATIVE_CHARGE         := :old.POS_CUMULATIVE_CHARGE;
    ltplOld.POS_DATE_1                    := :old.POS_DATE_1;
    ltplOld.POS_DATE_2                    := :old.POS_DATE_2;
    ltplOld.POS_DATE_3                    := :old.POS_DATE_3;
    ltplOld.POS_DATE_BALANCED             := :old.POS_DATE_BALANCED;
    ltplOld.POS_DATE_DELIVERY             := :old.POS_DATE_DELIVERY;
    ltplOld.POS_DATE_PARTNER_DOCUMENT     := :old.POS_DATE_PARTNER_DOCUMENT;
    ltplOld.POS_DECIMAL_1                 := :old.POS_DECIMAL_1;
    ltplOld.POS_DECIMAL_2                 := :old.POS_DECIMAL_2;
    ltplOld.POS_DECIMAL_3                 := :old.POS_DECIMAL_3;
    ltplOld.POS_DISCOUNT_AMOUNT           := :old.POS_DISCOUNT_AMOUNT;
    ltplOld.POS_DISCOUNT_RATE             := :old.POS_DISCOUNT_RATE;
    ltplOld.POS_DISCOUNT_UNIT_VALUE       := :old.POS_DISCOUNT_UNIT_VALUE;
    ltplOld.POS_EAN_CODE                  := :old.POS_EAN_CODE;
    ltplOld.POS_EAN_UCC14_CODE            := :old.POS_EAN_UCC14_CODE;
    ltplOld.POS_EFFECTIVE_DIC_TARIFF_ID   := :old.POS_EFFECTIVE_DIC_TARIFF_ID;
    ltplOld.POS_EFFECT_BUDGET_AMOUNT_MB   := :old.POS_EFFECT_BUDGET_AMOUNT_MB;
    ltplOld.POS_FINAL_QUANTITY            := :old.POS_FINAL_QUANTITY;
    ltplOld.POS_FINAL_QUANTITY_SU         := :old.POS_FINAL_QUANTITY_SU;
    ltplOld.POS_FLAT_RATE                 := :old.POS_FLAT_RATE;
    ltplOld.POS_FREE_DESCRIPTION          := :old.POS_FREE_DESCRIPTION;
    ltplOld.POS_GENERATE_MOVEMENT         := :old.POS_GENERATE_MOVEMENT;
    ltplOld.POS_GENERATE_SUBCO_COMP_MVT   := :old.POS_GENERATE_SUBCO_COMP_MVT;
    ltplOld.POS_GEN_CML_EVENTS            := :old.POS_GEN_CML_EVENTS;
    ltplOld.POS_GROSS_UNIT_VALUE          := :old.POS_GROSS_UNIT_VALUE;
    ltplOld.POS_GROSS_UNIT_VALUE2         := :old.POS_GROSS_UNIT_VALUE2;
    ltplOld.POS_GROSS_UNIT_VALUE_INCL     := :old.POS_GROSS_UNIT_VALUE_INCL;
    ltplOld.POS_GROSS_UNIT_VALUE_INCL_SU  := :old.POS_GROSS_UNIT_VALUE_INCL_SU;
    ltplOld.POS_GROSS_UNIT_VALUE_SU       := :old.POS_GROSS_UNIT_VALUE_SU;
    ltplOld.POS_GROSS_VALUE               := :old.POS_GROSS_VALUE;
    ltplOld.POS_GROSS_VALUE_B             := :old.POS_GROSS_VALUE_B;
    ltplOld.POS_GROSS_VALUE_E             := :old.POS_GROSS_VALUE_E;
    ltplOld.POS_GROSS_VALUE_INCL          := :old.POS_GROSS_VALUE_INCL;
    ltplOld.POS_GROSS_VALUE_INCL_B        := :old.POS_GROSS_VALUE_INCL_B;
    ltplOld.POS_GROSS_VALUE_INCL_E        := :old.POS_GROSS_VALUE_INCL_E;
    ltplOld.POS_GROSS_VALUE_INCL_V        := :old.POS_GROSS_VALUE_INCL_V;
    ltplOld.POS_GROSS_VALUE_V             := :old.POS_GROSS_VALUE_V;
    ltplOld.POS_GROSS_WEIGHT              := :old.POS_GROSS_WEIGHT;
    ltplOld.POS_HIBC_PRIMARY_CODE         := :old.POS_HIBC_PRIMARY_CODE;
    ltplOld.POS_IMF_NUMBER_2              := :old.POS_IMF_NUMBER_2;
    ltplOld.POS_IMF_NUMBER_3              := :old.POS_IMF_NUMBER_3;
    ltplOld.POS_IMF_NUMBER_4              := :old.POS_IMF_NUMBER_4;
    ltplOld.POS_IMF_NUMBER_5              := :old.POS_IMF_NUMBER_5;
    ltplOld.POS_IMF_TEXT_1                := :old.POS_IMF_TEXT_1;
    ltplOld.POS_IMF_TEXT_2                := :old.POS_IMF_TEXT_2;
    ltplOld.POS_IMF_TEXT_3                := :old.POS_IMF_TEXT_3;
    ltplOld.POS_IMF_TEXT_4                := :old.POS_IMF_TEXT_4;
    ltplOld.POS_IMF_TEXT_5                := :old.POS_IMF_TEXT_5;
    ltplOld.POS_IMPUTATION                := :old.POS_IMPUTATION;
    ltplOld.POS_INCLUDE_TAX_TARIFF        := :old.POS_INCLUDE_TAX_TARIFF;
    ltplOld.POS_INTERMEDIATE_QUANTITY     := :old.POS_INTERMEDIATE_QUANTITY;
    ltplOld.POS_INTERMEDIATE_QUANTITY_SU  := :old.POS_INTERMEDIATE_QUANTITY_SU;
    ltplOld.POS_INVOICE_EXPIRY            := :old.POS_INVOICE_EXPIRY;
    ltplOld.POS_LONG_DESCRIPTION          := :old.POS_LONG_DESCRIPTION;
    ltplOld.POS_MODIFY_RATE               := :old.POS_MODIFY_RATE;
    ltplOld.POS_NET_TARIFF                := :old.POS_NET_TARIFF;
    ltplOld.POS_NET_UNIT_VALUE            := :old.POS_NET_UNIT_VALUE;
    ltplOld.POS_NET_UNIT_VALUE_INCL       := :old.POS_NET_UNIT_VALUE_INCL;
    ltplOld.POS_NET_VALUE_EXCL            := :old.POS_NET_VALUE_EXCL;
    ltplOld.POS_NET_VALUE_EXCL_B          := :old.POS_NET_VALUE_EXCL_B;
    ltplOld.POS_NET_VALUE_EXCL_E          := :old.POS_NET_VALUE_EXCL_E;
    ltplOld.POS_NET_VALUE_EXCL_V          := :old.POS_NET_VALUE_EXCL_V;
    ltplOld.POS_NET_VALUE_INCL            := :old.POS_NET_VALUE_INCL;
    ltplOld.POS_NET_VALUE_INCL_B          := :old.POS_NET_VALUE_INCL_B;
    ltplOld.POS_NET_VALUE_INCL_E          := :old.POS_NET_VALUE_INCL_E;
    ltplOld.POS_NET_VALUE_INCL_V          := :old.POS_NET_VALUE_INCL_V;
    ltplOld.POS_NET_WEIGHT                := :old.POS_NET_WEIGHT;
    ltplOld.POS_NOM_TEXT                  := :old.POS_NOM_TEXT;
    ltplOld.POS_NUMBER                    := :old.POS_NUMBER;
    ltplOld.POS_PARENT_CHARGE             := :old.POS_PARENT_CHARGE;
    ltplOld.POS_PARTNER_NUMBER            := :old.POS_PARTNER_NUMBER;
    ltplOld.POS_PARTNER_POS_NUMBER        := :old.POS_PARTNER_POS_NUMBER;
    ltplOld.POS_PARTNER_REFERENCE         := :old.POS_PARTNER_REFERENCE;
    ltplOld.POS_PRICE_TRANSFERED          := :old.POS_PRICE_TRANSFERED;
    ltplOld.POS_QUANTITY_BALANCED         := :old.POS_QUANTITY_BALANCED;
    ltplOld.POS_RATE_FACTOR               := :old.POS_RATE_FACTOR;
    ltplOld.POS_RECALC_AMOUNTS            := :old.POS_RECALC_AMOUNTS;
    ltplOld.POS_REFERENCE                 := :old.POS_REFERENCE;
    ltplOld.POS_REF_UNIT_VALUE            := :old.POS_REF_UNIT_VALUE;
    ltplOld.POS_SECONDARY_REFERENCE       := :old.POS_SECONDARY_REFERENCE;
    ltplOld.POS_SHORT_DESCRIPTION         := :old.POS_SHORT_DESCRIPTION;
    ltplOld.POS_SPECIAL_TARIFF            := :old.POS_SPECIAL_TARIFF;
    ltplOld.POS_STOCK_OUTAGE              := :old.POS_STOCK_OUTAGE;
    ltplOld.POS_TARIFF_DATE               := :old.POS_TARIFF_DATE;
    ltplOld.POS_TARIFF_INITIALIZED        := :old.POS_TARIFF_INITIALIZED;
    ltplOld.POS_TARIFF_SET                := :old.POS_TARIFF_SET;
    ltplOld.POS_TARIFF_UNIT               := :old.POS_TARIFF_UNIT;
    ltplOld.POS_TEXT_1                    := :old.POS_TEXT_1;
    ltplOld.POS_TEXT_2                    := :old.POS_TEXT_2;
    ltplOld.POS_TEXT_3                    := :old.POS_TEXT_3;
    ltplOld.POS_TRANSFERT_PROPRIETOR      := :old.POS_TRANSFERT_PROPRIETOR;
    ltplOld.POS_UNIT_COST_PRICE           := :old.POS_UNIT_COST_PRICE;
    ltplOld.POS_UPDATE_ATTRIB             := :old.POS_UPDATE_ATTRIB;
    ltplOld.POS_UPDATE_OP                 := :old.POS_UPDATE_OP;
    ltplOld.POS_UPDATE_POSITION_CHARGE    := :old.POS_UPDATE_POSITION_CHARGE;
    ltplOld.POS_UPDATE_QTY_PRICE          := :old.POS_UPDATE_QTY_PRICE;
    ltplOld.POS_UPDATE_TARIFF             := :old.POS_UPDATE_TARIFF;
    ltplOld.POS_UTIL_COEFF                := :old.POS_UTIL_COEFF;
    ltplOld.POS_VALUE_QUANTITY            := :old.POS_VALUE_QUANTITY;
    ltplOld.POS_VAT_AMOUNT                := :old.POS_VAT_AMOUNT;
    ltplOld.POS_VAT_AMOUNT_E              := :old.POS_VAT_AMOUNT_E;
    ltplOld.POS_VAT_AMOUNT_V              := :old.POS_VAT_AMOUNT_V;
    ltplOld.POS_VAT_BASE_AMOUNT           := :old.POS_VAT_BASE_AMOUNT;
    ltplOld.POS_VAT_DEDUCTIBLE_RATE       := :old.POS_VAT_DEDUCTIBLE_RATE;
    ltplOld.POS_VAT_LIABLED_AMOUNT        := :old.POS_VAT_LIABLED_AMOUNT;
    ltplOld.POS_VAT_LIABLED_RATE          := :old.POS_VAT_LIABLED_RATE;
    ltplOld.POS_VAT_RATE                  := :old.POS_VAT_RATE;
    ltplOld.POS_VAT_TOTAL_AMOUNT          := :old.POS_VAT_TOTAL_AMOUNT;
    ltplOld.POS_VAT_TOTAL_AMOUNT_B        := :old.POS_VAT_TOTAL_AMOUNT_B;
    ltplOld.POS_VAT_TOTAL_AMOUNT_V        := :old.POS_VAT_TOTAL_AMOUNT_V;
    ltplOld.STM_LOCATION_ID               := :old.STM_LOCATION_ID;
    ltplOld.STM_MOVEMENT_KIND_ID          := :old.STM_MOVEMENT_KIND_ID;
    ltplOld.STM_STM_LOCATION_ID           := :old.STM_STM_LOCATION_ID;
    ltplOld.STM_STM_STOCK_ID              := :old.STM_STM_STOCK_ID;
    ltplOld.STM_STOCK_ID                  := :old.STM_STOCK_ID;
    -- Journaliser position
    DOC_JOURNAL_FUNCTIONS.JournalizePosition(aCode => 'DELETE', aOldPos => ltplOld, aNewPos => ltplOld);
  end if;
end DOC_POS_AD_JOURNAL;

ALTER TRIGGER "C_ITX"."DOC_POS_AD_JOURNAL" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_AD_VAT"
  after delete
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour du récapitulatif TVA des position
* @author Fabrice Perotto - Joffroy Christen
* @version 10
* @lastUpdate 03.11.2010
*/
begin
  if :old.C_DOC_POS_STATUS <> '05' then
    -- Retrait du récapitulatif TVA des position
    DOC_PRC_VAT.UpdatePositionVat(:old.DOC_DOCUMENT_ID
                                , :old.C_GAUGE_TYPE_POS
                                , :old.ACS_TAX_CODE_ID
                                , :old.POS_NET_VALUE_EXCL
                                , :old.POS_NET_VALUE_EXCL_B
                                , :old.POS_NET_VALUE_EXCL_V
                                , :old.POS_VAT_RATE
                                , :old.POS_VAT_TOTAL_AMOUNT
                                , :old.POS_VAT_TOTAL_AMOUNT_B
                                , :old.POS_VAT_TOTAL_AMOUNT_V
                                , :old.POS_VAT_AMOUNT
                                , :old.POS_VAT_BASE_AMOUNT
                                , :old.POS_VAT_AMOUNT_V
                                , -1
                                 );
  end if;
-- Si on passe dans cette exception, cela signifie que l'effacement est
-- fait à partir d'un trigger sur DOC_DOCUMENT
exception
  when ex.TABLE_MUTATING then
    null;
end DOC_POS_AD_VAT;

ALTER TRIGGER "C_ITX"."DOC_POS_AD_VAT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_AI_JOURNAL"
  after insert
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Journaliser la position
*
* @author Nuno Gomes Vieira
* @created 11/10/2005
* @version 2003
*/
declare
  ltplNew       DOC_POSITION%rowtype;
  lvJournalCode DOC_JOURNAL_DETAIL.C_DOC_JOURNAL_DETAIL%type;
begin
  if DOC_JOURNAL_FUNCTIONS.MustPosJournalize(:new.DOC_DOCUMENT_ID
                                           , :new.DOC_GAUGE_ID
                                           , :new.C_GAUGE_TYPE_POS
                                           , :new.DOC_GAUGE_POSITION_ID
                                           , :new.DOC_DOC_POSITION_ID
                                            ) = 1 then
    -- Assignation de TOUS les champs de la table DOC_POSITION
    --   Champs triés par ordre alphabetique
    ltplNew.ACS_CDA_ACCOUNT_ID            := :new.ACS_CDA_ACCOUNT_ID;
    ltplNew.ACS_CPN_ACCOUNT_ID            := :new.ACS_CPN_ACCOUNT_ID;
    ltplNew.ACS_DIVISION_ACCOUNT_ID       := :new.ACS_DIVISION_ACCOUNT_ID;
    ltplNew.ACS_FINANCIAL_ACCOUNT_ID      := :new.ACS_FINANCIAL_ACCOUNT_ID;
    ltplNew.ACS_PF_ACCOUNT_ID             := :new.ACS_PF_ACCOUNT_ID;
    ltplNew.ACS_PJ_ACCOUNT_ID             := :new.ACS_PJ_ACCOUNT_ID;
    ltplNew.ACS_TAX_CODE_ID               := :new.ACS_TAX_CODE_ID;
    ltplNew.ASA_INTERVENTION_DETAIL_ID    := :new.ASA_INTERVENTION_DETAIL_ID;
    ltplNew.ASA_RECORD_COMP_ID            := :new.ASA_RECORD_COMP_ID;
    ltplNew.ASA_RECORD_ID                 := :new.ASA_RECORD_ID;
    ltplNew.ASA_RECORD_TASK_ID            := :new.ASA_RECORD_TASK_ID;
    ltplNew.ASA_RECORD_TASK_IMPUT_ID      := :new.ASA_RECORD_TASK_IMPUT_ID;
    ltplNew.A_CONFIRM                     := :new.A_CONFIRM;
    ltplNew.A_DATECRE                     := :new.A_DATECRE;
    ltplNew.A_DATEMOD                     := :new.A_DATEMOD;
    ltplNew.A_IDCRE                       := :new.A_IDCRE;
    ltplNew.A_IDMOD                       := :new.A_IDMOD;
    ltplNew.A_RECLEVEL                    := :new.A_RECLEVEL;
    ltplNew.A_RECSTATUS                   := :new.A_RECSTATUS;
    ltplNew.CML_EVENTS_ID                 := :new.CML_EVENTS_ID;
    ltplNew.CML_POSITION_ID               := :new.CML_POSITION_ID;
    ltplNew.C_DOC_LOT_TYPE                := :new.C_DOC_LOT_TYPE;
    ltplNew.C_DOC_POS_STATUS              := :new.C_DOC_POS_STATUS;
    ltplNew.C_FAM_TRANSACTION_TYP         := :new.C_FAM_TRANSACTION_TYP;
    ltplNew.C_GAUGE_TYPE_POS              := :new.C_GAUGE_TYPE_POS;
    ltplNew.C_INVOICE_EXPIRY_INPUT_TYPE   := :new.C_INVOICE_EXPIRY_INPUT_TYPE;
    ltplNew.C_POS_CREATE_MODE             := :new.C_POS_CREATE_MODE;
    ltplNew.C_POS_DELIVERY_TYP            := :new.C_POS_DELIVERY_TYP;
    ltplNew.DIC_DIC_UNIT_OF_MEASURE_ID    := :new.DIC_DIC_UNIT_OF_MEASURE_ID;
    ltplNew.DIC_IMP_FREE1_ID              := :new.DIC_IMP_FREE1_ID;
    ltplNew.DIC_IMP_FREE2_ID              := :new.DIC_IMP_FREE2_ID;
    ltplNew.DIC_IMP_FREE3_ID              := :new.DIC_IMP_FREE3_ID;
    ltplNew.DIC_IMP_FREE4_ID              := :new.DIC_IMP_FREE4_ID;
    ltplNew.DIC_IMP_FREE5_ID              := :new.DIC_IMP_FREE5_ID;
    ltplNew.DIC_POS_FREE_TABLE_1_ID       := :new.DIC_POS_FREE_TABLE_1_ID;
    ltplNew.DIC_POS_FREE_TABLE_2_ID       := :new.DIC_POS_FREE_TABLE_2_ID;
    ltplNew.DIC_POS_FREE_TABLE_3_ID       := :new.DIC_POS_FREE_TABLE_3_ID;
    ltplNew.DIC_TARIFF_ID                 := :new.DIC_TARIFF_ID;
    ltplNew.DIC_UNIT_OF_MEASURE_ID        := :new.DIC_UNIT_OF_MEASURE_ID;
    ltplNew.DOC_DOCUMENT_ID               := :new.DOC_DOCUMENT_ID;
    ltplNew.DOC_DOC_POSITION_ID           := :new.DOC_DOC_POSITION_ID;
    ltplNew.DOC_DOC_RECORD_ID             := :new.DOC_DOC_RECORD_ID;
    ltplNew.DOC_EXTRACT_COMMISSION_ID     := :new.DOC_EXTRACT_COMMISSION_ID;
    ltplNew.DOC_GAUGE_ID                  := :new.DOC_GAUGE_ID;
    ltplNew.DOC_GAUGE_POSITION_ID         := :new.DOC_GAUGE_POSITION_ID;
    ltplNew.DOC_INVOICE_EXPIRY_DETAIL_ID  := :new.DOC_INVOICE_EXPIRY_DETAIL_ID;
    ltplNew.DOC_INVOICE_EXPIRY_ID         := :new.DOC_INVOICE_EXPIRY_ID;
    ltplNew.DOC_POSITION_ID               := :new.DOC_POSITION_ID;
    ltplNew.DOC_POS_LITIG_ID              := :new.DOC_POS_LITIG_ID;
    ltplNew.DOC_RECORD_ID                 := :new.DOC_RECORD_ID;
    ltplNew.FAL_LOT_ID                    := :new.FAL_LOT_ID;
    ltplNew.FAL_SCHEDULE_STEP_ID          := :new.FAL_SCHEDULE_STEP_ID;
    ltplNew.FAL_SUPPLY_REQUEST_ID         := :new.FAL_SUPPLY_REQUEST_ID;
    ltplNew.FAM_FIXED_ASSETS_ID           := :new.FAM_FIXED_ASSETS_ID;
    ltplNew.GCO_COMPL_DATA_ID             := :new.GCO_COMPL_DATA_ID;
    ltplNew.GCO_GOOD_ID                   := :new.GCO_GOOD_ID;
    ltplNew.GCO_MANUFACTURED_GOOD_ID      := :new.GCO_MANUFACTURED_GOOD_ID;
    ltplNew.HRM_PERSON_ID                 := :new.HRM_PERSON_ID;
    ltplNew.PAC_PERSON_ID                 := :new.PAC_PERSON_ID;
    ltplNew.PAC_REPRESENTATIVE_ID         := :new.PAC_REPRESENTATIVE_ID;
    ltplNew.PAC_REPR_ACI_ID               := :new.PAC_REPR_ACI_ID;
    ltplNew.PAC_REPR_DELIVERY_ID          := :new.PAC_REPR_DELIVERY_ID;
    ltplNew.PAC_THIRD_ACI_ID              := :new.PAC_THIRD_ACI_ID;
    ltplNew.PAC_THIRD_CDA_ID              := :new.PAC_THIRD_CDA_ID;
    ltplNew.PAC_THIRD_DELIVERY_ID         := :new.PAC_THIRD_DELIVERY_ID;
    ltplNew.PAC_THIRD_ID                  := :new.PAC_THIRD_ID;
    ltplNew.PAC_THIRD_TARIFF_ID           := :new.PAC_THIRD_TARIFF_ID;
    ltplNew.PAC_THIRD_VAT_ID              := :new.PAC_THIRD_VAT_ID;
    ltplNew.PC_APPLTXT_ID                 := :new.PC_APPLTXT_ID;
    ltplNew.POS_ADDENDUM_QTY_BALANCED     := :new.POS_ADDENDUM_QTY_BALANCED;
    ltplNew.POS_ADDENDUM_SRC_POS_ID       := :new.POS_ADDENDUM_SRC_POS_ID;
    ltplNew.POS_ADDENDUM_VALUE_QTY        := :new.POS_ADDENDUM_VALUE_QTY;
    ltplNew.POS_BALANCED                  := :new.POS_BALANCED;
    ltplNew.POS_BALANCE_QTY_VALUE         := :new.POS_BALANCE_QTY_VALUE;
    ltplNew.POS_BALANCE_QUANTITY          := :new.POS_BALANCE_QUANTITY;
    ltplNew.POS_BASIS_QUANTITY            := :new.POS_BASIS_QUANTITY;
    ltplNew.POS_BASIS_QUANTITY_SU         := :new.POS_BASIS_QUANTITY_SU;
    ltplNew.POS_BODY_TEXT                 := :new.POS_BODY_TEXT;
    ltplNew.POS_BUDGET_ACCEPT_DATE        := :new.POS_BUDGET_ACCEPT_DATE;
    ltplNew.POS_BUDGET_COMMENT            := :new.POS_BUDGET_COMMENT;
    ltplNew.POS_BUDGET_EXCEEDED           := :new.POS_BUDGET_EXCEEDED;
    ltplNew.POS_BUDGET_USER_ID            := :new.POS_BUDGET_USER_ID;
    ltplNew.POS_CALC_BUDGET_AMOUNT_MB     := :new.POS_CALC_BUDGET_AMOUNT_MB;
    ltplNew.POS_CHARGE_AMOUNT             := :new.POS_CHARGE_AMOUNT;
    ltplNew.POS_CONVERT_FACTOR            := :new.POS_CONVERT_FACTOR;
    ltplNew.POS_CONVERT_FACTOR2           := :new.POS_CONVERT_FACTOR2;
    ltplNew.POS_CREATE_MAT                := :new.POS_CREATE_MAT;
    ltplNew.POS_CREATE_POSITION_CHARGE    := :new.POS_CREATE_POSITION_CHARGE;
    ltplNew.POS_CUMULATIVE_CHARGE         := :new.POS_CUMULATIVE_CHARGE;
    ltplNew.POS_DATE_1                    := :new.POS_DATE_1;
    ltplNew.POS_DATE_2                    := :new.POS_DATE_2;
    ltplNew.POS_DATE_3                    := :new.POS_DATE_3;
    ltplNew.POS_DATE_BALANCED             := :new.POS_DATE_BALANCED;
    ltplNew.POS_DATE_DELIVERY             := :new.POS_DATE_DELIVERY;
    ltplNew.POS_DATE_PARTNER_DOCUMENT     := :new.POS_DATE_PARTNER_DOCUMENT;
    ltplNew.POS_DECIMAL_1                 := :new.POS_DECIMAL_1;
    ltplNew.POS_DECIMAL_2                 := :new.POS_DECIMAL_2;
    ltplNew.POS_DECIMAL_3                 := :new.POS_DECIMAL_3;
    ltplNew.POS_DISCOUNT_AMOUNT           := :new.POS_DISCOUNT_AMOUNT;
    ltplNew.POS_DISCOUNT_RATE             := :new.POS_DISCOUNT_RATE;
    ltplNew.POS_DISCOUNT_UNIT_VALUE       := :new.POS_DISCOUNT_UNIT_VALUE;
    ltplNew.POS_EAN_CODE                  := :new.POS_EAN_CODE;
    ltplNew.POS_EAN_UCC14_CODE            := :new.POS_EAN_UCC14_CODE;
    ltplNew.POS_EFFECTIVE_DIC_TARIFF_ID   := :new.POS_EFFECTIVE_DIC_TARIFF_ID;
    ltplNew.POS_EFFECT_BUDGET_AMOUNT_MB   := :new.POS_EFFECT_BUDGET_AMOUNT_MB;
    ltplNew.POS_FINAL_QUANTITY            := :new.POS_FINAL_QUANTITY;
    ltplNew.POS_FINAL_QUANTITY_SU         := :new.POS_FINAL_QUANTITY_SU;
    ltplNew.POS_FLAT_RATE                 := :new.POS_FLAT_RATE;
    ltplNew.POS_FREE_DESCRIPTION          := :new.POS_FREE_DESCRIPTION;
    ltplNew.POS_GENERATE_MOVEMENT         := :new.POS_GENERATE_MOVEMENT;
    ltplNew.POS_GENERATE_SUBCO_COMP_MVT   := :new.POS_GENERATE_SUBCO_COMP_MVT;
    ltplNew.POS_GEN_CML_EVENTS            := :new.POS_GEN_CML_EVENTS;
    ltplNew.POS_GROSS_UNIT_VALUE          := :new.POS_GROSS_UNIT_VALUE;
    ltplNew.POS_GROSS_UNIT_VALUE2         := :new.POS_GROSS_UNIT_VALUE2;
    ltplNew.POS_GROSS_UNIT_VALUE_INCL     := :new.POS_GROSS_UNIT_VALUE_INCL;
    ltplNew.POS_GROSS_UNIT_VALUE_INCL_SU  := :new.POS_GROSS_UNIT_VALUE_INCL_SU;
    ltplNew.POS_GROSS_UNIT_VALUE_SU       := :new.POS_GROSS_UNIT_VALUE_SU;
    ltplNew.POS_GROSS_VALUE               := :new.POS_GROSS_VALUE;
    ltplNew.POS_GROSS_VALUE_B             := :new.POS_GROSS_VALUE_B;
    ltplNew.POS_GROSS_VALUE_E             := :new.POS_GROSS_VALUE_E;
    ltplNew.POS_GROSS_VALUE_INCL          := :new.POS_GROSS_VALUE_INCL;
    ltplNew.POS_GROSS_VALUE_INCL_B        := :new.POS_GROSS_VALUE_INCL_B;
    ltplNew.POS_GROSS_VALUE_INCL_E        := :new.POS_GROSS_VALUE_INCL_E;
    ltplNew.POS_GROSS_VALUE_INCL_V        := :new.POS_GROSS_VALUE_INCL_V;
    ltplNew.POS_GROSS_VALUE_V             := :new.POS_GROSS_VALUE_V;
    ltplNew.POS_GROSS_WEIGHT              := :new.POS_GROSS_WEIGHT;
    ltplNew.POS_HIBC_PRIMARY_CODE         := :new.POS_HIBC_PRIMARY_CODE;
    ltplNew.POS_IMF_NUMBER_2              := :new.POS_IMF_NUMBER_2;
    ltplNew.POS_IMF_NUMBER_3              := :new.POS_IMF_NUMBER_3;
    ltplNew.POS_IMF_NUMBER_4              := :new.POS_IMF_NUMBER_4;
    ltplNew.POS_IMF_NUMBER_5              := :new.POS_IMF_NUMBER_5;
    ltplNew.POS_IMF_TEXT_1                := :new.POS_IMF_TEXT_1;
    ltplNew.POS_IMF_TEXT_2                := :new.POS_IMF_TEXT_2;
    ltplNew.POS_IMF_TEXT_3                := :new.POS_IMF_TEXT_3;
    ltplNew.POS_IMF_TEXT_4                := :new.POS_IMF_TEXT_4;
    ltplNew.POS_IMF_TEXT_5                := :new.POS_IMF_TEXT_5;
    ltplNew.POS_IMPUTATION                := :new.POS_IMPUTATION;
    ltplNew.POS_INCLUDE_TAX_TARIFF        := :new.POS_INCLUDE_TAX_TARIFF;
    ltplNew.POS_INTERMEDIATE_QUANTITY     := :new.POS_INTERMEDIATE_QUANTITY;
    ltplNew.POS_INTERMEDIATE_QUANTITY_SU  := :new.POS_INTERMEDIATE_QUANTITY_SU;
    ltplNew.POS_INVOICE_EXPIRY            := :new.POS_INVOICE_EXPIRY;
    ltplNew.POS_LONG_DESCRIPTION          := :new.POS_LONG_DESCRIPTION;
    ltplNew.POS_MODIFY_RATE               := :new.POS_MODIFY_RATE;
    ltplNew.POS_NET_TARIFF                := :new.POS_NET_TARIFF;
    ltplNew.POS_NET_UNIT_VALUE            := :new.POS_NET_UNIT_VALUE;
    ltplNew.POS_NET_UNIT_VALUE_INCL       := :new.POS_NET_UNIT_VALUE_INCL;
    ltplNew.POS_NET_VALUE_EXCL            := :new.POS_NET_VALUE_EXCL;
    ltplNew.POS_NET_VALUE_EXCL_B          := :new.POS_NET_VALUE_EXCL_B;
    ltplNew.POS_NET_VALUE_EXCL_E          := :new.POS_NET_VALUE_EXCL_E;
    ltplNew.POS_NET_VALUE_EXCL_V          := :new.POS_NET_VALUE_EXCL_V;
    ltplNew.POS_NET_VALUE_INCL            := :new.POS_NET_VALUE_INCL;
    ltplNew.POS_NET_VALUE_INCL_B          := :new.POS_NET_VALUE_INCL_B;
    ltplNew.POS_NET_VALUE_INCL_E          := :new.POS_NET_VALUE_INCL_E;
    ltplNew.POS_NET_VALUE_INCL_V          := :new.POS_NET_VALUE_INCL_V;
    ltplNew.POS_NET_WEIGHT                := :new.POS_NET_WEIGHT;
    ltplNew.POS_NOM_TEXT                  := :new.POS_NOM_TEXT;
    ltplNew.POS_NUMBER                    := :new.POS_NUMBER;
    ltplNew.POS_PARENT_CHARGE             := :new.POS_PARENT_CHARGE;
    ltplNew.POS_PARTNER_NUMBER            := :new.POS_PARTNER_NUMBER;
    ltplNew.POS_PARTNER_POS_NUMBER        := :new.POS_PARTNER_POS_NUMBER;
    ltplNew.POS_PARTNER_REFERENCE         := :new.POS_PARTNER_REFERENCE;
    ltplNew.POS_PRICE_TRANSFERED          := :new.POS_PRICE_TRANSFERED;
    ltplNew.POS_QUANTITY_BALANCED         := :new.POS_QUANTITY_BALANCED;
    ltplNew.POS_RATE_FACTOR               := :new.POS_RATE_FACTOR;
    ltplNew.POS_RECALC_AMOUNTS            := :new.POS_RECALC_AMOUNTS;
    ltplNew.POS_REFERENCE                 := :new.POS_REFERENCE;
    ltplNew.POS_REF_UNIT_VALUE            := :new.POS_REF_UNIT_VALUE;
    ltplNew.POS_SECONDARY_REFERENCE       := :new.POS_SECONDARY_REFERENCE;
    ltplNew.POS_SHORT_DESCRIPTION         := :new.POS_SHORT_DESCRIPTION;
    ltplNew.POS_SPECIAL_TARIFF            := :new.POS_SPECIAL_TARIFF;
    ltplNew.POS_STOCK_OUTAGE              := :new.POS_STOCK_OUTAGE;
    ltplNew.POS_TARIFF_DATE               := :new.POS_TARIFF_DATE;
    ltplNew.POS_TARIFF_INITIALIZED        := :new.POS_TARIFF_INITIALIZED;
    ltplNew.POS_TARIFF_SET                := :new.POS_TARIFF_SET;
    ltplNew.POS_TARIFF_UNIT               := :new.POS_TARIFF_UNIT;
    ltplNew.POS_TEXT_1                    := :new.POS_TEXT_1;
    ltplNew.POS_TEXT_2                    := :new.POS_TEXT_2;
    ltplNew.POS_TEXT_3                    := :new.POS_TEXT_3;
    ltplNew.POS_TRANSFERT_PROPRIETOR      := :new.POS_TRANSFERT_PROPRIETOR;
    ltplNew.POS_UNIT_COST_PRICE           := :new.POS_UNIT_COST_PRICE;
    ltplNew.POS_UPDATE_ATTRIB             := :new.POS_UPDATE_ATTRIB;
    ltplNew.POS_UPDATE_OP                 := :new.POS_UPDATE_OP;
    ltplNew.POS_UPDATE_POSITION_CHARGE    := :new.POS_UPDATE_POSITION_CHARGE;
    ltplNew.POS_UPDATE_QTY_PRICE          := :new.POS_UPDATE_QTY_PRICE;
    ltplNew.POS_UPDATE_TARIFF             := :new.POS_UPDATE_TARIFF;
    ltplNew.POS_UTIL_COEFF                := :new.POS_UTIL_COEFF;
    ltplNew.POS_VALUE_QUANTITY            := :new.POS_VALUE_QUANTITY;
    ltplNew.POS_VAT_AMOUNT                := :new.POS_VAT_AMOUNT;
    ltplNew.POS_VAT_AMOUNT_E              := :new.POS_VAT_AMOUNT_E;
    ltplNew.POS_VAT_AMOUNT_V              := :new.POS_VAT_AMOUNT_V;
    ltplNew.POS_VAT_BASE_AMOUNT           := :new.POS_VAT_BASE_AMOUNT;
    ltplNew.POS_VAT_DEDUCTIBLE_RATE       := :new.POS_VAT_DEDUCTIBLE_RATE;
    ltplNew.POS_VAT_LIABLED_AMOUNT        := :new.POS_VAT_LIABLED_AMOUNT;
    ltplNew.POS_VAT_LIABLED_RATE          := :new.POS_VAT_LIABLED_RATE;
    ltplNew.POS_VAT_RATE                  := :new.POS_VAT_RATE;
    ltplNew.POS_VAT_TOTAL_AMOUNT          := :new.POS_VAT_TOTAL_AMOUNT;
    ltplNew.POS_VAT_TOTAL_AMOUNT_B        := :new.POS_VAT_TOTAL_AMOUNT_B;
    ltplNew.POS_VAT_TOTAL_AMOUNT_V        := :new.POS_VAT_TOTAL_AMOUNT_V;
    ltplNew.STM_LOCATION_ID               := :new.STM_LOCATION_ID;
    ltplNew.STM_MOVEMENT_KIND_ID          := :new.STM_MOVEMENT_KIND_ID;
    ltplNew.STM_STM_LOCATION_ID           := :new.STM_STM_LOCATION_ID;
    ltplNew.STM_STM_STOCK_ID              := :new.STM_STM_STOCK_ID;
    ltplNew.STM_STOCK_ID                  := :new.STM_STOCK_ID;

    -- si position crée par décharge
    if substr(:new.C_POS_CREATE_MODE, 1, 1) = '3' then
      lvJournalCode  := 'INS_DISCH';
    else
      lvJournalCode  := 'INSERT';
    end if;

    -- Journaliser position
    DOC_JOURNAL_FUNCTIONS.JournalizePosition(aCode => lvJournalCode, aOldPos => ltplNew, aNewPos => ltplNew);
  end if;
end DOC_POS_AI_JOURNAL;

ALTER TRIGGER "C_ITX"."DOC_POS_AI_JOURNAL" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_AIUD_ASA_PRICE"
  after insert or delete or update of "ASA_RECORD_TASK_IMPUT_ID"
                                    , "POS_NET_VALUE_INCL"
                                    , "POS_NET_VALUE_INCL_B"
                                    , "POS_NET_VALUE_INCL_E"
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*   calcul du prix d'achat d'une commance sous-traitance
* @created fp 28.06.2004
* @version 2003
* @lastUpdate
*/
declare
  docCurrencyId     DOC_DOCUMENT.ACS_FINANCIAL_CURRENCY_ID%type;
  docRateOfExchange DOC_DOCUMENT.DMT_RATE_OF_EXCHANGE%type;
  docBasePrice      DOC_DOCUMENT.DMT_BASE_PRICE%type;
  docDateRef        date;
  asaCurrencyId     ASA_RECORD.ACS_FINANCIAL_CURRENCY_ID%type;
  asaRateOfExchange ASA_RECORD.ARE_CURR_RATE_OF_EXCH%type;
  asaBasePrice      ASA_RECORD.ARE_CURR_BASE_PRICE%type;
  amountMe          ASA_RECORD_TASK.RET_AMOUNT_ME%type;
  asaDateRef        date;
begin
  if :old.ASA_RECORD_TASK_IMPUT_ID is not null or :new.ASA_RECORD_TASK_IMPUT_ID is not null then
    -- recherche des informations relatives aux cours de change du document logistique
    select ACS_FINANCIAL_CURRENCY_ID
         , DMT_RATE_OF_EXCHANGE
         , DMT_BASE_PRICE
         , DMT_DATE_DOCUMENT
      into docCurrencyId
         , docRateOfExchange
         , docBasePrice
         , docDateRef
      from DOC_DOCUMENT
     where DOC_DOCUMENT_ID = nvl(:new.DOC_DOCUMENT_ID, :old.DOC_DOCUMENT_ID);
  end if;

  if :old.ASA_RECORD_TASK_IMPUT_ID is not null then
    -- si mise à jour ou supression
    if    updating
       or deleting then
      -- recherche des informations relatives aux cours de change du document SAV
      select are.ACS_FINANCIAL_CURRENCY_ID
           , are.ARE_CURR_BASE_PRICE
           , are.ARE_CURR_RATE_OF_EXCH
           , are.ARE_DATECRE
        into asaCurrencyId
           , asaBasePrice
           , asaRateOfExchange
           , asaDateRef
        from ASA_RECORD_TASK ART
           , ASA_RECORD are
       where ART.ASA_RECORD_TASK_ID = :old.ASA_RECORD_TASK_IMPUT_ID
         and ART.ASA_RECORD_ID = are.ASA_RECORD_ID;

      -- mise à jour du montant en monnaie étrangère suivant les combinaisons de monnaies
      if asaCurrencyid = docCurrencyId then
        amountMe  := :old.POS_NET_VALUE_INCL;
      elsif     asaCurrencyId <> docCurrencyId
            and asaCurrencyId = ACS_FUNCTION.GetLocalCurrencyId then
        amountMe  := :old.POS_NET_VALUE_INCL_B;
      else
        amountMe  :=
          ACS_FUNCTION.ConvertAmountForView(:old.POS_NET_VALUE_INCL_B   /*Prix selon tarif trouvé*/
                                          , ACS_FUNCTION.GetLocalCurrencyId   /*Monnaie de base*/
                                          , asaCurrencyId
                                          , trunc(asaDateRef)   /*Date référence*/
                                          , asaRateOfExchange
                                          , asaBasePRice
                                          , 0   /*Pas d'Arrondi*/
                                          , 5
                                           );   /*Cours logistique*/
      end if;

      -- retrait des montants
      update ASA_RECORD_TASK
         set RET_AMOUNT = nvl(RET_AMOUNT, 0) - :old.POS_NET_VALUE_INCL_B
           , RET_AMOUNT_ME = nvl(RET_AMOUNT_ME, 0) - amountMe
           , RET_AMOUNT_EURO = nvl(RET_AMOUNT_EURO, 0) - :old.POS_NET_VALUE_INCL_E
       where ASA_RECORD_TASK_ID = :old.ASA_RECORD_TASK_IMPUT_ID;
    end if;
  end if;

  if :new.ASA_RECORD_TASK_IMPUT_ID is not null then
    -- si mise à jour ou création
    if    updating
       or inserting then
      -- recherche des informations relatives aux cours de change du document SAV
      select are.ACS_FINANCIAL_CURRENCY_ID
           , are.ARE_CURR_BASE_PRICE
           , are.ARE_CURR_RATE_OF_EXCH
        into asaCurrencyId
           , asaBasePrice
           , asaRateOfExchange
        from ASA_RECORD_TASK ART
           , ASA_RECORD are
       where ART.ASA_RECORD_TASK_ID = :new.ASA_RECORD_TASK_IMPUT_ID
         and ART.ASA_RECORD_ID = are.ASA_RECORD_ID;

      if asaCurrencyid = docCurrencyId then
        amountMe  := :new.POS_NET_VALUE_INCL;
      elsif     asaCurrencyId <> docCurrencyId
            and asaCurrencyId = ACS_FUNCTION.GetLocalCurrencyId then
        amountMe  := :new.POS_NET_VALUE_INCL_B;
      else
        amountMe  :=
          ACS_FUNCTION.ConvertAmountForView(:new.POS_NET_VALUE_INCL_B   /*Prix selon tarif trouvé*/
                                          , ACS_FUNCTION.GetLocalCurrencyId   /*Monnaie de base*/
                                          , asaCurrencyId
                                          , trunc(asaDateRef)   /*Date référence*/
                                          , asaRateOfExchange
                                          , asaBasePRice
                                          , 0   /*Pas d'Arrondi*/
                                          , 5
                                           );   /*Cours logistique*/
      end if;

      -- ajout des montants
      update ASA_RECORD_TASK
         set RET_AMOUNT = nvl(RET_AMOUNT, 0) + :new.POS_NET_VALUE_INCL_B
           , RET_AMOUNT_ME = nvl(RET_AMOUNT_ME, 0) + amountMe
           , RET_AMOUNT_EURO = nvl(RET_AMOUNT_EURO, 0) + :new.POS_NET_VALUE_INCL_E
       where ASA_RECORD_TASK_ID = :new.ASA_RECORD_TASK_IMPUT_ID;
    end if;
  end if;
end DOC_POS_AIUD_ASA_PRICE;

ALTER TRIGGER "C_ITX"."DOC_POS_AIUD_ASA_PRICE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_AI_VAT"
  after insert
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour du récapitulatif TVA des position
* @author Fabrice Perotto - Joffroy Christen
* @version 10
* @lastUpdate 03.11.2010
*/
begin
  if :new.C_DOC_POS_STATUS <> '05' then
    -- Ajout du récapitulatif TVA des position
    DOC_PRC_VAT.UpdatePositionVat(:new.DOC_DOCUMENT_ID
                                , :new.C_GAUGE_TYPE_POS
                                , :new.ACS_TAX_CODE_ID
                                , :new.POS_NET_VALUE_EXCL
                                , :new.POS_NET_VALUE_EXCL_B
                                , :new.POS_NET_VALUE_EXCL_V
                                , :new.POS_VAT_RATE
                                , :new.POS_VAT_TOTAL_AMOUNT
                                , :new.POS_VAT_TOTAL_AMOUNT_B
                                , :new.POS_VAT_TOTAL_AMOUNT_V
                                , :new.POS_VAT_AMOUNT
                                , :new.POS_VAT_BASE_AMOUNT
                                , :new.POS_VAT_AMOUNT_V
                                , 1
                                 );
  end if;
end DOC_POS_AI_VAT;

ALTER TRIGGER "C_ITX"."DOC_POS_AI_VAT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_AU_ASA_EVENTS"
  after update of C_DOC_POS_STATUS
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*     Mise à jour du flag RRE_DOC_POSITION_UPD_STAT de ASA_RECORD_EVENTS
*     qui permet de connaître si la position générée à partir du module SAV est soldée
* @author AG?
* @version 2003
* @lastUpdate
*/
begin
  if     :new.C_DOC_POS_STATUS = '04'
     and :new.ASA_RECORD_ID is not null then
    update ASA_RECORD_EVENTS
       set RRE_DOC_POSITION_UPD_STAT = 1
         , A_DATEMOD = sysdate
         , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
     where ASA_RECORD_ID = :new.ASA_RECORD_ID
       and DOC_POSITION_ID = :new.DOC_POSITION_ID;
  end if;
end DOC_POS_AU_ASA_EVENTS;

ALTER TRIGGER "C_ITX"."DOC_POS_AU_ASA_EVENTS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_AU_FORNETWORK"
  after update of C_DOC_POS_STATUS
                , C_GAUGE_TYPE_POS
                , DOC_DOCUMENT_ID
                , DOC_POSITION_ID
                , DOC_RECORD_ID
                , PAC_REPRESENTATIVE_ID
                , GCO_GOOD_ID
                , POS_CONVERT_FACTOR
                , POS_NUMBER
  on DOC_POSITION
  referencing old as old new as new
  for each row
declare
  -- curseur sur tous les detail position de la position
  cursor detail_position_cursor(position_id number)
  is
    select DET.*
      from DOC_POSITION_DETAIL DET
     where DET.DOC_POSITION_ID = position_id;

  detail_position_tuple detail_position_cursor%rowtype;
  aGaugeType            DOC_GAUGE.C_GAUGE_TYPE%type;
  aDocRecordID          DOC_RECORD.DOC_RECORD_ID%type;
  aDIC_PIC_GROUP_ID     DIC_PIC_GROUP.DIC_PIC_GROUP_ID%type;
  aGasUpdatePicOrderQty DOC_GAUGE_STRUCTURED.GAS_UPDATE_PIC_ORDER_QTY%type;
  aDateValue            date;
  lvFanDescr            FAL_NETWORK_SUPPLY.FAN_DESCRIPTION%type;
begin
  -- Vérifier que les réseaux Logiqistiques sont activés
  if not FAL_NETWORK_DOC.IsDOCNetWorkEnabled then
    return;
  end if;

  -- Récupérer le type de gabarit du document, ainsi que le Flag de MAJ de la Qté commande PIC
  begin
    select GAU.C_GAUGE_TYPE
         , GAS.GAS_UPDATE_PIC_ORDER_QTY
      into aGaugeType
         , aGasUpdatePicOrderQty
      from DOC_GAUGE_STRUCTURED GAS
         , DOC_GAUGE GAU
     where GAU.DOC_GAUGE_ID = :new.DOC_GAUGE_ID
       and GAU.DOC_GAUGE_ID = GAS.DOC_GAUGE_ID;
  exception
    when no_data_found then
      begin
        aGaugeType             := '';
        aGasUpdatePicOrderQty  := 0;
      end;
  end;

  -- Description pour le besoin/appro
  select DMT.DMT_NUMBER || ' / ' || :new.POS_NUMBER
    into lvFanDescr
    from DOC_DOCUMENT DMT
   where DMT.DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID;

  -- Màj de la description du besoin/appro lors du changement de n° de position
  if :old.POS_NUMBER <> :new.POS_NUMBER then
    -- Appro
    update FAL_NETWORK_SUPPLY
       set FAN_DESCRIPTION = lvFanDescr
         , A_DATEMOD = sysdate
         , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
     where DOC_POSITION_ID = :new.DOC_POSITION_ID;

    -- Besoin
    update FAL_NETWORK_NEED
       set FAN_DESCRIPTION = lvFanDescr
         , A_DATEMOD = sysdate
         , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
     where DOC_POSITION_ID = :new.DOC_POSITION_ID;
  end if;

  -- Graphe d'evenement "Update Dossier Position"
  -- Si le dossier a changé
  -- Il faut savoir aussi si le représentant a changé
  if    (nvl(:new.DOC_RECORD_ID, 0) <> nvl(:old.DOC_RECORD_ID, 0) )
     or (nvl(:new.PAC_REPRESENTATIVE_ID, 0) <> nvl(:old.PAC_REPRESENTATIVE_ID, 0) ) then
    -- Processus : Mise à jour Dossier RéseauxLogAppro
    FAL_NETWORK_DOC.ReseauApproDOC_MAJ_Dossier(:new.DOC_POSITION_ID, :new.DOC_RECORD_ID);
    -- Processus : Mise à jour Dossier RéseauxLogBesoin
    FAL_NETWORK_DOC.ReseauBesoinDOC_MAJ_Dossier(:new.DOC_POSITION_ID, :new.DOC_RECORD_ID);
    -- Processus : Mise à jour Représentant RéseauxLogBesoin
    FAL_NETWORK_DOC.ReseauBesoinDOC_MAJ_Repres(:new.DOC_POSITION_ID, :new.PAC_REPRESENTATIVE_ID);
  end if;

  -- Vérifier que le nouveau status de la position maître est Solder (02) ou Liquidé (04) et Si l'ancien est
  -- A confirmer (01)
  if     (    (:new.C_DOC_POS_STATUS = '02')
          or (:new.C_DOC_POS_STATUS = '04') )
     and (:old.C_DOC_POS_STATUS = '01') then
    -- Vérifier que le type de la position maître est Bien (1), Bien avec nomenclature informative (2),
    -- ou Bien avec nomenclature active (3)
    -- VJ : en attente / ainsi que tous les types de position kit ou assemblage
    if    (:new.C_GAUGE_TYPE_POS = '1')
       or (:new.C_GAUGE_TYPE_POS = '2')
       or (:new.C_GAUGE_TYPE_POS = '3')
       or (:new.C_GAUGE_TYPE_POS = '71')
       or (:new.C_GAUGE_TYPE_POS = '81')
       or (:new.C_GAUGE_TYPE_POS = '91')
       or (:new.C_GAUGE_TYPE_POS = '101') then
      -- ouverture du curseur sur les details de position
      open detail_position_cursor(:new.DOC_POSITION_ID);

      fetch detail_position_cursor
       into detail_position_tuple;

      while detail_position_cursor%found loop
        -- Déterminer la valeur du dossier
        if :new.DOC_RECORD_ID is null then
          aDocRecordID  := 0;
        else
          aDocRecordID  := :new.DOC_RECORD_ID;
        end if;

        -- Est-ce un bien et la position a t'elle une durée pour le transfert du stock propriétaire
        -- Note il faut bien entendu faire ce test en premier
        if     (aGaugeType = '1')
           and (:new.POS_TRANSFERT_PROPRIETOR = 1) then
          -- Empecher la création de réseaux avec Qtés négatives ou nulles.
          if nvl(detail_position_tuple.PDE_BALANCE_QUANTITY, 0) > 0 then
            -- Processus : Création RéseauxLogBesoin
            FAL_NETWORK_DOC.ReseauBesoinDOC_Creation(aPositionDetail          => detail_position_tuple
                                                   , pDocumentID              => :new.DOC_DOCUMENT_ID
                                                   , pGoodID                  => :new.GCO_GOOD_ID
                                                   , pDocRecordID             => aDocRecordID
                                                   , pConversionFactor        => :new.POS_CONVERT_FACTOR
                                                   , pPAC_REPRESENTATIVE_ID   => :new.PAC_REPRESENTATIVE_ID
                                                   , iDescription             => lvFanDescr
                                                    );
            -- Processus : Création RéseauxLogAppro
            -- Pour ce cas , l'appro doit être sur le stock de transfert, c'est une exception
            detail_position_tuple.STM_LOCATION_ID  := :new.STM_STM_LOCATION_ID;
            FAL_NETWORK_DOC.ReseauApproDOC_Creation(aPositionDetail     => detail_position_tuple
                                                  , pDocumentID         => :new.DOC_DOCUMENT_ID
                                                  , pGoodID             => :new.GCO_GOOD_ID
                                                  , pDocRecordID        => aDocRecordID
                                                  , pConversionFactor   => :new.POS_CONVERT_FACTOR
                                                  , iDescription        => lvFanDescr
                                                   );
          end if;
        elsif     aGaugeType = '2'
              and (     (:new.C_GAUGE_TYPE_POS <> '71')
                   and (:new.C_GAUGE_TYPE_POS <> '81') ) then
          -- Empecher la création de réseaux avec Qtés négatives ou nulles.
          if nvl(detail_position_tuple.PDE_BALANCE_QUANTITY, 0) > 0 then
            -- Processus : Création ReseauxLogAppro
            FAL_NETWORK_DOC.ReseauApproDOC_Creation(aPositionDetail     => detail_position_tuple
                                                  , pDocumentID         => :new.DOC_DOCUMENT_ID
                                                  , pGoodID             => :new.GCO_GOOD_ID
                                                  , pDocRecordID        => aDocRecordID
                                                  , pConversionFactor   => :new.POS_CONVERT_FACTOR
                                                  , iDescription        => lvFanDescr
                                                   );
          end if;
        elsif    aGaugeType = '1'
              or (     (aGaugeType = '2')
                  and (    (:new.C_GAUGE_TYPE_POS = '71')
                       or (:new.C_GAUGE_TYPE_POS = '81') ) ) then
          -- Empecher la création de réseaux avec Qtés négatives ou nulles.
          if nvl(detail_position_tuple.PDE_BALANCE_QUANTITY, 0) > 0 then
            -- Processus : Création ReseauxLogBesoin
            FAL_NETWORK_DOC.ReseauBesoinDOC_Creation(aPositionDetail          => detail_position_tuple
                                                   , pDocumentID              => :new.DOC_DOCUMENT_ID
                                                   , pGoodID                  => :new.GCO_GOOD_ID
                                                   , pDocRecordID             => aDocRecordID
                                                   , pConversionFactor        => :new.POS_CONVERT_FACTOR
                                                   , pPAC_REPRESENTATIVE_ID   => :new.PAC_REPRESENTATIVE_ID
                                                   , iDescription             => lvFanDescr
                                                    );
          end if;

          -- Seulement si le gabarit est de type Besoin (1)
          if     (aGaugeType = '1')
             and to_number(PCS.PC_CONFIG.GetConfig('FAL_PIC') ) in(2, 3)
             and aGasUpdatePicOrderQty = 1
             and FAL_TOOLS.IsLocationOnStockNeedPic(detail_position_tuple.STM_LOCATION_ID) then
            -- Récupération du DIC_PIC_GROUP_ID via le PAC_THIRD_ID
            aDIC_PIC_GROUP_ID  := null;

            if :new.PAC_THIRD_ID is not null then
              select DIC_PIC_GROUP_ID
                into aDIC_PIC_GROUP_ID
                from PAC_CUSTOM_PARTNER
               where PAC_CUSTOM_PARTNER_ID = :new.PAC_THIRD_ID;
            end if;

            -- Ce n'est pas le PDE_FINAL_DELAY qu'il faut prendre mais le PDE_BASIS_DELAY
            FAL_PLAN_DIRECTEUR.ProcessusMajQteCmdPicLine(:new.GCO_GOOD_ID
                                                       , detail_position_tuple.PDE_BASIS_DELAY
                                                       , :new.PAC_THIRD_ID
                                                       , :new.PAC_REPRESENTATIVE_ID
                                                       , detail_position_tuple.PDE_BALANCE_QUANTITY
                                                       , aDIC_PIC_GROUP_ID
                                                        );
          end if;
        elsif     (aGaugeType = '3')
              and to_number(PCS.PC_CONFIG.GetConfig('FAL_PIC') ) in(2, 3)
              and aGasUpdatePicOrderQty = 1
              and FAL_TOOLS.IsLocationOnStockNeedPic(detail_position_tuple.STM_LOCATION_ID) then
          -- Récupération du DIC_PIC_GROUP_ID via le PAC_THIRD_ID
          aDIC_PIC_GROUP_ID  := null;

          if :new.PAC_THIRD_ID is not null then
            select DIC_PIC_GROUP_ID
              into aDIC_PIC_GROUP_ID
              from PAC_CUSTOM_PARTNER
             where PAC_CUSTOM_PARTNER_ID = :new.PAC_THIRD_ID;
          end if;

          -- Ce n'est pas le le PDE_BASIS_DELAY dans ce cas mais la date valeur du document
          select dmt_date_value
            into aDateValue
            from doc_document
           where doc_document_id = :new.doc_document_id;

          -- La Qté en commande passe dans le réalisé.
          FAL_PLAN_DIRECTEUR.ProcessusMajQteCmdPicLine(:new.GCO_GOOD_ID
                                                     , aDateValue
                                                     , :new.PAC_THIRD_ID
                                                     , :new.PAC_REPRESENTATIVE_ID
                                                     , -detail_position_tuple.PDE_BALANCE_QUANTITY
                                                     , aDIC_PIC_GROUP_ID
                                                      );
        end if;

        fetch detail_position_cursor
         into detail_position_tuple;
      end loop;

      close detail_position_cursor;
    end if;

    if    (:new.C_GAUGE_TYPE_POS = '7')
       or (:new.C_GAUGE_TYPE_POS = '8')
       or (:new.C_GAUGE_TYPE_POS = '9')
       or (:new.C_GAUGE_TYPE_POS = '10') then
      -- ouverture du curseur sur les details de position
      open detail_position_cursor(:new.DOC_POSITION_ID);

      fetch detail_position_cursor
       into detail_position_tuple;

      while detail_position_cursor%found loop
        -- Déterminer la valeur du dossier
        if :new.DOC_RECORD_ID is null then
          aDocRecordID  := 0;
        else
          aDocRecordID  := :new.DOC_RECORD_ID;
        end if;

        -- Vérifier que le type de gabarit est Approvisionnement (2)
        if aGaugeType = '2' then
          -- Empecher la création de réseaux avec Qtés négatives ou nulles.
          if nvl(detail_position_tuple.PDE_BALANCE_QUANTITY, 0) > 0 then
            -- Processus : Création ReseauxLogAppro
            FAL_NETWORK_DOC.ReseauApproDOC_Creation(aPositionDetail     => detail_position_tuple
                                                  , pDocumentID         => :new.DOC_DOCUMENT_ID
                                                  , pGoodID             => :new.GCO_GOOD_ID
                                                  , pDocRecordID        => aDocRecordID
                                                  , pConversionFactor   => :new.POS_CONVERT_FACTOR
                                                  , iDescription        => lvFanDescr
                                                   );
          end if;
        end if;

        -- Vérifier que le type de gabarit est Besoin (1)
        if aGaugeType = '1' then
          -- Empecher la création de réseaux avec Qtés négatives ou nulles.
          if nvl(detail_position_tuple.PDE_BALANCE_QUANTITY, 0) > 0 then
            -- Processus : Création ReseauxLogBesoin
            FAL_NETWORK_DOC.ReseauBesoinDOC_Creation(aPositionDetail          => detail_position_tuple
                                                   , pDocumentID              => :new.DOC_DOCUMENT_ID
                                                   , pGoodID                  => :new.GCO_GOOD_ID
                                                   , pDocRecordID             => aDocRecordID
                                                   , pConversionFactor        => :new.POS_CONVERT_FACTOR
                                                   , pPAC_REPRESENTATIVE_ID   => :new.PAC_REPRESENTATIVE_ID
                                                   , iDescription             => lvFanDescr
                                                    );
            -- Processus : Création ReseauxLogAppro
            detail_position_tuple.PDE_FINAL_DELAY  := detail_position_tuple.PDE_BASIS_DELAY;
            FAL_NETWORK_DOC.ReseauApproDOC_Creation(aPositionDetail     => detail_position_tuple
                                                  , pDocumentID         => :new.DOC_DOCUMENT_ID
                                                  , pGoodID             => :new.GCO_GOOD_ID
                                                  , pDocRecordID        => aDocRecordID
                                                  , pConversionFactor   => :new.POS_CONVERT_FACTOR
                                                  , iDescription        => lvFanDescr
                                                   );
            -- Processus : Création Attribution Besoin sur Appro ...
            FAL_NETWORK.CreateAttribBesoinAppro(FAL_NETWORK_DOC.glbNewBesoinID
                                              , FAL_NETWORK_DOC.glbNewApproID
                                              , :new.POS_CONVERT_FACTOR * detail_position_tuple.PDE_BALANCE_QUANTITY
                                               );
          end if;
        end if;

        fetch detail_position_cursor
         into detail_position_tuple;
      end loop;

      close detail_position_cursor;
    end if;
  end if;
end DOC_POS_AU_FORNETWORK;

ALTER TRIGGER "C_ITX"."DOC_POS_AU_FORNETWORK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_AU_IMPUTATION"
  after update of POS_IMPUTATION
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Déclenche le traitement de mise à jour de la table des imputations position. Les règles suivantes doivent être respectées :
*
*    1. Aucune imputation ne doit exister si le flag POS_IMPUTATION passe de 1 à 0.
*    2. Au moins une imputation position doit être créée si le flag POS_IMPUTATION est à 1.
*    3. Les imputations créées se basent sur un modèle de répartition (imputations positions avec uniquement l'ID du
*       document qui est renseigné).
*
* @author VJ
* @created 24/08/2006
* @version 2003
*/
declare
  nRecord         number;
  nRefRecord      number;
  vPositionRow    DOC_POSITION%rowtype;
  docDocumentID   DOC_DOCUMENT.DOC_DOCUMENT_ID%type;
  pacThirdID      PAC_THIRD.PAC_THIRD_ID%type;
  docGaugeID      DOC_GAUGE.DOC_GAUGE_ID%type;
  cAdminDomain    DOC_GAUGE.C_ADMIN_DOMAIN%type;
  docDateDocument DOC_DOCUMENT.DMT_DATE_DOCUMENT%type;
begin
  if (nvl(:old.POS_IMPUTATION, 0) <> nvl(:new.POS_IMPUTATION, 0) ) then
    -- Passage du flag de 1 à 0.
    if (nvl(:new.POS_IMPUTATION, 0) = 0) then
      -- Supprime les éventuelles imputations lors du passage du flag d'imputation à 0
      DOC_IMPUTATION_FUNCTIONS.DeletePositionImputations(:new.DOC_POSITION_ID, null, null);
    -- Passage du flag de 0 à 1.
    elsif(nvl(:new.POS_IMPUTATION, 0) = 1) then
      -- Vérifie l'existance d'une ou plusieurs imputations position.
      select count(POI.DOC_POSITION_IMPUTATION_ID)
        into nRecord
        from DOC_POSITION_IMPUTATION POI
       where POI.DOC_POSITION_ID = :new.DOC_POSITION_ID;

      -- Aucune imputation ne doit être créée s'il en existe déjà
      if nRecord = 0 then
        -- Vérifie l'existance d'une ou plusieurs répartitions de référence. Les modèles de répartition se distinguent
        -- par le fait que le seul le champ DOC_DOCUMENT_ID est renseigné.
        select count(POI.DOC_POSITION_IMPUTATION_ID)
          into nRefRecord
          from DOC_POSITION_IMPUTATION POI
         where POI.DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID
           and POI.DOC_POSITION_ID is null
           and POI.DOC_POSITION_CHARGE_ID is null
           and POI.DOC_FOOT_CHARGE_ID is null;

        if nRefRecord = 0 then
          -- Cas en principe impossible. Le contrôle effectué par le trigger DOC_POS_BU_IMPUTATION doit exclure
          -- ce cas.
          raise_application_error(-20100, 'Imputation structure not found !');
        end if;

        -- Recherche les comptes à appliquer
        begin
          select DMT.DOC_DOCUMENT_ID
               , DMT.PAC_THIRD_ID
               , GAU.DOC_GAUGE_ID
               , GAU.C_ADMIN_DOMAIN
               , DMT.DMT_DATE_DOCUMENT
            into docDocumentID
               , pacThirdID
               , docGaugeID
               , cAdminDomain
               , docDateDocument
            from DOC_DOCUMENT DMT
               , DOC_GAUGE GAU
           where DMT.DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID
             and GAU.DOC_GAUGE_ID = DMT.DOC_GAUGE_ID;
        exception
          when ex.TABLE_MUTATING then
            null;
          when no_data_found then
            null;
        end;

        if docDocumentID is not null then
          -- Rempli l'enregistrement représentant la position courante.
          vPositionRow.DOC_DOCUMENT_ID           := :new.DOC_DOCUMENT_ID;
          vPositionRow.DOC_POSITION_ID           := :new.DOC_POSITION_ID;
          vPositionRow.POS_NUMBER                := :new.POS_NUMBER;
          vPositionRow.DOC_DOCUMENT_ID           := :new.DOC_DOCUMENT_ID;
          vPositionRow.GCO_GOOD_ID               := :new.GCO_GOOD_ID;
          vPositionRow.ACS_FINANCIAL_ACCOUNT_ID  := :new.ACS_FINANCIAL_ACCOUNT_ID;
          vPositionRow.ACS_DIVISION_ACCOUNT_ID   := :new.ACS_DIVISION_ACCOUNT_ID;
          vPositionRow.ACS_PJ_ACCOUNT_ID         := :new.ACS_PJ_ACCOUNT_ID;
          vPositionRow.ACS_PF_ACCOUNT_ID         := :new.ACS_PF_ACCOUNT_ID;
          vPositionRow.ACS_CDA_ACCOUNT_ID        := :new.ACS_CDA_ACCOUNT_ID;
          vPositionRow.ACS_CPN_ACCOUNT_ID        := :new.ACS_CPN_ACCOUNT_ID;
          vPositionRow.DIC_IMP_FREE1_ID          := :new.DIC_IMP_FREE1_ID;
          vPositionRow.DIC_IMP_FREE2_ID          := :new.DIC_IMP_FREE2_ID;
          vPositionRow.DIC_IMP_FREE3_ID          := :new.DIC_IMP_FREE3_ID;
          vPositionRow.DIC_IMP_FREE4_ID          := :new.DIC_IMP_FREE4_ID;
          vPositionRow.DIC_IMP_FREE5_ID          := :new.DIC_IMP_FREE5_ID;
          vPositionRow.POS_NUMBER                := :new.POS_NUMBER;
          vPositionRow.POS_IMF_NUMBER_2          := :new.POS_IMF_NUMBER_2;
          vPositionRow.POS_IMF_NUMBER_3          := :new.POS_IMF_NUMBER_3;
          vPositionRow.POS_IMF_NUMBER_4          := :new.POS_IMF_NUMBER_4;
          vPositionRow.POS_IMF_NUMBER_5          := :new.POS_IMF_NUMBER_5;
          vPositionRow.POS_IMF_TEXT_1            := :new.POS_IMF_TEXT_1;
          vPositionRow.POS_IMF_TEXT_2            := :new.POS_IMF_TEXT_2;
          vPositionRow.POS_IMF_TEXT_3            := :new.POS_IMF_TEXT_3;
          vPositionRow.POS_IMF_TEXT_4            := :new.POS_IMF_TEXT_4;
          vPositionRow.POS_IMF_TEXT_5            := :new.POS_IMF_TEXT_5;
          vPositionRow.C_FAM_TRANSACTION_TYP     := :new.C_FAM_TRANSACTION_TYP;
          vPositionRow.FAM_FIXED_ASSETS_ID       := :new.FAM_FIXED_ASSETS_ID;
          vPositionRow.HRM_PERSON_ID             := :new.HRM_PERSON_ID;
          DOC_IMPUTATION_FUNCTIONS.CreateLikePositionImputations(:new.DOC_DOCUMENT_ID
                                                               , docGaugeID
                                                               , pacThirdID
                                                               , cAdminDomain
                                                               , docDateDocument
                                                               , :new.DOC_POSITION_ID
                                                               , vPositionRow
                                                               , null
                                                               , null
                                                               , null
                                                               , null
                                                                );
        end if;
      end if;

      -- Fonction de répartition du montant d'une position
      DOC_IMPUTATION_FUNCTIONS.imputePosition(:new.DOC_POSITION_ID
                                            , :new.POS_GROSS_VALUE
                                            , :new.POS_GROSS_VALUE_B
                                            , :new.POS_GROSS_VALUE_E
                                            , :new.POS_GROSS_VALUE_V
                                            , :new.POS_GROSS_VALUE_INCL
                                            , :new.POS_GROSS_VALUE_INCL_B
                                            , :new.POS_GROSS_VALUE_INCL_E
                                            , :new.POS_GROSS_VALUE_INCL_V
                                            , :new.POS_INCLUDE_TAX_TARIFF
                                             );
    end if;

    -- Garantit le création des imputations sur les remises et taxes de la position.
    update DOC_POSITION_CHARGE PCH
       set PCH.PCH_IMPUTATION = :new.POS_IMPUTATION
         , PCH.A_DATEMOD = sysdate
         , PCH.A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
     where PCH.DOC_POSITION_ID = :new.DOC_POSITION_ID;
  end if;
end DOC_POS_AU_IMPUTATION;

ALTER TRIGGER "C_ITX"."DOC_POS_AU_IMPUTATION" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_AU_JOURNAL"
  after update of POS_BASIS_QUANTITY
                , POS_INTERMEDIATE_QUANTITY
                , POS_FINAL_QUANTITY
                , POS_BASIS_QUANTITY_SU
                , POS_INTERMEDIATE_QUANTITY_SU
                , POS_FINAL_QUANTITY_SU
                , POS_BALANCE_QUANTITY
                , POS_GROSS_VALUE
                , POS_GROSS_VALUE_B
                , POS_GROSS_VALUE_INCL
                , POS_GROSS_VALUE_INCL_B
                , POS_NET_VALUE_EXCL
                , POS_NET_VALUE_EXCL_B
                , POS_NET_VALUE_INCL
                , POS_NET_VALUE_INCL_B
                , C_DOC_POS_STATUS
                , GCO_GOOD_ID
                , POS_SHORT_DESCRIPTION
                , POS_LONG_DESCRIPTION
                , STM_STOCK_ID
                , STM_LOCATION_ID
                , DOC_RECORD_ID
                , ACS_FINANCIAL_ACCOUNT_ID
                , ACS_DIVISION_ACCOUNT_ID
                , ACS_CPN_ACCOUNT_ID
                , ACS_CDA_ACCOUNT_ID
                , ACS_PF_ACCOUNT_ID
                , ACS_PJ_ACCOUNT_ID
                , PAC_THIRD_ID
                , PAC_PERSON_ID
                , PAC_REPRESENTATIVE_ID
                , FAM_FIXED_ASSETS_ID
                , HRM_PERSON_ID
                , C_FAM_TRANSACTION_TYP
                , POS_IMF_NUMBER_2
                , POS_IMF_NUMBER_3
                , POS_IMF_NUMBER_4
                , POS_IMF_NUMBER_5
                , POS_IMF_TEXT_1
                , POS_IMF_TEXT_2
                , POS_IMF_TEXT_3
                , POS_IMF_TEXT_4
                , POS_IMF_TEXT_5
                , DIC_IMP_FREE1_ID
                , DIC_IMP_FREE2_ID
                , DIC_IMP_FREE3_ID
                , DIC_IMP_FREE4_ID
                , DIC_IMP_FREE5_ID
                , POS_IMPUTATION
                , POS_MODIFY_RATE
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Journaliser la position
*
* @author Nuno Gomes Vieira
* @created 11/10/2005
* @version 2003
*/
declare
  ltplNew       DOC_POSITION%rowtype;
  ltplOld       DOC_POSITION%rowtype;
  lvJournalCode DOC_JOURNAL_DETAIL.C_DOC_JOURNAL_DETAIL%type;
begin
  if    (nvl(:new.POS_BASIS_QUANTITY, -1) <> nvl(:old.POS_BASIS_QUANTITY, -1) )
     or (nvl(:new.POS_INTERMEDIATE_QUANTITY, -1) <> nvl(:old.POS_INTERMEDIATE_QUANTITY, -1) )
     or (nvl(:new.POS_FINAL_QUANTITY, -1) <> nvl(:old.POS_FINAL_QUANTITY, -1) )
     or (nvl(:new.POS_BASIS_QUANTITY_SU, -1) <> nvl(:old.POS_BASIS_QUANTITY_SU, -1) )
     or (nvl(:new.POS_INTERMEDIATE_QUANTITY_SU, -1) <> nvl(:old.POS_INTERMEDIATE_QUANTITY_SU, -1) )
     or (nvl(:new.POS_FINAL_QUANTITY_SU, -1) <> nvl(:old.POS_FINAL_QUANTITY_SU, -1) )
     or (nvl(:new.POS_BALANCE_QUANTITY, -1) <> nvl(:old.POS_BALANCE_QUANTITY, -1) )
     or (nvl(:new.POS_GROSS_VALUE, -1) <> nvl(:old.POS_GROSS_VALUE, -1) )
     or (nvl(:new.POS_GROSS_VALUE_B, -1) <> nvl(:old.POS_GROSS_VALUE_B, -1) )
     or (nvl(:new.POS_GROSS_VALUE_INCL, -1) <> nvl(:old.POS_GROSS_VALUE_INCL, -1) )
     or (nvl(:new.POS_GROSS_VALUE_INCL_B, -1) <> nvl(:old.POS_GROSS_VALUE_INCL_B, -1) )
     or (nvl(:new.POS_NET_VALUE_EXCL, -1) <> nvl(:old.POS_NET_VALUE_EXCL, -1) )
     or (nvl(:new.POS_NET_VALUE_EXCL_B, -1) <> nvl(:old.POS_NET_VALUE_EXCL_B, -1) )
     or (nvl(:new.POS_NET_VALUE_INCL, -1) <> nvl(:old.POS_NET_VALUE_INCL, -1) )
     or (nvl(:new.POS_NET_VALUE_INCL_B, -1) <> nvl(:old.POS_NET_VALUE_INCL_B, -1) )
     or (nvl(:new.POS_IMPUTATION, -1) <> nvl(:old.POS_IMPUTATION, -1) )
     or (nvl(:new.POS_MODIFY_RATE, -1) <> nvl(:old.POS_MODIFY_RATE, -1) )
     or (nvl(:new.C_DOC_POS_STATUS, 'NULL') <> nvl(:old.C_DOC_POS_STATUS, 'NULL') )
     or (nvl(:new.GCO_GOOD_ID, -1) <> nvl(:old.GCO_GOOD_ID, -1) )
     or (nvl(:new.POS_SHORT_DESCRIPTION, 'NULL') <> nvl(:old.POS_SHORT_DESCRIPTION, 'NULL') )
     or (nvl(:new.POS_LONG_DESCRIPTION, 'NULL') <> nvl(:old.POS_LONG_DESCRIPTION, 'NULL') )
     or (nvl(:new.STM_STOCK_ID, -1) <> nvl(:old.STM_STOCK_ID, -1) )
     or (nvl(:new.STM_LOCATION_ID, -1) <> nvl(:old.STM_LOCATION_ID, -1) )
     or (nvl(:new.DOC_RECORD_ID, -1) <> nvl(:old.DOC_RECORD_ID, -1) )
     or (nvl(:new.ACS_FINANCIAL_ACCOUNT_ID, -1) <> nvl(:old.ACS_FINANCIAL_ACCOUNT_ID, -1) )
     or (nvl(:new.ACS_DIVISION_ACCOUNT_ID, -1) <> nvl(:old.ACS_DIVISION_ACCOUNT_ID, -1) )
     or (nvl(:new.ACS_CPN_ACCOUNT_ID, -1) <> nvl(:old.ACS_CPN_ACCOUNT_ID, -1) )
     or (nvl(:new.ACS_CDA_ACCOUNT_ID, -1) <> nvl(:old.ACS_CDA_ACCOUNT_ID, -1) )
     or (nvl(:new.ACS_PF_ACCOUNT_ID, -1) <> nvl(:old.ACS_PF_ACCOUNT_ID, -1) )
     or (nvl(:new.ACS_PJ_ACCOUNT_ID, -1) <> nvl(:old.ACS_PJ_ACCOUNT_ID, -1) )
     or (nvl(:new.PAC_THIRD_ID, -1) <> nvl(:old.PAC_THIRD_ID, -1) )
     or (nvl(:new.PAC_PERSON_ID, -1) <> nvl(:old.PAC_PERSON_ID, -1) )
     or (nvl(:new.PAC_REPRESENTATIVE_ID, -1) <> nvl(:old.PAC_REPRESENTATIVE_ID, -1) )
     or (nvl(:new.FAM_FIXED_ASSETS_ID, -1) <> nvl(:old.FAM_FIXED_ASSETS_ID, -1) )
     or (nvl(:new.HRM_PERSON_ID, -1) <> nvl(:old.HRM_PERSON_ID, -1) )
     or (nvl(:new.C_FAM_TRANSACTION_TYP, 'NULL') <> nvl(:old.C_FAM_TRANSACTION_TYP, 'NULL') )
     or (nvl(:new.POS_IMF_NUMBER_2, 0) <> nvl(:old.POS_IMF_NUMBER_2, 0) )
     or (nvl(:new.POS_IMF_NUMBER_3, 0) <> nvl(:old.POS_IMF_NUMBER_3, 0) )
     or (nvl(:new.POS_IMF_NUMBER_4, 0) <> nvl(:old.POS_IMF_NUMBER_4, 0) )
     or (nvl(:new.POS_IMF_NUMBER_5, 0) <> nvl(:old.POS_IMF_NUMBER_5, 0) )
     or (nvl(:new.POS_IMF_TEXT_1, 'NULL') <> nvl(:old.POS_IMF_TEXT_1, 'NULL') )
     or (nvl(:new.POS_IMF_TEXT_2, 'NULL') <> nvl(:old.POS_IMF_TEXT_2, 'NULL') )
     or (nvl(:new.POS_IMF_TEXT_3, 'NULL') <> nvl(:old.POS_IMF_TEXT_3, 'NULL') )
     or (nvl(:new.POS_IMF_TEXT_4, 'NULL') <> nvl(:old.POS_IMF_TEXT_4, 'NULL') )
     or (nvl(:new.POS_IMF_TEXT_5, 'NULL') <> nvl(:old.POS_IMF_TEXT_5, 'NULL') )
     or (nvl(:new.DIC_IMP_FREE1_ID, 'NULL') <> nvl(:old.DIC_IMP_FREE1_ID, 'NULL') )
     or (nvl(:new.DIC_IMP_FREE2_ID, 'NULL') <> nvl(:old.DIC_IMP_FREE2_ID, 'NULL') )
     or (nvl(:new.DIC_IMP_FREE3_ID, 'NULL') <> nvl(:old.DIC_IMP_FREE3_ID, 'NULL') )
     or (nvl(:new.DIC_IMP_FREE4_ID, 'NULL') <> nvl(:old.DIC_IMP_FREE4_ID, 'NULL') )
     or (nvl(:new.DIC_IMP_FREE5_ID, 'NULL') <> nvl(:old.DIC_IMP_FREE5_ID, 'NULL') )
     or (nvl(:new.POS_IMPUTATION, -1) <> nvl(:old.POS_IMPUTATION, -1) ) then
    if DOC_JOURNAL_FUNCTIONS.MustPosJournalize(:new.DOC_DOCUMENT_ID
                                             , :new.DOC_GAUGE_ID
                                             , :new.C_GAUGE_TYPE_POS
                                             , :new.DOC_GAUGE_POSITION_ID
                                             , :new.DOC_DOC_POSITION_ID
                                              ) = 1 then
      --
      -- Rechercher le type de modification effectué sur la position
      -- BALANCE     Solder position
      -- BAL_EXT     Solder position avec extourne
      -- CANCEL      Annulation
      -- CONFIRM     confirmation
      -- UPDATE      Modification

      -- Confirmation de la position
      if     (:old.C_DOC_POS_STATUS = '01')
         and (:new.C_DOC_POS_STATUS <> '01') then
        lvJournalCode  := 'CONFIRM';
      -- Annulation de la position
      elsif     (:new.C_DOC_POS_STATUS = '05')
            and (:old.C_DOC_POS_STATUS <> '05') then
        lvJournalCode  := 'CANCEL';
      -- Solde de la position avec/sans extourne
      elsif     (:new.POS_BALANCED = 1)
            and (nvl(:old.POS_BALANCED, 0) = 0) then
        -- Vérifier s'il s'agit d'un solde ou solde avec extourne
        select case
                 when nvl(max(SMO_EXTOURNE_MVT), 0) = 1 then 'BAL_EXT'
                 else 'BALANCE'
               end
          into lvJournalCode
          from STM_STOCK_MOVEMENT
         where DOC_POSITION_ID = :new.DOC_POSITION_ID;
      elsif     (DOC_JOURNAL_FUNCTIONS.CURRENT_TRANSACTION = DBMS_TRANSACTION.local_transaction_id)
            and (DOC_JOURNAL_FUNCTIONS.DISCH_SRC_POS_ID = :new.DOC_POSITION_ID) then
        if DOC_JOURNAL_FUNCTIONS.DISCH_CODE = 'INSERT' then
          lvJournalCode  := 'DISCHARGED';
        elsif DOC_JOURNAL_FUNCTIONS.DISCH_CODE = 'UPDATE' then
          lvJournalCode  := 'UPD_TGT';
        elsif DOC_JOURNAL_FUNCTIONS.DISCH_CODE = 'DELETE' then
          lvJournalCode  := 'DEL_TGT';
        end if;
      else
        lvJournalCode  := 'UPDATE';
      end if;

      -- Assignation de TOUS les champs de la table DOC_POSITION
      --   Champs triés par ordre alphabetique
      ltplNew.ACS_CDA_ACCOUNT_ID            := :new.ACS_CDA_ACCOUNT_ID;
      ltplNew.ACS_CPN_ACCOUNT_ID            := :new.ACS_CPN_ACCOUNT_ID;
      ltplNew.ACS_DIVISION_ACCOUNT_ID       := :new.ACS_DIVISION_ACCOUNT_ID;
      ltplNew.ACS_FINANCIAL_ACCOUNT_ID      := :new.ACS_FINANCIAL_ACCOUNT_ID;
      ltplNew.ACS_PF_ACCOUNT_ID             := :new.ACS_PF_ACCOUNT_ID;
      ltplNew.ACS_PJ_ACCOUNT_ID             := :new.ACS_PJ_ACCOUNT_ID;
      ltplNew.ACS_TAX_CODE_ID               := :new.ACS_TAX_CODE_ID;
      ltplNew.ASA_INTERVENTION_DETAIL_ID    := :new.ASA_INTERVENTION_DETAIL_ID;
      ltplNew.ASA_RECORD_COMP_ID            := :new.ASA_RECORD_COMP_ID;
      ltplNew.ASA_RECORD_ID                 := :new.ASA_RECORD_ID;
      ltplNew.ASA_RECORD_TASK_ID            := :new.ASA_RECORD_TASK_ID;
      ltplNew.ASA_RECORD_TASK_IMPUT_ID      := :new.ASA_RECORD_TASK_IMPUT_ID;
      ltplNew.A_CONFIRM                     := :new.A_CONFIRM;
      ltplNew.A_DATECRE                     := :new.A_DATECRE;
      ltplNew.A_DATEMOD                     := :new.A_DATEMOD;
      ltplNew.A_IDCRE                       := :new.A_IDCRE;
      ltplNew.A_IDMOD                       := :new.A_IDMOD;
      ltplNew.A_RECLEVEL                    := :new.A_RECLEVEL;
      ltplNew.A_RECSTATUS                   := :new.A_RECSTATUS;
      ltplNew.CML_EVENTS_ID                 := :new.CML_EVENTS_ID;
      ltplNew.CML_POSITION_ID               := :new.CML_POSITION_ID;
      ltplNew.C_DOC_LOT_TYPE                := :new.C_DOC_LOT_TYPE;
      ltplNew.C_DOC_POS_STATUS              := :new.C_DOC_POS_STATUS;
      ltplNew.C_FAM_TRANSACTION_TYP         := :new.C_FAM_TRANSACTION_TYP;
      ltplNew.C_GAUGE_TYPE_POS              := :new.C_GAUGE_TYPE_POS;
      ltplNew.C_INVOICE_EXPIRY_INPUT_TYPE   := :new.C_INVOICE_EXPIRY_INPUT_TYPE;
      ltplNew.C_POS_CREATE_MODE             := :new.C_POS_CREATE_MODE;
      ltplNew.C_POS_DELIVERY_TYP            := :new.C_POS_DELIVERY_TYP;
      ltplNew.DIC_DIC_UNIT_OF_MEASURE_ID    := :new.DIC_DIC_UNIT_OF_MEASURE_ID;
      ltplNew.DIC_IMP_FREE1_ID              := :new.DIC_IMP_FREE1_ID;
      ltplNew.DIC_IMP_FREE2_ID              := :new.DIC_IMP_FREE2_ID;
      ltplNew.DIC_IMP_FREE3_ID              := :new.DIC_IMP_FREE3_ID;
      ltplNew.DIC_IMP_FREE4_ID              := :new.DIC_IMP_FREE4_ID;
      ltplNew.DIC_IMP_FREE5_ID              := :new.DIC_IMP_FREE5_ID;
      ltplNew.DIC_POS_FREE_TABLE_1_ID       := :new.DIC_POS_FREE_TABLE_1_ID;
      ltplNew.DIC_POS_FREE_TABLE_2_ID       := :new.DIC_POS_FREE_TABLE_2_ID;
      ltplNew.DIC_POS_FREE_TABLE_3_ID       := :new.DIC_POS_FREE_TABLE_3_ID;
      ltplNew.DIC_TARIFF_ID                 := :new.DIC_TARIFF_ID;
      ltplNew.DIC_UNIT_OF_MEASURE_ID        := :new.DIC_UNIT_OF_MEASURE_ID;
      ltplNew.DOC_DOCUMENT_ID               := :new.DOC_DOCUMENT_ID;
      ltplNew.DOC_DOC_POSITION_ID           := :new.DOC_DOC_POSITION_ID;
      ltplNew.DOC_DOC_RECORD_ID             := :new.DOC_DOC_RECORD_ID;
      ltplNew.DOC_EXTRACT_COMMISSION_ID     := :new.DOC_EXTRACT_COMMISSION_ID;
      ltplNew.DOC_GAUGE_ID                  := :new.DOC_GAUGE_ID;
      ltplNew.DOC_GAUGE_POSITION_ID         := :new.DOC_GAUGE_POSITION_ID;
      ltplNew.DOC_INVOICE_EXPIRY_DETAIL_ID  := :new.DOC_INVOICE_EXPIRY_DETAIL_ID;
      ltplNew.DOC_INVOICE_EXPIRY_ID         := :new.DOC_INVOICE_EXPIRY_ID;
      ltplNew.DOC_POSITION_ID               := :new.DOC_POSITION_ID;
      ltplNew.DOC_POS_LITIG_ID              := :new.DOC_POS_LITIG_ID;
      ltplNew.DOC_RECORD_ID                 := :new.DOC_RECORD_ID;
      ltplNew.FAL_LOT_ID                    := :new.FAL_LOT_ID;
      ltplNew.FAL_SCHEDULE_STEP_ID          := :new.FAL_SCHEDULE_STEP_ID;
      ltplNew.FAL_SUPPLY_REQUEST_ID         := :new.FAL_SUPPLY_REQUEST_ID;
      ltplNew.FAM_FIXED_ASSETS_ID           := :new.FAM_FIXED_ASSETS_ID;
      ltplNew.GCO_COMPL_DATA_ID             := :new.GCO_COMPL_DATA_ID;
      ltplNew.GCO_GOOD_ID                   := :new.GCO_GOOD_ID;
      ltplNew.GCO_MANUFACTURED_GOOD_ID      := :new.GCO_MANUFACTURED_GOOD_ID;
      ltplNew.HRM_PERSON_ID                 := :new.HRM_PERSON_ID;
      ltplNew.PAC_PERSON_ID                 := :new.PAC_PERSON_ID;
      ltplNew.PAC_REPRESENTATIVE_ID         := :new.PAC_REPRESENTATIVE_ID;
      ltplNew.PAC_REPR_ACI_ID               := :new.PAC_REPR_ACI_ID;
      ltplNew.PAC_REPR_DELIVERY_ID          := :new.PAC_REPR_DELIVERY_ID;
      ltplNew.PAC_THIRD_ACI_ID              := :new.PAC_THIRD_ACI_ID;
      ltplNew.PAC_THIRD_CDA_ID              := :new.PAC_THIRD_CDA_ID;
      ltplNew.PAC_THIRD_DELIVERY_ID         := :new.PAC_THIRD_DELIVERY_ID;
      ltplNew.PAC_THIRD_ID                  := :new.PAC_THIRD_ID;
      ltplNew.PAC_THIRD_TARIFF_ID           := :new.PAC_THIRD_TARIFF_ID;
      ltplNew.PAC_THIRD_VAT_ID              := :new.PAC_THIRD_VAT_ID;
      ltplNew.PC_APPLTXT_ID                 := :new.PC_APPLTXT_ID;
      ltplNew.POS_ADDENDUM_QTY_BALANCED     := :new.POS_ADDENDUM_QTY_BALANCED;
      ltplNew.POS_ADDENDUM_SRC_POS_ID       := :new.POS_ADDENDUM_SRC_POS_ID;
      ltplNew.POS_ADDENDUM_VALUE_QTY        := :new.POS_ADDENDUM_VALUE_QTY;
      ltplNew.POS_BALANCED                  := :new.POS_BALANCED;
      ltplNew.POS_BALANCE_QTY_VALUE         := :new.POS_BALANCE_QTY_VALUE;
      ltplNew.POS_BALANCE_QUANTITY          := :new.POS_BALANCE_QUANTITY;
      ltplNew.POS_BASIS_QUANTITY            := :new.POS_BASIS_QUANTITY;
      ltplNew.POS_BASIS_QUANTITY_SU         := :new.POS_BASIS_QUANTITY_SU;
      ltplNew.POS_BODY_TEXT                 := :new.POS_BODY_TEXT;
      ltplNew.POS_BUDGET_ACCEPT_DATE        := :new.POS_BUDGET_ACCEPT_DATE;
      ltplNew.POS_BUDGET_COMMENT            := :new.POS_BUDGET_COMMENT;
      ltplNew.POS_BUDGET_EXCEEDED           := :new.POS_BUDGET_EXCEEDED;
      ltplNew.POS_BUDGET_USER_ID            := :new.POS_BUDGET_USER_ID;
      ltplNew.POS_CALC_BUDGET_AMOUNT_MB     := :new.POS_CALC_BUDGET_AMOUNT_MB;
      ltplNew.POS_CHARGE_AMOUNT             := :new.POS_CHARGE_AMOUNT;
      ltplNew.POS_CONVERT_FACTOR            := :new.POS_CONVERT_FACTOR;
      ltplNew.POS_CONVERT_FACTOR2           := :new.POS_CONVERT_FACTOR2;
      ltplNew.POS_CREATE_MAT                := :new.POS_CREATE_MAT;
      ltplNew.POS_CREATE_POSITION_CHARGE    := :new.POS_CREATE_POSITION_CHARGE;
      ltplNew.POS_CUMULATIVE_CHARGE         := :new.POS_CUMULATIVE_CHARGE;
      ltplNew.POS_DATE_1                    := :new.POS_DATE_1;
      ltplNew.POS_DATE_2                    := :new.POS_DATE_2;
      ltplNew.POS_DATE_3                    := :new.POS_DATE_3;
      ltplNew.POS_DATE_BALANCED             := :new.POS_DATE_BALANCED;
      ltplNew.POS_DATE_DELIVERY             := :new.POS_DATE_DELIVERY;
      ltplNew.POS_DATE_PARTNER_DOCUMENT     := :new.POS_DATE_PARTNER_DOCUMENT;
      ltplNew.POS_DECIMAL_1                 := :new.POS_DECIMAL_1;
      ltplNew.POS_DECIMAL_2                 := :new.POS_DECIMAL_2;
      ltplNew.POS_DECIMAL_3                 := :new.POS_DECIMAL_3;
      ltplNew.POS_DISCOUNT_AMOUNT           := :new.POS_DISCOUNT_AMOUNT;
      ltplNew.POS_DISCOUNT_RATE             := :new.POS_DISCOUNT_RATE;
      ltplNew.POS_DISCOUNT_UNIT_VALUE       := :new.POS_DISCOUNT_UNIT_VALUE;
      ltplNew.POS_EAN_CODE                  := :new.POS_EAN_CODE;
      ltplNew.POS_EAN_UCC14_CODE            := :new.POS_EAN_UCC14_CODE;
      ltplNew.POS_EFFECTIVE_DIC_TARIFF_ID   := :new.POS_EFFECTIVE_DIC_TARIFF_ID;
      ltplNew.POS_EFFECT_BUDGET_AMOUNT_MB   := :new.POS_EFFECT_BUDGET_AMOUNT_MB;
      ltplNew.POS_FINAL_QUANTITY            := :new.POS_FINAL_QUANTITY;
      ltplNew.POS_FINAL_QUANTITY_SU         := :new.POS_FINAL_QUANTITY_SU;
      ltplNew.POS_FLAT_RATE                 := :new.POS_FLAT_RATE;
      ltplNew.POS_FREE_DESCRIPTION          := :new.POS_FREE_DESCRIPTION;
      ltplNew.POS_GENERATE_MOVEMENT         := :new.POS_GENERATE_MOVEMENT;
      ltplNew.POS_GENERATE_SUBCO_COMP_MVT   := :new.POS_GENERATE_SUBCO_COMP_MVT;
      ltplNew.POS_GEN_CML_EVENTS            := :new.POS_GEN_CML_EVENTS;
      ltplNew.POS_GROSS_UNIT_VALUE          := :new.POS_GROSS_UNIT_VALUE;
      ltplNew.POS_GROSS_UNIT_VALUE2         := :new.POS_GROSS_UNIT_VALUE2;
      ltplNew.POS_GROSS_UNIT_VALUE_INCL     := :new.POS_GROSS_UNIT_VALUE_INCL;
      ltplNew.POS_GROSS_UNIT_VALUE_INCL_SU  := :new.POS_GROSS_UNIT_VALUE_INCL_SU;
      ltplNew.POS_GROSS_UNIT_VALUE_SU       := :new.POS_GROSS_UNIT_VALUE_SU;
      ltplNew.POS_GROSS_VALUE               := :new.POS_GROSS_VALUE;
      ltplNew.POS_GROSS_VALUE_B             := :new.POS_GROSS_VALUE_B;
      ltplNew.POS_GROSS_VALUE_E             := :new.POS_GROSS_VALUE_E;
      ltplNew.POS_GROSS_VALUE_INCL          := :new.POS_GROSS_VALUE_INCL;
      ltplNew.POS_GROSS_VALUE_INCL_B        := :new.POS_GROSS_VALUE_INCL_B;
      ltplNew.POS_GROSS_VALUE_INCL_E        := :new.POS_GROSS_VALUE_INCL_E;
      ltplNew.POS_GROSS_VALUE_INCL_V        := :new.POS_GROSS_VALUE_INCL_V;
      ltplNew.POS_GROSS_VALUE_V             := :new.POS_GROSS_VALUE_V;
      ltplNew.POS_GROSS_WEIGHT              := :new.POS_GROSS_WEIGHT;
      ltplNew.POS_HIBC_PRIMARY_CODE         := :new.POS_HIBC_PRIMARY_CODE;
      ltplNew.POS_IMF_NUMBER_2              := :new.POS_IMF_NUMBER_2;
      ltplNew.POS_IMF_NUMBER_3              := :new.POS_IMF_NUMBER_3;
      ltplNew.POS_IMF_NUMBER_4              := :new.POS_IMF_NUMBER_4;
      ltplNew.POS_IMF_NUMBER_5              := :new.POS_IMF_NUMBER_5;
      ltplNew.POS_IMF_TEXT_1                := :new.POS_IMF_TEXT_1;
      ltplNew.POS_IMF_TEXT_2                := :new.POS_IMF_TEXT_2;
      ltplNew.POS_IMF_TEXT_3                := :new.POS_IMF_TEXT_3;
      ltplNew.POS_IMF_TEXT_4                := :new.POS_IMF_TEXT_4;
      ltplNew.POS_IMF_TEXT_5                := :new.POS_IMF_TEXT_5;
      ltplNew.POS_IMPUTATION                := :new.POS_IMPUTATION;
      ltplNew.POS_INCLUDE_TAX_TARIFF        := :new.POS_INCLUDE_TAX_TARIFF;
      ltplNew.POS_INTERMEDIATE_QUANTITY     := :new.POS_INTERMEDIATE_QUANTITY;
      ltplNew.POS_INTERMEDIATE_QUANTITY_SU  := :new.POS_INTERMEDIATE_QUANTITY_SU;
      ltplNew.POS_INVOICE_EXPIRY            := :new.POS_INVOICE_EXPIRY;
      ltplNew.POS_LONG_DESCRIPTION          := :new.POS_LONG_DESCRIPTION;
      ltplNew.POS_MODIFY_RATE               := :new.POS_MODIFY_RATE;
      ltplNew.POS_NET_TARIFF                := :new.POS_NET_TARIFF;
      ltplNew.POS_NET_UNIT_VALUE            := :new.POS_NET_UNIT_VALUE;
      ltplNew.POS_NET_UNIT_VALUE_INCL       := :new.POS_NET_UNIT_VALUE_INCL;
      ltplNew.POS_NET_VALUE_EXCL            := :new.POS_NET_VALUE_EXCL;
      ltplNew.POS_NET_VALUE_EXCL_B          := :new.POS_NET_VALUE_EXCL_B;
      ltplNew.POS_NET_VALUE_EXCL_E          := :new.POS_NET_VALUE_EXCL_E;
      ltplNew.POS_NET_VALUE_EXCL_V          := :new.POS_NET_VALUE_EXCL_V;
      ltplNew.POS_NET_VALUE_INCL            := :new.POS_NET_VALUE_INCL;
      ltplNew.POS_NET_VALUE_INCL_B          := :new.POS_NET_VALUE_INCL_B;
      ltplNew.POS_NET_VALUE_INCL_E          := :new.POS_NET_VALUE_INCL_E;
      ltplNew.POS_NET_VALUE_INCL_V          := :new.POS_NET_VALUE_INCL_V;
      ltplNew.POS_NET_WEIGHT                := :new.POS_NET_WEIGHT;
      ltplNew.POS_NOM_TEXT                  := :new.POS_NOM_TEXT;
      ltplNew.POS_NUMBER                    := :new.POS_NUMBER;
      ltplNew.POS_PARENT_CHARGE             := :new.POS_PARENT_CHARGE;
      ltplNew.POS_PARTNER_NUMBER            := :new.POS_PARTNER_NUMBER;
      ltplNew.POS_PARTNER_POS_NUMBER        := :new.POS_PARTNER_POS_NUMBER;
      ltplNew.POS_PARTNER_REFERENCE         := :new.POS_PARTNER_REFERENCE;
      ltplNew.POS_PRICE_TRANSFERED          := :new.POS_PRICE_TRANSFERED;
      ltplNew.POS_QUANTITY_BALANCED         := :new.POS_QUANTITY_BALANCED;
      ltplNew.POS_RATE_FACTOR               := :new.POS_RATE_FACTOR;
      ltplNew.POS_RECALC_AMOUNTS            := :new.POS_RECALC_AMOUNTS;
      ltplNew.POS_REFERENCE                 := :new.POS_REFERENCE;
      ltplNew.POS_REF_UNIT_VALUE            := :new.POS_REF_UNIT_VALUE;
      ltplNew.POS_SECONDARY_REFERENCE       := :new.POS_SECONDARY_REFERENCE;
      ltplNew.POS_SHORT_DESCRIPTION         := :new.POS_SHORT_DESCRIPTION;
      ltplNew.POS_SPECIAL_TARIFF            := :new.POS_SPECIAL_TARIFF;
      ltplNew.POS_STOCK_OUTAGE              := :new.POS_STOCK_OUTAGE;
      ltplNew.POS_TARIFF_DATE               := :new.POS_TARIFF_DATE;
      ltplNew.POS_TARIFF_INITIALIZED        := :new.POS_TARIFF_INITIALIZED;
      ltplNew.POS_TARIFF_SET                := :new.POS_TARIFF_SET;
      ltplNew.POS_TARIFF_UNIT               := :new.POS_TARIFF_UNIT;
      ltplNew.POS_TEXT_1                    := :new.POS_TEXT_1;
      ltplNew.POS_TEXT_2                    := :new.POS_TEXT_2;
      ltplNew.POS_TEXT_3                    := :new.POS_TEXT_3;
      ltplNew.POS_TRANSFERT_PROPRIETOR      := :new.POS_TRANSFERT_PROPRIETOR;
      ltplNew.POS_UNIT_COST_PRICE           := :new.POS_UNIT_COST_PRICE;
      ltplNew.POS_UPDATE_ATTRIB             := :new.POS_UPDATE_ATTRIB;
      ltplNew.POS_UPDATE_OP                 := :new.POS_UPDATE_OP;
      ltplNew.POS_UPDATE_POSITION_CHARGE    := :new.POS_UPDATE_POSITION_CHARGE;
      ltplNew.POS_UPDATE_QTY_PRICE          := :new.POS_UPDATE_QTY_PRICE;
      ltplNew.POS_UPDATE_TARIFF             := :new.POS_UPDATE_TARIFF;
      ltplNew.POS_UTIL_COEFF                := :new.POS_UTIL_COEFF;
      ltplNew.POS_VALUE_QUANTITY            := :new.POS_VALUE_QUANTITY;
      ltplNew.POS_VAT_AMOUNT                := :new.POS_VAT_AMOUNT;
      ltplNew.POS_VAT_AMOUNT_E              := :new.POS_VAT_AMOUNT_E;
      ltplNew.POS_VAT_AMOUNT_V              := :new.POS_VAT_AMOUNT_V;
      ltplNew.POS_VAT_BASE_AMOUNT           := :new.POS_VAT_BASE_AMOUNT;
      ltplNew.POS_VAT_DEDUCTIBLE_RATE       := :new.POS_VAT_DEDUCTIBLE_RATE;
      ltplNew.POS_VAT_LIABLED_AMOUNT        := :new.POS_VAT_LIABLED_AMOUNT;
      ltplNew.POS_VAT_LIABLED_RATE          := :new.POS_VAT_LIABLED_RATE;
      ltplNew.POS_VAT_RATE                  := :new.POS_VAT_RATE;
      ltplNew.POS_VAT_TOTAL_AMOUNT          := :new.POS_VAT_TOTAL_AMOUNT;
      ltplNew.POS_VAT_TOTAL_AMOUNT_B        := :new.POS_VAT_TOTAL_AMOUNT_B;
      ltplNew.POS_VAT_TOTAL_AMOUNT_V        := :new.POS_VAT_TOTAL_AMOUNT_V;
      ltplNew.STM_LOCATION_ID               := :new.STM_LOCATION_ID;
      ltplNew.STM_MOVEMENT_KIND_ID          := :new.STM_MOVEMENT_KIND_ID;
      ltplNew.STM_STM_LOCATION_ID           := :new.STM_STM_LOCATION_ID;
      ltplNew.STM_STM_STOCK_ID              := :new.STM_STM_STOCK_ID;
      ltplNew.STM_STOCK_ID                  := :new.STM_STOCK_ID;
      -- Assignation de TOUS les champs de la table DOC_POSITION
      --   Champs triés par ordre alphabetique
      ltplOld.ACS_CDA_ACCOUNT_ID            := :old.ACS_CDA_ACCOUNT_ID;
      ltplOld.ACS_CPN_ACCOUNT_ID            := :old.ACS_CPN_ACCOUNT_ID;
      ltplOld.ACS_DIVISION_ACCOUNT_ID       := :old.ACS_DIVISION_ACCOUNT_ID;
      ltplOld.ACS_FINANCIAL_ACCOUNT_ID      := :old.ACS_FINANCIAL_ACCOUNT_ID;
      ltplOld.ACS_PF_ACCOUNT_ID             := :old.ACS_PF_ACCOUNT_ID;
      ltplOld.ACS_PJ_ACCOUNT_ID             := :old.ACS_PJ_ACCOUNT_ID;
      ltplOld.ACS_TAX_CODE_ID               := :old.ACS_TAX_CODE_ID;
      ltplOld.ASA_INTERVENTION_DETAIL_ID    := :old.ASA_INTERVENTION_DETAIL_ID;
      ltplOld.ASA_RECORD_COMP_ID            := :old.ASA_RECORD_COMP_ID;
      ltplOld.ASA_RECORD_ID                 := :old.ASA_RECORD_ID;
      ltplOld.ASA_RECORD_TASK_ID            := :old.ASA_RECORD_TASK_ID;
      ltplOld.ASA_RECORD_TASK_IMPUT_ID      := :old.ASA_RECORD_TASK_IMPUT_ID;
      ltplOld.A_CONFIRM                     := :old.A_CONFIRM;
      ltplOld.A_DATECRE                     := :old.A_DATECRE;
      ltplOld.A_DATEMOD                     := :old.A_DATEMOD;
      ltplOld.A_IDCRE                       := :old.A_IDCRE;
      ltplOld.A_IDMOD                       := :old.A_IDMOD;
      ltplOld.A_RECLEVEL                    := :old.A_RECLEVEL;
      ltplOld.A_RECSTATUS                   := :old.A_RECSTATUS;
      ltplOld.CML_EVENTS_ID                 := :old.CML_EVENTS_ID;
      ltplOld.CML_POSITION_ID               := :old.CML_POSITION_ID;
      ltplOld.C_DOC_LOT_TYPE                := :old.C_DOC_LOT_TYPE;
      ltplOld.C_DOC_POS_STATUS              := :old.C_DOC_POS_STATUS;
      ltplOld.C_FAM_TRANSACTION_TYP         := :old.C_FAM_TRANSACTION_TYP;
      ltplOld.C_GAUGE_TYPE_POS              := :old.C_GAUGE_TYPE_POS;
      ltplOld.C_INVOICE_EXPIRY_INPUT_TYPE   := :old.C_INVOICE_EXPIRY_INPUT_TYPE;
      ltplOld.C_POS_CREATE_MODE             := :old.C_POS_CREATE_MODE;
      ltplOld.C_POS_DELIVERY_TYP            := :old.C_POS_DELIVERY_TYP;
      ltplOld.DIC_DIC_UNIT_OF_MEASURE_ID    := :old.DIC_DIC_UNIT_OF_MEASURE_ID;
      ltplOld.DIC_IMP_FREE1_ID              := :old.DIC_IMP_FREE1_ID;
      ltplOld.DIC_IMP_FREE2_ID              := :old.DIC_IMP_FREE2_ID;
      ltplOld.DIC_IMP_FREE3_ID              := :old.DIC_IMP_FREE3_ID;
      ltplOld.DIC_IMP_FREE4_ID              := :old.DIC_IMP_FREE4_ID;
      ltplOld.DIC_IMP_FREE5_ID              := :old.DIC_IMP_FREE5_ID;
      ltplOld.DIC_POS_FREE_TABLE_1_ID       := :old.DIC_POS_FREE_TABLE_1_ID;
      ltplOld.DIC_POS_FREE_TABLE_2_ID       := :old.DIC_POS_FREE_TABLE_2_ID;
      ltplOld.DIC_POS_FREE_TABLE_3_ID       := :old.DIC_POS_FREE_TABLE_3_ID;
      ltplOld.DIC_TARIFF_ID                 := :old.DIC_TARIFF_ID;
      ltplOld.DIC_UNIT_OF_MEASURE_ID        := :old.DIC_UNIT_OF_MEASURE_ID;
      ltplOld.DOC_DOCUMENT_ID               := :old.DOC_DOCUMENT_ID;
      ltplOld.DOC_DOC_POSITION_ID           := :old.DOC_DOC_POSITION_ID;
      ltplOld.DOC_DOC_RECORD_ID             := :old.DOC_DOC_RECORD_ID;
      ltplOld.DOC_EXTRACT_COMMISSION_ID     := :old.DOC_EXTRACT_COMMISSION_ID;
      ltplOld.DOC_GAUGE_ID                  := :old.DOC_GAUGE_ID;
      ltplOld.DOC_GAUGE_POSITION_ID         := :old.DOC_GAUGE_POSITION_ID;
      ltplOld.DOC_INVOICE_EXPIRY_DETAIL_ID  := :old.DOC_INVOICE_EXPIRY_DETAIL_ID;
      ltplOld.DOC_INVOICE_EXPIRY_ID         := :old.DOC_INVOICE_EXPIRY_ID;
      ltplOld.DOC_POSITION_ID               := :old.DOC_POSITION_ID;
      ltplOld.DOC_POS_LITIG_ID              := :old.DOC_POS_LITIG_ID;
      ltplOld.DOC_RECORD_ID                 := :old.DOC_RECORD_ID;
      ltplOld.FAL_LOT_ID                    := :old.FAL_LOT_ID;
      ltplOld.FAL_SCHEDULE_STEP_ID          := :old.FAL_SCHEDULE_STEP_ID;
      ltplOld.FAL_SUPPLY_REQUEST_ID         := :old.FAL_SUPPLY_REQUEST_ID;
      ltplOld.FAM_FIXED_ASSETS_ID           := :old.FAM_FIXED_ASSETS_ID;
      ltplOld.GCO_COMPL_DATA_ID             := :old.GCO_COMPL_DATA_ID;
      ltplOld.GCO_GOOD_ID                   := :old.GCO_GOOD_ID;
      ltplOld.GCO_MANUFACTURED_GOOD_ID      := :old.GCO_MANUFACTURED_GOOD_ID;
      ltplOld.HRM_PERSON_ID                 := :old.HRM_PERSON_ID;
      ltplOld.PAC_PERSON_ID                 := :old.PAC_PERSON_ID;
      ltplOld.PAC_REPRESENTATIVE_ID         := :old.PAC_REPRESENTATIVE_ID;
      ltplOld.PAC_REPR_ACI_ID               := :old.PAC_REPR_ACI_ID;
      ltplOld.PAC_REPR_DELIVERY_ID          := :old.PAC_REPR_DELIVERY_ID;
      ltplOld.PAC_THIRD_ACI_ID              := :old.PAC_THIRD_ACI_ID;
      ltplOld.PAC_THIRD_CDA_ID              := :old.PAC_THIRD_CDA_ID;
      ltplOld.PAC_THIRD_DELIVERY_ID         := :old.PAC_THIRD_DELIVERY_ID;
      ltplOld.PAC_THIRD_ID                  := :old.PAC_THIRD_ID;
      ltplOld.PAC_THIRD_TARIFF_ID           := :old.PAC_THIRD_TARIFF_ID;
      ltplOld.PAC_THIRD_VAT_ID              := :old.PAC_THIRD_VAT_ID;
      ltplOld.PC_APPLTXT_ID                 := :old.PC_APPLTXT_ID;
      ltplOld.POS_ADDENDUM_QTY_BALANCED     := :old.POS_ADDENDUM_QTY_BALANCED;
      ltplOld.POS_ADDENDUM_SRC_POS_ID       := :old.POS_ADDENDUM_SRC_POS_ID;
      ltplOld.POS_ADDENDUM_VALUE_QTY        := :old.POS_ADDENDUM_VALUE_QTY;
      ltplOld.POS_BALANCED                  := :old.POS_BALANCED;
      ltplOld.POS_BALANCE_QTY_VALUE         := :old.POS_BALANCE_QTY_VALUE;
      ltplOld.POS_BALANCE_QUANTITY          := :old.POS_BALANCE_QUANTITY;
      ltplOld.POS_BASIS_QUANTITY            := :old.POS_BASIS_QUANTITY;
      ltplOld.POS_BASIS_QUANTITY_SU         := :old.POS_BASIS_QUANTITY_SU;
      ltplOld.POS_BODY_TEXT                 := :old.POS_BODY_TEXT;
      ltplOld.POS_BUDGET_ACCEPT_DATE        := :old.POS_BUDGET_ACCEPT_DATE;
      ltplOld.POS_BUDGET_COMMENT            := :old.POS_BUDGET_COMMENT;
      ltplOld.POS_BUDGET_EXCEEDED           := :old.POS_BUDGET_EXCEEDED;
      ltplOld.POS_BUDGET_USER_ID            := :old.POS_BUDGET_USER_ID;
      ltplOld.POS_CALC_BUDGET_AMOUNT_MB     := :old.POS_CALC_BUDGET_AMOUNT_MB;
      ltplOld.POS_CHARGE_AMOUNT             := :old.POS_CHARGE_AMOUNT;
      ltplOld.POS_CONVERT_FACTOR            := :old.POS_CONVERT_FACTOR;
      ltplOld.POS_CONVERT_FACTOR2           := :old.POS_CONVERT_FACTOR2;
      ltplOld.POS_CREATE_MAT                := :old.POS_CREATE_MAT;
      ltplOld.POS_CREATE_POSITION_CHARGE    := :old.POS_CREATE_POSITION_CHARGE;
      ltplOld.POS_CUMULATIVE_CHARGE         := :old.POS_CUMULATIVE_CHARGE;
      ltplOld.POS_DATE_1                    := :old.POS_DATE_1;
      ltplOld.POS_DATE_2                    := :old.POS_DATE_2;
      ltplOld.POS_DATE_3                    := :old.POS_DATE_3;
      ltplOld.POS_DATE_BALANCED             := :old.POS_DATE_BALANCED;
      ltplOld.POS_DATE_DELIVERY             := :old.POS_DATE_DELIVERY;
      ltplOld.POS_DATE_PARTNER_DOCUMENT     := :old.POS_DATE_PARTNER_DOCUMENT;
      ltplOld.POS_DECIMAL_1                 := :old.POS_DECIMAL_1;
      ltplOld.POS_DECIMAL_2                 := :old.POS_DECIMAL_2;
      ltplOld.POS_DECIMAL_3                 := :old.POS_DECIMAL_3;
      ltplOld.POS_DISCOUNT_AMOUNT           := :old.POS_DISCOUNT_AMOUNT;
      ltplOld.POS_DISCOUNT_RATE             := :old.POS_DISCOUNT_RATE;
      ltplOld.POS_DISCOUNT_UNIT_VALUE       := :old.POS_DISCOUNT_UNIT_VALUE;
      ltplOld.POS_EAN_CODE                  := :old.POS_EAN_CODE;
      ltplOld.POS_EAN_UCC14_CODE            := :old.POS_EAN_UCC14_CODE;
      ltplOld.POS_EFFECTIVE_DIC_TARIFF_ID   := :old.POS_EFFECTIVE_DIC_TARIFF_ID;
      ltplOld.POS_EFFECT_BUDGET_AMOUNT_MB   := :old.POS_EFFECT_BUDGET_AMOUNT_MB;
      ltplOld.POS_FINAL_QUANTITY            := :old.POS_FINAL_QUANTITY;
      ltplOld.POS_FINAL_QUANTITY_SU         := :old.POS_FINAL_QUANTITY_SU;
      ltplOld.POS_FLAT_RATE                 := :old.POS_FLAT_RATE;
      ltplOld.POS_FREE_DESCRIPTION          := :old.POS_FREE_DESCRIPTION;
      ltplOld.POS_GENERATE_MOVEMENT         := :old.POS_GENERATE_MOVEMENT;
      ltplOld.POS_GENERATE_SUBCO_COMP_MVT   := :old.POS_GENERATE_SUBCO_COMP_MVT;
      ltplOld.POS_GEN_CML_EVENTS            := :old.POS_GEN_CML_EVENTS;
      ltplOld.POS_GROSS_UNIT_VALUE          := :old.POS_GROSS_UNIT_VALUE;
      ltplOld.POS_GROSS_UNIT_VALUE2         := :old.POS_GROSS_UNIT_VALUE2;
      ltplOld.POS_GROSS_UNIT_VALUE_INCL     := :old.POS_GROSS_UNIT_VALUE_INCL;
      ltplOld.POS_GROSS_UNIT_VALUE_INCL_SU  := :old.POS_GROSS_UNIT_VALUE_INCL_SU;
      ltplOld.POS_GROSS_UNIT_VALUE_SU       := :old.POS_GROSS_UNIT_VALUE_SU;
      ltplOld.POS_GROSS_VALUE               := :old.POS_GROSS_VALUE;
      ltplOld.POS_GROSS_VALUE_B             := :old.POS_GROSS_VALUE_B;
      ltplOld.POS_GROSS_VALUE_E             := :old.POS_GROSS_VALUE_E;
      ltplOld.POS_GROSS_VALUE_INCL          := :old.POS_GROSS_VALUE_INCL;
      ltplOld.POS_GROSS_VALUE_INCL_B        := :old.POS_GROSS_VALUE_INCL_B;
      ltplOld.POS_GROSS_VALUE_INCL_E        := :old.POS_GROSS_VALUE_INCL_E;
      ltplOld.POS_GROSS_VALUE_INCL_V        := :old.POS_GROSS_VALUE_INCL_V;
      ltplOld.POS_GROSS_VALUE_V             := :old.POS_GROSS_VALUE_V;
      ltplOld.POS_GROSS_WEIGHT              := :old.POS_GROSS_WEIGHT;
      ltplOld.POS_HIBC_PRIMARY_CODE         := :old.POS_HIBC_PRIMARY_CODE;
      ltplOld.POS_IMF_NUMBER_2              := :old.POS_IMF_NUMBER_2;
      ltplOld.POS_IMF_NUMBER_3              := :old.POS_IMF_NUMBER_3;
      ltplOld.POS_IMF_NUMBER_4              := :old.POS_IMF_NUMBER_4;
      ltplOld.POS_IMF_NUMBER_5              := :old.POS_IMF_NUMBER_5;
      ltplOld.POS_IMF_TEXT_1                := :old.POS_IMF_TEXT_1;
      ltplOld.POS_IMF_TEXT_2                := :old.POS_IMF_TEXT_2;
      ltplOld.POS_IMF_TEXT_3                := :old.POS_IMF_TEXT_3;
      ltplOld.POS_IMF_TEXT_4                := :old.POS_IMF_TEXT_4;
      ltplOld.POS_IMF_TEXT_5                := :old.POS_IMF_TEXT_5;
      ltplOld.POS_IMPUTATION                := :old.POS_IMPUTATION;
      ltplOld.POS_INCLUDE_TAX_TARIFF        := :old.POS_INCLUDE_TAX_TARIFF;
      ltplOld.POS_INTERMEDIATE_QUANTITY     := :old.POS_INTERMEDIATE_QUANTITY;
      ltplOld.POS_INTERMEDIATE_QUANTITY_SU  := :old.POS_INTERMEDIATE_QUANTITY_SU;
      ltplOld.POS_INVOICE_EXPIRY            := :old.POS_INVOICE_EXPIRY;
      ltplOld.POS_LONG_DESCRIPTION          := :old.POS_LONG_DESCRIPTION;
      ltplOld.POS_MODIFY_RATE               := :old.POS_MODIFY_RATE;
      ltplOld.POS_NET_TARIFF                := :old.POS_NET_TARIFF;
      ltplOld.POS_NET_UNIT_VALUE            := :old.POS_NET_UNIT_VALUE;
      ltplOld.POS_NET_UNIT_VALUE_INCL       := :old.POS_NET_UNIT_VALUE_INCL;
      ltplOld.POS_NET_VALUE_EXCL            := :old.POS_NET_VALUE_EXCL;
      ltplOld.POS_NET_VALUE_EXCL_B          := :old.POS_NET_VALUE_EXCL_B;
      ltplOld.POS_NET_VALUE_EXCL_E          := :old.POS_NET_VALUE_EXCL_E;
      ltplOld.POS_NET_VALUE_EXCL_V          := :old.POS_NET_VALUE_EXCL_V;
      ltplOld.POS_NET_VALUE_INCL            := :old.POS_NET_VALUE_INCL;
      ltplOld.POS_NET_VALUE_INCL_B          := :old.POS_NET_VALUE_INCL_B;
      ltplOld.POS_NET_VALUE_INCL_E          := :old.POS_NET_VALUE_INCL_E;
      ltplOld.POS_NET_VALUE_INCL_V          := :old.POS_NET_VALUE_INCL_V;
      ltplOld.POS_NET_WEIGHT                := :old.POS_NET_WEIGHT;
      ltplOld.POS_NOM_TEXT                  := :old.POS_NOM_TEXT;
      ltplOld.POS_NUMBER                    := :old.POS_NUMBER;
      ltplOld.POS_PARENT_CHARGE             := :old.POS_PARENT_CHARGE;
      ltplOld.POS_PARTNER_NUMBER            := :old.POS_PARTNER_NUMBER;
      ltplOld.POS_PARTNER_POS_NUMBER        := :old.POS_PARTNER_POS_NUMBER;
      ltplOld.POS_PARTNER_REFERENCE         := :old.POS_PARTNER_REFERENCE;
      ltplOld.POS_PRICE_TRANSFERED          := :old.POS_PRICE_TRANSFERED;
      ltplOld.POS_QUANTITY_BALANCED         := :old.POS_QUANTITY_BALANCED;
      ltplOld.POS_RATE_FACTOR               := :old.POS_RATE_FACTOR;
      ltplOld.POS_RECALC_AMOUNTS            := :old.POS_RECALC_AMOUNTS;
      ltplOld.POS_REFERENCE                 := :old.POS_REFERENCE;
      ltplOld.POS_REF_UNIT_VALUE            := :old.POS_REF_UNIT_VALUE;
      ltplOld.POS_SECONDARY_REFERENCE       := :old.POS_SECONDARY_REFERENCE;
      ltplOld.POS_SHORT_DESCRIPTION         := :old.POS_SHORT_DESCRIPTION;
      ltplOld.POS_SPECIAL_TARIFF            := :old.POS_SPECIAL_TARIFF;
      ltplOld.POS_STOCK_OUTAGE              := :old.POS_STOCK_OUTAGE;
      ltplOld.POS_TARIFF_DATE               := :old.POS_TARIFF_DATE;
      ltplOld.POS_TARIFF_INITIALIZED        := :old.POS_TARIFF_INITIALIZED;
      ltplOld.POS_TARIFF_SET                := :old.POS_TARIFF_SET;
      ltplOld.POS_TARIFF_UNIT               := :old.POS_TARIFF_UNIT;
      ltplOld.POS_TEXT_1                    := :old.POS_TEXT_1;
      ltplOld.POS_TEXT_2                    := :old.POS_TEXT_2;
      ltplOld.POS_TEXT_3                    := :old.POS_TEXT_3;
      ltplOld.POS_TRANSFERT_PROPRIETOR      := :old.POS_TRANSFERT_PROPRIETOR;
      ltplOld.POS_UNIT_COST_PRICE           := :old.POS_UNIT_COST_PRICE;
      ltplOld.POS_UPDATE_ATTRIB             := :old.POS_UPDATE_ATTRIB;
      ltplOld.POS_UPDATE_OP                 := :old.POS_UPDATE_OP;
      ltplOld.POS_UPDATE_POSITION_CHARGE    := :old.POS_UPDATE_POSITION_CHARGE;
      ltplOld.POS_UPDATE_QTY_PRICE          := :old.POS_UPDATE_QTY_PRICE;
      ltplOld.POS_UPDATE_TARIFF             := :old.POS_UPDATE_TARIFF;
      ltplOld.POS_UTIL_COEFF                := :old.POS_UTIL_COEFF;
      ltplOld.POS_VALUE_QUANTITY            := :old.POS_VALUE_QUANTITY;
      ltplOld.POS_VAT_AMOUNT                := :old.POS_VAT_AMOUNT;
      ltplOld.POS_VAT_AMOUNT_E              := :old.POS_VAT_AMOUNT_E;
      ltplOld.POS_VAT_AMOUNT_V              := :old.POS_VAT_AMOUNT_V;
      ltplOld.POS_VAT_BASE_AMOUNT           := :old.POS_VAT_BASE_AMOUNT;
      ltplOld.POS_VAT_DEDUCTIBLE_RATE       := :old.POS_VAT_DEDUCTIBLE_RATE;
      ltplOld.POS_VAT_LIABLED_AMOUNT        := :old.POS_VAT_LIABLED_AMOUNT;
      ltplOld.POS_VAT_LIABLED_RATE          := :old.POS_VAT_LIABLED_RATE;
      ltplOld.POS_VAT_RATE                  := :old.POS_VAT_RATE;
      ltplOld.POS_VAT_TOTAL_AMOUNT          := :old.POS_VAT_TOTAL_AMOUNT;
      ltplOld.POS_VAT_TOTAL_AMOUNT_B        := :old.POS_VAT_TOTAL_AMOUNT_B;
      ltplOld.POS_VAT_TOTAL_AMOUNT_V        := :old.POS_VAT_TOTAL_AMOUNT_V;
      ltplOld.STM_LOCATION_ID               := :old.STM_LOCATION_ID;
      ltplOld.STM_MOVEMENT_KIND_ID          := :old.STM_MOVEMENT_KIND_ID;
      ltplOld.STM_STM_LOCATION_ID           := :old.STM_STM_LOCATION_ID;
      ltplOld.STM_STM_STOCK_ID              := :old.STM_STM_STOCK_ID;
      ltplOld.STM_STOCK_ID                  := :old.STM_STOCK_ID;
      --
      -- Journaliser position
      DOC_JOURNAL_FUNCTIONS.JournalizePosition(aCode => lvJournalCode, aOldPos => ltplOld, aNewPos => ltplNew);

      if lvJournalCode = 'DISCHARGED' then
        DOC_JOURNAL_FUNCTIONS.CURRENT_TRANSACTION  := null;
        DOC_JOURNAL_FUNCTIONS.DISCH_SRC_POS_ID     := null;
      end if;
    end if;
  end if;
end DOC_POS_AU_JOURNAL;

ALTER TRIGGER "C_ITX"."DOC_POS_AU_JOURNAL" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_AU_MULTISOURCING"
  after update of POS_NET_VALUE_EXCL, POS_FINAL_QUANTITY_SU
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Déclenche le traitement de mise à jour du multi-sourcing réalisé. Les règles suivantes doivent être respectées :
*
*    1. Le bien doit gérer le multi-sourcing (GCO_PRODUCT.PDT_MULTI_SOURCING = 1).
*    2. Le gabarit doit gérer le multi-sourcing (DOC_GAUGE_STRUCTURED.GAS_MULTISOURCING_MGM = 1).
*    3. Au moins un détail de position doit exister.
*    4. La valeur net de la position doit changer mais pas la quantité finale de la position. Si la quantité change
*       également, la mise à jour du multi-sourcing réalisé se fera dans le trigger de la table des détails de
*       position (DOC_PDE_AU_MULTISOURCING) à la modification de la quantité du détail.
*
* @author VJ
* @created 14/03/2005
* @version 2003
*/
declare
  cursor crPositionDetail(cPositionID number)
  is
    select PDE.PDE_FINAL_QUANTITY_SU
         , PDE.GCO_GCO_GOOD_ID
         , PDE.DOC_POSITION_DETAIL_ID
      from DOC_POSITION_DETAIL PDE
         , GCO_PRODUCT PDT
         , DOC_GAUGE_STRUCTURED GAS
     where PDE.DOC_POSITION_ID = cPositionID
       and PDT.GCO_GOOD_ID = PDE.GCO_GOOD_ID
       and nvl(PDT.PDT_MULTI_SOURCING, 0) = 1
       and GAS.DOC_GAUGE_ID = PDE.DOC_GAUGE_ID
       and nvl(GAS.GAS_MULTISOURCING_MGM, 0) = 1
       and nvl(PDE.PDE_FINAL_QUANTITY_SU, 0) <> 0;

  oldPosNetUnitValueExclB DOC_POSITION.POS_NET_UNIT_VALUE%type;
  newPosNetUnitValueExclB DOC_POSITION.POS_NET_UNIT_VALUE%type;
  strInfo                 varchar2(2000);
begin
  if     :new.GCO_GOOD_ID is not null
     and (nvl(:old.POS_NET_VALUE_EXCL_B, 0) <> nvl(:new.POS_NET_VALUE_EXCL_B, 0) )
     and (nvl(:old.POS_FINAL_QUANTITY_SU, 0) = nvl(:new.POS_FINAL_QUANTITY_SU, 0) ) then
    select decode(nvl(:old.POS_FINAL_QUANTITY_SU, 0), 0, 0, :old.POS_NET_VALUE_EXCL_B / :old.POS_FINAL_QUANTITY_SU)
                                                                                              POS_NET_UNIT_VALUE_EXCL_B
      into oldPosNetUnitValueExclB
      from dual;

    select decode(nvl(:new.POS_FINAL_QUANTITY_SU, 0), 0, 0, :new.POS_NET_VALUE_EXCL_B / :new.POS_FINAL_QUANTITY_SU)
                                                                                              POS_NET_UNIT_VALUE_EXCL_B
      into newPosNetUnitValueExclB
      from dual;

    -- Traite tous les détails de position liées à un produit gérant le multi-sourcing
    for tplPositionDetail in crPositionDetail(:new.DOC_POSITION_ID) loop
      if false then
        strInfo  :=
          'DOC_POS_AU_MULTISOURCING' ||
          chr(13) ||
          chr(13) ||
          'Document : ' ||
          :new.DOC_DOCUMENT_ID ||
          chr(13) ||
          'Bien : ' ||
          :new.GCO_GOOD_ID ||
          chr(13) ||
          'Ancien prix unitaire net ht : ' ||
          oldPosNetUnitValueExclB ||
          chr(13) ||
          'Nouveau prix unitaire net ht : ' ||
          newPosNetUnitValueExclB ||
          chr(13) ||
          'Quantité : ' ||
          tplPositionDetail.PDE_FINAL_QUANTITY_SU ||
          chr(13) ||
          'Ancien montant : ' ||
          oldPosNetUnitValueExclB * tplPositionDetail.PDE_FINAL_QUANTITY_SU ||
          chr(13) ||
          'Nouveau montant : ' ||
          newPosNetUnitValueExclB * tplPositionDetail.PDE_FINAL_QUANTITY_SU;
        DOC_FUNCTIONS.CreateHistoryInformation(:new.DOC_DOCUMENT_ID
                                             , :new.DOC_POSITION_ID   -- DOC_POSITION_ID
                                             , 'MULTISOURCING'   -- no de document
                                             , 'PLSQL'   -- DUH_TYPE
                                             , 'Getting detail informations DOC_POS_AU_MULTISOURCING : ' ||
                                               tplPositionDetail.DOC_POSITION_DETAIL_ID
                                             , strInfo   -- description libre
                                             , null   -- status document
                                             , null   -- status position
                                              );
      end if;

      --
      -- Mise à jour du réalisé en multi-sourcing
      --
      FAL_MSOURCING_FUNCTIONS.UpdateMultiSourcingRealized(:new.DOC_DOCUMENT_ID
                                                        , :new.GCO_GOOD_ID
                                                        , tplPositionDetail.GCO_GCO_GOOD_ID
                                                        , tplPositionDetail.GCO_GCO_GOOD_ID
                                                        , tplPositionDetail.PDE_FINAL_QUANTITY_SU
                                                        , tplPositionDetail.PDE_FINAL_QUANTITY_SU
                                                        , newPosNetUnitValueExclB
                                                        , oldPosNetUnitValueExclB
                                                         );
    end loop;
  end if;
end DOC_POS_AU_MULTISOURCING;


ALTER TRIGGER "C_ITX"."DOC_POS_AU_MULTISOURCING" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_AU_SQM_PENALTY"
  after update of POS_NET_UNIT_VALUE
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des notes des détails de position lors de la mise
*    à jour du prix de la position cible
* @author DSA
* @version 2003
*/
declare
  vEffValue  SQM_PENALTY.SPE_EFFECTIVE_VALUE%type;
  vAxisValue SQM_PENALTY.SPE_INIT_VALUE%type;
begin
  if PCS.PC_CONFIG.GETCONFIG('SQM_QUALITY_MGM') = '1' then
    if :new.POS_NET_UNIT_VALUE <> :old.POS_NET_UNIT_VALUE then
      -- Pour éviter l'exception table_is_mutating on stocke la nouvelle valeur du prix dans une variable...
      SQM_INIT_METHOD.PosNetUnitValue    := :new.POS_NET_UNIT_VALUE;
      SQM_INIT_METHOD.PosFinalQuantity   := :new.POS_FINAL_QUANTITY;
      SQM_INIT_METHOD.PosNetUnitValBase  := :new.POS_NET_VALUE_EXCL_B;

      --... et la valeur de la date du document
      select DMT_DATE_DOCUMENT
           , ACS_FINANCIAL_CURRENCY_ID
           , case
               when DMT_BASE_PRICE = 0 then 0
               else DMT_RATE_OF_EXCHANGE / DMT_BASE_PRICE
             end
           , DMT_BASE_PRICE
        into SQM_INIT_METHOD.dtDateDoc
           , SQM_INIT_METHOD.DocLocalCurrencyId
           , SQM_INIT_METHOD.DocRateofExchInv
           , SQM_INIT_METHOD.DocBasePrice
        from DOC_DOCUMENT
       where DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID;

      -- Recalcule des notes (axes actifs et notes automatiques) de tous les détails de la position
      for cr_axis in (select SQM_FUNCTIONS.GetFirstFitScale(SPE.SQM_AXIS_ID, SPE.SPE_DATE_REFERENCE, SPE.GCO_GOOD_ID) SQM_SCALE_ID
                           , SPE.SQM_AXIS_ID
                           , SPE.DOC_POSITION_DETAIL_ID
                           , SPE.GCO_GOOD_ID
                           , SPE.SQM_PENALTY_ID
                           , SPE.SPE_EXPECTED_VALUE
                        from SQM_PENALTY SPE
                           , SQM_AXIS SAX
                       where SPE.DOC_POSITION_ID = :new.DOC_POSITION_ID
                         and SAX.SQM_AXIS_ID = SPE.SQM_AXIS_ID
                         and SAX.C_AXIS_STATUS = 'ACT'
                         and SPE.SPE_MANUAL_PENALTY = 0) loop
        SQM_INIT_METHOD.CalcAxisValue(cr_axis.SQM_AXIS_ID, cr_axis.SPE_EXPECTED_VALUE, vEffValue, vAxisValue, cr_axis.DOC_POSITION_DETAIL_ID);

        update SQM_PENALTY
           set SQM_SCALE_ID = cr_axis.SQM_SCALE_ID
             , SPE_CALC_PENALTY = SQM_FUNCTIONS.CalcPenalty(cr_axis.SQM_SCALE_ID, vAxisValue)
             , SPE_EXPECTED_VALUE = cr_axis.SPE_EXPECTED_VALUE
             , SPE_EFFECTIVE_VALUE = vEffValue
             , SPE_INIT_VALUE = vAxisValue
             , A_DATEMOD = sysdate
             , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
         where SQM_PENALTY_ID = cr_axis.SQM_PENALTY_ID;
      end loop;
    end if;
  end if;
end DOC_POS_AU_SQM_PENALTY;

ALTER TRIGGER "C_ITX"."DOC_POS_AU_SQM_PENALTY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_AU_SQM_PENALTY_STATUS"
  after update of C_DOC_POS_STATUS
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*     Mise à jour du statut des criticités correspondant à la position
*     lors de la confirmation de la position
* @author DSA
* @version 2003
*/
begin
  if :new.C_DOC_POS_STATUS <> '01' then
    update SQM_PENALTY
       set C_PENALTY_STATUS = 'CONF'
         , A_DATEMOD = sysdate
         , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
     where DOC_POSITION_ID = :new.DOC_POSITION_ID;
  end if;
end DOC_POS_AU_SQM_PENALTY_STATUS;

ALTER TRIGGER "C_ITX"."DOC_POS_AU_SQM_PENALTY_STATUS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_AU_VAT"
  after update of ACS_TAX_CODE_ID
                , C_DOC_POS_STATUS
                , C_GAUGE_TYPE_POS
                , DOC_DOCUMENT_ID
                , POS_NET_VALUE_EXCL
                , POS_VAT_RATE
                , POS_VAT_TOTAL_AMOUNT
                , POS_VAT_AMOUNT
                , POS_VAT_BASE_AMOUNT
                , POS_VAT_AMOUNT_E
                , POS_VAT_AMOUNT_V
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour du récapitulatif TVA des position
* @author Fabrice Perotto - Joffroy Christen
* @version 10
* @lastUpdate 03.11.2010
*/
begin
  if :old.C_DOC_POS_STATUS <> '05' then
    -- Mise à jour du récapitulatif TVA des positions
    -- Retrait des anciennes valeurs
    DOC_PRC_VAT.UpdatePositionVat(:old.DOC_DOCUMENT_ID
                                , :old.C_GAUGE_TYPE_POS
                                , :old.ACS_TAX_CODE_ID
                                , :old.POS_NET_VALUE_EXCL
                                , :old.POS_NET_VALUE_EXCL_B
                                , :old.POS_NET_VALUE_EXCL_V
                                , :old.POS_VAT_RATE
                                , :old.POS_VAT_TOTAL_AMOUNT
                                , :old.POS_VAT_TOTAL_AMOUNT_B
                                , :old.POS_VAT_TOTAL_AMOUNT_V
                                , :old.POS_VAT_AMOUNT
                                , :old.POS_VAT_BASE_AMOUNT
                                , :old.POS_VAT_AMOUNT_V
                                , -1
                                 );
  end if;

  if :new.C_DOC_POS_STATUS <> '05' then
    -- Ajout des nouvelles valeurs
    DOC_PRC_VAT.UpdatePositionVat(:new.DOC_DOCUMENT_ID
                                , :new.C_GAUGE_TYPE_POS
                                , :new.ACS_TAX_CODE_ID
                                , :new.POS_NET_VALUE_EXCL
                                , :new.POS_NET_VALUE_EXCL_B
                                , :new.POS_NET_VALUE_EXCL_V
                                , :new.POS_VAT_RATE
                                , :new.POS_VAT_TOTAL_AMOUNT
                                , :new.POS_VAT_TOTAL_AMOUNT_B
                                , :new.POS_VAT_TOTAL_AMOUNT_V
                                , :new.POS_VAT_AMOUNT
                                , :new.POS_VAT_BASE_AMOUNT
                                , :new.POS_VAT_AMOUNT_V
                                , 1
                                 );
  end if;
end DOC_POS_AU_VAT;

ALTER TRIGGER "C_ITX"."DOC_POS_AU_VAT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_BD_FORNETWORK"
  before delete
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Appel la suppression de chaque détail position
*    pour contourner le problème "Table Is Mutating"
* @created DJEANNERET
* @version 2003
* @lastUpdate
*/
declare
  -- curseur sur tous les detail position de la position
  cursor detail_position_cursor(position_id NUMBER) is
    select DET.*
    from DOC_POSITION_DETAIL DET
    where DET.DOC_POSITION_ID = position_id;

  detail_position_tuple detail_position_cursor%rowtype;

begin
  -- ouverture du curseur sur les details de position
  Open detail_position_cursor(:OLD.DOC_POSITION_ID);
  LOOP
    fetch detail_position_cursor into detail_position_tuple;

  	-- Appel du graph d'événements "Delete DétailPosition"

    FAL_NETWORK_DOC.TRT_DOC_PDE_AD_FORNETWORK(
        detail_position_tuple.DOC_POSITION_DETAIL_ID
  	  , :OLD.C_GAUGE_TYPE_POS
  		, :OLD.POS_TRANSFERT_PROPRIETOR
  		, detail_position_tuple.STM_LOCATION_ID
  		, detail_position_tuple.PDE_BASIS_DELAY
  		, detail_position_tuple.PAC_THIRD_ID
  		, detail_position_tuple.PDE_BALANCE_QUANTITY
  		, detail_position_tuple.DOC_DOCUMENT_ID
  		, :OLD.DOC_GAUGE_ID
  		, :OLD.GCO_GOOD_ID
  		, :OLD.PAC_REPRESENTATIVE_ID
  		);

    exit when detail_position_cursor%Notfound;
  end loop;
  close detail_position_cursor;

end DOC_POS_BD_FORNETWORK;

ALTER TRIGGER "C_ITX"."DOC_POS_BD_FORNETWORK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_BD_MAJ_SUBCONTRACT"
  before delete
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des opérations après effacement d'une position
* @author Fabrice Perotto
* @created 27.4.2000
* @version 2003
* @lastUpdate 06.11.2007
*/
declare
  -- Curseur sur les détails de position
  cursor crPositionDetail(position_id number, gauge_type_pos varchar2)
  is
    select PDE.FAL_SCHEDULE_STEP_ID
         , nvl(ACS_FUNCTION.RoundNear(PDE.PDE_BALANCE_QUANTITY * nvl(CDA.CDA_CONVERSION_FACTOR, 1)
                                    , 1 /
                                      power(10
                                          , nvl(GCO_FUNCTIONS.GETCDADECIMAL(PDE.GCO_GOOD_ID
                                                                          , 'PURCHASE'
                                                                          , PDE.PAC_THIRD_ID
                                                                           )
                                              , 0
                                               )
                                           )
                                    , -1
                                     )
             , PDE.PDE_BALANCE_QUANTITY
              ) PDE_BALANCE_QUANTITY
      from DOC_POSITION_DETAIL PDE
         , DOC_GAUGE GAU
         , GCO_COMPL_DATA_PURCHASE CDA
     where GAU.DOC_GAUGE_ID = PDE.DOC_GAUGE_ID
       and PDE.DOC_POSITION_ID = position_id
       and PDE.PAC_THIRD_ID = CDA.PAC_SUPPLIER_PARTNER_ID(+)
       and PDE.GCO_GOOD_ID = CDA.GCO_GOOD_ID(+)
       and instr(PCS.PC_CONFIG.GetConfig('DOC_GAUGE_OP_SUBCONTRACT'), GAU.DIC_GAUGE_TYPE_DOC_ID) > 0
       and PDE.FAL_SCHEDULE_STEP_ID is not null
       and GAUGE_TYPE_POS <> '3';

begin

  for tplPositionDetail in crPositionDetail(:old.DOC_POSITION_ID, :old.C_GAUGE_TYPE_POS) loop
    -- Appel de la procédure stockée de mise-à-jour opération suppression
    FAL_CMD_SUPPLIER_PARTNER.MAJ_OP_generation_suppression(tplPositionDetail.FAL_SCHEDULE_STEP_ID
                                                         , tplPositionDetail.PDE_BALANCE_QUANTITY
                                                          );

  end loop;

end DOC_POS_BD_MAJ_SUBCONTRACT;

ALTER TRIGGER "C_ITX"."DOC_POS_BD_MAJ_SUBCONTRACT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_BD_MULTISOURCING"
  before delete
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Déclenche le traitement de mise à jour du multi-sourcing réalisé. Les règles suivantes doivent être respectées :
*
*    1. Le bien doit gérer le multi-sourcing (GCO_PRODUCT.PDT_MULTI_SOURCING = 1).
*    2. Le gabarit doit gérer le multi-sourcing (DOC_GAUGE_STRUCTURED.GAS_MULTISOURCING_MGM = 1).
*    3. Au moins un détail de position doit exister.
*
* @author VJ
* @created 31/03/2005
* @version 2003
*/
declare
  cursor crPositionDetail(cPositionID number)
  is
    select PDE.PDE_FINAL_QUANTITY_SU
         , PDE.GCO_GCO_GOOD_ID
         , PDE.DOC_POSITION_DETAIL_ID
      from DOC_POSITION_DETAIL PDE
         , GCO_PRODUCT PDT
         , DOC_GAUGE_STRUCTURED GAS
     where PDE.DOC_POSITION_ID = cPositionID
       and PDT.GCO_GOOD_ID = PDE.GCO_GOOD_ID
       and nvl(PDT.PDT_MULTI_SOURCING, 0) = 1
       and GAS.DOC_GAUGE_ID = PDE.DOC_GAUGE_ID
       and nvl(GAS.GAS_MULTISOURCING_MGM, 0) = 1
       and nvl(PDE.PDE_FINAL_QUANTITY_SU, 0) <> 0;

  posNetUnitValueExclB DOC_POSITION.POS_NET_UNIT_VALUE%type;
  strInfo              varchar2(2000);
begin
  if :old.GCO_GOOD_ID is not null then
    select decode(nvl(:old.POS_FINAL_QUANTITY_SU, 0), 0, 0, :old.POS_NET_VALUE_EXCL_B / :old.POS_FINAL_QUANTITY_SU)
                                                                                              POS_NET_UNIT_VALUE_EXCL_B
      into posNetUnitValueExclB
      from dual;

    if posNetUnitValueExclB is not null then
      -- Traite tous les détails de position liées à un produit gérant le multi-sourcing
      for tplPositionDetail in crPositionDetail(:old.DOC_POSITION_ID) loop
        if false then
          strInfo  :=
            'DOC_POS_BD_MULTISOURCING' ||
            chr(13) ||
            chr(13) ||
            'Document : ' ||
            :old.DOC_DOCUMENT_ID ||
            chr(13) ||
            'Bien : ' ||
            :old.GCO_GOOD_ID ||
            chr(13) ||
            'Prix unitaire net ht : ' ||
            posNetUnitValueExclB ||
            chr(13) ||
            'Quantité : ' ||
            tplPositionDetail.PDE_FINAL_QUANTITY_SU ||
            chr(13) ||
            'Montant : ' ||
            posNetUnitValueExclB * tplPositionDetail.PDE_FINAL_QUANTITY_SU;
          DOC_FUNCTIONS.CreateHistoryInformation(:old.DOC_DOCUMENT_ID
                                               , :old.DOC_POSITION_ID   -- DOC_POSITION_ID
                                               , 'MULTISOURCING'   -- no de document
                                               , 'PLSQL'   -- DUH_TYPE
                                               , 'Getting detail informations DOC_POS_BD_MULTISOURCING : ' ||
                                                 tplPositionDetail.DOC_POSITION_DETAIL_ID
                                               , strInfo   -- description libre
                                               , null   -- status document
                                               , null   -- status position
                                                );
        end if;

        --
        -- Mise à jour du réalisé en multi-sourcing
        --
        FAL_MSOURCING_FUNCTIONS.UpdateMultiSourcingRealized(:old.DOC_DOCUMENT_ID
                                                          , :old.GCO_GOOD_ID
                                                          , tplPositionDetail.GCO_GCO_GOOD_ID
                                                          , tplPositionDetail.GCO_GCO_GOOD_ID
                                                          , 0
                                                          , tplPositionDetail.PDE_FINAL_QUANTITY_SU
                                                          , 0
                                                          , posNetUnitValueExclB
                                                           );
      end loop;
    end if;
  end if;
end DOC_POS_BD_MULTISOURCING;


ALTER TRIGGER "C_ITX"."DOC_POS_BD_MULTISOURCING" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_BD_NO_MORPH_CHAR"
  before delete
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour de la table des numéros (pièce, lot et chronologique) lors de
*    l'effacement d'un détail
*    de position.
* @author VJ
* @created 08.05.2002
* @version 2003
* @lastUpdate 30.01.2002
*/
declare
  /* Curseur sur tous les detail position de la position */
  cursor cDetailPositionInfo(aPositionID number, aDocumentID number, aGaugePositionID number)
  is
    select DET.GCO_CHARACTERIZATION_ID
         , DET.GCO_GCO_CHARACTERIZATION_ID
         , DET.GCO2_GCO_CHARACTERIZATION_ID
         , DET.GCO3_GCO_CHARACTERIZATION_ID
         , DET.GCO4_GCO_CHARACTERIZATION_ID
         , DET.PDE_CHARACTERIZATION_VALUE_1
         , DET.PDE_CHARACTERIZATION_VALUE_2
         , DET.PDE_CHARACTERIZATION_VALUE_3
         , DET.PDE_CHARACTERIZATION_VALUE_4
         , DET.PDE_CHARACTERIZATION_VALUE_5
         , DET.STM_LOCATION_ID
         , DET.STM_STM_LOCATION_ID
         , DET.PDE_MOVEMENT_QUANTITY
         , DET.PDE_FINAL_DELAY
         , DET.PDE_FINAL_QUANTITY
         , DET.PDE_BALANCE_QUANTITY
         , nvl(DET.PDE_BALANCE_QUANTITY_PARENT, 0) PDE_BALANCE_QUANTITY_PARENT
         , DET.DOC_GAUGE_RECEIPT_ID
         , DET.DOC_DOC_POSITION_DETAIL_ID
         , DET.DOC_GAUGE_COPY_ID
         , DET.DOC2_DOC_POSITION_DETAIL_ID
         , DOC.PAC_THIRD_ID
         , DOC.DIC_GAUGE_TYPE_DOC_ID
         , DOC.DMT_DATE_DOCUMENT
         , DOC.DMT_RATE_OF_EXCHANGE
         , DOC.DMT_BASE_PRICE
         , GAU.C_ADMIN_DOMAIN
         , GAP.GAP_DESIGNATION
      from DOC_POSITION_DETAIL DET
         , DOC_DOCUMENT DOC
         , DOC_GAUGE GAU
         , DOC_GAUGE_POSITION GAP
     where DET.DOC_POSITION_ID = aPositionID
       and DOC.DOC_DOCUMENT_ID = aDocumentID
       and GAU.DOC_GAUGE_ID = DOC.DOC_GAUGE_ID
       and GAP.DOC_GAUGE_POSITION_ID = aGaugePositionID
       and DET.STM_LOCATION_ID is not null
       and :old.C_GAUGE_TYPE_POS in('1', '2', '3', '7', '8', '71', '81', '91', '101', '21');

  tDetailPositionInfo cDetailPositionInfo%rowtype;
  vMovementSort       STM_MOVEMENT_KIND.C_MOVEMENT_SORT%type;
  vMovementKindID     STM_MOVEMENT_KIND.STM_MOVEMENT_KIND_ID%type;
  vDesignation        DOC_GAUGE_POSITION.GAP_DESIGNATION%type;
  vElementNumberID1   STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vElementNumberID2   STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vElementNumberID3   STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  lQualityStatusId    STM_ELEMENT_NUMBER.GCO_QUALITY_STATUS_ID%type;
  vUpdateMode         varchar2(2);
  lAllChar            DOC_GAUGE_STRUCTURED.GAS_ALL_CHARACTERIZATION%type;
begin
  -- Recherche du type de mouvement en fonction du domaine
  select GAS_ALL_CHARACTERIZATION
    into lAllChar
    from DOC_GAUGE_STRUCTURED GAS
   where GAS.DOC_GAUGE_ID = :old.DOC_GAUGE_ID;

  -- traitement effectué seulement dans le cas ou l'on gère les caractérisations non-morphologiques
  if lAllChar = 1 then
    /* Ouverture du curseur sur les details de position */
    open cDetailPositionInfo(:old.DOC_POSITION_ID, :old.DOC_DOCUMENT_ID, :old.DOC_GAUGE_POSITION_ID);

    fetch cDetailPositionInfo
     into tDetailPositionInfo;

    while cDetailPositionInfo%found loop
      if     (   :old.STM_MOVEMENT_KIND_ID is null
              or tDetailPositionInfo.PDE_MOVEMENT_QUANTITY = 0)
         and   /* Le genre de mouvement est inexistant et */
             (:old.C_GAUGE_TYPE_POS in('1', '2', '3', '7', '8', '71', '81', '91', '101', '21') ) then                 /* l'on traite une position bien qui gère les caratérisations */
                                                                                                        /* Recherche du type de mouvement en fonction du domaine */
        if (tDetailPositionInfo.C_ADMIN_DOMAIN = '1') then   /* Achat */
          vMovementSort  := 'ENT';
        elsif(tDetailPositionInfo.C_ADMIN_DOMAIN = '2') then   /* Vente */
          vMovementSort  := 'SOR';
        else
          vMovementSort  := '';
        end if;

        /**
        * Recherche du mode de mise à jour des élements.
        *
        * On différentie l'effacement simple de l'effacement de position obtenue
        * par copie ou décharge.
        *
        *   DD = effacement d'un détail lié (détail fils ou cible),
        *   D  = effacement d'un détail non lié
        */
        if tDetailPositionInfo.DOC_GAUGE_RECEIPT_ID is not null then   /* Le détail de position est issu d'une décharge */
          select max(GAP.STM_MOVEMENT_KIND_ID)
            into vMovementKindID
            from DOC_GAUGE_POSITION GAP
               , DOC_GAUGE_RECEIPT GAR
           where GAR.DOC_GAUGE_RECEIPT_ID = tDetailPositionInfo.DOC_GAUGE_RECEIPT_ID
             and GAP.DOC_GAUGE_ID = GAR.DOC_DOC_GAUGE_ID
             and GAP.C_GAUGE_TYPE_POS = :old.C_GAUGE_TYPE_POS
             and GAP.GAP_DESIGNATION = tDetailPositionInfo.GAP_DESIGNATION;

          if vMovementKindID is not null then   /* Le détail parent est lié à un genre de mouvement */
            vUpdateMode  := 'DD';
          else
            /* Remarque : J'effectue une nouvelle fois le teste sur la configuration,
               car je ne suis pas certain que le test initial sera conservé. */
            if (PCS.PC_CONFIG.GetConfig('DOC_CHARACTERIZATION_MODE') = '1') then   /* Le gabarit parent et la configuration gèrent tous les types de carctérisation */
              vUpdateMode  := 'DD';
            else
              vUpdateMode  := 'D';
            end if;
          end if;
        elsif tDetailPositionInfo.DOC_GAUGE_COPY_ID is not null then   /* Le détail de position est issu d'une copie */
          select max(GAP.STM_MOVEMENT_KIND_ID)
            into vMovementKindID
            from DOC_GAUGE_POSITION GAP
               , DOC_GAUGE_COPY GAC
           where GAC.DOC_GAUGE_COPY_ID = tDetailPositionInfo.DOC_GAUGE_COPY_ID
             and GAP.DOC_GAUGE_ID = GAC.DOC_DOC_GAUGE_ID
             and GAP.C_GAUGE_TYPE_POS = :old.C_GAUGE_TYPE_POS
             and GAP.GAP_DESIGNATION = tDetailPositionInfo.GAP_DESIGNATION;

          if vMovementKindID is not null then   /* Le détail source est lié à un genre de mouvement */
            vUpdateMode  := 'DD';
          else
            /* Remarque : J'effectue une nouvelle fois le teste sur la configuration,
               car je ne suis pas certain que le test initial sera conservé. */
            if (PCS.PC_CONFIG.GetConfig('DOC_CHARACTERIZATION_MODE') = '1') then   /* Le gabarit parent et la configuration gèrent tous les types de carctérisation */
              vUpdateMode  := 'DD';
            else
              vUpdateMode  := 'D';
            end if;
          end if;
        else
          vUpdateMode  := 'D';
        end if;

        /**
        * Mise à jour de la table element_number et récupération des ID
        *
        * Remarques :
        *
        *  Le status de l'élement est définit dans la fonction (null transmis).
        *
        *  Il faut transmettre les ID et les valeurs de caractérisation sans
        *  tenir compte de l'éventuel non gestion en stock de celles-ci.
        */
        STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => :old.GCO_GOOD_ID   -- bien
                                                , iUpdateMode               => vUpdateMode   -- Mode de mise à jour
                                                , iMovementSort             => vMovementSort   -- Type de mouvement 'ENT' = Entrée 'SOR' = Sortie
                                                , iCharacterizationId       => tDetailPositionInfo.GCO_CHARACTERIZATION_ID   -- Caractérisation 1
                                                , iCharacterization2Id      => tDetailPositionInfo.GCO_GCO_CHARACTERIZATION_ID
                                                , iCharacterization3Id      => tDetailPositionInfo.GCO2_GCO_CHARACTERIZATION_ID
                                                , iCharacterization4Id      => tDetailPositionInfo.GCO3_GCO_CHARACTERIZATION_ID
                                                , iCharacterization5Id      => tDetailPositionInfo.GCO4_GCO_CHARACTERIZATION_ID
                                                , iCharacterizationValue1   => tDetailPositionInfo.PDE_CHARACTERIZATION_VALUE_1   -- Valeur de caractérisation 1
                                                , iCharacterizationValue2   => tDetailPositionInfo.PDE_CHARACTERIZATION_VALUE_2
                                                , iCharacterizationValue3   => tDetailPositionInfo.PDE_CHARACTERIZATION_VALUE_3
                                                , iCharacterizationValue4   => tDetailPositionInfo.PDE_CHARACTERIZATION_VALUE_4
                                                , iCharacterizationValue5   => tDetailPositionInfo.PDE_CHARACTERIZATION_VALUE_5
                                                , iVerifyChar               => 1   -- Vérification de l'unicité des valeurs de caract.
                                                , iElementStatus            => null   -- Statut de l'élement après mise à jour
                                                , ioElementNumberId1        => vElementNumberID1   -- Elément 1 en sortie
                                                , ioElementNumberId2        => vElementNumberID2   -- Elément 2 en sortie
                                                , ioElementNumberId3        => vElementNumberID3   -- Elément 3 en sortie
                                                , ioQualityStatusId         => lQualityStatusId
                                                 );
      end if;

      fetch cDetailPositionInfo
       into tDetailPositionInfo;
    end loop;

    close cDetailPositionInfo;
  end if;
exception
  /**
  * Si on passe dans cette exception, cela signifie que la mise à jour est faite à
  * partir du trigger DOC_DMT_AD_NO_MORPH (inexistant pour le moment)
  */
  when ex.TABLE_MUTATING then
    null;
end DOC_POS_BD_NO_MORPH_CHAR;

ALTER TRIGGER "C_ITX"."DOC_POS_BD_NO_MORPH_CHAR" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_BD_POSI_ACCU"
  before delete
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Maj des totalisateurs de positions
* @author Fabrice Perotto
* @version 2003
*/
declare
  -- curseur sur tous les detail position de la position
  cursor detail_position_cursor(position_id number, document_id number, gauge_position_id number)
  is
    select DET.GCO_CHARACTERIZATION_ID
         , DET.GCO_GCO_CHARACTERIZATION_ID
         , DET.GCO2_GCO_CHARACTERIZATION_ID
         , DET.GCO3_GCO_CHARACTERIZATION_ID
         , DET.GCO4_GCO_CHARACTERIZATION_ID
         , DET.PDE_CHARACTERIZATION_VALUE_1
         , DET.PDE_CHARACTERIZATION_VALUE_2
         , DET.PDE_CHARACTERIZATION_VALUE_3
         , DET.PDE_CHARACTERIZATION_VALUE_4
         , DET.PDE_CHARACTERIZATION_VALUE_5
         , DET.STM_LOCATION_ID
         , DET.STM_STM_LOCATION_ID
         , DET.PDE_MOVEMENT_QUANTITY
         , DET.PDE_FINAL_DELAY
         , DET.PDE_FINAL_QUANTITY
         , DET.PDE_BALANCE_QUANTITY
         , DOC.PAC_THIRD_ID
         , DOC.DIC_GAUGE_TYPE_DOC_ID
         , DOC.DMT_DATE_DOCUMENT
         , GPO.GAP_DELAY
         , GST.GAS_BALANCE_STATUS
         , GAU.C_GAUGE_TYPE
      from DOC_POSITION_DETAIL DET
         , DOC_DOCUMENT DOC
         , DOC_GAUGE_POSITION GPO
         , DOC_GAUGE_STRUCTURED GST
         , DOC_GAUGE GAU
     where DET.DOC_POSITION_ID = position_id
       and DOC.DOC_DOCUMENT_ID = document_id
       and GPO.DOC_GAUGE_POSITION_ID = gauge_position_id
       and GST.DOC_GAUGE_ID = DOC.DOC_GAUGE_ID
       and GAU.DOC_GAUGE_ID = GST.DOC_GAUGE_ID;

  detail_position_tuple detail_position_cursor%rowtype;
begin
  -- mise à jour  des totalisateurs de position
  if :old.c_gauge_type_pos in('1', '2', '3', '7', '8', '91', '101') then
    -- pas de mise à jour des totalisateurs (possible uniquement par recalcul global)
    if PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '0' then
      null;
    -- mise à jour instantannée des totalisateurs de position
    elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '1' then
      -- ouverture du curseur sur les detail de position
      open detail_position_cursor(:old.DOC_POSITION_ID, :old.DOC_DOCUMENT_ID, :old.DOC_GAUGE_POSITION_ID);

      fetch detail_position_cursor
       into detail_position_tuple;

      while detail_position_cursor%found loop
        DOC_ACCUMULATOR.DOC_TOTAL_POSITION(:old.GCO_GOOD_ID
                                         , detail_position_tuple.PAC_THIRD_ID
                                         , detail_position_tuple.DIC_GAUGE_TYPE_DOC_ID
                                         , detail_position_tuple.GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.GCO_GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.GCO2_GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.GCO3_GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.GCO4_GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_1
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_2
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_3
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_4
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_5
                                         , detail_position_tuple.GAP_DELAY
                                         , nvl(detail_position_tuple.PDE_FINAL_DELAY
                                             , detail_position_tuple.DMT_DATE_DOCUMENT
                                              )
                                         , detail_position_tuple.DMT_DATE_DOCUMENT
                                         , detail_position_tuple.PDE_FINAL_QUANTITY
                                         , detail_position_tuple.PDE_BALANCE_QUANTITY
                                         , :old.POS_NET_VALUE_EXCL_B
                                         , :old.C_DOC_POS_STATUS
                                         , detail_position_tuple.GAS_BALANCE_STATUS
                                         , detail_position_tuple.C_GAUGE_TYPE
                                         , -1
                                         , 0
                                          );

        fetch detail_position_cursor
         into detail_position_tuple;
      end loop;

      close detail_position_cursor;
    -- insertion dans le buffer des totalisateurs de position (maj différée)
    elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '2' then
      insert into DOC_POSI_ACCU_BUFFER
                  (DOC_POSI_ACCU_BUFFER_ID
                 , ABU_SIGN
                 , C_DOC_POS_STATUS
                 , C_GAUGE_TYPE
                 , GCO_GOOD_ID
                 , PAC_THIRD_ID
                 , DIC_GAUGE_TYPE_DOC_ID
                 , GCO_CHARACTERIZATION_ID
                 , GCO_GCO_CHARACTERIZATION_ID
                 , GCO2_GCO_CHARACTERIZATION_ID
                 , GCO3_GCO_CHARACTERIZATION_ID
                 , GCO4_GCO_CHARACTERIZATION_ID
                 , ABU_CHARACTERIZATION_VALUE_1
                 , ABU_CHARACTERIZATION_VALUE_2
                 , ABU_CHARACTERIZATION_VALUE_3
                 , ABU_CHARACTERIZATION_VALUE_4
                 , ABU_CHARACTERIZATION_VALUE_5
                 , ABU_DELAY
                 , ABU_FINAL_DELAY
                 , ABU_DOCUMENT_DATE
                 , ABU_FINAL_QUANTITY
                 , ABU_BALANCE_QUANTITY
                 , ABU_NET_VALUE_EXCL
                 , ABU_BALANCE_STATUS
                  )
        select INIT_ID_SEQ.nextval
             , -1
             , :old.C_DOC_POS_STATUS
             , GAU.C_GAUGE_TYPE
             , :old.GCO_GOOD_ID
             , DOC.PAC_THIRD_ID
             , DOC.DIC_GAUGE_TYPE_DOC_ID
             , DET.GCO_CHARACTERIZATION_ID
             , DET.GCO_GCO_CHARACTERIZATION_ID
             , DET.GCO2_GCO_CHARACTERIZATION_ID
             , DET.GCO3_GCO_CHARACTERIZATION_ID
             , DET.GCO4_GCO_CHARACTERIZATION_ID
             , DET.PDE_CHARACTERIZATION_VALUE_1
             , DET.PDE_CHARACTERIZATION_VALUE_2
             , DET.PDE_CHARACTERIZATION_VALUE_3
             , DET.PDE_CHARACTERIZATION_VALUE_4
             , DET.PDE_CHARACTERIZATION_VALUE_5
             , GPO.GAP_DELAY
             , nvl(DET.PDE_FINAL_DELAY, DOC.DMT_DATE_DOCUMENT)
             , DOC.DMT_DATE_DOCUMENT
             , DET.PDE_FINAL_QUANTITY
             , DET.PDE_BALANCE_QUANTITY
             , :old.POS_NET_VALUE_EXCL_B
             , GST.GAS_BALANCE_STATUS
          from DOC_DOCUMENT DOC
             , DOC_POSITION_DETAIL DET
             , DOC_GAUGE_POSITION GPO
             , DOC_GAUGE_STRUCTURED GST
             , DOC_GAUGE GAU
         where DOC.DOC_DOCUMENT_ID = :old.DOC_DOCUMENT_ID
           and GPO.DOC_GAUGE_POSITION_ID = :old.DOC_GAUGE_POSITION_ID
           and DET.DOC_POSITION_ID = :old.DOC_POSITION_ID
           and GST.DOC_GAUGE_ID = DOC.DOC_GAUGE_ID
           and GAU.DOC_GAUGE_ID = GST.DOC_GAUGE_ID
           and :old.C_GAUGE_TYPE_POS in('1', '2', '3', '7', '8', '91', '101');
    end if;
  end if;
-- Si on passe dans cette exception, cela signifie que l'effacement est
-- fait à partir du trigger DOC_DMT_BD_POSI_ACCU
exception
  when ex.TABLE_MUTATING then
    null;
end DOC_POS_BD_POSI_ACCU;

ALTER TRIGGER "C_ITX"."DOC_POS_BD_POSI_ACCU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_BD_PROV_QTY"
  before delete
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des quantités provisoires à l'effacement d'une position
* @author FP
* @created 01.01.1998
* @version 2003
* @lastUpdate VJ 23.05.2002
*/
declare
  -- curseur sur tous les detail position de la position
  cursor detail_position_cursor(position_id number, document_id number, gauge_position_id number)
  is
    select DET.GCO_CHARACTERIZATION_ID
         , DET.GCO_GCO_CHARACTERIZATION_ID
         , DET.GCO2_GCO_CHARACTERIZATION_ID
         , DET.GCO3_GCO_CHARACTERIZATION_ID
         , DET.GCO4_GCO_CHARACTERIZATION_ID
         , DET.PDE_CHARACTERIZATION_VALUE_1
         , DET.PDE_CHARACTERIZATION_VALUE_2
         , DET.PDE_CHARACTERIZATION_VALUE_3
         , DET.PDE_CHARACTERIZATION_VALUE_4
         , DET.PDE_CHARACTERIZATION_VALUE_5
         , DET.STM_LOCATION_ID
         , DET.STM_STM_LOCATION_ID
         , DET.PDE_MOVEMENT_QUANTITY
         , DET.PDE_FINAL_DELAY
         , DET.PDE_FINAL_QUANTITY
         , DET.PDE_BALANCE_QUANTITY
         , nvl(DET.PDE_BALANCE_QUANTITY_PARENT, 0) PDE_BALANCE_QUANTITY_PARENT
         , DET.DOC_GAUGE_RECEIPT_ID
         , DET.DOC_GAUGE_COPY_ID
         , DET.DOC_DOC_POSITION_DETAIL_ID
         , DOC.PAC_THIRD_ID
         , DOC.DIC_GAUGE_TYPE_DOC_ID
         , DOC.DMT_DATE_DOCUMENT
         , DOC.DMT_RATE_OF_EXCHANGE
         , DOC.DMT_BASE_PRICE
         , GAS.GAS_ALL_CHARACTERIZATION
      from DOC_POSITION_DETAIL DET
         , DOC_DOCUMENT DOC
         , DOC_GAUGE_STRUCTURED GAS
     where DET.DOC_POSITION_ID = position_id
       and DOC.DOC_DOCUMENT_ID = document_id
       and GAS.DOC_GAUGE_ID = DOC.DOC_GAUGE_ID
       and DET.STM_LOCATION_ID is not null
       and :old.c_gauge_type_pos in('1', '2', '3', '7', '8', '71', '81', '91', '101')
       and :old.pos_generate_movement = 0;

  detail_position_tuple      detail_position_cursor%rowtype;

  /* Curseur sur le détail père */
  cursor cFatherDetail(aPositionDetailID number)
  is
    select DET.GCO_GOOD_ID
         , DET.GCO_CHARACTERIZATION_ID
         , DET.GCO_GCO_CHARACTERIZATION_ID
         , DET.GCO2_GCO_CHARACTERIZATION_ID
         , DET.GCO3_GCO_CHARACTERIZATION_ID
         , DET.GCO4_GCO_CHARACTERIZATION_ID
         , DET.PDE_CHARACTERIZATION_VALUE_1
         , DET.PDE_CHARACTERIZATION_VALUE_2
         , DET.PDE_CHARACTERIZATION_VALUE_3
         , DET.PDE_CHARACTERIZATION_VALUE_4
         , DET.PDE_CHARACTERIZATION_VALUE_5
         , GAU.C_ADMIN_DOMAIN
      from DOC_POSITION_DETAIL DET
         , DOC_GAUGE GAU
     where DET.DOC_POSITION_DETAIL_ID = aPositionDetailID
       and GAU.DOC_GAUGE_ID = DET.DOC_GAUGE_ID;

  tFatherDetail              cFatherDetail%rowtype;

  cursor extourne_mvt_cursor(position_id number)
  is
    select A.GCO_GOOD_ID
         , A.GCO_CHARACTERIZATION_ID
         , A.GCO_GCO_CHARACTERIZATION_ID
         , A.GCO2_GCO_CHARACTERIZATION_ID
         , A.GCO3_GCO_CHARACTERIZATION_ID
         , A.GCO4_GCO_CHARACTERIZATION_ID
         , A.SMO_CHARACTERIZATION_VALUE_1
         , A.SMO_CHARACTERIZATION_VALUE_2
         , A.SMO_CHARACTERIZATION_VALUE_3
         , A.SMO_CHARACTERIZATION_VALUE_4
         , A.SMO_CHARACTERIZATION_VALUE_5
         , A.STM_STOCK_ID
         , A.STM_LOCATION_ID
         , A.SMO_MOVEMENT_QUANTITY
         , C.C_MOVEMENT_SORT
         , C.MOK_VERIFY_CHARACTERIZATION
         , C.STM_STM_MOVEMENT_KIND_ID
         , D.PDE_MOVEMENT_QUANTITY
         , D.STM_STM_LOCATION_ID
         , nvl(D.PDE_BALANCE_QUANTITY_PARENT, 0) PDE_BALANCE_QUANTITY_PARENT
         , D.DOC_GAUGE_RECEIPT_ID
      from STM_STOCK_MOVEMENT A
         , DOC_GAUGE_RECEIPT B
         , STM_MOVEMENT_KIND C
         , DOC_POSITION_DETAIL D
     where B.DOC_GAUGE_RECEIPT_ID = D.DOC_GAUGE_RECEIPT_ID
       and B.GAR_EXTOURNE_MVT = 1
       and A.DOC_POSITION_DETAIL_ID = D.DOC_DOC_POSITION_DETAIL_ID
       and C.STM_MOVEMENT_KIND_ID = A.STM_MOVEMENT_KIND_ID
       and D.DOC_POSITION_ID = position_id
       and :old.C_GAUGE_TYPE_POS in('1', '2', '3', '7', '8', '71', '81', '91', '101')
       and :old.POS_GENERATE_MOVEMENT = 0;

  extourne_mvt_tuple         extourne_mvt_cursor%rowtype;

  -- recherche du type de mouvement de stock et de l'id du bien d'aprSs la table des positions
  cursor MOVE_KIND_CURSOR(idMOVEMENT_KIND number)
  is
    select C_MOVEMENT_SORT
         , STM_STM_MOVEMENT_KIND_ID
         , MOK_VERIFY_CHARACTERIZATION
         , DOC_GAUGE_POSITION.GAP_DESIGNATION
      from STM_MOVEMENT_KIND
         , DOC_GAUGE_POSITION
     where STM_MOVEMENT_KIND.STM_MOVEMENT_KIND_ID = idMOVEMENT_KIND
       and DOC_GAUGE_POSITION.DOC_GAUGE_POSITION_ID = :old.DOC_GAUGE_POSITION_ID;

  move_kind_cursor_tuple     move_kind_cursor%rowtype;
  update_mode                varchar2(2);
  main_stock_id              STM_STOCK.STM_STOCK_ID%type;
  trans_stock_id             STM_STOCK.STM_STOCK_ID%type;
  vDeleteProvisoryQuantities number(1);
  vMovementKindID            STM_MOVEMENT_KIND.STM_MOVEMENT_KIND_ID%type;
  vMovementSort              STM_MOVEMENT_KIND.C_MOVEMENT_SORT%type;
  vUseAllCharacterization    DOC_GAUGE_STRUCTURED.GAS_ALL_CHARACTERIZATION%type;
  vElementNumberID1          STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vElementNumberID2          STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vElementNumberID3          STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  lQualityStatusId           STM_ELEMENT_NUMBER.GCO_QUALITY_STATUS_ID%type;
  vAdminDomain               DOC_GAUGE.C_ADMIN_DOMAIN%type;
  vCreateCharacterization    boolean;
begin
  vCreateCharacterization  := false;

  -- recherche du type de mouvement de stock et de l'id du bien d'après la table des positions
  -- si le trigger est déclenché depuis en dessous, on part dans l'exception
  -- La mise à jour est déjà faite dans ce cas
  open move_kind_cursor(:old.STM_MOVEMENT_KIND_ID);

  fetch move_kind_cursor
   into move_kind_cursor_tuple;

  if move_kind_cursor%found then
    -- ouverture du curseur sur les details de position
    open detail_position_cursor(:old.DOC_POSITION_ID, :old.DOC_DOCUMENT_ID, :old.DOC_GAUGE_POSITION_ID);

    fetch detail_position_cursor
     into detail_position_tuple;

    while detail_position_cursor%found loop
      if detail_position_tuple.STM_LOCATION_ID is not null then
        if (nvl(move_kind_cursor_tuple.STM_STM_MOVEMENT_KIND_ID, 0) <> 0) then   /* Mouvement de transfert (peux valoir 0) */
          if detail_position_tuple.STM_STM_LOCATION_ID is not null then   /* L'emplacement cible initial n'était pas vide avant l'effacement */
            if    (:old.C_GAUGE_TYPE_POS = '7')
               or   /* Position assemblage (valeur PT) ou */
                  (:old.C_GAUGE_TYPE_POS = '8') then   /* Position assemblage (valeur CPT) */
              vDeleteProvisoryQuantities  := 1;
            else   /* Pas de position assemblage */
              if (detail_position_tuple.STM_LOCATION_ID = detail_position_tuple.STM_STM_LOCATION_ID) then   /* Les emplacements source et cible étaient identique avant l'effacement */
                vDeleteProvisoryQuantities  := 0;
              else
                vDeleteProvisoryQuantities  := 1;
              end if;
            end if;
          else   /* L'emplacement cible initiale était vide avant l'effacement */
            vDeleteProvisoryQuantities  := 0;
          end if;
        else   /* Pas de mouvement de transfert */
          vDeleteProvisoryQuantities  := 1;
        end if;
      else   /* Pas d'emplacement source */
        vDeleteProvisoryQuantities  := 0;
      end if;

      /**
      * Retrait des anciennes valeurs
      */
      if (vDeleteProvisoryQuantities = 1) then
        /*
        -- On différentie l'effacement simple de l'effacement de position obtenue par copie ou décharge
        if detail_position_tuple.doc_gauge_receipt_id is not null then

          select decode(max(gap.stm_movement_kind_id), null, 'D', 'DD') into update_mode
            from doc_gauge_position gap
               , doc_gauge_receipt gar
           where gar.doc_gauge_receipt_id = detail_position_tuple.doc_gauge_receipt_id
             and gap.doc_gauge_id = gar.doc_doc_gauge_id
             and gap.c_gauge_type_pos = :old.c_gauge_type_pos
             and gap.gap_designation = move_kind_cursor_tuple.gap_designation;

        elsif detail_position_tuple.doc_gauge_copy_id is not null then

          select decode(max(gap.stm_movement_kind_id), null, 'D', 'DD') into update_mode
            from doc_gauge_position gap
               , doc_gauge_copy gac
           where gac.doc_gauge_copy_id = detail_position_tuple.doc_gauge_copy_id
             and gap.doc_gauge_id = gac.doc_doc_gauge_id
             and gap.c_gauge_type_pos = :old.c_gauge_type_pos
             and gap.gap_designation = move_kind_cursor_tuple.gap_designation;

        else

          update_mode := 'D';

        end if;
        */

        /**
        * On différentie l'effacement simple de l'effacement de position obtenue
        * par copie ou décharge.
        *
        *   DD = effacement d'un détail lié (détail fils ou cible),
        *   D  = effacement d'un détail non lié
        */
        if detail_position_tuple.DOC_GAUGE_RECEIPT_ID is not null then   /* Le détail de position est issu d'une décharge */
          select max(GAP.STM_MOVEMENT_KIND_ID)
               , nvl(max(GAS.GAS_ALL_CHARACTERIZATION), 0)
            into vMovementKindID
               , vUseAllCharacterization
            from DOC_GAUGE_POSITION GAP
               , DOC_GAUGE_RECEIPT GAR
               , DOC_GAUGE_STRUCTURED GAS
           where GAR.DOC_GAUGE_RECEIPT_ID = detail_position_tuple.DOC_GAUGE_RECEIPT_ID
             and GAP.DOC_GAUGE_ID = GAR.DOC_DOC_GAUGE_ID
             and GAP.C_GAUGE_TYPE_POS = :old.C_GAUGE_TYPE_POS
             and GAP.GAP_DESIGNATION = move_kind_cursor_tuple.GAP_DESIGNATION
             and GAS.DOC_GAUGE_ID = GAP.DOC_GAUGE_ID;

          /* Impossible car on effectue un select sur la table des positions,
             ce qui génére une exception du fait que le trigger est déclenché
             sur cette même table des positions.
          select max(POS.STM_MOVEMENT_KIND_ID)
               , nvl(max(GAS.GAS_ALL_CHARACTERIZATION), 0)
            into vMovementKindID
               , vUseAllCharacterization
            from DOC_POSITION POS
               , DOC_POSITION_DETAIL PDE
               , DOC_GAUGE_STRUCTURED GAS
           where PDE.DOC_POSITION_DETAIL_ID = detail_position_tuple.DOC_DOC_POSITION_DETAIL_ID
             and POS.DOC_POSITION_ID = PDE.DOC_POSITION_ID
             and GAS.DOC_GAUGE_ID = PDE.DOC_GAUGE_ID; */
          if vMovementKindID is not null then   /* Le détail parent est lié à un genre de mouvement */
            update_mode  := 'DD';
          else
            if     (vUseAllCharacterization = 1)
               and (PCS.PC_CONFIG.GetConfig('DOC_CHARACTERIZATION_MODE') = '1') then                                                                            /* Le gabarit parent et la configuration gèrent tous les types de carctérisation */
                                                                                       /* Demande la suppression de la valeur de caractérisation du fils
                                                                                          et le création de la valeur de caractérisation du père. Le
                                                                                          traitement ne peut pas se faire à cette endroit, car les quantités
                                                                                          provisoires ne sont pas encore mis à jour. */
              vCreateCharacterization  := true;
              update_mode              := 'DD';
            else
              update_mode  := 'D';
            end if;
          end if;
        elsif detail_position_tuple.DOC_GAUGE_COPY_ID is not null then   /* Le détail de position est issu d'une copie */
          select max(GAP.STM_MOVEMENT_KIND_ID)
               , nvl(max(GAS.GAS_ALL_CHARACTERIZATION), 0)
            into vMovementKindID
               , vUseAllCharacterization
            from DOC_GAUGE_POSITION GAP
               , DOC_GAUGE_COPY GAC
               , DOC_GAUGE_STRUCTURED GAS
           where GAC.DOC_GAUGE_COPY_ID = detail_position_tuple.DOC_GAUGE_COPY_ID
             and GAP.DOC_GAUGE_ID = GAC.DOC_DOC_GAUGE_ID
             and GAP.C_GAUGE_TYPE_POS = :old.C_GAUGE_TYPE_POS
             and GAP.GAP_DESIGNATION = move_kind_cursor_tuple.GAP_DESIGNATION
             and GAS.DOC_GAUGE_ID = GAP.DOC_GAUGE_ID;

          /* Impossible car on effectue un select sur la table des positions,
             ce qui génére une exception du fait que le trigger est déclenché
             sur cette même table des positions.
          select max(POS.STM_MOVEMENT_KIND_ID)
               , nvl(max(GAS.GAS_ALL_CHARACTERIZATION), 0)
            into vMovementKindID
               , vUseAllCharacterization
            from DOC_POSITION POS
               , DOC_POSITION_DETAIL PDE
               , DOC_GAUGE_STRUCTURED GAS
           where PDE.DOC_POSITION_DETAIL_ID = detail_position_tuple.DOC2_DOC_POSITION_DETAIL_ID
             and POS.DOC_POSITION_ID = PDE.DOC_POSITION_ID
             and GAS.DOC_GAUGE_ID = PDE.DOC_GAUGE_ID; */
          if vMovementKindID is not null then   /* Le détail source est lié à un genre de mouvement */
            update_mode  := 'DD';
          else
            if     (vUseAllCharacterization = 1)
               and (PCS.PC_CONFIG.GetConfig('DOC_CHARACTERIZATION_MODE') = '1') then   /* Le gabarit parent et la configuration gèrent tous les types de carctérisation */
              update_mode  := 'DD';
            else
              update_mode  := 'D';
            end if;
          end if;
        else
          update_mode  := 'D';
        end if;

        /* Recherche les stocks en fonction des emplacements. */
        select STM_STOCK_ID
          into main_stock_id
          from STM_LOCATION
         where STM_LOCATION_ID = detail_position_tuple.STM_LOCATION_ID;

        select max(STM_STOCK_ID)
          into trans_stock_id
          from STM_LOCATION
         where STM_LOCATION_ID = detail_position_tuple.STM_STM_LOCATION_ID;

        DOC_INIT_MOVEMENT.DOC_PROV_QTY(:old.GCO_GOOD_ID
                                     , update_mode
                                     ,   -- Mode effacement (D ou DD)
                                       move_kind_cursor_tuple.C_MOVEMENT_SORT
                                     , move_kind_cursor_tuple.MOK_VERIFY_CHARACTERIZATION
                                     , move_kind_cursor_tuple.STM_STM_MOVEMENT_KIND_ID
                                     , detail_position_tuple.GCO_CHARACTERIZATION_ID
                                     , detail_position_tuple.GCO_GCO_CHARACTERIZATION_ID
                                     , detail_position_tuple.GCO2_GCO_CHARACTERIZATION_ID
                                     , detail_position_tuple.GCO3_GCO_CHARACTERIZATION_ID
                                     , detail_position_tuple.GCO4_GCO_CHARACTERIZATION_ID
                                     , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_1
                                     , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_2
                                     , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_3
                                     , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_4
                                     , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_5
                                     , main_stock_id
                                     , detail_position_tuple.STM_LOCATION_ID
                                     , trans_stock_id
                                     , detail_position_tuple.STM_STM_LOCATION_ID
                                     , detail_position_tuple.PDE_MOVEMENT_QUANTITY *(-1)
                                      );

        if vCreateCharacterization then
          /**
          * Dans ce contexte là, il faut supprimer le numéro de l'élement de
          * caractérisation du détail courant (fils) et recréer le numéro de
          * l'élement de caractérisation du détail père.
          */

          /* Supprime le numéro du détail fils */
          STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => :old.GCO_GOOD_ID   -- Bien
                                                  , iUpdateMode               => 'D'   -- Mode de mise à jour
                                                  , iMovementSort             => move_kind_cursor_tuple.C_MOVEMENT_SORT   -- Type de mouvement 'ENT' = Entrée 'SOR' = Sortie
                                                  , iCharacterizationId       => detail_position_tuple.GCO_CHARACTERIZATION_ID   -- Caractérisation
                                                  , iCharacterization2Id      => detail_position_tuple.GCO_GCO_CHARACTERIZATION_ID
                                                  , iCharacterization3Id      => detail_position_tuple.GCO2_GCO_CHARACTERIZATION_ID
                                                  , iCharacterization4Id      => detail_position_tuple.GCO3_GCO_CHARACTERIZATION_ID
                                                  , iCharacterization5Id      => detail_position_tuple.GCO4_GCO_CHARACTERIZATION_ID
                                                  , iCharacterizationValue1   => detail_position_tuple.PDE_CHARACTERIZATION_VALUE_1   -- Valeur de caractérisation
                                                  , iCharacterizationValue2   => detail_position_tuple.PDE_CHARACTERIZATION_VALUE_2
                                                  , iCharacterizationValue3   => detail_position_tuple.PDE_CHARACTERIZATION_VALUE_3
                                                  , iCharacterizationValue4   => detail_position_tuple.PDE_CHARACTERIZATION_VALUE_4
                                                  , iCharacterizationValue5   => detail_position_tuple.PDE_CHARACTERIZATION_VALUE_5
                                                  , iVerifyChar               => 1   -- Vérification de l'unicité des valeurs de caract.
                                                  , iElementStatus            => null   -- Statut de l'élement après mise à jour
                                                  , ioElementNumberId1        => vElementNumberID1   -- Elément 1 en sortie
                                                  , ioElementNumberId2        => vElementNumberID2   -- Elément 2 en sortie
                                                  , ioElementNumberId3        => vElementNumberID3   -- Elément 3 en sortie
                                                  , ioQualityStatusId         => lQualityStatusId
                                                   );

          /* Ouverture du curseur sur les details de position */
          open cFatherDetail(detail_position_tuple.DOC_DOC_POSITION_DETAIL_ID);

          fetch cFatherDetail
           into tFatherDetail;

          if cFatherDetail%found then
            /* Recherche du type de mouvement en fonction du domaine */
            if (tFatherDetail.C_ADMIN_DOMAIN = '1') then   /* Achat */
              vMovementSort  := 'ENT';
            elsif(tFatherDetail.C_ADMIN_DOMAIN = '2') then   /* Vente */
              vMovementSort  := 'SOR';
            else
              vMovementSort  := '';
            end if;

            /* Recrée le numéro du détail père */
            STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => tFatherDetail.GCO_GOOD_ID   -- Bien
                                                    , iUpdateMode               => 'I'   -- Mode de mise à jour
                                                    , iMovementSort             => vMovementSort   -- Type de mouvement 'ENT' = Entrée 'SOR' = Sortie
                                                    , iCharacterizationId       => tFatherDetail.GCO_CHARACTERIZATION_ID   -- Caractérisation
                                                    , iCharacterization2Id      => tFatherDetail.GCO_GCO_CHARACTERIZATION_ID
                                                    , iCharacterization3Id      => tFatherDetail.GCO2_GCO_CHARACTERIZATION_ID
                                                    , iCharacterization4Id      => tFatherDetail.GCO3_GCO_CHARACTERIZATION_ID
                                                    , iCharacterization5Id      => tFatherDetail.GCO4_GCO_CHARACTERIZATION_ID
                                                    , iCharacterizationValue1   => tFatherDetail.PDE_CHARACTERIZATION_VALUE_1   -- Valeur de caractérisation
                                                    , iCharacterizationValue2   => tFatherDetail.PDE_CHARACTERIZATION_VALUE_2
                                                    , iCharacterizationValue3   => tFatherDetail.PDE_CHARACTERIZATION_VALUE_3
                                                    , iCharacterizationValue4   => tFatherDetail.PDE_CHARACTERIZATION_VALUE_4
                                                    , iCharacterizationValue5   => tFatherDetail.PDE_CHARACTERIZATION_VALUE_5
                                                    , iVerifyChar               => 1   -- Vérification de l'unicité des valeurs de caract.
                                                    , iElementStatus            => '03'   -- Statut de l'élement après mise à jour
                                                    , ioElementNumberId1        => vElementNumberID1   -- Elément 1 en sortie
                                                    , ioElementNumberId2        => vElementNumberID2   -- Elément 2 en sortie
                                                    , ioElementNumberId3        => vElementNumberID3   -- Elément 3 en sortie
                                                    , ioQualityStatusId         => lQualityStatusId
                                                     );
          end if;

          close cFatherDetail;
        end if;
      end if;

      fetch detail_position_cursor
       into detail_position_tuple;
    end loop;

    close detail_position_cursor;

    -- Eventuellement traitement de l'extourne
    open extourne_mvt_cursor(:old.DOC_POSITION_ID);

    fetch extourne_mvt_cursor
     into extourne_mvt_tuple;

    while extourne_mvt_cursor%found loop
      if extourne_mvt_tuple.STM_LOCATION_ID is not null then
        if (nvl(move_kind_cursor_tuple.STM_STM_MOVEMENT_KIND_ID, 0) <> 0) then   /* Mouvement de transfert */
          if extourne_mvt_tuple.STM_STM_LOCATION_ID is not null then   /* L'emplacement cible initial n'était pas vide avant l'effacement */
            if    (:old.C_GAUGE_TYPE_POS = '7')
               or   /* Position assemblage (valeur PT) ou */
                  (:old.C_GAUGE_TYPE_POS = '8') then   /* Position assemblage (valeur CPT) */
              vDeleteProvisoryQuantities  := 1;
            else   /* Pas de position assemblage */
              if (extourne_mvt_tuple.STM_LOCATION_ID = extourne_mvt_tuple.STM_STM_LOCATION_ID) then   /* Les emplacements source et cible étaient identique avant l'effacement */
                vDeleteProvisoryQuantities  := 0;
              else
                vDeleteProvisoryQuantities  := 1;
              end if;
            end if;
          else   /* L'emplacement cible initiale était vide avant l'effacement */
            vDeleteProvisoryQuantities  := 0;
          end if;
        else   /* Pas de mouvement de transfert */
          vDeleteProvisoryQuantities  := 1;
        end if;
      else   /* Pas d'emplacement source */
        vDeleteProvisoryQuantities  := 0;
      end if;

      /**
      * Retrait des anciennes valeurs
      */
      if (vDeleteProvisoryQuantities = 1) then
        /*
        if update_mode is null then

           Recherche si c'est un effacement d'une position crée par décharge.
             Si c'est le cas, le mode de mise à jour est 'DD' sinon c'est 'D'.
          select decode(max(GAP.STM_MOVEMENT_KIND_ID),
                        null, 'D',
                              'DD') into update_mode
            from DOC_GAUGE_POSITION GAP
               , DOC_GAUGE_RECEIPT GAR
           where GAR.DOC_GAUGE_RECEIPT_ID = extourne_mvt_tuple.DOC_GAUGE_RECEIPT_ID
             and GAP.DOC_GAUGE_ID = GAR.DOC_DOC_GAUGE_ID
             and GAP.C_GAUGE_TYPE_POS = :old.C_GAUGE_TYPE_POS
             and GAP.GAP_DESIGNATION = move_kind_cursor_tuple.GAP_DESIGNATION;

        end if;
        */
        if update_mode is null then
          /**
          * On différentie l'effacement simple de l'effacement de position obtenue
          * décharge.
          *
          *   DD = effacement d'un détail lié (détail fils ou cible),
          *   D  = effacement d'un détail non lié
          */
          if extourne_mvt_tuple.DOC_GAUGE_RECEIPT_ID is not null then   /* Le détail de position est issu d'une décharge */
            select max(GAP.STM_MOVEMENT_KIND_ID)
                 , nvl(max(GAS.GAS_ALL_CHARACTERIZATION), 0)
              into vMovementKindID
                 , vUseAllCharacterization
              from DOC_GAUGE_POSITION GAP
                 , DOC_GAUGE_RECEIPT GAR
                 , DOC_GAUGE_STRUCTURED GAS
             where GAR.DOC_GAUGE_RECEIPT_ID = extourne_mvt_tuple.DOC_GAUGE_RECEIPT_ID
               and GAP.DOC_GAUGE_ID = GAR.DOC_DOC_GAUGE_ID
               and GAP.C_GAUGE_TYPE_POS = :old.C_GAUGE_TYPE_POS
               and GAP.GAP_DESIGNATION = move_kind_cursor_tuple.GAP_DESIGNATION
               and GAS.DOC_GAUGE_ID = GAP.DOC_GAUGE_ID;

            /* Impossible car on effectue un select sur la table des positions,
               ce qui génére une exception du fait que le trigger est déclenché
               sur cette même table des positions.
            select max(POS.STM_MOVEMENT_KIND_ID)
                 , nvl(max(GAS.GAS_ALL_CHARACTERIZATION), 0)
              into vMovementKindID
                 , vUseAllCharacterization
              from DOC_POSITION POS
                 , DOC_POSITION_DETAIL PDE
                 , DOC_GAUGE_STRUCTURED GAS
             where PDE.DOC_POSITION_DETAIL_ID = extourne_mvt_tuple.DOC_DOC_POSITION_DETAIL_ID
               and POS.DOC_POSITION_ID = PDE.DOC_POSITION_ID
               and GAS.DOC_GAUGE_ID = PDE.DOC_GAUGE_ID; */
            if vMovementKindID is not null then   /* Le détail parent est lié à un genre de mouvement */
              update_mode  := 'DD';
            else
              if     (vUseAllCharacterization = 1)
                 and (PCS.PC_CONFIG.GetConfig('DOC_CHARACTERIZATION_MODE') = '1') then   /* Le gabarit parent et la configuration gèrent tous les types de carctérisation */
                update_mode  := 'DD';
              else
                update_mode  := 'D';
              end if;
            end if;
          else
            update_mode  := 'D';
          end if;
        end if;

        DOC_INIT_MOVEMENT.DOC_PROV_QTY(extourne_mvt_tuple.GCO_GOOD_ID
                                     , update_mode
                                     ,   -- Mode effacement (D ou DD)
                                       extourne_mvt_tuple.C_MOVEMENT_SORT
                                     , extourne_mvt_tuple.MOK_VERIFY_CHARACTERIZATION
                                     , extourne_mvt_tuple.STM_STM_MOVEMENT_KIND_ID
                                     , extourne_mvt_tuple.GCO_CHARACTERIZATION_ID
                                     , extourne_mvt_tuple.GCO_GCO_CHARACTERIZATION_ID
                                     , extourne_mvt_tuple.GCO2_GCO_CHARACTERIZATION_ID
                                     , extourne_mvt_tuple.GCO3_GCO_CHARACTERIZATION_ID
                                     , extourne_mvt_tuple.GCO4_GCO_CHARACTERIZATION_ID
                                     , extourne_mvt_tuple.SMO_CHARACTERIZATION_VALUE_1
                                     , extourne_mvt_tuple.SMO_CHARACTERIZATION_VALUE_2
                                     , extourne_mvt_tuple.SMO_CHARACTERIZATION_VALUE_3
                                     , extourne_mvt_tuple.SMO_CHARACTERIZATION_VALUE_4
                                     , extourne_mvt_tuple.SMO_CHARACTERIZATION_VALUE_5
                                     , extourne_mvt_tuple.STM_STOCK_ID
                                     , extourne_mvt_tuple.STM_LOCATION_ID
                                     , null
                                     , null
                                     , sign(extourne_mvt_tuple.PDE_MOVEMENT_QUANTITY) *
                                       least(abs(extourne_mvt_tuple.PDE_MOVEMENT_QUANTITY +
                                                 (nvl(extourne_mvt_tuple.PDE_BALANCE_QUANTITY_PARENT, 0) * :old.POS_CONVERT_FACTOR
                                                 )
                                                )
                                           , abs(extourne_mvt_tuple.SMO_MOVEMENT_QUANTITY)
                                            )
                                      );
      end if;

      fetch extourne_mvt_cursor
       into extourne_mvt_tuple;
    end loop;

    close extourne_mvt_cursor;
  end if;

  close move_kind_cursor;
/**
* Si on passe dans cette exception, cela signifie que la mise à jour est faite à
* partir du trigger DOC_DMT_BD_PROV_QTY
*/
exception
  when ex.TABLE_MUTATING then
    null;
end DOC_POS_BD_PROV_QTY;

ALTER TRIGGER "C_ITX"."DOC_POS_BD_PROV_QTY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_BD_SUPPLY_REQUEST"
  before delete
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Màj du statut de la demande d'appro à l'effacement de la position
* @author Nuno Gomes Vieira
* @created 23/04/2002
* @version 2003
* @lastUpdate 23/04/2002
*/
begin
  -- Màj du statut de la Demande d'appro à la valeur 4 (Annulée) à l'effacement de la position
  if :old.FAL_SUPPLY_REQUEST_ID is not null then
    update FAL_SUPPLY_REQUEST
       set C_REQUEST_STATUS = '4'
         , A_DATEMOD = sysdate
         , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
     where FAL_SUPPLY_REQUEST_ID = :old.FAL_SUPPLY_REQUEST_ID;
  end if;
end DOC_POS_BD_SUPPLY_REQUEST;

ALTER TRIGGER "C_ITX"."DOC_POS_BD_SUPPLY_REQUEST" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_BI_CONSTRAINTS"
  before insert
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Remplace la contrainte entre DOC_POSITION et DOC_DOCUMENT
* @author Fabrice Perotto
* @version 2003
* @lastUpdate
*/
declare
  doc_id DOC_DOCUMENT.DOC_DOCUMENT_ID%type;
begin
  -- erreur si le parent n'existe pas
  select DOC_DOCUMENT_ID
    into doc_id
    from DOC_DOCUMENT
   where DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID;
exception
  when no_data_found then
    raise_application_error(-20010, 'PCS - Value of DOC_DOCUMENT_ID does not exist in table DOC_DOCUMENT');
end DOC_POS_BI_CONSTRAINTS;

ALTER TRIGGER "C_ITX"."DOC_POS_BI_CONSTRAINTS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_BI_DENORM"
  before insert
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des champs dénormalisés de DOC_POSITION
* @author Fabrice Perotto
* @version 2003
*/
begin
  select PAC_THIRD_ID
       , PAC_THIRD_ACI_ID
       , PAC_THIRD_DELIVERY_ID
       , PAC_THIRD_TARIFF_ID
       , PAC_THIRD_VAT_ID
       , PAC_THIRD_CDA_ID
       , DOC_GAUGE_ID
    into :new.PAC_THIRD_ID
       , :new.PAC_THIRD_ACI_ID
       , :new.PAC_THIRD_DELIVERY_ID
       , :new.PAC_THIRD_TARIFF_ID
       , :new.PAC_THIRD_VAT_ID
       , :new.PAC_THIRD_CDA_ID
       , :new.DOC_GAUGE_ID
    from DOC_DOCUMENT
   where DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID;
end DOC_POS_BI_DENORM;

ALTER TRIGGER "C_ITX"."DOC_POS_BI_DENORM" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_BIUD_INVOICE_EXPIRY"
  before insert or delete or update of "DOC_INVOICE_EXPIRY_ID"
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Maj du compteur de position généré par un échéancier
* @created fp 30.11.2006
* @lastUpdate
*/
declare
begin
  -- maj du compteur de positions générées par les échéances
  if     (   inserting
          or updating)
     and :new.DOC_INVOICE_EXPIRY_ID is not null then
    update DOC_INVOICE_EXPIRY
       set INX_NB_POS_GEN = INX_NB_POS_GEN + 1
         , INX_INVOICE_GENERATED = sign(INX_NB_POS_GEN + 1)
     where DOC_INVOICE_EXPIRY_ID = :new.DOC_INVOICE_EXPIRY_ID;
  elsif     (   updating
             or deleting)
        and :old.DOC_INVOICE_EXPIRY_ID is not null then
    update DOC_INVOICE_EXPIRY
       set INX_NB_POS_GEN = INX_NB_POS_GEN - 1
         , INX_INVOICE_GENERATED = sign(INX_NB_POS_GEN - 1)
     where DOC_INVOICE_EXPIRY_ID = :old.DOC_INVOICE_EXPIRY_ID;
  end if;
end DOC_POS_BIUD_INVOICE_EXPIRY;


ALTER TRIGGER "C_ITX"."DOC_POS_BIUD_INVOICE_EXPIRY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_BIUD_RECORD_LINK"
  before insert or update of "DOC_RECORD_ID", "C_DOC_POS_STATUS", "POS_IMPUTATION" or delete
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Maintenance des liens entre dossiers
* @created fp 31.10.2007
* @version 2003
* @lastUpdate
*/
declare
  vIsGaugeOk number(1);
begin
  if PCS.PC_CONFIG.GetBooleanConfig('GAL_PROJECT_MANAGEMENT') then
    select sign(count(*) )
      into vIsgaugeOk
      from DOC_DOCUMENT DMT
         , DOC_GAUGE GAU
     where DMT.DOC_DOCUMENT_ID = nvl(:old.DOC_DOCUMENT_ID, :new.DOC_DOCUMENT_ID)
       and GAU.DOC_GAUGE_ID = DMT.DOC_GAUGE_ID
       and instr(';' || PCS.PC_CONFIG.GetConfig('GAL_GAUGE_BALANCE_ORDER') || ';', ';' || GAU.GAU_DESCRIBE || ';') > 0;

    if vIsGaugeOk = 1 then
      -- ne passe que si le dossier est renseigné ou si le statut de la position à changé
      if    :old.DOC_RECORD_ID is not null
         or :new.DOC_RECORD_ID is not null
         or (     (   nvl(:old.C_DOC_POS_STATUS, '00') = '05'
                   or nvl(:new.C_DOC_POS_STATUS, '00') = '05')
             and nvl(:new.C_DOC_POS_STATUS, '00') <> nvl(:old.C_DOC_POS_STATUS, '00')
            ) then
        -- mode ajout des valeurs
        if     (   inserting
                or updating)
           and :new.DOC_RECORD_ID is not null
           and :new.C_DOC_POS_STATUS <> '05'
           and :new.POS_IMPUTATION = 0 then
          -- création du lien dans DOC_RECORD_LINK
          DOC_RECORD_FUNCTIONS.linkProjectRecord(:new.DOC_DOCUMENT_ID, :new.DOC_RECORD_ID, 1);
        end if;

        -- Mode suppression anciennes valeurs
        if     (   deleting
                or updating)
           and :old.DOC_RECORD_Id is not null
           and :old.C_DOC_POS_STATUS <> '05'
           and :old.POS_IMPUTATION = 0 then
          -- création du lien dans DOC_RECORD_LINK
          DOC_RECORD_FUNCTIONS.linkProjectRecord(:old.DOC_DOCUMENT_ID, :old.DOC_RECORD_ID, -1);
        end if;
      end if;

      -- mode ventilation
      if    (    updating
             and (    (:old.pos_imputation <> :new.pos_imputation)
                  or (    :old.pos_imputation = 1
                      and (     (   :old.c_doc_pos_status = '05'
                                 or :new.c_doc_pos_status = '05')
                           and :old.c_doc_pos_status <> :new.c_doc_pos_status
                          )
                     )
                 )
            )
         or     deleting
            and :old.pos_imputation = 1 then
        -- modification
        if updating then
          -- changement du flag ventilation
          if (:old.pos_imputation <> :new.pos_imputation) then
            for tplImputation in (select DOC_RECORD_ID
                                    from DOC_POSITION_IMPUTATION
                                   where DOC_POSITION_ID = :new.DOC_POSITION_ID) loop
              if :old.pos_imputation = 0 then
                -- création du lien dans DOC_RECORD_LINK
                DOC_RECORD_FUNCTIONS.linkProjectRecord(:new.DOC_DOCUMENT_ID, tplImputation.DOC_RECORD_ID, 1);
              else
                -- création du lien dans DOC_RECORD_LINK
                DOC_RECORD_FUNCTIONS.linkProjectRecord(:new.DOC_DOCUMENT_ID, tplImputation.DOC_RECORD_ID, -1);
              end if;
            end loop;
          -- changement du statut de la position à "annuler" ou de "annuler" à "autre"
          elsif     (   :old.c_doc_pos_status = '05'
                     or :new.c_doc_pos_status = '05')
                and :old.c_doc_pos_status <> :new.c_doc_pos_status then
            for tplImputation in (select DOC_RECORD_ID
                                    from DOC_POSITION_IMPUTATION
                                   where DOC_POSITION_ID = :new.DOC_POSITION_ID) loop
              if :old.c_doc_pos_status = '05' then
                -- création du lien dans DOC_RECORD_LINK
                DOC_RECORD_FUNCTIONS.linkProjectRecord(:new.DOC_DOCUMENT_ID, tplImputation.DOC_RECORD_ID, 1);
              else
                -- création du lien dans DOC_RECORD_LINK
                DOC_RECORD_FUNCTIONS.linkProjectRecord(:new.DOC_DOCUMENT_ID, tplImputation.DOC_RECORD_ID, -1);
              end if;
            end loop;
          end if;
        -- effacement de la position
        elsif deleting then
          for tplImputation in (select DOC_RECORD_ID
                                  from DOC_POSITION_IMPUTATION
                                 where DOC_POSITION_ID = :new.DOC_POSITION_ID) loop
            -- création du lien dans DOC_RECORD_LINK
            DOC_RECORD_FUNCTIONS.linkProjectRecord(:new.DOC_DOCUMENT_ID, tplImputation.DOC_RECORD_ID, -1);
          end loop;
        end if;
      end if;
    end if;
  end if;
end DOC_POS_BIUD_RECORD_LINK;

ALTER TRIGGER "C_ITX"."DOC_POS_BIUD_RECORD_LINK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_BIUD_UPDATE_FLAGS"
  before insert or delete or update of "POS_DISCOUNT_AMOUNT"
                                     , "POS_CHARGE_AMOUNT"
                                     , "POS_VAT_AMOUNT"
                                     , "POS_VAT_BASE_AMOUNT"
                                     , "POS_GROSS_UNIT_VALUE"
                                     , "POS_NET_UNIT_VALUE"
                                     , "POS_NET_UNIT_VALUE_INCL"
                                     , "POS_REF_UNIT_VALUE"
                                     , "POS_GROSS_VALUE"
                                     , "POS_NET_VALUE_EXCL"
                                     , "POS_NET_VALUE_INCL"
                                     , "POS_BASIS_QUANTITY"
                                     , "POS_BASIS_QUANTITY_SU"
                                     , "POS_FINAL_QUANTITY"
                                     , "POS_INTERMEDIATE_QUANTITY"
                                     , "POS_NET_WEIGHT"
                                     , "POS_GROSS_WEIGHT"
                                     , "C_DOC_POS_STATUS"
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Maj des flag de recalculation des échéances et de rewgénération des no de BVR
* @created fp 15.02.2002
* @lastUpdate fp 03.11.2010
* @version 10
*/
declare
  detAccountId     ACS_TAX_CODE.ACS_TAX_CODE_ID%type;
  gasWeightMat     DOC_GAUGE_STRUCTURED.GAS_WEIGHT_MAT%type;
  dmtCreateFootMat DOC_DOCUMENT.DMT_CREATE_FOOT_MAT%type;
  posCreateMat     DOC_POSITION.POS_CREATE_MAT%type;
  bUpdateFlags     boolean                                    default false;
begin
  -- A l'annulation d'une position, il faut recalculer les montants du doc
  if     (:new.C_DOC_POS_STATUS = '05')
     and (:old.C_DOC_POS_STATUS <> '05') then
    bUpdateFlags  := true;
  end if;

  -- maj des flags document
  if (    (     (   inserting
                 or updating)
           and :new.C_GAUGE_TYPE_POS not in('6') )
      or (    deleting
          and :old.C_GAUGE_TYPE_POS not in('6') )
     ) then
    bUpdateFlags  := true;
  end if;

  -- maj des flags document
  if bUpdateFlags then
    update DOC_DOCUMENT
       set DMT_REDO_PAYMENT_DATE = 1
         , DMT_RECALC_FOOT_CHARGE = 1
         , DMT_RECALC_TOTAL = 1
     where DOC_DOCUMENT_ID = nvl(:new.DOC_DOCUMENT_ID, :old.DOC_DOCUMENT_ID);
  end if;

  -- maj des flags position
  if     inserting
     and :new.C_GAUGE_TYPE_POS in('1', '2', '3', '7', '8', '10', '91', '21')
     and :new.POS_NET_TARIFF = 0 then
    :new.POS_CREATE_POSITION_CHARGE  := 1;
    :new.POS_UPDATE_POSITION_CHARGE  := 1;
  elsif     updating
        and (   :old.POS_GROSS_VALUE <> :new.POS_GROSS_VALUE
             or :old.POS_GROSS_VALUE_INCL <> :new.POS_GROSS_VALUE_INCL
             or :old.POS_BASIS_QUANTITY <> :new.POS_BASIS_QUANTITY
             or :old.POS_INTERMEDIATE_QUANTITY <> :new.POS_INTERMEDIATE_QUANTITY
             or :old.POS_FINAL_QUANTITY <> :new.POS_FINAL_QUANTITY
            )
        and :new.POS_NET_TARIFF = 0 then
    -- recherche si l'on effectue une correction du montant de TVA
    select max(VDA.DOC_VAT_DET_ACCOUNT_ID)
      into detAccountId
      from DOC_VAT_DET_ACCOUNT VDA
     where VDA.DOC_FOOT_ID = :new.DOC_DOCUMENT_ID
       and VDA.DOC_POSITION_ID = :new.DOC_POSITION_ID;

    -- si la modification de montant est liée à la correction d'arrondi, on ne recalcule pas les remises/taxes
    if detAccountId is null then
      :new.POS_UPDATE_POSITION_CHARGE  := 1;
    end if;
  end if;

  -- maj du flag position de gestion des poids matières précieuses
  if inserting then
    -- si on a pas affaire à un gabarit structuré, on passe dans l'exception silencieuse
    begin
      select GAS_WEIGHT_MAT
        into gasWeightMat
        from DOC_GAUGE_STRUCTURED
       where DOC_GAUGE_ID = :new.DOC_GAUGE_ID;

      :new.POS_CREATE_MAT  := nvl(:new.POS_CREATE_MAT, gasWeightMat);
    exception
      when no_data_found then
        null;
    end;
  elsif     updating
        and (nvl(:old.POS_BASIS_QUANTITY_SU, 0) <> nvl(:new.POS_BASIS_QUANTITY_SU, 0) ) then
    -- Mise à jour des matières précieuses position si la quantité de base en unité de stockage a changé
    begin
      select DMT.DMT_CREATE_FOOT_MAT
           , GAS.GAS_WEIGHT_MAT
        into dmtCreateFootMat
           , gasWeightMat
        from DOC_DOCUMENT DMT
           , DOC_GAUGE_STRUCTURED GAS
       where DMT.DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID
         and DMT.DOC_GAUGE_ID = GAS.DOC_GAUGE_ID;

      DOC_POSITION_ALLOY_FUNCTIONS.UpdateAlloyPosQtyChange(:new.DOC_POSITION_ID
                                                         , :new.DOC_DOCUMENT_ID
                                                         , :new.GCO_GOOD_ID
                                                         , :old.POS_BASIS_QUANTITY_SU
                                                         , :new.POS_BASIS_QUANTITY_SU
                                                         , dmtCreateFootMat
                                                         , gasWeightMat
                                                         , :new.POS_CREATE_MAT
                                                          );
    exception
      when no_data_found then
        null;
    end;
  end if;
exception
  -- dans ce cas c'est le trigger DOC_DMT_AU_PROTECTED qui provoque cette mise à jour
  -- et il fait de toute façon le traîtement
  when ex.TABLE_MUTATING then
    null;
end DOC_POS_BIUD_UPDATE_FLAGS;

ALTER TRIGGER "C_ITX"."DOC_POS_BIUD_UPDATE_FLAGS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_BIU_LOCAL_CURRENCY"
  before insert or update of POS_MODIFY_RATE
                           , POS_NET_VALUE_EXCL
                           , POS_NET_VALUE_INCL
                           , POS_GROSS_VALUE
                           , POS_GROSS_VALUE_INCL
                           , POS_VAT_TOTAL_AMOUNT
                           , POS_VAT_AMOUNT
                           , POS_VAT_RATE
                           , ACS_TAX_CODE_ID
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Maj des montants en monnaie locale
* @author Fabrice Perotto - Joffroy Christen
* @version 2003
* @lastUpdate 06.01.2006
*/
declare
  euro_rate            DOC_DOCUMENT.DMT_RATE_OF_EXCHANGE%type;
  curr_id              DOC_DOCUMENT.ACS_FINANCIAL_CURRENCY_ID%type;
  vat_curr_id          DOC_DOCUMENT.ACS_ACS_FINANCIAL_CURRENCY_ID%type;
  local_curr_id        DOC_DOCUMENT.ACS_FINANCIAL_CURRENCY_ID%type;
  document_date        DOC_DOCUMENT.DMT_DATE_DOCUMENT%type;
  rate_of_exchange     DOC_DOCUMENT.DMT_RATE_OF_EXCHANGE%type;
  base_price           DOC_DOCUMENT.DMT_BASE_PRICE%type;
  vat_rate_of_exchange DOC_DOCUMENT.DMT_VAT_EXCHANGE_RATE%type;
  vat_base_price       DOC_DOCUMENT.DMT_VAT_BASE_PRICE%type;
  det_account_id       DOC_VAT_DET_ACCOUNT.DOC_VAT_DET_ACCOUNT_ID%type;
  bidon                DOC_POSITION.POS_NET_VALUE_EXCL_E%type;
  vTaxTransaction      ACS_ACCOUNT.ACC_INTEREST%type;
  vRefDate             DOC_DOCUMENT.DMT_DATE_DELIVERY%type;
begin
  -- Initialisation du champ POS_INCLUDE_TAX_TARIFF pour les positions de type '5'
  if     (:new.C_GAUGE_TYPE_POS = '5')
     and (inserting) then
    :new.POS_INCLUDE_TAX_TARIFF  := DOC_FUNCTIONS.isDocumentTTC(:new.DOC_DOCUMENT_ID);
  end if;

  if (:new.C_GAUGE_TYPE_POS <> '6') then
    vRefDate  := null;

    -- recherche si l'on effectue une correction du montant de TVA
    select max(VDA.DOC_VAT_DET_ACCOUNT_ID)
      into det_account_id
      from DOC_VAT_DET_ACCOUNT VDA
     where VDA.DOC_FOOT_ID = :new.DOC_DOCUMENT_ID
       and VDA.DOC_POSITION_ID = :new.DOC_POSITION_ID;

    -- Si ce n'est pas le cas
    if    det_account_id is null
       or :new.POS_MODIFY_RATE = 1 then
      -- Si c'est une modification des taux de change,
      if     updating
         and :old.POS_MODIFY_RATE = 0
         and :new.POS_MODIFY_RATE = 1 then
        -- Mise à jour du récapitulatif TVA des positions
        -- Retrait des valeurs avant recalcul des montants B/E/V
        DOC_VAT.UPDATE_POSITION_VAT(:new.DOC_DOCUMENT_ID
                                  , :new.C_GAUGE_TYPE_POS
                                  , :new.ACS_TAX_CODE_ID
                                  , :new.POS_NET_VALUE_EXCL
                                  , :new.POS_NET_VALUE_EXCL_B
                                  , :new.POS_NET_VALUE_EXCL_V
                                  , :new.POS_VAT_RATE
                                  , :new.POS_VAT_TOTAL_AMOUNT
                                  , :new.POS_VAT_TOTAL_AMOUNT_B
                                  , :new.POS_VAT_TOTAL_AMOUNT_V
                                  , :new.POS_VAT_AMOUNT
                                  , :new.POS_VAT_BASE_AMOUNT
                                  , :new.POS_VAT_AMOUNT_V
                                  , -1
                                   );
      else
        -- Si ce n'est pas une modification des taux de change, on recalcule la TVA

        -- Recherche de la date de livraison
        -- Recherche de la date de livraison de la position source
        vRefDate  := :new.POS_DATE_DELIVERY;

        -- Si nulle, recherche de la date de livraison du document source
        -- ou de la date valeur
        if vRefDate is null then
          select nvl(DMT.DMT_DATE_DELIVERY, nvl(DMT.DMT_REVALUATION_DATE, DMT.DMT_DATE_VALUE) )
            into vRefDate
            from DOC_DOCUMENT DMT
           where DMT.DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID;
        end if;

        if :new.POS_INCLUDE_TAX_TARIFF = 1 then   -- TTC
          ACS_FUNCTION.CalcVatAmount(aTaxCodeId        => :new.ACS_TAX_CODE_ID
                                   , aRefDate          => vRefDate
                                   , aIncludedVat      => 'I'
                                   , aRoundAmount      => to_number(nvl(2   /*PCS.PC_CONFIG.GetConfig('DOC_ROUND_POSITION')*/
                                                                         , '0') )
                                   , aNetAmountExcl    => :new.POS_NET_VALUE_EXCL
                                   , aNetAmountIncl    => :new.POS_NET_VALUE_INCL
                                   , aLiabledRate      => :new.POS_VAT_LIABLED_RATE
                                   , aLiabledAmount    => :new.POS_VAT_LIABLED_AMOUNT
                                   , aTaxeRate         => :new.POS_VAT_RATE
                                   , aVatTotalAmount   => :new.POS_VAT_TOTAL_AMOUNT
                                   , aDeductibleRate   => :new.POS_VAT_DEDUCTIBLE_RATE
                                   , aVatAmount        => :new.POS_VAT_AMOUNT
                                    );

          if :new.POS_BASIS_QUANTITY <> 0 then
            :new.POS_NET_UNIT_VALUE  := :new.POS_NET_VALUE_EXCL / :new.POS_BASIS_QUANTITY;
          else
            :new.POS_NET_UNIT_VALUE  := :new.POS_NET_VALUE_EXCL;
          end if;
        else   -- HT
          ACS_FUNCTION.CalcVatAmount(aTaxCodeId        => :new.ACS_TAX_CODE_ID
                                   , aRefDate          => vRefDate
                                   , aIncludedVat      => 'E'
                                   , aRoundAmount      => to_number(nvl(2   /*PCS.PC_CONFIG.GetConfig('DOC_ROUND_POSITION')*/
                                                                         , '0') )
                                   , aNetAmountExcl    => :new.POS_NET_VALUE_EXCL
                                   , aNetAmountIncl    => :new.POS_NET_VALUE_INCL
                                   , aLiabledRate      => :new.POS_VAT_LIABLED_RATE
                                   , aLiabledAmount    => :new.POS_VAT_LIABLED_AMOUNT
                                   , aTaxeRate         => :new.POS_VAT_RATE
                                   , aVatTotalAmount   => :new.POS_VAT_TOTAL_AMOUNT
                                   , aDeductibleRate   => :new.POS_VAT_DEDUCTIBLE_RATE
                                   , aVatAmount        => :new.POS_VAT_AMOUNT
                                    );

          if :new.POS_BASIS_QUANTITY <> 0 then
            :new.POS_NET_UNIT_VALUE_INCL  := :new.POS_NET_VALUE_INCL / :new.POS_BASIS_QUANTITY;
          else
            :new.POS_NET_UNIT_VALUE_INCL  := :new.POS_NET_VALUE_INCL;
          end if;
        end if;
      -- Fin du calcul décompte TVA
      end if;

      -- recherche des informations nécessaires à la conversion dans la table DOC_DOCUMENT
      select ACS_FINANCIAL_CURRENCY_ID
           , ACS_ACS_FINANCIAL_CURRENCY_ID
           , DMT_DATE_DOCUMENT
           , DMT_RATE_OF_EXCHANGE
           , DMT_BASE_PRICE
           , DMT_VAT_EXCHANGE_RATE
           , DMT_VAT_BASE_PRICE
        into curr_id
           , vat_curr_id
           , document_date
           , rate_of_exchange
           , base_price
           , vat_rate_of_exchange
           , vat_base_price
        from DOC_DOCUMENT
       where DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID;

      begin
        select nvl(ACC.ACC_INTEREST, 0)
          into vTaxTransaction
          from ACS_ACCOUNT ACC
         where ACC.ACS_ACCOUNT_ID = :new.ACS_TAX_CODE_ID;
      exception
        when no_data_found then
          vTaxTransaction  := 0;
      end;

      local_curr_id         := ACS_FUNCTION.GetLocalCurrencyId;

      -- Les différents cas possibles
      -- n°   Monnaie base    Monnaie Document    Monnaie TVA
      -- 1.   CHF             CHF                 CHF
      -- 2.   CHF             EUR                 CHF
      -- 3.   CHF             EUR                 EUR
      -- 4.   CHF             CHF                 EUR
      -- 5.   CHF             USD                 EUR
      if     (local_curr_id = vat_curr_id)
         and (curr_id = vat_curr_id) then   -- Cas n° 1 -> Ex : CHF - CHF - CHF
        :new.POS_NET_VALUE_INCL_B    := :new.POS_NET_VALUE_INCL;
        :new.POS_NET_VALUE_EXCL_B    := :new.POS_NET_VALUE_EXCL;
        :new.POS_GROSS_VALUE_B       := :new.POS_GROSS_VALUE;
        :new.POS_GROSS_VALUE_INCL_B  := :new.POS_GROSS_VALUE_INCL;
        :new.POS_NET_VALUE_INCL_V    := :new.POS_NET_VALUE_INCL;
        :new.POS_NET_VALUE_EXCL_V    := :new.POS_NET_VALUE_EXCL;
        :new.POS_GROSS_VALUE_V       := :new.POS_GROSS_VALUE;
        :new.POS_GROSS_VALUE_INCL_V  := :new.POS_GROSS_VALUE_INCL;
        :new.POS_VAT_TOTAL_AMOUNT_B  := :new.POS_VAT_TOTAL_AMOUNT;
        :new.POS_VAT_TOTAL_AMOUNT_V  := :new.POS_VAT_TOTAL_AMOUNT;
        :new.POS_VAT_BASE_AMOUNT     := :new.POS_VAT_AMOUNT;
        :new.POS_VAT_AMOUNT_V        := :new.POS_VAT_BASE_AMOUNT;
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_INCL, 0)
                                 , curr_id
                                 , local_curr_id
                                 , document_date
                                 , rate_of_exchange
                                 , base_price
                                 , 0
                                 , :new.POS_NET_VALUE_INCL_E
                                 , bidon
                                  );
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_EXCL, 0)
                                 , curr_id
                                 , local_curr_id
                                 , document_date
                                 , rate_of_exchange
                                 , base_price
                                 , 0
                                 , :new.POS_NET_VALUE_EXCL_E
                                 , bidon
                                  );
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE, 0)
                                 , curr_id
                                 , local_curr_id
                                 , document_date
                                 , rate_of_exchange
                                 , base_price
                                 , 0
                                 , :new.POS_GROSS_VALUE_E
                                 , bidon
                                  );
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE_INCL, 0)
                                 , curr_id
                                 , local_curr_id
                                 , document_date
                                 , rate_of_exchange
                                 , base_price
                                 , 0
                                 , :new.POS_GROSS_VALUE_INCL_E
                                 , bidon
                                  );
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_VAT_AMOUNT, 0)
                                 , curr_id
                                 , local_curr_id
                                 , document_date
                                 , rate_of_exchange
                                 , base_price
                                 , 0
                                 , :new.POS_VAT_AMOUNT_E
                                 , bidon
                                  );
--      :new.POS_VAT_AMOUNT_E        := :new.POS_NET_VALUE_INCL_E - :new.POS_NET_VALUE_EXCL_E;
      elsif     (local_curr_id = vat_curr_id)
            and (curr_id <> local_curr_id) then   -- Cas n° 2 -> Ex : CHF - EUR - CHF
        -- ATTENTION : Les paramètres vat_base_price et vat_rate_of_exchange
        --             ont été inversés exprès dans l'appel ConvertAmount()
        --             pour le cas n°2 car le cours TVA stocké est le cours
        --             entre Monnaie TVA et Monnaie Document

        -- Cas n° 2 -> Ex : CHF - EUR - CHF

        -- Les montants en monnaie TVA sont convertis depuis les montants document avec le cours inversé stocké pour la monnaie TVA
        -- Valeur Nette TTC en monnaie TVA
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_INCL, 0)
                                 , vat_curr_id
                                 , curr_id
                                 , document_date
                                 , vat_base_price
                                 , vat_rate_of_exchange
                                 , 0
                                 , bidon
                                 , :new.POS_NET_VALUE_INCL_V
                                  );
        -- Valeur Nette HT en monnaie TVA
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_EXCL, 0)
                                 , vat_curr_id
                                 , curr_id
                                 , document_date
                                 , vat_base_price
                                 , vat_rate_of_exchange
                                 , 0
                                 , bidon
                                 , :new.POS_NET_VALUE_EXCL_V
                                  );
        -- Valeur Brutte TTC en monnaie TVA
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE_INCL, 0)
                                 , vat_curr_id
                                 , curr_id
                                 , document_date
                                 , vat_base_price
                                 , vat_rate_of_exchange
                                 , 0
                                 , bidon
                                 , :new.POS_GROSS_VALUE_INCL_V
                                  );
        -- Valeur Brutte HT en monnaie TVA
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE, 0)
                                 , vat_curr_id
                                 , curr_id
                                 , document_date
                                 , vat_base_price
                                 , vat_rate_of_exchange
                                 , 0
                                 , bidon
                                 , :new.POS_GROSS_VALUE_V
                                  );
        -- Calcul Montant total TVA en monnaie TVA
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_VAT_TOTAL_AMOUNT, 0)
                                 , vat_curr_id
                                 , curr_id
                                 , document_date
                                 , vat_base_price
                                 , vat_rate_of_exchange
                                 , 0
                                 , bidon
                                 , :new.POS_VAT_TOTAL_AMOUNT_V
                                  );
        -- Montant total TVA en monnaie de Base = Montant TVA en monnaie TVA
        :new.POS_VAT_TOTAL_AMOUNT_B  := :new.POS_VAT_TOTAL_AMOUNT_V;
        -- Calcul Montant TVA en monnaie TVA
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_VAT_AMOUNT, 0)
                                 , vat_curr_id
                                 , curr_id
                                 , document_date
                                 , vat_base_price
                                 , vat_rate_of_exchange
                                 , 0
                                 , bidon
                                 , :new.POS_VAT_AMOUNT_V
                                  );
        -- Le Montant TVA en monnaie de Base = Montant TVA en monnaie TVA
        :new.POS_VAT_BASE_AMOUNT     := :new.POS_VAT_AMOUNT_V;
        -- ATTENTION : Ce bout de code est à vérifier NGOMES
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_VAT_AMOUNT, 0)
                                 , curr_id
                                 , local_curr_id
                                 , document_date
                                 , rate_of_exchange
                                 , base_price
                                 , 0
                                 , :new.POS_VAT_AMOUNT_E
                                 , bidon
                                  );

        if :new.POS_INCLUDE_TAX_TARIFF = 0 then   -- HT
          -- Valeur Nette HT en monnaie de base et en monnaie IN
          ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_EXCL, 0)
                                   , curr_id
                                   , local_curr_id
                                   , document_date
                                   , rate_of_exchange
                                   , base_price
                                   , 0
                                   , :new.POS_NET_VALUE_EXCL_E
                                   , :new.POS_NET_VALUE_EXCL_B
                                    );

          -- Valeur Nette TTC en monnaie de base et en monnaie IN
          if vTaxTransaction = 1 then
            :new.POS_NET_VALUE_INCL_B  := :new.POS_NET_VALUE_EXCL_B;
            :new.POS_NET_VALUE_INCL_E  := :new.POS_NET_VALUE_EXCL_E;
          else
            :new.POS_NET_VALUE_INCL_B  := :new.POS_NET_VALUE_EXCL_B + :new.POS_VAT_TOTAL_AMOUNT_B;
--          :new.POS_NET_VALUE_INCL_E  := :new.POS_NET_VALUE_EXCL_E + :new.POS_VAT_TOTAL_AMOUNT_E;
          end if;

          -- Valeur Brutte HT en monnaie de base et en monnaie IN
          ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE, 0)
                                   , curr_id
                                   , local_curr_id
                                   , document_date
                                   , rate_of_exchange
                                   , base_price
                                   , 0
                                   , :new.POS_GROSS_VALUE_E
                                   , :new.POS_GROSS_VALUE_B
                                    );
        else   -- TTC
          -- Valeur Nette TTC en monnaie de base et en monnaie IN
          ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_INCL, 0)
                                   , curr_id
                                   , local_curr_id
                                   , document_date
                                   , rate_of_exchange
                                   , base_price
                                   , 0
                                   , :new.POS_NET_VALUE_INCL_E
                                   , :new.POS_NET_VALUE_INCL_B
                                    );

          -- Valeur Nette HT en monnaie de base et en monnaie IN
          if vTaxTransaction = 1 then
            :new.POS_NET_VALUE_EXCL_B  := :new.POS_NET_VALUE_INCL_B;
            :new.POS_NET_VALUE_EXCL_E  := :new.POS_NET_VALUE_INCL_E;
          else
            :new.POS_NET_VALUE_EXCL_B  := :new.POS_NET_VALUE_INCL_B - :new.POS_VAT_TOTAL_AMOUNT_B;
--          :new.POS_NET_VALUE_EXCL_E  := :new.POS_NET_VALUE_INCL_E - :new.POS_VAT_TOTAL_AMOUNT_E;
          end if;

          -- Valeur Brutte TTC en monnaie de base et en monnaie IN
          ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE_INCL, 0)
                                   , local_curr_id
                                   , curr_id
                                   , document_date
                                   , vat_base_price
                                   , vat_rate_of_exchange
                                   , 0
                                   , :new.POS_GROSS_VALUE_INCL_E
                                   , :new.POS_GROSS_VALUE_INCL_B
                                    );
        end if;
      elsif     (curr_id = vat_curr_id)
            and (curr_id <> local_curr_id) then   -- Cas n° 3 -> Ex : CHF - EUR - EUR
        -- Cas n° 3 -> Ex : CHF - EUR - EUR

        -- Montant en monnaie TVA = Montant en monnaie Document
        :new.POS_NET_VALUE_INCL_V    := :new.POS_NET_VALUE_INCL;
        :new.POS_NET_VALUE_EXCL_V    := :new.POS_NET_VALUE_EXCL;
        :new.POS_GROSS_VALUE_V       := :new.POS_GROSS_VALUE;
        :new.POS_GROSS_VALUE_INCL_V  := :new.POS_GROSS_VALUE_INCL;
        :new.POS_VAT_TOTAL_AMOUNT_V  := :new.POS_VAT_TOTAL_AMOUNT;
        :new.POS_VAT_AMOUNT_V        := :new.POS_VAT_AMOUNT;
        -- Le montant total TVA de la monnaie de base est converti à partir du cours TVA
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_VAT_TOTAL_AMOUNT_V, 0)
                                 , vat_curr_id
                                 , local_curr_id
                                 , document_date
                                 , vat_rate_of_exchange
                                 , vat_base_price
                                 , 0
                                 , bidon
                                 , :new.POS_VAT_TOTAL_AMOUNT_B
                                  );
        -- Le montant TVA de la monnaie de base est converti à partir du cours TVA
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_VAT_AMOUNT_V, 0)
                                 , vat_curr_id
                                 , local_curr_id
                                 , document_date
                                 , vat_rate_of_exchange
                                 , vat_base_price
                                 , 0
                                 , bidon
                                 , :new.POS_VAT_BASE_AMOUNT
                                  );
        -- ATTENTION : Ce bout de code est à vérifier NGOMES
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_VAT_AMOUNT, 0)
                                 , curr_id
                                 , local_curr_id
                                 , document_date
                                 , rate_of_exchange
                                 , base_price
                                 , 0
                                 , :new.POS_VAT_AMOUNT_E
                                 , bidon
                                  );

        if :new.POS_INCLUDE_TAX_TARIFF = 0 then   -- HT
          -- Valeur Nette HT en monnaie de base et en monnaie IN
          ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_EXCL, 0)
                                   , curr_id
                                   , local_curr_id
                                   , document_date
                                   , rate_of_exchange
                                   , base_price
                                   , 0
                                   , :new.POS_NET_VALUE_EXCL_E
                                   , :new.POS_NET_VALUE_EXCL_B
                                    );

          -- Valeur Nette TTC en monnaie de base et en monnaie IN
          if vTaxTransaction = 1 then
            :new.POS_NET_VALUE_INCL_B  := :new.POS_NET_VALUE_EXCL_B;
            :new.POS_NET_VALUE_INCL_E  := :new.POS_NET_VALUE_EXCL_E;
          else
            :new.POS_NET_VALUE_INCL_B  := :new.POS_NET_VALUE_EXCL_B + :new.POS_VAT_TOTAL_AMOUNT_B;
--          :new.POS_NET_VALUE_INCL_E  := :new.POS_NET_VALUE_EXCL_E + :new.POS_VAT_TOTAL_AMOUNT_E;
          end if;

          -- Valeur Brutte HT en monnaie de base et en monnaie IN
          ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE, 0)
                                   , curr_id
                                   , local_curr_id
                                   , document_date
                                   , rate_of_exchange
                                   , base_price
                                   , 0
                                   , :new.POS_GROSS_VALUE_E
                                   , :new.POS_GROSS_VALUE_B
                                    );
        else   -- TTC
          -- Valeur Nette TTC en monnaie de base et en monnaie IN
          ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_INCL, 0)
                                   , curr_id
                                   , local_curr_id
                                   , document_date
                                   , rate_of_exchange
                                   , base_price
                                   , 0
                                   , :new.POS_NET_VALUE_INCL_E
                                   , :new.POS_NET_VALUE_INCL_B
                                    );

          -- Valeur Nette HT en monnaie de base et en monnaie IN
          if vTaxTransaction = 1 then
            :new.POS_NET_VALUE_EXCL_B  := :new.POS_NET_VALUE_INCL_B;
            :new.POS_NET_VALUE_EXCL_E  := :new.POS_NET_VALUE_INCL_E;
          else
            :new.POS_NET_VALUE_EXCL_B  := :new.POS_NET_VALUE_INCL_B - :new.POS_VAT_TOTAL_AMOUNT_B;
--          :new.POS_NET_VALUE_EXCL_E  := :new.POS_NET_VALUE_INCL_E - :new.POS_VAT_TOTAL_AMOUNT_E;
            ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_EXCL, 0)
                                     , curr_id
                                     , local_curr_id
                                     , document_date
                                     , rate_of_exchange
                                     , base_price
                                     , 0
                                     , :new.POS_NET_VALUE_EXCL_E
                                     , bidon
                                      );
          end if;

          -- Valeur Brutte TTC en monnaie de base et en monnaie IN
          ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE_INCL, 0)
                                   , curr_id
                                   , local_curr_id
                                   , document_date
                                   , rate_of_exchange
                                   , base_price
                                   , 0
                                   , :new.POS_GROSS_VALUE_INCL_E
                                   , :new.POS_GROSS_VALUE_INCL_B
                                    );
        end if;
      else
        -- Cas n° 4 -> Ex : CHF - CHF - EUR
        -- Cas n° 5 -> Ex : CHF - USD - EUR
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_INCL, 0)
                                 , curr_id
                                 , local_curr_id
                                 , document_date
                                 , rate_of_exchange
                                 , base_price
                                 , 0
                                 , :new.POS_NET_VALUE_INCL_E
                                 , :new.POS_NET_VALUE_INCL_B
                                  );
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_EXCL, 0)
                                 , curr_id
                                 , local_curr_id
                                 , document_date
                                 , rate_of_exchange
                                 , base_price
                                 , 0
                                 , :new.POS_NET_VALUE_EXCL_E
                                 , :new.POS_NET_VALUE_EXCL_B
                                  );
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE, 0)
                                 , curr_id
                                 , local_curr_id
                                 , document_date
                                 , rate_of_exchange
                                 , base_price
                                 , 0
                                 , :new.POS_GROSS_VALUE_E
                                 , :new.POS_GROSS_VALUE_B
                                  );
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE_INCL, 0)
                                 , curr_id
                                 , local_curr_id
                                 , document_date
                                 , rate_of_exchange
                                 , base_price
                                 , 0
                                 , :new.POS_GROSS_VALUE_INCL_E
                                 , :new.POS_GROSS_VALUE_INCL_B
                                  );
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_VAT_AMOUNT, 0)
                                 , curr_id
                                 , local_curr_id
                                 , document_date
                                 , rate_of_exchange
                                 , base_price
                                 , 0
                                 , :new.POS_VAT_AMOUNT_E
                                 , :new.POS_VAT_BASE_AMOUNT
                                  );

        if vTaxTransaction = 1 then
          :new.POS_VAT_TOTAL_AMOUNT_B  := :new.POS_NET_VALUE_EXCL_B;
        else
          :new.POS_VAT_TOTAL_AMOUNT_B  := :new.POS_NET_VALUE_INCL_B - :new.POS_NET_VALUE_EXCL_B;
        end if;

        -- Montants TVA
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_INCL_B, 0)
                                 , local_curr_id
                                 , vat_curr_id
                                 , document_date
                                 , vat_rate_of_exchange
                                 , vat_base_price
                                 , 0
                                 , bidon
                                 , :new.POS_NET_VALUE_INCL_V
                                  );
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_NET_VALUE_EXCL_B, 0)
                                 , local_curr_id
                                 , vat_curr_id
                                 , document_date
                                 , vat_rate_of_exchange
                                 , vat_base_price
                                 , 0
                                 , bidon
                                 , :new.POS_NET_VALUE_EXCL_V
                                  );
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE_B, 0)
                                 , local_curr_id
                                 , vat_curr_id
                                 , document_date
                                 , vat_rate_of_exchange
                                 , vat_base_price
                                 , 0
                                 , bidon
                                 , :new.POS_GROSS_VALUE_V
                                  );
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_GROSS_VALUE_INCL_B, 0)
                                 , local_curr_id
                                 , vat_curr_id
                                 , document_date
                                 , vat_rate_of_exchange
                                 , vat_base_price
                                 , 0
                                 , bidon
                                 , :new.POS_GROSS_VALUE_INCL_V
                                  );
        ACS_FUNCTION.ConvertAmount(nvl(:new.POS_VAT_BASE_AMOUNT, 0)
                                 , local_curr_id
                                 , vat_curr_id
                                 , document_date
                                 , vat_rate_of_exchange
                                 , vat_base_price
                                 , 0
                                 , bidon
                                 , :new.POS_VAT_AMOUNT_V
                                  );

        if vTaxTransaction = 1 then
          :new.POS_VAT_TOTAL_AMOUNT_V  := :new.POS_NET_VALUE_EXCL_V;
        else
          :new.POS_VAT_TOTAL_AMOUNT_V  := :new.POS_NET_VALUE_INCL_V - :new.POS_NET_VALUE_EXCL_V;
        end if;
      end if;

      if     updating
         and :old.POS_MODIFY_RATE = 0
         and :new.POS_MODIFY_RATE = 1 then
        -- Mise à jour du récapitulatif TVA des positions
        -- Ajout des valeurs après recalcul des montants B/E/V
        DOC_VAT.UPDATE_POSITION_VAT(:new.DOC_DOCUMENT_ID
                                  , :new.C_GAUGE_TYPE_POS
                                  , :new.ACS_TAX_CODE_ID
                                  , :new.POS_NET_VALUE_EXCL
                                  , :new.POS_NET_VALUE_EXCL_B
                                  , :new.POS_NET_VALUE_EXCL_V
                                  , :new.POS_VAT_RATE
                                  , :new.POS_VAT_TOTAL_AMOUNT
                                  , :new.POS_VAT_TOTAL_AMOUNT_B
                                  , :new.POS_VAT_TOTAL_AMOUNT_V
                                  , :new.POS_VAT_AMOUNT
                                  , :new.POS_VAT_BASE_AMOUNT
                                  , :new.POS_VAT_AMOUNT_V
                                  , 1
                                   );
      end if;

      :new.POS_MODIFY_RATE  := 0;
    end if;
  end if;
end DOC_POS_BIU_LOCAL_CURRENCY;

ALTER TRIGGER "C_ITX"."DOC_POS_BIU_LOCAL_CURRENCY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_BIU_OPERATION_AMOUNT"
  before insert or update of POS_GROSS_UNIT_VALUE, POS_FINAL_QUANTITY
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour du flag de recalcul des montants de position et mise à jour du flag de mise à jour de l'opération suite
*    à une modif dans les positions
* @created fp 24.04.2014
* @version 201
* @lastUpdate
*/
declare
  nUpdateOp number;
begin
  if    :new.FAL_SCHEDULE_STEP_ID is not null
     or :new.FAL_LOT_ID is not null then
    nUpdateOp           := nvl(:new.POS_UPDATE_OP, 0);

    if nUpdateOp = 0 then
      nUpdateOp  := 2;   -- Montant
    else
      nUpdateOp  := 3;   -- delai et montant
    end if;

    -- Mise à jour du flag de demande de mise à jour de l'opération suite à la modification du délai
    :new.POS_UPDATE_OP  := nUpdateOp;
  end if;
exception
  -- dans ce cas c'est l'effacement en cascade d'une position qui provoque le déclenchement
  -- du trigger et il n'est pas nécessaire de faire de mise à jour
  when ex.TABLE_MUTATING then
    null;
end DOC_POS_BIU_OPERATION_AMOUNT;

ALTER TRIGGER "C_ITX"."DOC_POS_BIU_OPERATION_AMOUNT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_BIU_UNIT_VALUE"
  before insert or update of POS_DISCOUNT_AMOUNT
                           , POS_CHARGE_AMOUNT
                           , POS_DISCOUNT_UNIT_VALUE
                           , POS_INCLUDE_TAX_TARIFF
                           , POS_VAT_AMOUNT
                           , POS_TARIFF_UNIT
                           , POS_GROSS_UNIT_VALUE
                           , POS_GROSS_UNIT_VALUE_INCL
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Si la position n'a pas de remises/taxes, la Valeur unitaire brutte = Valeur unitaire nette
*    Si l'unité tariffaire est à 0, ce n'est pas un tarif alors on vide les champs relatifs
* @created NGV 25/10/2002
* @version 2003
* @lastUpdate fp 29.08.2003
*/
begin
  if     (:new.POS_DISCOUNT_AMOUNT = 0)
     and (:new.POS_CHARGE_AMOUNT = 0)
     and (:new.POS_DISCOUNT_UNIT_VALUE = 0) then
    if :new.POS_INCLUDE_TAX_TARIFF = 1 then   -- TTC
      :new.POS_NET_UNIT_VALUE_INCL  := :new.POS_GROSS_UNIT_VALUE_INCL;
    else   -- HT
      :new.POS_NET_UNIT_VALUE  := :new.POS_GROSS_UNIT_VALUE;
    end if;
  end if;

  if (:new.POS_VAT_AMOUNT = 0) then
    if :new.POS_INCLUDE_TAX_TARIFF = 1 then   -- TTC
      :new.POS_NET_UNIT_VALUE  := :new.POS_NET_UNIT_VALUE_INCL;
    else   -- HT
      :new.POS_NET_UNIT_VALUE_INCL  := :new.POS_NET_UNIT_VALUE;
    end if;
  end if;

  if (:new.POS_TARIFF_UNIT = 0) then
    :new.POS_TARIFF_UNIT         := null;
    :new.DIC_TARIFF_ID           := null;
    :new.POS_TARIFF_INITIALIZED  := null;
  end if;

  -- valeurs unitaires en unité de stockage
  if :NEW.POS_GROSS_UNIT_VALUE is not null and :NEW.POS_GROSS_UNIT_VALUE_SU is null and :NEW.POS_CONVERT_FACTOR <> 0 then
    :NEW.POS_GROSS_UNIT_VALUE_SU := :NEW.POS_GROSS_UNIT_VALUE/:NEW.POS_CONVERT_FACTOR;
  end if;
  if :NEW.POS_GROSS_UNIT_VALUE_INCL is not null and :NEW.POS_GROSS_UNIT_VALUE_INCL_SU is null and :NEW.POS_CONVERT_FACTOR <> 0 then
    :NEW.POS_GROSS_UNIT_VALUE_INCL_SU := :NEW.POS_GROSS_UNIT_VALUE_INCL/:NEW.POS_CONVERT_FACTOR;
  end if;

end DOC_POS_BIU_UNIT_VALUE;

ALTER TRIGGER "C_ITX"."DOC_POS_BIU_UNIT_VALUE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_BU_IMPUTATION"
  before update of POS_IMPUTATION
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Vérifie si les imputations sont autorisée
*
* @author VJ
* @created 14/09/2006
* @version 2003
*/
declare
  nRecord    number;
  nRefRecord number;
begin
  if (nvl(:old.POS_IMPUTATION, 0) <> nvl(:new.POS_IMPUTATION, 0) ) then
    -- Passage du flag de 0 à 1.
    if (nvl(:new.POS_IMPUTATION, 0) = 1) then
      -- Vérifie l'existance d'une ou plusieurs imputations position.
      select count(POI.DOC_POSITION_IMPUTATION_ID)
        into nRecord
        from DOC_POSITION_IMPUTATION POI
       where POI.DOC_POSITION_ID = :new.DOC_POSITION_ID;

      if nRecord = 0 then
        -- Vérifie l'existance d'une ou plusieurs répartitions de référence. Les modèles de répartition se distinguent
        -- par le fait que le seul de champ DOC_DOCUMENT_ID est renseigné.
        select count(POI.DOC_POSITION_IMPUTATION_ID)
          into nRefRecord
          from DOC_POSITION_IMPUTATION POI
         where POI.DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID
           and POI.DOC_POSITION_ID is null
           and POI.DOC_POSITION_CHARGE_ID is null
           and POI.DOC_FOOT_CHARGE_ID is null;

        if    nRefRecord = 0
           or (:new.C_GAUGE_TYPE_POS > '1')
           or (:new.DOC_DOC_POSITION_ID is not null) then
--           or :new.C_GAUGE_TYPE_POS = '4'   -- texte
--           or :new.C_GAUGE_TYPE_POS = '5'   -- Valeur
--           or :new.C_GAUGE_TYPE_POS = '6'   -- Recapitulative
--           or :new.C_GAUGE_TYPE_POS = '9'   -- Kit (valeur CPT)
--           or :new.C_GAUGE_TYPE_POS = '71'   -- Composant Assemblage (valeur PT)
--           or :new.C_GAUGE_TYPE_POS = '81'   -- Composant Assemblage (valeur PT somme CPT)
--           or :new.C_GAUGE_TYPE_POS = '101' then   -- Composant Kit (valeur PT)
          -- Imputation interdite
          :new.POS_IMPUTATION  := 0;
        end if;
      end if;
    end if;
  end if;
end DOC_POS_BU_IMPUTATION;

ALTER TRIGGER "C_ITX"."DOC_POS_BU_IMPUTATION" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_BU_POSI_ACCU"
  before update of GCO_GOOD_ID, POS_NET_UNIT_VALUE, POS_FINAL_QUANTITY, POS_BASIS_QUANTITY, C_DOC_POS_STATUS
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des totalisateurs de positions
* @author Fabrice Perotto
* @version 2003
* @lastUpdate
*/
declare
  -- curseur sur tous les detail position de la position
  cursor detail_position_cursor(position_id number, document_id number, gauge_position_id number)
  is
    select DET.GCO_CHARACTERIZATION_ID
         , DET.GCO_GCO_CHARACTERIZATION_ID
         , DET.GCO2_GCO_CHARACTERIZATION_ID
         , DET.GCO3_GCO_CHARACTERIZATION_ID
         , DET.GCO4_GCO_CHARACTERIZATION_ID
         , DET.PDE_CHARACTERIZATION_VALUE_1
         , DET.PDE_CHARACTERIZATION_VALUE_2
         , DET.PDE_CHARACTERIZATION_VALUE_3
         , DET.PDE_CHARACTERIZATION_VALUE_4
         , DET.PDE_CHARACTERIZATION_VALUE_5
         , DET.STM_LOCATION_ID
         , DET.STM_STM_LOCATION_ID
         , DET.PDE_MOVEMENT_QUANTITY
         , DET.PDE_FINAL_DELAY
         , DET.PDE_FINAL_QUANTITY
         , DET.PDE_BALANCE_QUANTITY
         , DOC.PAC_THIRD_ID
         , DOC.DIC_GAUGE_TYPE_DOC_ID
         , DOC.DMT_DATE_DOCUMENT
         , GPO.GAP_DELAY
         , GST.GAS_BALANCE_STATUS
         , GAU.C_GAUGE_TYPE
      from DOC_POSITION_DETAIL DET
         , DOC_DOCUMENT DOC
         , DOC_GAUGE_POSITION GPO
         , DOC_GAUGE_STRUCTURED GST
         , DOC_GAUGE GAU
     where DET.DOC_POSITION_ID = position_id
       and DOC.DOC_DOCUMENT_ID = document_id
       and GPO.DOC_GAUGE_POSITION_ID = gauge_position_id
       and GST.DOC_GAUGE_ID = DOC.DOC_GAUGE_ID
       and GAU.DOC_GAUGE_ID = GST.DOC_GAUGE_ID;

  detail_position_tuple detail_position_cursor%rowtype;
begin
  -- pas de mise à jour des totalisateurs (possible uniquement par recalcul global)
  if PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '0' then
    null;
  -- mise à jour instantannée des totalisateurs de position
  elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '1' then
    -- ouverture du curseur sur les detail de position
    open detail_position_cursor(:old.DOC_POSITION_ID, :old.DOC_DOCUMENT_ID, :old.DOC_GAUGE_POSITION_ID);

    fetch detail_position_cursor
     into detail_position_tuple;

    while detail_position_cursor%found loop
      if :old.c_gauge_type_pos in('1', '2', '3', '7', '8', '91', '101') then
        -- retrait des anciennes valeurs
        DOC_ACCUMULATOR.DOC_TOTAL_POSITION(:old.GCO_GOOD_ID
                                         , detail_position_tuple.PAC_THIRD_ID
                                         , detail_position_tuple.DIC_GAUGE_TYPE_DOC_ID
                                         , detail_position_tuple.GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.GCO_GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.GCO2_GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.GCO3_GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.GCO4_GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_1
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_2
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_3
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_4
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_5
                                         , detail_position_tuple.GAP_DELAY
                                         , nvl(detail_position_tuple.PDE_FINAL_DELAY
                                             , detail_position_tuple.DMT_DATE_DOCUMENT
                                              )
                                         , detail_position_tuple.DMT_DATE_DOCUMENT
                                         , detail_position_tuple.PDE_FINAL_QUANTITY
                                         , detail_position_tuple.PDE_BALANCE_QUANTITY
                                         , :old.POS_NET_VALUE_EXCL_B
                                         , :old.C_DOC_POS_STATUS
                                         , detail_position_tuple.GAS_BALANCE_STATUS
                                         , detail_position_tuple.C_GAUGE_TYPE
                                         , -1
                                         , 0
                                          );
      end if;

      if :new.c_gauge_type_pos in('1', '2', '3', '7', '8', '91', '101') then
        -- ajout des nouvelles valeurs
        DOC_ACCUMULATOR.DOC_TOTAL_POSITION(:new.GCO_GOOD_ID
                                         , detail_position_tuple.PAC_THIRD_ID
                                         , detail_position_tuple.DIC_GAUGE_TYPE_DOC_ID
                                         , detail_position_tuple.GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.GCO_GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.GCO2_GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.GCO3_GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.GCO4_GCO_CHARACTERIZATION_ID
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_1
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_2
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_3
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_4
                                         , detail_position_tuple.PDE_CHARACTERIZATION_VALUE_5
                                         , detail_position_tuple.GAP_DELAY
                                         , nvl(detail_position_tuple.PDE_FINAL_DELAY
                                             , detail_position_tuple.DMT_DATE_DOCUMENT
                                              )
                                         , detail_position_tuple.DMT_DATE_DOCUMENT
                                         , detail_position_tuple.PDE_FINAL_QUANTITY
                                         , detail_position_tuple.PDE_BALANCE_QUANTITY
                                         , :new.POS_NET_VALUE_EXCL_B
                                         , :new.C_DOC_POS_STATUS
                                         , detail_position_tuple.GAS_BALANCE_STATUS
                                         , detail_position_tuple.C_GAUGE_TYPE
                                         , 1
                                         , 0
                                          );
      end if;

      fetch detail_position_cursor
       into detail_position_tuple;
    end loop;

    close detail_position_cursor;
  -- insertion dans le buffer des totalisateurs de position (maj différée)
  elsif PCS.PC_CONFIG.GetConfig('DOC_OFF_LINE_ACCUMULATOR') = '2' then
    -- Retrait des anciennes valeurs
    insert into DOC_POSI_ACCU_BUFFER
                (DOC_POSI_ACCU_BUFFER_ID
               , ABU_SIGN
               , C_DOC_POS_STATUS
               , C_GAUGE_TYPE
               , GCO_GOOD_ID
               , PAC_THIRD_ID
               , DIC_GAUGE_TYPE_DOC_ID
               , GCO_CHARACTERIZATION_ID
               , GCO_GCO_CHARACTERIZATION_ID
               , GCO2_GCO_CHARACTERIZATION_ID
               , GCO3_GCO_CHARACTERIZATION_ID
               , GCO4_GCO_CHARACTERIZATION_ID
               , ABU_CHARACTERIZATION_VALUE_1
               , ABU_CHARACTERIZATION_VALUE_2
               , ABU_CHARACTERIZATION_VALUE_3
               , ABU_CHARACTERIZATION_VALUE_4
               , ABU_CHARACTERIZATION_VALUE_5
               , ABU_DELAY
               , ABU_FINAL_DELAY
               , ABU_DOCUMENT_DATE
               , ABU_FINAL_QUANTITY
               , ABU_BALANCE_QUANTITY
               , ABU_NET_VALUE_EXCL
               , ABU_BALANCE_STATUS
                )
      select INIT_ID_SEQ.nextval
           , -1
           , :old.C_DOC_POS_STATUS
           , GAU.C_GAUGE_TYPE
           , :old.GCO_GOOD_ID
           , DOC.PAC_THIRD_ID
           , DOC.DIC_GAUGE_TYPE_DOC_ID
           , DET.GCO_CHARACTERIZATION_ID
           , DET.GCO_GCO_CHARACTERIZATION_ID
           , DET.GCO2_GCO_CHARACTERIZATION_ID
           , DET.GCO3_GCO_CHARACTERIZATION_ID
           , DET.GCO4_GCO_CHARACTERIZATION_ID
           , DET.PDE_CHARACTERIZATION_VALUE_1
           , DET.PDE_CHARACTERIZATION_VALUE_2
           , DET.PDE_CHARACTERIZATION_VALUE_3
           , DET.PDE_CHARACTERIZATION_VALUE_4
           , DET.PDE_CHARACTERIZATION_VALUE_5
           , GPO.GAP_DELAY
           , nvl(DET.PDE_FINAL_DELAY, DOC.DMT_DATE_DOCUMENT)
           , DOC.DMT_DATE_DOCUMENT
           , DET.PDE_FINAL_QUANTITY
           , DET.PDE_BALANCE_QUANTITY
           , :old.POS_NET_VALUE_EXCL_B
           , GST.GAS_BALANCE_STATUS
        from DOC_DOCUMENT DOC
           , DOC_POSITION_DETAIL DET
           , DOC_GAUGE_POSITION GPO
           , DOC_GAUGE_STRUCTURED GST
           , DOC_GAUGE GAU
       where DOC.DOC_DOCUMENT_ID = :old.DOC_DOCUMENT_ID
         and GPO.DOC_GAUGE_POSITION_ID = :old.DOC_GAUGE_POSITION_ID
         and DET.DOC_POSITION_ID = :old.DOC_POSITION_ID
         and GST.DOC_GAUGE_ID = DOC.DOC_GAUGE_ID
         and GAU.DOC_GAUGE_ID = GST.DOC_GAUGE_ID
         and :old.C_GAUGE_TYPE_POS in('1', '2', '3', '7', '8', '91', '101');

    -- Ajout des nouvelles valeurs
    insert into DOC_POSI_ACCU_BUFFER
                (DOC_POSI_ACCU_BUFFER_ID
               , ABU_SIGN
               , C_DOC_POS_STATUS
               , C_GAUGE_TYPE
               , GCO_GOOD_ID
               , PAC_THIRD_ID
               , DIC_GAUGE_TYPE_DOC_ID
               , GCO_CHARACTERIZATION_ID
               , GCO_GCO_CHARACTERIZATION_ID
               , GCO2_GCO_CHARACTERIZATION_ID
               , GCO3_GCO_CHARACTERIZATION_ID
               , GCO4_GCO_CHARACTERIZATION_ID
               , ABU_CHARACTERIZATION_VALUE_1
               , ABU_CHARACTERIZATION_VALUE_2
               , ABU_CHARACTERIZATION_VALUE_3
               , ABU_CHARACTERIZATION_VALUE_4
               , ABU_CHARACTERIZATION_VALUE_5
               , ABU_DELAY
               , ABU_FINAL_DELAY
               , ABU_DOCUMENT_DATE
               , ABU_FINAL_QUANTITY
               , ABU_BALANCE_QUANTITY
               , ABU_NET_VALUE_EXCL
               , ABU_BALANCE_STATUS
                )
      select INIT_ID_SEQ.nextval
           , 1
           , :new.C_DOC_POS_STATUS
           , GAU.C_GAUGE_TYPE
           , :new.GCO_GOOD_ID
           , DOC.PAC_THIRD_ID
           , DOC.DIC_GAUGE_TYPE_DOC_ID
           , DET.GCO_CHARACTERIZATION_ID
           , DET.GCO_GCO_CHARACTERIZATION_ID
           , DET.GCO2_GCO_CHARACTERIZATION_ID
           , DET.GCO3_GCO_CHARACTERIZATION_ID
           , DET.GCO4_GCO_CHARACTERIZATION_ID
           , DET.PDE_CHARACTERIZATION_VALUE_1
           , DET.PDE_CHARACTERIZATION_VALUE_2
           , DET.PDE_CHARACTERIZATION_VALUE_3
           , DET.PDE_CHARACTERIZATION_VALUE_4
           , DET.PDE_CHARACTERIZATION_VALUE_5
           , GPO.GAP_DELAY
           , nvl(DET.PDE_FINAL_DELAY, DOC.DMT_DATE_DOCUMENT)
           , DOC.DMT_DATE_DOCUMENT
           , DET.PDE_FINAL_QUANTITY
           , DET.PDE_BALANCE_QUANTITY
           , :new.POS_NET_VALUE_EXCL_B
           , GST.GAS_BALANCE_STATUS
        from DOC_DOCUMENT DOC
           , DOC_POSITION_DETAIL DET
           , DOC_GAUGE_POSITION GPO
           , DOC_GAUGE_STRUCTURED GST
           , DOC_GAUGE GAU
       where DOC.DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID
         and GPO.DOC_GAUGE_POSITION_ID = :new.DOC_GAUGE_POSITION_ID
         and DET.DOC_POSITION_ID = :new.DOC_POSITION_ID
         and GST.DOC_GAUGE_ID = DOC.DOC_GAUGE_ID
         and GAU.DOC_GAUGE_ID = GST.DOC_GAUGE_ID
         and :new.C_GAUGE_TYPE_POS in('1', '2', '3', '7', '8', '91', '101');
  end if;
end DOC_POS_BU_POSI_ACCU;

ALTER TRIGGER "C_ITX"."DOC_POS_BU_POSI_ACCU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_BU_RECORD"
  before update of DOC_RECORD_ID
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Effectue le traitement associé à la modification du dossier de la position et en particulier la mise à jour
*    des comptes financiers de la position.
*
* @author Vincent Jeanfavre
* @created vje 24/04/2006
* @update fpe 20.12.2010 : conditionne l'exécution du trigger selon la config DOC_FIN_ACCOUNT_REINIT_RECORD
* @version 10
*/
declare
  -- Info générales sur la position à créér
  cursor crAccountInfo(cDocumentID DOC_DOCUMENT.DOC_DOCUMENT_ID%type)
  is
    select DMT.DOC_DOCUMENT_ID
         , DMT.DOC_GAUGE_ID
         , DMT.PAC_THIRD_ACI_ID
         , DMT.DMT_DATE_DOCUMENT
         , GAU.C_ADMIN_DOMAIN
         , GAU.GAU_USE_MANAGED_DATA
         , decode(nvl(GAS.GAS_VISIBLE_COUNT, 0) + nvl(GAS.GAS_FINANCIAL_CHARGE, 0), 0, 0, 1) GAS_FINANCIAL
         , decode(nvl(GAS.GAS_VISIBLE_COUNT, 0) + nvl(GAS.GAS_ANAL_CHARGE, 0), 0, 0, 1) GAS_ANALYTICAL
      from DOC_DOCUMENT DMT
         , DOC_GAUGE GAU
         , DOC_GAUGE_STRUCTURED GAS
     where DMT.DOC_DOCUMENT_ID = cDocumentID
       and DMT.DOC_GAUGE_ID = GAU.DOC_GAUGE_ID
       and GAS.DOC_GAUGE_ID = GAU.DOC_GAUGE_ID;

  tplAccountInfo   crAccountInfo%rowtype;
  FinAccountID     DOC_POSITION.ACS_FINANCIAL_ACCOUNT_ID%type;
  DivAccountID     DOC_POSITION.ACS_DIVISION_ACCOUNT_ID%type;
  CpnAccountID     DOC_POSITION.ACS_CPN_ACCOUNT_ID%type;
  CdaAccountID     DOC_POSITION.ACS_CDA_ACCOUNT_ID%type;
  PfAccountID      DOC_POSITION.ACS_PF_ACCOUNT_ID%type;
  PjAccountID      DOC_POSITION.ACS_PJ_ACCOUNT_ID%type;
  AccountInfo      ACS_I_LIB_LOGISTIC_FINANCIAL.TAccountInfo;
  cGaugeTypePosCpt DOC_GAUGE_POSITION.C_GAUGE_TYPE_POS%type;
begin
  -- mise à jour si la config DOC_FIN_ACCOUNT_REINIT_RECORD
  if     nvl(:old.DOC_RECORD_ID, 0) <> nvl(:new.DOC_RECORD_ID, 0)
     and PCS.PC_CONFIG.GetConfig('DOC_FIN_ACCOUNT_REINIT_RECORD') = 1 then
    -- Informations Gabarit, Gabarit structuré, Gabarit Position et Document de la position à créer
    open crAccountInfo(:new.DOC_DOCUMENT_ID);

    fetch crAccountInfo
     into tplAccountInfo;

    if crAccountInfo%found then
      -- Initialise le type informatif du CPT si position CPT est de type '1'
      if     (:new.DOC_DOC_POSITION_ID is not null)
         and (:new.C_GAUGE_TYPE_POS = '1') then
        -- Recherche le type de la position PT (en allant sur le gabarit position car pas possible sur la pos -> trigger table mutating)
        -- Renseigner le type du CPT (71,81,91 ou 101) si l'on a retrouvé la position PT
        select max(C_GAUGE_TYPE_POS || '1')
          into cGaugeTypePosCpt
          from DOC_GAUGE_POSITION
         where DOC_DOC_GAUGE_POSITION_ID = :new.DOC_GAUGE_POSITION_ID;
      end if;

      -- Comptes, Immobilisation, Type de transaction, Informations complémentaires
      -- pour les positions 1, 2, 3, 5, 7, 8, 10, 91, 1-91
      if     (    (    :new.C_GAUGE_TYPE_POS = '1'
                   and (   cGaugeTypePosCpt is null
                        or cGaugeTypePosCpt = '91') )
              or to_number(:new.C_GAUGE_TYPE_POS) in(2, 3, 5, 7, 8, 91, 10, 21)
             )
         and (   tplAccountInfo.GAS_FINANCIAL = 1
              or tplAccountInfo.GAS_ANALYTICAL = 1) then
        -- Position Valeur
        if :new.C_GAUGE_TYPE_POS = '5' then
          -- Recherche des comptes
          ACS_I_LIB_LOGISTIC_FINANCIAL.GetAccounts(:new.GCO_GOOD_ID
                                                 , '40'
                                                 , tplAccountInfo.C_ADMIN_DOMAIN
                                                 , tplAccountInfo.DMT_DATE_DOCUMENT
                                                 , null
                                                 , tplAccountInfo.DOC_GAUGE_ID
                                                 , tplAccountInfo.DOC_DOCUMENT_ID
                                                 , :new.DOC_POSITION_ID
                                                 , :new.DOC_RECORD_ID
                                                 , tplAccountInfo.PAC_THIRD_ACI_ID
                                                 , null   -- :new.ACS_FINANCIAL_ACCOUNT_ID
                                                 , null   -- :new.ACS_DIVISION_ACCOUNT_ID
                                                 , null   -- :new.ACS_CPN_ACCOUNT_ID
                                                 , null   -- :new.ACS_CDA_ACCOUNT_ID
                                                 , null   -- :new.ACS_PF_ACCOUNT_ID
                                                 , null   -- :new.ACS_PJ_ACCOUNT_ID
                                                 , FinAccountID
                                                 , DivAccountID
                                                 , CpnAccountID
                                                 , CdaAccountID
                                                 , PfAccountID
                                                 , PjAccountID
                                                 , AccountInfo
                                                  );
        else
          -- Recherche des comptes
          ACS_I_LIB_LOGISTIC_FINANCIAL.GetAccounts(:new.GCO_GOOD_ID
                                                 , '10'
                                                 , tplAccountInfo.C_ADMIN_DOMAIN
                                                 , tplAccountInfo.DMT_DATE_DOCUMENT
                                                 , :new.GCO_GOOD_ID
                                                 , tplAccountInfo.DOC_GAUGE_ID
                                                 , tplAccountInfo.DOC_DOCUMENT_ID
                                                 , :new.DOC_POSITION_ID
                                                 , :new.DOC_RECORD_ID
                                                 , tplAccountInfo.PAC_THIRD_ACI_ID
                                                 , null   -- :new.ACS_FINANCIAL_ACCOUNT_ID
                                                 , null   -- :new.ACS_DIVISION_ACCOUNT_ID
                                                 , null   -- :new.ACS_CPN_ACCOUNT_ID
                                                 , null   -- :new.ACS_CDA_ACCOUNT_ID
                                                 , null   -- :new.ACS_PF_ACCOUNT_ID
                                                 , null   -- :new.ACS_PJ_ACCOUNT_ID
                                                 , FinAccountID
                                                 , DivAccountID
                                                 , CpnAccountID
                                                 , CdaAccountID
                                                 , PfAccountID
                                                 , PjAccountID
                                                 , AccountInfo
                                                  );
        end if;

        -- Comptes
        :new.ACS_FINANCIAL_ACCOUNT_ID  := FinAccountID;
        :new.ACS_DIVISION_ACCOUNT_ID   := DivAccountID;
        :new.ACS_CPN_ACCOUNT_ID        := CpnAccountID;
        :new.ACS_CDA_ACCOUNT_ID        := CdaAccountID;
        :new.ACS_PF_ACCOUNT_ID         := PfAccountID;
        :new.ACS_PJ_ACCOUNT_ID         := PjAccountID;

        -- Informations complémentaires gérées
        if tplAccountInfo.GAU_USE_MANAGED_DATA = 1 then
          -- Immobilisation
          :new.FAM_FIXED_ASSETS_ID    := AccountInfo.FAM_FIXED_ASSETS_ID;
          -- Type de transaction
          :new.C_FAM_TRANSACTION_TYP  := AccountInfo.C_FAM_TRANSACTION_TYP;
          -- Personne HRM
          :new.HRM_PERSON_ID          := ACS_I_LIB_LOGISTIC_FINANCIAL.GetHrmPerson(AccountInfo.DEF_HRM_PERSON);
          -- Textes des Informations complémentaires
          :new.POS_IMF_TEXT_1         := AccountInfo.DEF_TEXT1;
          :new.POS_IMF_TEXT_2         := AccountInfo.DEF_TEXT2;
          :new.POS_IMF_TEXT_3         := AccountInfo.DEF_TEXT3;
          :new.POS_IMF_TEXT_4         := AccountInfo.DEF_TEXT4;
          :new.POS_IMF_TEXT_5         := AccountInfo.DEF_TEXT5;
          -- Numériques des Informations complémentaires
          :new.POS_IMF_NUMBER_2       := AccountInfo.DEF_NUMBER2;
          :new.POS_IMF_NUMBER_3       := AccountInfo.DEF_NUMBER3;
          :new.POS_IMF_NUMBER_4       := AccountInfo.DEF_NUMBER4;
          :new.POS_IMF_NUMBER_5       := AccountInfo.DEF_NUMBER5;
          -- Dicos des Informations complémentaires
          :new.DIC_IMP_FREE1_ID       := AccountInfo.DEF_DIC_IMP_FREE1;
          :new.DIC_IMP_FREE2_ID       := AccountInfo.DEF_DIC_IMP_FREE2;
          :new.DIC_IMP_FREE3_ID       := AccountInfo.DEF_DIC_IMP_FREE3;
          :new.DIC_IMP_FREE4_ID       := AccountInfo.DEF_DIC_IMP_FREE4;
          :new.DIC_IMP_FREE5_ID       := AccountInfo.DEF_DIC_IMP_FREE5;
        else
          -- GAU_USE_MANAGED_DATA = 0
          -- Immobilisation
          :new.FAM_FIXED_ASSETS_ID    := null;
          -- Type de transaction
          :new.C_FAM_TRANSACTION_TYP  := null;
          -- Personne HRM
          :new.HRM_PERSON_ID          := null;
          -- Textes des Informations complémentaires
          :new.POS_IMF_TEXT_1         := null;
          :new.POS_IMF_TEXT_2         := null;
          :new.POS_IMF_TEXT_3         := null;
          :new.POS_IMF_TEXT_4         := null;
          :new.POS_IMF_TEXT_5         := null;
          -- Numériques des Informations complémentaires
          :new.POS_IMF_NUMBER_2       := null;
          :new.POS_IMF_NUMBER_3       := null;
          :new.POS_IMF_NUMBER_4       := null;
          :new.POS_IMF_NUMBER_5       := null;
          -- Dicos des Informations complémentaires
          :new.DIC_IMP_FREE1_ID       := null;
          :new.DIC_IMP_FREE2_ID       := null;
          :new.DIC_IMP_FREE3_ID       := null;
          :new.DIC_IMP_FREE4_ID       := null;
          :new.DIC_IMP_FREE5_ID       := null;
        end if;
      else
        -- Comptes
        :new.ACS_FINANCIAL_ACCOUNT_ID  := null;
        :new.ACS_DIVISION_ACCOUNT_ID   := null;
        :new.ACS_CPN_ACCOUNT_ID        := null;
        :new.ACS_CDA_ACCOUNT_ID        := null;
        :new.ACS_PF_ACCOUNT_ID         := null;
        :new.ACS_PJ_ACCOUNT_ID         := null;
        -- Immobilisation
        :new.FAM_FIXED_ASSETS_ID       := null;
        -- Type de transaction
        :new.C_FAM_TRANSACTION_TYP     := null;
        -- Personne HRM
        :new.HRM_PERSON_ID             := null;
        -- Textes des Informations complémentaires
        :new.POS_IMF_TEXT_1            := null;
        :new.POS_IMF_TEXT_2            := null;
        :new.POS_IMF_TEXT_3            := null;
        :new.POS_IMF_TEXT_4            := null;
        :new.POS_IMF_TEXT_5            := null;
        -- Numériques des Informations complémentaires
        :new.POS_IMF_NUMBER_2          := null;
        :new.POS_IMF_NUMBER_3          := null;
        :new.POS_IMF_NUMBER_4          := null;
        :new.POS_IMF_NUMBER_5          := null;
        -- Dicos des Informations complémentaires
        :new.DIC_IMP_FREE1_ID          := null;
        :new.DIC_IMP_FREE2_ID          := null;
        :new.DIC_IMP_FREE3_ID          := null;
        :new.DIC_IMP_FREE4_ID          := null;
        :new.DIC_IMP_FREE5_ID          := null;
      end if;
    end if;

    close crAccountInfo;
  end if;
end DOC_POS_BU_RECORD;

ALTER TRIGGER "C_ITX"."DOC_POS_BU_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_POS_BU_UPDATE_BALANCED_POS"
  before update of "POS_GROSS_UNIT_VALUE", "POS_FINAL_QUANTITY", "POS_BALANCE_QUANTITY"
  on DOC_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Maj du flag de modification des montants ou des qté d'une position partiellement soldée
* @created fp 08.12.2003
* @lastUpdate
* @version 2003
*/
begin
  -- flag de modification des montants ou des qté d'une position partiellement soldée
  if     :new.POS_BALANCE_QUANTITY <> :new.POS_FINAL_QUANTITY
     and (   :new.POS_GROSS_UNIT_VALUE <> :old.POS_GROSS_UNIT_VALUE
          or :new.POS_FINAL_QUANTITY <> :old.POS_FINAL_QUANTITY)
     and nvl(:new.pos_update_qty_price, 0) = 0 then
    :new.pos_update_qty_price  := 1;

    update DOC_POSITION_CHARGE
       set PCH_BALANCE_AMOUNT = decode(:new.POS_FINAL_QUANTITY, 0, 0, PCH_AMOUNT *(:new.POS_BALANCE_QUANTITY / :new.POS_FINAL_QUANTITY) )
         , A_DATEMOD = sysdate
         , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
     where DOC_POSITION_ID = :new.DOC_POSITION_ID
       and PCH_TRANSFERT_PROP = 1;

    DOC_FUNCTIONS.CreateHistoryInformation(:new.DOC_DOCUMENT_ID
                                         , :new.DOC_POSITION_ID
                                         , null   -- no de document
                                         , 'PL/SQL'   -- DUH_TYPE
                                         , 'ACTIVE POS_UPDATE_QTY_PRICE'
                                         , 'Update of qty or unit price of a position which is partially balanced.'
                                         , null   -- status document
                                         , null   -- status position
                                          );
  elsif     :new.POS_BALANCE_QUANTITY = :new.POS_FINAL_QUANTITY
        and nvl(:new.pos_update_qty_price, 0) = 1 then
    :new.pos_update_qty_price  := 0;

    update DOC_POSITION_CHARGE
       set PCH_BALANCE_AMOUNT = PCH_AMOUNT
         , A_DATEMOD = sysdate
         , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
     where DOC_POSITION_ID = :new.DOC_POSITION_ID
       and PCH_TRANSFERT_PROP = 1;

    DOC_FUNCTIONS.CreateHistoryInformation(:new.DOC_DOCUMENT_ID
                                         , :new.DOC_POSITION_ID
                                         , null   -- no de document
                                         , 'PL/SQL'   -- DUH_TYPE
                                         , 'DESACTIVE POS_UPDATE_QTY_PRICE'
                                         , 'All child positions of a partially balanced update position have been deleted.'
                                         , null   -- status document
                                         , null   -- status position
                                          );
  end if;
end DOC_POS_BU_UPDATE_BALANCED_POS;

ALTER TRIGGER "C_ITX"."DOC_POS_BU_UPDATE_BALANCED_POS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_RCO_AIU_ASA_MACHINE"
  after insert or update of RCO_MACHINE_GOOD_ID
  on DOC_RECORD
  referencing old as old new as new
  for each row
/**
* Description
*    Création des compteurs associés à la machine (selon modèle de machine)
*
* @author David Saadé
* @created 28/10/2005
* @version 2003
*/
begin
  -- en modification du modèle de machine, supprimer tous les compteurs associés à la machine
  if     updating
     and (nvl(:old.RCO_MACHINE_GOOD_ID, 0) <> nvl(:new.RCO_MACHINE_GOOD_ID, 0) ) then
    delete from ASA_COUNTER
          where DOC_RECORD_ID = :new.DOC_RECORD_ID;
  end if;

  -- si le modèle est renseigné
  if :new.RCO_MACHINE_GOOD_ID is not null then
    -- création des compteurs associés à la machine selon le nouveau modèle de machine
    insert into ASA_COUNTER
                (ASA_COUNTER_ID
               , ASA_COUNTER_TYPE_ID
               , DOC_RECORD_ID
               , A_DATECRE
               , A_IDCRE
                )
      select INIT_ID_SEQ.nextval
           , ASA_COUNTER_TYPE_ID
           , :new.DOC_RECORD_ID
           , sysdate
           , pcs.PC_I_LIB_SESSION.GetUserIni
        from ASA_COUNTER_TYPE_S_GOOD
       where GCO_GOOD_ID = :new.RCO_MACHINE_GOOD_ID;
  end if;
end DOC_RCO_AIU_ASA_MACHINE;

ALTER TRIGGER "C_ITX"."DOC_RCO_AIU_ASA_MACHINE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_RCO_BI_TITLE"
  before insert
  on DOC_RECORD
  referencing old as old new as new
  for each row
/**
* Description
*    Effectue recherche et l'initialisation du titre du dossier
*
* @author Vincent Jeanfavre
* @created 04/08/2005
* @version 2003
*/
declare
  rcoTitle   DOC_RECORD.RCO_TITLE%type;
begin
  if :new.RCO_NUMBER is null then
    select RCO_NUMBER_SEQ.nextval
      into :new.RCO_NUMBER
      from dual;
  end if;

  if     :new.RCO_TITLE is null
     and :new.DOC_RECORD_CATEGORY_ID is not null
     and :new.C_RCO_TYPE = '11' then
    GCO_GOOD_NUMBERING_FUNCTIONS.GetNumberAutoTrans(:new.DOC_RECORD_CATEGORY_ID, 'DOC_RECORD_CATEGORY', rcoTitle);
    :new.RCO_TITLE  := rcoTitle;
  end if;

  if :new.RCO_TITLE is null then
    :new.RCO_TITLE  := :new.RCO_NUMBER;
  end if;
end DOC_RCO_BI_TITLE;

ALTER TRIGGER "C_ITX"."DOC_RCO_BI_TITLE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_REC_ADD_AIU_REPLICATE"
  after insert or update
  on DOC_RECORD_ADDRESS
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des documents.
 * @author rforchelet
 * @author spfister
 * @date 10.2010
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_RCO_TRIGGERS') = 1) then
    rep_functions.PublishDocRecord(:NEW.DOC_RECORD_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."DOC_REC_ADD_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_REC_AIU_REPLICATE"
  after insert or update
  on DOC_RECORD
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des documents.
 * @author rforchelet
 * @author spfister
 * @date 10.2006
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_RCO_TRIGGERS') = 1) then
    rep_functions.PublishDocRecord(:NEW.DOC_RECORD_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."DOC_REC_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_REC_CAT_AIU_REPLICATE"
  after insert or update
  on DOC_RECORD_CATEGORY
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des catégories de documents.
 * @author rforchelet
 * @author spfister
 * @date 10.2006
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_RCO_TRIGGERS') = 1) then
    rep_functions.PublishDocRecordCategory(:NEW.DOC_RECORD_CATEGORY_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."DOC_REC_CAT_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_REC_LNK_AIU_REPLICATE"
  after insert or update
  on DOC_RECORD_LINK
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des documents.
 * @author rforchelet
 * @author spfister
 * @date 10.2006
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_RCO_TRIGGERS') = 1) then
    rep_functions.PublishDocRecord(:NEW.DOC_RECORD_FATHER_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."DOC_REC_LNK_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_RLT_AIU_REPLICATE"
  after insert or update
  on DOC_RECORD_CAT_LINK_TYPE
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des type de catégories de documents.
 * @author rforchelet
 * @author spfister
 * @date 10.2006
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_RCO_TRIGGERS') = 1) then
    rep_functions.PublishDocRecordCatLinkType(:NEW.DOC_RECORD_CAT_LINK_TYPE_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."DOC_RLT_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_RLT_DESC_AIU_REPLICATE"
  after insert or update
  on DOC_REC_CAT_LNK_TYPE_DESCR
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des type de catégories de documents.
 * @author rforchelet
 * @author spfister
 * @date 10.2006
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_RCO_TRIGGERS') = 1) then
    rep_functions.PublishDocRecordCatLinkType(:NEW.DOC_RECORD_CAT_LINK_TYPE_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."DOC_RLT_DESC_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_TMP_BI_DTP_SESSION"
before insert on DOC_TMP_POSITION_DETAIL
referencing OLD as OLD NEW as NEW
for each row

/**
* Description
*     Ce Trigger permet d'éditer la liste des composants en initialisant l'ID de session : DTP_SESSION_ID
* @version DEVELOP
*/



begin
  :NEW.DTP_SESSION_ID := USERENV('SESSIONID');

end DOC_TMP_BI_DTP_SESSION;


ALTER TRIGGER "C_ITX"."DOC_TMP_BI_DTP_SESSION" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_VDA_BI_CONSTRAINTS"
  before insert
  on DOC_VAT_DET_ACCOUNT
  referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour des totalisateurs de document
* @author Fabrice Perotto
* @version 2003
*/
declare
  foot_id DOC_VAT_DET_ACCOUNT.DOC_FOOT_ID%type;
begin
  -- controle que l'id de doc_foot existe dans la table parent
  -- en remplacement d'une contrainte
  select DOC_FOOT_ID
    into foot_id
    from DOC_FOOT
   where DOC_FOOT_ID = :new.DOC_FOOT_ID;
exception
  when no_data_found then
    raise_application_error(-20015, 'PCS - Value of DOC_FOOT_ID does not exist in table DOC_FOOT');
end DOC_VDA_BI_CONSTRAINTS;

ALTER TRIGGER "C_ITX"."DOC_VDA_BI_CONSTRAINTS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_VDA_BU_CONSTRAINTS"
  before update of DOC_FOOT_ID, DOC_VAT_DET_ACCOUNT_ID
  on DOC_VAT_DET_ACCOUNT
  referencing old as old new as new
  for each row
/**
* Description
*   Remplace une contrainte entre les pieds de document et les détail de compte TVA
* @author Fabrice Perotto
* @version 2003
*/
begin
  -- Interdiction de modifier l'ID du détail de compte tva
  if (:old.DOC_VAT_DET_ACCOUNT_ID <> :new.DOC_VAT_DET_ACCOUNT_ID) then
    raise_application_error(-20010, 'PCS - Cannot change the value of the primary key (DOC_VAT_DET_ACCOUNT_ID)');
  end if;

  -- Interdiction de modifier l'ID du pied de document
  if (:old.DOC_FOOT_ID <> :new.DOC_FOOT_ID) then
    raise_application_error(-20016, 'PCS - Cannot change the value of DOC_FOOT_ID in DOC_VAT_DET_ACCOUNT');
  end if;
end DOC_VDA_BU_CONSTRAINTS;

ALTER TRIGGER "C_ITX"."DOC_VDA_BU_CONSTRAINTS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_V_DCD_IOI_QUANTITY"
  instead of insert
  on V_DOC_POS_DET_COPY_DISCHARGE
  for each row
/**
* Description
*    Mise à jour des quantité en décharge en fonction du solde sur parent
* @created FP 20.01.2003
* @version 2003
* @lastUpdate VJ 02.04.2003
*/
declare
  ptQuantity        DOC_POSITION_DETAIL.PDE_BASIS_QUANTITY%type;
  ptQuantitySU      DOC_POSITION_DETAIL.PDE_BASIS_QUANTITY_SU%type;
  ptQuantityCpt     DOC_POSITION_DETAIL.PDE_BASIS_QUANTITY%type;
  ptQuantityCptSU   DOC_POSITION_DETAIL.PDE_BASIS_QUANTITY_SU%type;
  cumCptQuantity    DOC_POSITION_DETAIL.PDE_BASIS_QUANTITY%type;
  cumCptQuantitySU  DOC_POSITION_DETAIL.PDE_BASIS_QUANTITY%type;
  dcdQuantity       DOC_POS_DET_COPY_DISCHARGE.DCD_QUANTITY%type;
  dcdQuantitySU     DOC_POS_DET_COPY_DISCHARGE.DCD_QUANTITY_SU%type;
  crgSelect         number(1);
  GaugeFlowId       DOC_GAUGE_FLOW.DOC_GAUGE_FLOW_ID%type;
  GaugeReceiptId    DOC_GAUGE_RECEIPT.DOC_GAUGE_RECEIPT_ID%type;
  GaugeCopyId       DOC_GAUGE_COPY.DOC_GAUGE_COPY_ID%type;
  vC_GAUGE_TYPE_POS DOC_POSITION.C_GAUGE_TYPE_POS%type;
begin
  -- Qté par défaut
  dcdQuantity    := :new.DCD_QUANTITY;
  dcdQuantitySU  := :new.DCD_QUANTITY_SU;
  crgSelect      := :new.CRG_SELECT;

  -- Contrôle quantité
  -- Seulement en mode décharge.
  if :new.DOC_GAUGE_RECEIPT_ID is not null then
    -- Recherche du flux sur le détail source
    select DOC_GAUGE_FLOW_ID
      into GaugeFlowId
      from DOC_POSITION_DETAIL PDE
     where DOC_POSITION_DETAIL_ID = :new.DOC_POSITION_DETAIL_ID;

    if nvl(GaugeFlowId, 0) = 0 then
      select DOC_I_LIB_GAUGE.GetFlowID(GAU.C_ADMIN_DOMAIN, PDE.PAC_THIRD_ID)
        into GaugeFlowId
        from DOC_GAUGE GAU
           , DOC_POSITION_DETAIL PDE
           , DOC_DOCUMENT DMT
       where GAU.DOC_GAUGE_ID = DMT.DOC_GAUGE_ID
         and PDE.DOC_POSITION_DETAIL_ID = :new.DOC_POSITION_DETAIL_ID
         and DMT.DOC_DOCUMENT_ID = PDE.DOC_DOCUMENT_ID;
    end if;

    -- Position de type CPT
    if :new.DOC_DOC_POSITION_ID is not null then
      -- Vérifie le type de position cpt, si c'est du type 71,81,91,101 ou type 1 gabarit lié
      select C_GAUGE_TYPE_POS
        into vC_GAUGE_TYPE_POS
        from DOC_POSITION POS
       where DOC_POSITION_ID = :new.DOC_POSITION_ID;

      -- Recalcul de la qté cpt, uniquement pour les cpt de type 71,81,91,101
      -- La somme de la qté d'une position cpt ne doit pas dépasser la qté du pt
      if vC_GAUGE_TYPE_POS <> '1' then
        -- Recherche de la quantité initialisée pour le PT
        select sum(DCD_QUANTITY)
             , sum(DCD_QUANTITY_SU)
          into ptQuantity
             , ptQuantitySU
          from DOC_POS_DET_COPY_DISCHARGE
         where DOC_POSITION_ID = :new.DOC_DOC_POSITION_ID
           and NEW_DOCUMENT_ID = :new.NEW_DOCUMENT_ID;

        -- Recherche de la quantité déjà initialisée en décharge pour la position courante
        select nvl(sum(DCD_QUANTITY), 0)
             , nvl(sum(DCD_QUANTITY_SU), 0)
          into cumCptQuantity
             , cumCptQuantitySU
          from DOC_POS_DET_COPY_DISCHARGE
         where DOC_POSITION_ID = :new.DOC_POSITION_ID
           and NEW_DOCUMENT_ID = :new.NEW_DOCUMENT_ID;

        /**
        *  Recherche de la quantité initialisée pour le PT mais exprimé en fonction
        *  du coefficient d'utilisation du composant.
        */
        if :new.GCO_GOOD_ID is not null then
          select ACS_FUNCTION.RoundNear(ptQuantity * nvl(:new.POS_UTIL_COEFF, 1), 1 / power(10, nvl(GOO.GOO_NUMBER_OF_DECIMAL, 0) ), 0)
               , ACS_FUNCTION.RoundNear(ptQuantitySU * nvl(:new.POS_UTIL_COEFF, 1), 1 / power(10, nvl(GOO.GOO_NUMBER_OF_DECIMAL, 0) ), 0)
            into ptQuantityCpt
               , ptQuantityCptSU
            from GCO_GOOD GOO
           where GOO.GCO_GOOD_ID = :new.GCO_GOOD_ID;
        else
          ptQuantityCpt    := ptQuantity * :new.POS_UTIL_COEFF;
          ptQuantityCptSU  := ptQuantitySU * :new.POS_UTIL_COEFF;
        end if;

        /**
        * Toute la quantité du PT est-elle attribué sur les composants après le
        * traitement de ce composant ?
        */
        if (ptQuantityCpt < cumCptQuantity + :new.DCD_QUANTITY) then   /* Oui */
          dcdQuantity    := least(:new.DCD_QUANTITY, ptQuantityCpt - cumCptQuantity);
          dcdQuantitySU  := least(:new.DCD_QUANTITY_SU, ptQuantityCptSU - cumCptQuantitySU);
          crgSelect      := sign(dcdQuantity);
        end if;
      end if;
    end if;

    -- Initialisation du doc_gauge_receipt
    begin
      select GAR.DOC_GAUGE_RECEIPT_ID
        into GaugeReceiptId
        from DOC_GAUGE_RECEIPT GAR
           , DOC_GAUGE_FLOW_DOCUM GAD
       where GAD.DOC_GAUGE_FLOW_ID = GaugeFlowId
         and GAR.DOC_GAUGE_FLOW_DOCUM_ID = GAD.DOC_GAUGE_FLOW_DOCUM_ID
         and GAR.DOC_DOC_GAUGE_ID = :new.DOC_GAUGE_ID
         and GAD.DOC_GAUGE_ID = (select DMT.DOC_GAUGE_ID
                                   from DOC_DOCUMENT DMT
                                  where DMT.DOC_DOCUMENT_ID = :new.NEW_DOCUMENT_ID);
    exception
      when no_data_found then
        raise_application_error(-20000, PCS.PC_FUNCTIONS.TranslateWord('PCS - Aucun flux défini!') );
        GaugeReceiptId  := 0;
        crgSelect       := 0;
    end;
  -- Mode copie
  else
    -- Ne pas reprendre le flux document en copie si l'on a un changement de domaine
    select case
             when GAU_TGT.C_ADMIN_DOMAIN = GAU_SRC.C_ADMIN_DOMAIN then PDE_SRC.DOC_GAUGE_FLOW_ID
             else null
           end
      into GaugeFlowID
      from DOC_GAUGE GAU_TGT
         , DOC_DOCUMENT DMT_TGT
         , DOC_GAUGE GAU_SRC
         , DOC_DOCUMENT DMT_SRC
         , DOC_POSITION POS_SRC
         , DOC_POSITION_DETAIL PDE_SRC
     where DMT_TGT.DOC_DOCUMENT_ID = :new.NEW_DOCUMENT_ID
       and DMT_TGT.DOC_GAUGE_ID = GAU_TGT.DOC_GAUGE_ID
       and PDE_SRC.DOC_POSITION_DETAIL_ID = :new.DOC_POSITION_DETAIL_ID
       and PDE_SRC.DOC_POSITION_ID = POS_SRC.DOC_POSITION_ID
       and POS_SRC.DOC_DOCUMENT_ID = DMT_SRC.DOC_DOCUMENT_ID
       and DMT_SRC.DOC_GAUGE_ID = GAU_SRC.DOC_GAUGE_ID;

    if nvl(GaugeFlowId, 0) = 0 then
      select DOC_I_LIB_GAUGE.GetFlowID(GAU.C_ADMIN_DOMAIN, DMT.PAC_THIRD_ID)
        into GaugeFlowId
        from DOC_GAUGE GAU
           , DOC_DOCUMENT DMT
       where GAU.DOC_GAUGE_ID = DMT.DOC_GAUGE_ID
         and DMT.DOC_DOCUMENT_ID = :new.NEW_DOCUMENT_ID;
    end if;

    -- Initialisation du doc_gauge_copy
    begin
      select GAC.DOC_GAUGE_COPY_ID
        into GaugeCopyId
        from DOC_GAUGE_COPY GAC
           , DOC_GAUGE_FLOW_DOCUM GAD
       where GAD.DOC_GAUGE_FLOW_ID = GaugeFlowId
         and GAC.DOC_GAUGE_FLOW_DOCUM_ID = GAD.DOC_GAUGE_FLOW_DOCUM_ID
         and GAC.DOC_DOC_GAUGE_ID = :new.DOC_GAUGE_ID
         and GAD.DOC_GAUGE_ID = (select DMT.DOC_GAUGE_ID
                                   from DOC_DOCUMENT DMT
                                  where DMT.DOC_DOCUMENT_ID = :new.NEW_DOCUMENT_ID);
    exception
      when no_data_found then
        GaugeCopyId  := 0;
        crgSelect    := 0;
    end;
  end if;

  insert into DOC_POS_DET_COPY_DISCHARGE
              (DOC_POSITION_DETAIL_ID
             , NEW_DOCUMENT_ID
             , DOC_POSITION_ID
             , CRG_SELECT
             , DOC_GAUGE_FLOW_ID
             , DOC_DOC_POSITION_ID
             , DOC_DOC_POSITION_DETAIL_ID
             , DOC2_DOC_POSITION_DETAIL_ID
             , DOC_INVOICE_EXPIRY_ID
             , GCO_GOOD_ID
             , STM_LOCATION_ID
             , GCO_CHARACTERIZATION_ID
             , GCO_GCO_CHARACTERIZATION_ID
             , GCO2_GCO_CHARACTERIZATION_ID
             , GCO3_GCO_CHARACTERIZATION_ID
             , GCO4_GCO_CHARACTERIZATION_ID
             , STM_STM_LOCATION_ID
             , DIC_PDE_FREE_TABLE_1_ID
             , DIC_PDE_FREE_TABLE_2_ID
             , DIC_PDE_FREE_TABLE_3_ID
             , FAL_SCHEDULE_STEP_ID
             , DOC_RECORD_ID
             , DOC_DOCUMENT_ID
             , PAC_THIRD_ID
             , PAC_THIRD_ACI_ID
             , PAC_THIRD_DELIVERY_ID
             , PAC_THIRD_TARIFF_ID
             , DOC_GAUGE_ID
             , DOC_GAUGE_RECEIPT_ID
             , DOC_GAUGE_COPY_ID
             , C_GAUGE_TYPE_POS
             , DIC_DELAY_UPDATE_TYPE_ID
             , PDE_BASIS_DELAY
             , PDE_BASIS_DELAY_W
             , PDE_BASIS_DELAY_M
             , PDE_INTERMEDIATE_DELAY
             , PDE_INTERMEDIATE_DELAY_W
             , PDE_INTERMEDIATE_DELAY_M
             , PDE_FINAL_DELAY
             , PDE_FINAL_DELAY_W
             , PDE_FINAL_DELAY_M
             , PDE_SQM_ACCEPTED_DELAY
             , PDE_BASIS_QUANTITY
             , PDE_INTERMEDIATE_QUANTITY
             , PDE_FINAL_QUANTITY
             , PDE_BALANCE_QUANTITY
             , PDE_BALANCE_QUANTITY_PARENT
             , PDE_BASIS_QUANTITY_SU
             , PDE_INTERMEDIATE_QUANTITY_SU
             , PDE_FINAL_QUANTITY_SU
             , PDE_MOVEMENT_QUANTITY
             , PDE_MOVEMENT_VALUE
             , PDE_CHARACTERIZATION_VALUE_1
             , PDE_CHARACTERIZATION_VALUE_2
             , PDE_CHARACTERIZATION_VALUE_3
             , PDE_CHARACTERIZATION_VALUE_4
             , PDE_CHARACTERIZATION_VALUE_5
             , PDE_DELAY_UPDATE_TEXT
             , PDE_DECIMAL_1
             , PDE_DECIMAL_2
             , PDE_DECIMAL_3
             , PDE_TEXT_1
             , PDE_TEXT_2
             , PDE_TEXT_3
             , PDE_DATE_1
             , PDE_DATE_2
             , PDE_DATE_3
             , PDE_GENERATE_MOVEMENT
             , DCD_QUANTITY
             , DCD_QUANTITY_SU
             , POS_UNIT_OF_MEASURE_ID
             , DCD_BALANCE_FLAG
             , POS_CONVERT_FACTOR
             , POS_CONVERT_FACTOR_CALC
             , POS_GROSS_UNIT_VALUE
             , POS_GROSS_UNIT_VALUE_INCL
             , POS_NET_UNIT_VALUE
             , POS_NET_UNIT_VALUE_INCL
             , POS_UTIL_COEFF
             , A_DATECRE
             , A_IDCRE
             , A_RECLEVEL
             , A_RECSTATUS
             , A_CONFIRM
             , DOC_GCO_GOOD_ID
             , DCD_USE_STOCK_LOCATION_ID
             , DCD_USE_PARENT_CHARACT
             , PDE_PIECE
             , PDE_SET
             , PDE_VERSION
             , PDE_CHRONOLOGICAL
             , PDE_STD_CHAR_1
             , PDE_STD_CHAR_2
             , PDE_STD_CHAR_3
             , PDE_STD_CHAR_4
             , PDE_STD_CHAR_5
             , PDE_BALANCE_PARENT
             , DCD_DEPLOYED_COMPONENTS
             , DCD_VISIBLE
             , FAL_NETWORK_LINK_ID
             , DCD_UPDATE_PARENT_DELAY
             , C_PDE_CREATE_MODE
             , ACS_CDA_ACCOUNT_BS_ID
             , ACS_CDA_ACCOUNT_PL_ID
             , ACS_CPN_ACCOUNT_BS_ID
             , ACS_CPN_ACCOUNT_PL_ID
             , ACS_DIVISION_ACCOUNT_BS_ID
             , ACS_DIVISION_ACCOUNT_PL_ID
             , ACS_FINANCIAL_ACCOUNT_BS_ID
             , ACS_FINANCIAL_ACCOUNT_PL_ID
             , ACS_PF_ACCOUNT_BS_ID
             , ACS_PF_ACCOUNT_PL_ID
             , ACS_PJ_ACCOUNT_BS_ID
             , ACS_PJ_ACCOUNT_PL_ID
             , CML_EVENTS_ID
             , C_FAM_TRANSACTION_TYP
             , DCD_FORCE_AMOUNT
             , DIC_IMP_FREE1_ID
             , DIC_IMP_FREE2_ID
             , DIC_IMP_FREE3_ID
             , DIC_IMP_FREE4_ID
             , DIC_IMP_FREE5_ID
             , DOC_DOCUMENT_SRC_ID
             , DOC_POSITION_SRC_ID
             , DOC_POS_DET_COPY_DISCHARGE_ID
             , DOC_RECORD_BS_ID
             , FAL_SUPPLY_REQUEST_ID
             , FAM_FIXED_ASSETS_ID
             , GCO_GCO_GOOD_ID
             , HRM_PERSON_ID
             , PAC_THIRD_CDA_ID
             , PAC_THIRD_VAT_ID
             , PDE_ADDENDUM_QTY_BALANCED
             , PDE_ADDENDUM_SRC_PDE_ID
             , PDE_IMF_NUMBER_1
             , PDE_IMF_NUMBER_2
             , PDE_IMF_NUMBER_3
             , PDE_IMF_NUMBER_4
             , PDE_IMF_NUMBER_5
             , PDE_IMF_TEXT_1
             , PDE_IMF_TEXT_2
             , PDE_IMF_TEXT_3
             , PDE_IMF_TEXT_4
             , PDE_IMF_TEXT_5
             , PDE_IMF_DATE_1
             , PDE_IMF_DATE_2
             , PDE_IMF_DATE_3
             , PDE_IMF_DATE_4
             , PDE_IMF_DATE_5
             , PDE_MOVEMENT_DATE
             , PDE_TRANSFERT_PROPRIETOR
             , POS_GROSS_VALUE
             , POS_LONG_DESCRIPTION
             , POS_NET_VALUE_EXCL
             , POS_SHORT_DESCRIPTION
             , FAL_LOT_ID
             , PDE_ST_PT_REJECT
             , PDE_ST_CPT_REJECT
             , GCO_QUALITY_STATUS_ID
              )
       values (:new.DOC_POSITION_DETAIL_ID
             , :new.NEW_DOCUMENT_ID
             , :new.DOC_POSITION_ID
             , nvl(crgSelect, 0)
             , GaugeFlowId
             , :new.DOC_DOC_POSITION_ID
             , :new.DOC_DOC_POSITION_DETAIL_ID
             , :new.DOC2_DOC_POSITION_DETAIL_ID
             , :new.DOC_INVOICE_EXPIRY_ID
             , :new.GCO_GOOD_ID
             , :new.STM_LOCATION_ID
             , :new.GCO_CHARACTERIZATION_ID
             , :new.GCO_GCO_CHARACTERIZATION_ID
             , :new.GCO2_GCO_CHARACTERIZATION_ID
             , :new.GCO3_GCO_CHARACTERIZATION_ID
             , :new.GCO4_GCO_CHARACTERIZATION_ID
             , :new.STM_STM_LOCATION_ID
             , :new.DIC_PDE_FREE_TABLE_1_ID
             , :new.DIC_PDE_FREE_TABLE_2_ID
             , :new.DIC_PDE_FREE_TABLE_3_ID
             , :new.FAL_SCHEDULE_STEP_ID
             , :new.DOC_RECORD_ID
             , :new.DOC_DOCUMENT_ID
             , :new.PAC_THIRD_ID
             , :new.PAC_THIRD_ACI_ID
             , :new.PAC_THIRD_DELIVERY_ID
             , :new.PAC_THIRD_TARIFF_ID
             , :new.DOC_GAUGE_ID
             , GaugeReceiptId
             , GaugeCopyId
             , :new.C_GAUGE_TYPE_POS
             , :new.DIC_DELAY_UPDATE_TYPE_ID
             , :new.PDE_BASIS_DELAY
             , :new.PDE_BASIS_DELAY_W
             , :new.PDE_BASIS_DELAY_M
             , :new.PDE_INTERMEDIATE_DELAY
             , :new.PDE_INTERMEDIATE_DELAY_W
             , :new.PDE_INTERMEDIATE_DELAY_M
             , :new.PDE_FINAL_DELAY
             , :new.PDE_FINAL_DELAY_W
             , :new.PDE_FINAL_DELAY_M
             , :new.PDE_SQM_ACCEPTED_DELAY
             , :new.PDE_BASIS_QUANTITY
             , :new.PDE_INTERMEDIATE_QUANTITY
             , :new.PDE_FINAL_QUANTITY
             , :new.PDE_BALANCE_QUANTITY
             , :new.PDE_BALANCE_QUANTITY_PARENT
             , :new.PDE_BASIS_QUANTITY_SU
             , :new.PDE_INTERMEDIATE_QUANTITY_SU
             , :new.PDE_FINAL_QUANTITY_SU
             , :new.PDE_MOVEMENT_QUANTITY
             , :new.PDE_MOVEMENT_VALUE
             , :new.PDE_CHARACTERIZATION_VALUE_1
             , :new.PDE_CHARACTERIZATION_VALUE_2
             , :new.PDE_CHARACTERIZATION_VALUE_3
             , :new.PDE_CHARACTERIZATION_VALUE_4
             , :new.PDE_CHARACTERIZATION_VALUE_5
             , :new.PDE_DELAY_UPDATE_TEXT
             , :new.PDE_DECIMAL_1
             , :new.PDE_DECIMAL_2
             , :new.PDE_DECIMAL_3
             , :new.PDE_TEXT_1
             , :new.PDE_TEXT_2
             , :new.PDE_TEXT_3
             , :new.PDE_DATE_1
             , :new.PDE_DATE_2
             , :new.PDE_DATE_3
             , nvl(:new.PDE_GENERATE_MOVEMENT, 0)
             , dcdQuantity
             , dcdQuantitySU
             , :new.POS_UNIT_OF_MEASURE_ID
             , :new.DCD_BALANCE_FLAG
             , nvl(:new.POS_CONVERT_FACTOR, 1)
             , nvl(:new.POS_CONVERT_FACTOR_CALC, 1)
             , :new.POS_GROSS_UNIT_VALUE
             , :new.POS_GROSS_UNIT_VALUE_INCL
             , :new.POS_NET_UNIT_VALUE
             , :new.POS_NET_UNIT_VALUE_INCL
             , :new.POS_UTIL_COEFF
             , :new.A_DATECRE
             , :new.A_IDCRE
             , :new.A_RECLEVEL
             , :new.A_RECSTATUS
             , :new.A_CONFIRM
             , :new.DOC_GCO_GOOD_ID
             , :new.DCD_USE_STOCK_LOCATION_ID
             , nvl(:new.DCD_USE_PARENT_CHARACT, 1)
             , :new.PDE_PIECE
             , :new.PDE_SET
             , :new.PDE_VERSION
             , :new.PDE_CHRONOLOGICAL
             , :new.PDE_STD_CHAR_1
             , :new.PDE_STD_CHAR_2
             , :new.PDE_STD_CHAR_3
             , :new.PDE_STD_CHAR_4
             , :new.PDE_STD_CHAR_5
             , :new.PDE_BALANCE_PARENT
             , :new.DCD_DEPLOYED_COMPONENTS
             , :new.DCD_VISIBLE
             , :new.FAL_NETWORK_LINK_ID
             , nvl(:new.DCD_UPDATE_PARENT_DELAY, 1)
             , :new.C_PDE_CREATE_MODE
             , :new.ACS_CDA_ACCOUNT_BS_ID
             , :new.ACS_CDA_ACCOUNT_PL_ID
             , :new.ACS_CPN_ACCOUNT_BS_ID
             , :new.ACS_CPN_ACCOUNT_PL_ID
             , :new.ACS_DIVISION_ACCOUNT_BS_ID
             , :new.ACS_DIVISION_ACCOUNT_PL_ID
             , :new.ACS_FINANCIAL_ACCOUNT_BS_ID
             , :new.ACS_FINANCIAL_ACCOUNT_PL_ID
             , :new.ACS_PF_ACCOUNT_BS_ID
             , :new.ACS_PF_ACCOUNT_PL_ID
             , :new.ACS_PJ_ACCOUNT_BS_ID
             , :new.ACS_PJ_ACCOUNT_PL_ID
             , :new.CML_EVENTS_ID
             , :new.C_FAM_TRANSACTION_TYP
             , :new.DCD_FORCE_AMOUNT
             , :new.DIC_IMP_FREE1_ID
             , :new.DIC_IMP_FREE2_ID
             , :new.DIC_IMP_FREE3_ID
             , :new.DIC_IMP_FREE4_ID
             , :new.DIC_IMP_FREE5_ID
             , :new.DOC_DOCUMENT_SRC_ID
             , :new.DOC_POSITION_SRC_ID
             , :new.DOC_POS_DET_COPY_DISCHARGE_ID
             , :new.DOC_RECORD_BS_ID
             , :new.FAL_SUPPLY_REQUEST_ID
             , :new.FAM_FIXED_ASSETS_ID
             , :new.GCO_GCO_GOOD_ID
             , :new.HRM_PERSON_ID
             , :new.PAC_THIRD_CDA_ID
             , :new.PAC_THIRD_VAT_ID
             , :new.PDE_ADDENDUM_QTY_BALANCED
             , :new.PDE_ADDENDUM_SRC_PDE_ID
             , :new.PDE_IMF_NUMBER_1
             , :new.PDE_IMF_NUMBER_2
             , :new.PDE_IMF_NUMBER_3
             , :new.PDE_IMF_NUMBER_4
             , :new.PDE_IMF_NUMBER_5
             , :new.PDE_IMF_TEXT_1
             , :new.PDE_IMF_TEXT_2
             , :new.PDE_IMF_TEXT_3
             , :new.PDE_IMF_TEXT_4
             , :new.PDE_IMF_TEXT_5
             , :new.PDE_IMF_DATE_1
             , :new.PDE_IMF_DATE_2
             , :new.PDE_IMF_DATE_3
             , :new.PDE_IMF_DATE_4
             , :new.PDE_IMF_DATE_5
             , :new.PDE_MOVEMENT_DATE
             , :new.PDE_TRANSFERT_PROPRIETOR
             , :new.POS_GROSS_VALUE
             , :new.POS_LONG_DESCRIPTION
             , :new.POS_NET_VALUE_EXCL
             , :new.POS_SHORT_DESCRIPTION
             , :new.FAL_LOT_ID
             , nvl(:new.PDE_ST_PT_REJECT, decode(PCS.PC_CONFIG.GETCONFIG('FAL_SUBCONTRACT_REJECT'), '1', 0, '2', 1, 0) )
             , nvl(:new.PDE_ST_CPT_REJECT, decode(PCS.PC_CONFIG.GETCONFIG('FAL_SUBCONTRACT_REJECT'), '1', 1, '2', 0, 0) )
             , :new.GCO_QUALITY_STATUS_ID
              );
end;

ALTER TRIGGER "C_ITX"."DOC_V_DCD_IOI_QUANTITY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_V_DCD_IOU_QUANTITY"
  instead of update
  on V_DOC_POS_DET_COPY_DISCHARGE
  referencing old as old new as new
  for each row
/**
* @description
*    Mise à jour des quantité et de l'indicateur de sélection des composants (CPT) en fonction de la
*    quantité et de l'indicateur de sélection du produit terminé.
*
* @rules
*    Prise en charge des produits terminés (PT) multi-détail.
*
*    Application les règles de répartition suivantes :
*
*    Diminution de quantité du PT
*    ---
*
*    Exemple :
*
*                      selection old qty  new qty
*    PT1  detail 1     x         5   =>   4 (diminution de quantité)
*    PT1  detail 2     x         5        5
*
*    CPT1 detail 1               1   =>   0
*    CPT1 detail 2     x         1        1
*    CPT1 detail 3     x         1        1
*    CPT1 detail 4     x         1        1
*    CPT1 detail 5     x         1        1
*    CPT1 detail 6     x         1        1
*    CPT1 detail 7     x         1        1
*    CPT1 detail 8     x         1        1
*    CPT1 detail 9     x         1        1
*    CPT1 detail 10    x         1        1
*
*    CPT2 detail 1     x         10  =>   9
*
*    CPT3 detail 1     x         5   =>   4
*    CPT3 detail 2     x         5        5
*
*    Augmentation de la quantité du PT.
*    ---
*
*    Exemple :
*                      selection old qty  new qty
*    PT1  detail 1     x         4   =>   5 (augmentation de la quantité)
*    PT1  detail 2     x         5        5
*
*    CPT1 detail 1     x         0   =>   1
*    CPT1 detail 2     x         1        1
*    CPT1 detail 3     x         1        1
*    CPT1 detail 4     x         1        1
*    CPT1 detail 5     x         1        1
*    CPT1 detail 6     x         1        1
*    CPT1 detail 7     x         1        1
*    CPT1 detail 8     x         1        1
*    CPT1 detail 9     x         1        1
*    CPT1 detail 10    x         1        1
*
*    CPT2 detail 1     x         9   =>   10
*
*    CPT3 detail 1     x         4   =>   5
*    CPT3 detail 2     x         5        5
*
*    Augmentation de la quantité du PT avec dépassement de quantité autorisé et avec un composant géré
*    avec numéro de série et donc avec un nombre de détail initial inférieur à la quantité totale du PT après modification.
*    Devra soit générer une exception ou créer les détails de composants manquants
*    ---
*
*    Exemple :
*                      selection old qty  new qty
*    PT1  detail 1     x         5   =>   6 (augmentation de la quantité)
*    PT1  detail 2     x         5   =>   5
*
*    CPT1 detail 1     x         1        1
*    CPT1 detail 2     x         1        1
*    CPT1 detail 3     x         1        1
*    CPT1 detail 4     x         1        1
*    CPT1 detail 5     x         1        1
*    CPT1 detail 6     x         1        1
*    CPT1 detail 7     x         1        1
*    CPT1 detail 8     x         1        1
*    CPT1 detail 9     x         1        1
*    CPT1 detail 10    x         1        1
*    CPT1 detail 11    x         1        1 (nouveau détail : actuellement pas supporté)
*
*    CPT2 detail 1     x         10  =>   11
*
*    CPT3 detail 1     x         5   =>   6
*    CPT3 detail 2     x         5        5
*
* @author VJE
* @created 02.04.2003
* @version 2003
* @lastUpdate 10.11.2008
*/
declare
  cursor crCpt(APositionID in number)
  is
    select   DCD.DCD_QUANTITY
           , DCD.DCD_QUANTITY_SU
           , case
               when nvl(DCD.DOC_GAUGE_RECEIPT_ID, 0) <> 0 then DCD.PDE_BALANCE_QUANTITY
               when nvl(DCD.DOC_GAUGE_COPY_ID, 0) <> 0 then DCD.PDE_FINAL_QUANTITY
               else DCD.DCD_QUANTITY
             end DCD_INITIAL_QUANTITY
           , DCD.POS_UTIL_COEFF
           , DCD.CRG_SELECT
           , DCD.DOC_POS_DET_COPY_DISCHARGE_ID
           , DCD.DOC_POSITION_ID
           , DCD.C_GAUGE_TYPE_POS
           , GOO.GOO_NUMBER_OF_DECIMAL
        from DOC_POS_DET_COPY_DISCHARGE DCD
           , GCO_GOOD GOO
       where DCD.DOC_DOC_POSITION_ID = APositionID
         and GOO.GCO_GOOD_ID(+) = DCD.GCO_GOOD_ID
    order by DCD.DOC_POS_DET_COPY_DISCHARGE_ID;

  tplCpt             crCpt%rowtype;
  dcdQuantity        DOC_POS_DET_COPY_DISCHARGE.DCD_QUANTITY%type;
  dcdQuantitySU      DOC_POS_DET_COPY_DISCHARGE.DCD_QUANTITY_SU%type;
  dcdQuantityCPT     DOC_POS_DET_COPY_DISCHARGE.DCD_QUANTITY%type;
  dcdQuantityCPTSU   DOC_POS_DET_COPY_DISCHARGE.DCD_QUANTITY_SU%type;
  dcdInitialQuantity DOC_POS_DET_COPY_DISCHARGE.DCD_QUANTITY%type;
  crgSelect          number(1);
  crgSelectCPTs      number(1);
  crgApplySelect     number(1);
  vSelectedCount     number;
  vRecordCount       number;
  vGap               DOC_POS_DET_COPY_DISCHARGE.DCD_QUANTITY%type;
  vGapCPT            DOC_POS_DET_COPY_DISCHARGE.DCD_QUANTITY%type;
  vRemainingGap      DOC_POS_DET_COPY_DISCHARGE.DCD_QUANTITY%type;
  vRemainingGapCPT   DOC_POS_DET_COPY_DISCHARGE.DCD_QUANTITY%type;
  vSign              number;
  docPositionID      DOC_POSITION.DOC_POSITION_ID%type;
  vRequestUpdateCpt  boolean                                           default false;
begin
  -- Qté par défaut
  dcdQuantity         := :new.DCD_QUANTITY;
  dcdQuantitySU       := :new.DCD_QUANTITY_SU;
  dcdInitialQuantity  := :new.DCD_QUANTITY;
  crgSelect           := :new.CRG_SELECT;

  -- Sauvegarde la quantité d'origine de la copie ou décharge, pour pouvoir réinitialiser la quantité par la suite.
  if nvl(:new.DOC_GAUGE_RECEIPT_ID, 0) <> 0 then
    dcdInitialQuantity  := :new.PDE_BALANCE_QUANTITY;
  elsif nvl(:new.DOC_GAUGE_COPY_ID, 0) <> 0 then
    dcdInitialQuantity  := :new.PDE_FINAL_QUANTITY;
  end if;

  ----
  -- Cas 1 : Modification de la quantité du PT avec CPT standard (composant non affiché) -> report sur CPT
  --
  --   visible                   old sel new sel old qty  new qty
  --   x       PT1  detail 1     x       x       5   =>   4 (diminution de quantité)
  --   x       PT1  detail 2     x       x       5        5
  --
  --           CPT1 detail 1     x       x       1   =>   0
  --           CPT1 detail 2     x       x       1        1
  --           CPT1 detail 3     x       x       1        1
  --           CPT1 detail 4     x       x       1        1
  --           CPT1 detail 5     x       x       1        1
  --           CPT1 detail 6     x       x       1        1
  --           CPT1 detail 7     x       x       1        1
  --           CPT1 detail 8     x       x       1        1
  --           CPT1 detail 9     x       x       1        1
  --           CPT1 detail 10    x       x       1        1
  --
  --           CPT2 detail 1     x       x       10  =>   9
  --
  --           CPT3 detail 1     x       x       5   =>   4
  --           CPT3 detail 2     x       x       5        5
  --
  ----
  -- Cas 2 : Séléctionne le flag du PT avec CPT standard (composant non affiché) -> report sur CPT
  --
  --   visible                   old sel new sel old qty  new qty
  --   x       PT1  detail 1             x       0   =>   5 (augmentation de la quantité)
  --   x       PT1  detail 2     x       x       5        5
  --
  --           CPT1 detail 1             x       0   =>   1
  --           CPT1 detail 2             x       0        1
  --           CPT1 detail 3             x       0        1
  --           CPT1 detail 4             x       0        1
  --           CPT1 detail 5             x       0        1
  --           CPT1 detail 6     x       x       1        1
  --           CPT1 detail 7     x       x       1        1
  --           CPT1 detail 8     x       x       1        1
  --           CPT1 detail 9     x       x       1        1
  --           CPT1 detail 10    x       x       1        1
  --
  --           CPT2 detail 1     x       x       5   =>   10
  --
  --           CPT3 detail 1             x       0   =>   5
  --           CPT3 detail 2     x       x       5        5
  ----
  -- Cas 3 : Modification de la quantité du PT avec CPT indépendant (kit partiel) (composant non affiché) -> report sur CPT
  --
  --   visible                   old sel new sel old qty  new qty
  --   x       PT1  detail 1     x       x       5   =>   4 (diminution de quantité)
  --   x       PT1  detail 2     x       x       5        5
  --
  --           CPT1 detail 1                     0        0
  --           CPT1 detail 2                     0        0
  --           CPT1 detail 3                     0        0
  --           CPT1 detail 4                     0        0
  --           CPT1 detail 5                     0        0
  --           CPT1 detail 6     x       x       1   =>   0
  --           CPT1 detail 7     x       x       1        1
  --           CPT1 detail 8     x       x       1        1
  --           CPT1 detail 9     x       x       1        1
  --           CPT1 detail 10    x       x       1        1
  --
  --           CPT2 detail 1     x       x       8        7
  --
  --           CPT3 detail 1     x       x       0        0
  --           CPT3 detail 2     x       x       5        5
  --
  ----
  -- Cas 3': Modification de la quantité du PT avec CPT indépendant (kit partiel) (composant affiché) -> aucun changement sur les CPT
  --
  --   visible                   old sel new sel old qty  new qty
  --   x       PT1  detail 1     x       x       5   =>   4 (diminution de quantité)
  --   x       PT1  detail 2     x       x       5        5
  --
  --   x       CPT1 detail 1                     0        0
  --   x       CPT1 detail 2                     0        0
  --   x       CPT1 detail 3                     0        0
  --   x       CPT1 detail 4                     0        0
  --   x       CPT1 detail 5                     0        0
  --   x       CPT1 detail 6     x       x       1        1
  --   x       CPT1 detail 7     x       x       1        1
  --   x       CPT1 detail 8     x       x       1        1
  --   x       CPT1 detail 9     x       x       1        1
  --   x       CPT1 detail 10    x       x       1        1
  --
  --   x       CPT2 detail 1     x       x       8        7
  --
  --   x       CPT3 detail 1     x       x       0        0
  --   x       CPT3 detail 2     x       x       5        5
  --
  ----
  -- Cas 4 : Modification du flag de séléction du PT avec CPT indépendant (kit partiel) (composant non affiché) -> report sur CPT
  --
  --   visible                   old sel new sel old qty  new qty
  --   x       PT1  detail 1        =>   x       0   =>   5 (augmentation de la quantité)
  --   x       PT1  detail 2     x       x       5        5
  --
  --           CPT1 detail 1             x       0   =>   1
  --           CPT1 detail 2             x       0        1
  --           CPT1 detail 3             x       0        1
  --           CPT1 detail 4             x       0        1
  --           CPT1 detail 5             x       0        1
  --           CPT1 detail 6     x       x       1        1
  --           CPT1 detail 7     x       x       1        1
  --           CPT1 detail 8     x       x       1        1
  --           CPT1 detail 9     x       x       1        1
  --           CPT1 detail 10    x       x       1        1
  --
  --           CPT2 detail 1     x       x       3        8
  --
  --           CPT3 detail 1             x       0        5
  --           CPT3 detail 2     x       x       5        5
  ----
  -- Cas 5 : Modification de la quantité du CPT standard -> interdit (CPT pas affiché)
  ----
  -- Cas 6 : Modification du flag de séléction du CPT standard -> interdit (CPT pas affiché)
  ----
  -- Cas 7 : Modification de la quantité du CPT indépendant (kit partiel) -> modification libre
  --
  --   visible                   old sel new sel old qty  new qty
  --   x       PT1  detail 1     x       x       0        0
  --   x       PT1  detail 2                     0        0
  --
  --   x       CPT1 detail 1                     0        0
  --   x       CPT1 detail 2     x  =>           1        0
  --   x       CPT1 detail 3                     0        0
  --   x       CPT1 detail 4                     0        0
  --   x       CPT1 detail 5                     0        0
  --   x       CPT1 detail 6        =>   x       0   =>   1
  --   x       CPT1 detail 7                     0        0
  --   x       CPT1 detail 8                     0        0
  --   x       CPT1 detail 9                     0        0
  --   x       CPT1 detail 10                    0        0
  --
  --   x       CPT2 detail 1             x       10  =>   8 (diminution de la quantité)
  --
  --   x       CPT3 detail 1     x       x       5        5
  --   x       CPT3 detail 2                     0        0
  ----
  -- Cas 8 : Modification du flag de séléction du CPT indépendant (kit partiel) -> report du flag sur le PT
  --
  --   visible                   old sel new sel old qty  new qty
  --   x       PT1  detail 1        =>   x       0        0
  --   x       PT1  detail 2                     0        0
  --
  --   x       CPT1 detail 1                     0        0
  --   x       CPT1 detail 2                     0        0
  --   x       CPT1 detail 3                     0        0
  --   x       CPT1 detail 4                     0        0
  --   x       CPT1 detail 5                     0        0
  --   x       CPT1 detail 6        =>   x       0   =>   1
  --   x       CPT1 detail 7                     0        0
  --   x       CPT1 detail 8                     0        0
  --   x       CPT1 detail 9                     0        0
  --   x       CPT1 detail 10                    0        0
  --
  --   x       CPT2 detail 1                     0        0
  --
  --   x       CPT3 detail 1                     0        0
  --   x       CPT3 detail 2                     0        0
  --
  if    (     (:old.DCD_QUANTITY <> dcdQuantity)
         and (:new.DCD_DEPLOYED_COMPONENTS = 1)
         and (:new.DCD_VISIBLE = 0) )
     or (     (:old.CRG_SELECT <> crgSelect)
         and (:new.DCD_DEPLOYED_COMPONENTS = 1)
         and (:new.DCD_VISIBLE = 0) ) then
    ----
    -- Mise à jour de le différence de quantité sur les détails des composants.
    -- Attention au fait que si les composants possèdent plusieurs détails, il faut répartir cette différence
    -- sur tous les détails.
    ----
    -- Ouvre la liste de tous les composants du produit terminé
    open crCpt(:new.DOC_POSITION_ID);

    fetch crCpt
     into tplCpt;

    -- Existe-t-il des composants ?
    -- et la configuration ne rend pas indépendantes les quantités des CPT et la quantité du PT en kit partiel dans le cas
    -- ou les composants ne sont pas affiché. Cela autorise donc, dans tous les cas, le report de la quantité du PT sur les CPT.
    if     crCpt%found   -- composant trouvé
       and not(     (nvl(PCS.PC_CONFIG.GetConfig('DOC_FREE_UPDATE_QTY_DISCHARGE'), '0') = '1')   -- PT <> CPT
               and (tplCpt.C_GAUGE_TYPE_POS = '1')   -- kit partiel
                                                  ) then
      -- Défini la quantité en fonction de l'éventuelle modification de l'indicateur de sélection du PT.
      if (:old.CRG_SELECT <> :new.CRG_SELECT) then
        if crgSelect = 0 then
          -- Demande de désélection du PT. Cela implique la mise à 0 de la quantité.
          dcdQuantity    := 0;
          dcdQuantitySU  := dcdQuantity;
        else
          -- Demande de sélection du PT. Cela implique la réinitialisation de la quantité avec la quantité initiale.
          dcdQuantity    := dcdInitialQuantity;
          dcdQuantitySU  := dcdQuantity;
        end if;
      end if;

      -- Détermine l'écart de quantité
      vGap           := :old.DCD_QUANTITY - dcdQuantity;
      -- Initialise l'écart restant à appliquer.
      vRemainingGap  := vGap;
      -- Détermine le signe de la quantité
      vSign          := sign(tplCpt.DCD_INITIAL_QUANTITY);
      -- Mémorise la position composant courante
      docPositionID  := tplCpt.DOC_POSITION_ID;

      -- Tant qu'il reste des détails de composant à traiter
      while crCpt%found loop
        -- Changement de composant
        if tplCpt.DOC_POSITION_ID <> docPositionID then
          -- Réinitialise l'écart restant à appliquer
          vRemainingGap  := vGap;
          -- Mémorise la position composant courante
          docPositionID  := tplCpt.DOC_POSITION_ID;
        end if;

        -- Traite le détail de composant courant pour autant qu'il reste un écart à appliquer.
        if vRemainingGap <> 0 then
          -- Valeur par défaut des nouvelles quantités à mettre à jour
          dcdQuantityCPT    := tplCpt.DCD_QUANTITY;
          dcdQuantityCPTSU  := tplCpt.DCD_QUANTITY_SU;

          -- Traitement de la quantité positive (zéro compris)
          if    vSign = 1
             or vSign = 0 then
            if vRemainingGap > 0 then
              ----
              -- Diminution de la quantité du produit terminé
              --
              -- Traite uniquement les composants avec une quantité supérieure à 0
              if tplCpt.DCD_QUANTITY > 0 then
                -- Applique le coefficient d'utilisation du composant à l'écart restant arrondi avec le nombre de décimal du composant.
                vRemainingGapCPT   :=
                                 ACS_FUNCTION.RoundNear(vRemainingGap * nvl(tplCpt.POS_UTIL_COEFF, 1), 1 / power(10, nvl(tplCpt.GOO_NUMBER_OF_DECIMAL, 0) ), 0);

                ----
                -- Détermine la nouvelle quantité du composant en tenant compte de la quantité du détail courant.
                -- La quantité ne pourra pas être inférieure à 0.
                --
                if tplCpt.DCD_QUANTITY >= vRemainingGapCPT then
                  -- Tout l'écart peut être appliqué à la quantité du détail
                  vGapCPT        := vRemainingGapCPT;
                  -- Termine la répartition sur ce composant
                  vRemainingGap  := 0;
                else
                  -- Uniquement une partie de l'écart peut être appliqué à la quantité du détail.
                  vGapCPT        := tplCpt.DCD_QUANTITY;
                  -- Détermine le nouvel écart à appliquer. Convertit la quantité du composant sans appliquer d'arrondi (à voir si ce
                  -- n'est pas une erreur).
                  vRemainingGap  := vGapCPT / nvl(tplCpt.POS_UTIL_COEFF, 1);
                end if;

                -- Calcul les nouvelles quantités à mettre à jour
                dcdQuantityCPT     := tplCpt.DCD_QUANTITY - vGapCPT;
                dcdQuantityCPTSU   := dcdQuantityCPT;
                -- Demande de mise à jour du composant
                vRequestUpdateCpt  := true;
              else   -- tplCpt.DCD_QUANTITY = 0
                -- Aucune demande de mise à jour du composant.
                vRequestUpdateCpt  := false;
              end if;   -- tplCpt.DCD_QUANTITY > 0
            else   -- vRemainingGap < 0
              ----
              -- Augmentation de la quantité du produit terminé
              --

              -- Applique le coefficient d'utilisation du composant à l'écart restant arrondi avec le nombre de décimal du
              -- composant.
              vRemainingGapCPT  :=
                                 ACS_FUNCTION.RoundNear(vRemainingGap * nvl(tplCpt.POS_UTIL_COEFF, 1), 1 / power(10, nvl(tplCpt.GOO_NUMBER_OF_DECIMAL, 0) ), 0);

              -- Traite uniquement les composants avec une quantité inférieure à la quantité initiale du détail + écart restant.
              if tplCpt.DCD_QUANTITY <(tplCpt.DCD_INITIAL_QUANTITY + abs(vRemainingGapCPT) ) then
                ----
                -- Détermine la nouvelle quantité du composant en tenant compte de la quantité du détail courant.
                -- La quantité ne pourra pas dépasser la quantité initiale du détail.
                --
                if (tplCpt.DCD_QUANTITY - vRemainingGapCPT) <= tplCpt.DCD_INITIAL_QUANTITY + abs(vRemainingGapCPT) then
                  -- Tout l'écart peut être appliqué à la quantité du détail
                  vGapCPT        := vRemainingGapCPT;
                  -- Termine la répartition sur ce composant
                  vRemainingGap  := 0;
                else
                  -- Uniquement une partie de l'écart peut être appliqué à la quantité du détail.
                  vGapCPT        := tplCpt.DCD_QUANTITY - tplCpt.DCD_INITIAL_QUANTITY;
                  -- Détermine le nouvel écart à appliquer. Convertit la quantité du composant sans appliquer d'arrondi (à voir si ce
                  -- n'est pas une erreur).
                  vRemainingGap  := vGapCPT / nvl(tplCpt.POS_UTIL_COEFF, 1);
                end if;

                -- Calcul les nouvelles quantités à mettre à jour
                dcdQuantityCPT     := tplCpt.DCD_QUANTITY - vGapCPT;
                dcdQuantityCPTSU   := dcdQuantityCPT;
                -- Demande de mise à jour du composant
                vRequestUpdateCpt  := true;
              else   -- tplCpt.DCD_QUANTITY = tplCpt.DCD_INITIAL_QUANTITY
                -- Aucune demande de mise à jour du composant.
                vRequestUpdateCpt  := false;
              end if;   -- tplCpt.DCD_QUANTITY < tplCpt.DCD_INITIAL_QUANTITY
            end if;
          elsif vSign = -1 then   -- Traitement de la quantité négative
            if vRemainingGap < 0 then
              ----
              -- Diminution de la quantité du produit terminé
              --
              -- Traite uniquement les composants avec une quantité inférieure à 0
              if tplCpt.DCD_QUANTITY < 0 then
                -- Applique le coefficient d'utilisation du composant à l'écart restant arrondi avec le nombre de décimal du composant.
                vRemainingGapCPT   :=
                                 ACS_FUNCTION.RoundNear(vRemainingGap * nvl(tplCpt.POS_UTIL_COEFF, 1), 1 / power(10, nvl(tplCpt.GOO_NUMBER_OF_DECIMAL, 0) ), 0);

                ----
                -- Détermine la nouvelle quantité du composant en tenant compte de la quantité du détail courant.
                -- La quantité ne pourra pas être supérieure à 0.
                --
                if tplCpt.DCD_QUANTITY <= vRemainingGapCPT then
                  -- Tout l'écart peut être appliqué à la quantité du détail
                  vGapCPT        := vRemainingGapCPT;
                  -- Termine la répartition sur ce composant
                  vRemainingGap  := 0;
                else
                  -- Uniquement une partie de l'écart peut être appliqué à la quantité du détail.
                  vGapCPT        := tplCpt.DCD_QUANTITY;
                  -- Détermine le nouvel écart à appliquer. Convertit la quantité du composant sans appliquer d'arrondi (à voir si ce
                  -- n'est pas une erreur).
                  vRemainingGap  := vGapCPT / nvl(tplCpt.POS_UTIL_COEFF, 1);
                end if;

                -- Calcul les nouvelles quantités à mettre à jour
                dcdQuantityCPT     := tplCpt.DCD_QUANTITY - vGapCPT;
                dcdQuantityCPTSU   := dcdQuantityCPT;
                -- Demande de mise à jour du composant
                vRequestUpdateCpt  := true;
              else   -- tplCpt.DCD_QUANTITY = 0
                -- Aucune demande de mise à jour du composant.
                vRequestUpdateCpt  := false;
              end if;   -- tplCpt.DCD_QUANTITY < 0
            else   -- vRemainingGap > 0
              ----
              -- Augmentation de la quantité du produit terminé
              --
              -- Traite uniquement les composants avec une quantité supérieure à la quantité initiale du détail.
              if tplCpt.DCD_QUANTITY > tplCpt.DCD_INITIAL_QUANTITY then
                -- Applique le coefficient d'utilisation du composant à l'écart restant arrondi avec le nombre de décimal du
                -- composant.
                vRemainingGapCPT   :=
                                 ACS_FUNCTION.RoundNear(vRemainingGap * nvl(tplCpt.POS_UTIL_COEFF, 1), 1 / power(10, nvl(tplCpt.GOO_NUMBER_OF_DECIMAL, 0) ), 0);

                ----
                -- Détermine la nouvelle quantité du composant en tenant compte de la quantité du détail courant.
                -- La quantité ne pourra pas dépasser (en valeur absolue) la quantité initiale du détail.
                --
                if (tplCpt.DCD_QUANTITY - vRemainingGapCPT) >= tplCpt.DCD_INITIAL_QUANTITY then
                  -- Tout l'écart peut être appliqué à la quantité du détail
                  vGapCPT        := vRemainingGapCPT;
                  -- Termine la répartition sur ce composant
                  vRemainingGap  := 0;
                else
                  -- Uniquement une partie de l'écart peut être appliqué à la quantité du détail.
                  vGapCPT        := tplCpt.DCD_INITIAL_QUANTITY;
                  -- Détermine le nouvel écart à appliquer. Convertit la quantité du composant sans appliquer d'arrondi (à voir si ce
                  -- n'est pas une erreur).
                  vRemainingGap  := vGapCPT / nvl(tplCpt.POS_UTIL_COEFF, 1);
                end if;

                -- Calcul les nouvelles quantités à mettre à jour
                dcdQuantityCPT     := tplCpt.DCD_QUANTITY - vGapCPT;
                dcdQuantityCPTSU   := dcdQuantityCPT;
                -- Demande de mise à jour du composant
                vRequestUpdateCpt  := true;
              else   -- tplCpt.DCD_QUANTITY = tplCpt.DCD_INITIAL_QUANTITY
                -- Aucune demande de mise à jour du composant.
                vRequestUpdateCpt  := false;
              end if;   -- tplCpt.DCD_QUANTITY > tplCpt.DCD_INITIAL_QUANTITY
            end if;
          end if;   -- vSign = 1

          if vRequestUpdateCpt then
            -- Réinitialise l'indicateur de demande de mise à jour du composant
            vRequestUpdateCpt  := false;

            -- Mise à jour de la nouvelle quantité et l'indicateur de sélection sur le détail de composant courant.
            update DOC_POS_DET_COPY_DISCHARGE
               set DCD_QUANTITY = dcdQuantityCPT
                 , DCD_QUANTITY_SU = dcdQuantityCPTSU
                 , CRG_SELECT = decode(dcdQuantityCPT, 0, 0, 1)
             where DOC_POS_DET_COPY_DISCHARGE_ID = tplCpt.DOC_POS_DET_COPY_DISCHARGE_ID;
          end if;
        end if;   -- vRemainingGap <> 0

        fetch crCpt
         into tplCpt;
      end loop;
    end if;   -- crCpt%found
  end if;   -- (:old.DCD_QUANTITY <> dcdQuantity) or (:old.CRG_SELECT <> crgSelect)

  ---
  -- Modification du flag solde du produit terminé alors que les composants ne sont
  -- pas affichés.
  --
  if     (:old.DCD_BALANCE_FLAG <> :new.DCD_BALANCE_FLAG)
     and (:new.DCD_DEPLOYED_COMPONENTS = 1)
     and (:new.DCD_VISIBLE = 0) then
    ---
    -- Copie l'indicateur du flag solde du produit terminé sur les composants.
    --
    update DOC_POS_DET_COPY_DISCHARGE
       set DCD_BALANCE_FLAG = :new.DCD_BALANCE_FLAG
     where NEW_DOCUMENT_ID = :new.NEW_DOCUMENT_ID
       and DOC_DOC_POSITION_ID = :new.DOC_POSITION_ID;
  end if;

  ---
  -- Modification de la sélection des composants. On doit garantir que le PT
  -- est sélectionné si un des composants au moins est sélectionné.
  --
  if     (:old.CRG_SELECT <> crgSelect)
     and (:new.DOC_DOC_POSITION_ID is not null) then
    ---
    -- Garantit que l'indicateur de sélection du PT est bien activé si le composant
    -- l'est.
    --
    if crgSelect = 1 then
      update DOC_POS_DET_COPY_DISCHARGE
         set CRG_SELECT = 1
       where NEW_DOCUMENT_ID = :new.NEW_DOCUMENT_ID
         and DOC_POSITION_ID = :new.DOC_DOC_POSITION_ID;
    else
           -- crgSelect = 0
      ---
      -- Garantit que l'indicateur de sélection du PT est bien désactivé lorsque
      -- tous les composants sont désélectionnés. Le PT doit avoir au moins
      -- un composant sélectionné.
      --
      select max(CRG_SELECT)
        into crgSelectCPTs
        from DOC_POS_DET_COPY_DISCHARGE
       where NEW_DOCUMENT_ID = :new.NEW_DOCUMENT_ID
         and DOC_DOC_POSITION_ID = :new.DOC_DOC_POSITION_ID
         and DOC_POS_DET_COPY_DISCHARGE_ID <> :new.DOC_POS_DET_COPY_DISCHARGE_ID;

      update DOC_POS_DET_COPY_DISCHARGE
         set CRG_SELECT = crgSelectCPTs
       where NEW_DOCUMENT_ID = :new.NEW_DOCUMENT_ID
         and DOC_POSITION_ID = :new.DOC_DOC_POSITION_ID;
    end if;
  end if;

  update DOC_POS_DET_COPY_DISCHARGE
     set DOC_POSITION_DETAIL_ID = :new.DOC_POSITION_DETAIL_ID
       , NEW_DOCUMENT_ID = :new.NEW_DOCUMENT_ID
       , DOC_POSITION_ID = :new.DOC_POSITION_ID
       , CRG_SELECT = crgSelect
       , DOC_GAUGE_FLOW_ID = :new.DOC_GAUGE_FLOW_ID
       , DOC_DOC_POSITION_ID = :new.DOC_DOC_POSITION_ID
       , DOC_DOC_POSITION_DETAIL_ID = :new.DOC_DOC_POSITION_DETAIL_ID
       , DOC2_DOC_POSITION_DETAIL_ID = :new.DOC2_DOC_POSITION_DETAIL_ID
       , DOC_INVOICE_EXPIRY_ID = :new.DOC_INVOICE_EXPIRY_ID
       , GCO_GOOD_ID = :new.GCO_GOOD_ID
       , STM_LOCATION_ID = :new.STM_LOCATION_ID
       , GCO_CHARACTERIZATION_ID = :new.GCO_CHARACTERIZATION_ID
       , GCO_GCO_CHARACTERIZATION_ID = :new.GCO_GCO_CHARACTERIZATION_ID
       , GCO2_GCO_CHARACTERIZATION_ID = :new.GCO2_GCO_CHARACTERIZATION_ID
       , GCO3_GCO_CHARACTERIZATION_ID = :new.GCO3_GCO_CHARACTERIZATION_ID
       , GCO4_GCO_CHARACTERIZATION_ID = :new.GCO4_GCO_CHARACTERIZATION_ID
       , STM_STM_LOCATION_ID = :new.STM_STM_LOCATION_ID
       , DIC_PDE_FREE_TABLE_1_ID = :new.DIC_PDE_FREE_TABLE_1_ID
       , DIC_PDE_FREE_TABLE_2_ID = :new.DIC_PDE_FREE_TABLE_2_ID
       , DIC_PDE_FREE_TABLE_3_ID = :new.DIC_PDE_FREE_TABLE_3_ID
       , FAL_SCHEDULE_STEP_ID = :new.FAL_SCHEDULE_STEP_ID
       , DOC_RECORD_ID = :new.DOC_RECORD_ID
       , DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID
       , PAC_THIRD_ID = :new.PAC_THIRD_ID
       , PAC_THIRD_ACI_ID = :new.PAC_THIRD_ACI_ID
       , PAC_THIRD_DELIVERY_ID = :new.PAC_THIRD_DELIVERY_ID
       , PAC_THIRD_TARIFF_ID = :new.PAC_THIRD_TARIFF_ID
       , DOC_GAUGE_ID = :new.DOC_GAUGE_ID
       , DOC_GAUGE_RECEIPT_ID = :new.DOC_GAUGE_RECEIPT_ID
       , DOC_GAUGE_COPY_ID = :new.DOC_GAUGE_COPY_ID
       , C_GAUGE_TYPE_POS = :new.C_GAUGE_TYPE_POS
       , DIC_DELAY_UPDATE_TYPE_ID = :new.DIC_DELAY_UPDATE_TYPE_ID
       , PDE_BASIS_DELAY = :new.PDE_BASIS_DELAY
       , PDE_BASIS_DELAY_W = :new.PDE_BASIS_DELAY_W
       , PDE_BASIS_DELAY_M = :new.PDE_BASIS_DELAY_M
       , PDE_INTERMEDIATE_DELAY = :new.PDE_INTERMEDIATE_DELAY
       , PDE_INTERMEDIATE_DELAY_W = :new.PDE_INTERMEDIATE_DELAY_W
       , PDE_INTERMEDIATE_DELAY_M = :new.PDE_INTERMEDIATE_DELAY_M
       , PDE_FINAL_DELAY = :new.PDE_FINAL_DELAY
       , PDE_FINAL_DELAY_W = :new.PDE_FINAL_DELAY_W
       , PDE_FINAL_DELAY_M = :new.PDE_FINAL_DELAY_M
       , PDE_SQM_ACCEPTED_DELAY = :new.PDE_SQM_ACCEPTED_DELAY
       , PDE_BASIS_QUANTITY = :new.PDE_BASIS_QUANTITY
       , PDE_INTERMEDIATE_QUANTITY = :new.PDE_INTERMEDIATE_QUANTITY
       , PDE_FINAL_QUANTITY = :new.PDE_FINAL_QUANTITY
       , PDE_BALANCE_QUANTITY = :new.PDE_BALANCE_QUANTITY
       , PDE_BALANCE_QUANTITY_PARENT = :new.PDE_BALANCE_QUANTITY_PARENT
       , PDE_BASIS_QUANTITY_SU = :new.PDE_BASIS_QUANTITY_SU
       , PDE_INTERMEDIATE_QUANTITY_SU = :new.PDE_INTERMEDIATE_QUANTITY_SU
       , PDE_FINAL_QUANTITY_SU = :new.PDE_FINAL_QUANTITY_SU
       , PDE_MOVEMENT_QUANTITY = :new.PDE_MOVEMENT_QUANTITY
       , PDE_MOVEMENT_VALUE = :new.PDE_MOVEMENT_VALUE
       , PDE_CHARACTERIZATION_VALUE_1 = :new.PDE_CHARACTERIZATION_VALUE_1
       , PDE_CHARACTERIZATION_VALUE_2 = :new.PDE_CHARACTERIZATION_VALUE_2
       , PDE_CHARACTERIZATION_VALUE_3 = :new.PDE_CHARACTERIZATION_VALUE_3
       , PDE_CHARACTERIZATION_VALUE_4 = :new.PDE_CHARACTERIZATION_VALUE_4
       , PDE_CHARACTERIZATION_VALUE_5 = :new.PDE_CHARACTERIZATION_VALUE_5
       , PDE_DELAY_UPDATE_TEXT = :new.PDE_DELAY_UPDATE_TEXT
       , PDE_DECIMAL_1 = :new.PDE_DECIMAL_1
       , PDE_DECIMAL_2 = :new.PDE_DECIMAL_2
       , PDE_DECIMAL_3 = :new.PDE_DECIMAL_3
       , PDE_TEXT_1 = :new.PDE_TEXT_1
       , PDE_TEXT_2 = :new.PDE_TEXT_2
       , PDE_TEXT_3 = :new.PDE_TEXT_3
       , PDE_DATE_1 = :new.PDE_DATE_1
       , PDE_DATE_2 = :new.PDE_DATE_2
       , PDE_DATE_3 = :new.PDE_DATE_3
       , PDE_GENERATE_MOVEMENT = :new.PDE_GENERATE_MOVEMENT
       , DCD_QUANTITY = dcdQuantity
       , DCD_QUANTITY_SU = dcdQuantitySU
       , POS_UNIT_OF_MEASURE_ID = :new.POS_UNIT_OF_MEASURE_ID
       , DCD_BALANCE_FLAG = :new.DCD_BALANCE_FLAG
       , POS_CONVERT_FACTOR = :new.POS_CONVERT_FACTOR
       , POS_CONVERT_FACTOR_CALC = :new.POS_CONVERT_FACTOR_CALC
       , POS_GROSS_UNIT_VALUE = :new.POS_GROSS_UNIT_VALUE
       , POS_GROSS_UNIT_VALUE_INCL = :new.POS_GROSS_UNIT_VALUE_INCL
       , POS_NET_UNIT_VALUE = :new.POS_NET_UNIT_VALUE
       , POS_NET_UNIT_VALUE_INCL = :new.POS_NET_UNIT_VALUE_INCL
       , POS_UTIL_COEFF = :new.POS_UTIL_COEFF
       , A_DATEMOD = :new.A_DATECRE
       , A_IDMOD = :new.A_IDCRE
       , A_RECLEVEL = :new.A_RECLEVEL
       , A_RECSTATUS = :new.A_RECSTATUS
       , A_CONFIRM = :new.A_CONFIRM
       , DOC_GCO_GOOD_ID = :new.DOC_GCO_GOOD_ID
       , DCD_USE_STOCK_LOCATION_ID = :new.DCD_USE_STOCK_LOCATION_ID
       , DCD_USE_PARENT_CHARACT = nvl(:new.DCD_USE_PARENT_CHARACT, 1)
       , PDE_PIECE = :new.PDE_PIECE
       , PDE_SET = :new.PDE_SET
       , PDE_VERSION = :new.PDE_VERSION
       , PDE_CHRONOLOGICAL = :new.PDE_CHRONOLOGICAL
       , PDE_STD_CHAR_1 = :new.PDE_STD_CHAR_1
       , PDE_STD_CHAR_2 = :new.PDE_STD_CHAR_2
       , PDE_STD_CHAR_3 = :new.PDE_STD_CHAR_3
       , PDE_STD_CHAR_4 = :new.PDE_STD_CHAR_4
       , PDE_STD_CHAR_5 = :new.PDE_STD_CHAR_5
       , PDE_BALANCE_PARENT = :new.PDE_BALANCE_PARENT
       , DCD_DEPLOYED_COMPONENTS = :new.DCD_DEPLOYED_COMPONENTS
       , DCD_VISIBLE = :new.DCD_VISIBLE
       , DCD_UPDATE_PARENT_DELAY = :new.DCD_UPDATE_PARENT_DELAY
       , ACS_CDA_ACCOUNT_BS_ID = :new.ACS_CDA_ACCOUNT_BS_ID
       , ACS_CDA_ACCOUNT_PL_ID = :new.ACS_CDA_ACCOUNT_PL_ID
       , ACS_CPN_ACCOUNT_BS_ID = :new.ACS_CPN_ACCOUNT_BS_ID
       , ACS_CPN_ACCOUNT_PL_ID = :new.ACS_CPN_ACCOUNT_PL_ID
       , ACS_DIVISION_ACCOUNT_BS_ID = :new.ACS_DIVISION_ACCOUNT_BS_ID
       , ACS_DIVISION_ACCOUNT_PL_ID = :new.ACS_DIVISION_ACCOUNT_PL_ID
       , ACS_FINANCIAL_ACCOUNT_BS_ID = :new.ACS_FINANCIAL_ACCOUNT_BS_ID
       , ACS_FINANCIAL_ACCOUNT_PL_ID = :new.ACS_FINANCIAL_ACCOUNT_PL_ID
       , ACS_PF_ACCOUNT_BS_ID = :new.ACS_PF_ACCOUNT_BS_ID
       , ACS_PF_ACCOUNT_PL_ID = :new.ACS_PF_ACCOUNT_PL_ID
       , ACS_PJ_ACCOUNT_BS_ID = :new.ACS_PJ_ACCOUNT_BS_ID
       , ACS_PJ_ACCOUNT_PL_ID = :new.ACS_PJ_ACCOUNT_PL_ID
       , CML_EVENTS_ID = :new.CML_EVENTS_ID
       , C_FAM_TRANSACTION_TYP = :new.C_FAM_TRANSACTION_TYP
       , C_PDE_CREATE_MODE = :new.C_PDE_CREATE_MODE
       , DCD_FORCE_AMOUNT = :new.DCD_FORCE_AMOUNT
       , DIC_IMP_FREE1_ID = :new.DIC_IMP_FREE1_ID
       , DIC_IMP_FREE2_ID = :new.DIC_IMP_FREE2_ID
       , DIC_IMP_FREE3_ID = :new.DIC_IMP_FREE3_ID
       , DIC_IMP_FREE4_ID = :new.DIC_IMP_FREE4_ID
       , DIC_IMP_FREE5_ID = :new.DIC_IMP_FREE5_ID
       , DOC_DOCUMENT_SRC_ID = :new.DOC_DOCUMENT_SRC_ID
       , DOC_POSITION_SRC_ID = :new.DOC_POSITION_SRC_ID
       , DOC_POS_DET_COPY_DISCHARGE_ID = :new.DOC_POS_DET_COPY_DISCHARGE_ID
       , DOC_RECORD_BS_ID = :new.DOC_RECORD_BS_ID
       , FAL_NETWORK_LINK_ID = :new.FAL_NETWORK_LINK_ID
       , FAL_SUPPLY_REQUEST_ID = :new.FAL_SUPPLY_REQUEST_ID
       , FAM_FIXED_ASSETS_ID = :new.FAM_FIXED_ASSETS_ID
       , GCO_GCO_GOOD_ID = :new.GCO_GCO_GOOD_ID
       , HRM_PERSON_ID = :new.HRM_PERSON_ID
       , PAC_THIRD_CDA_ID = :new.PAC_THIRD_CDA_ID
       , PAC_THIRD_VAT_ID = :new.PAC_THIRD_VAT_ID
       , PDE_ADDENDUM_QTY_BALANCED = :new.PDE_ADDENDUM_QTY_BALANCED
       , PDE_ADDENDUM_SRC_PDE_ID = :new.PDE_ADDENDUM_SRC_PDE_ID
       , PDE_IMF_NUMBER_1 = :new.PDE_IMF_NUMBER_1
       , PDE_IMF_NUMBER_2 = :new.PDE_IMF_NUMBER_2
       , PDE_IMF_NUMBER_3 = :new.PDE_IMF_NUMBER_3
       , PDE_IMF_NUMBER_4 = :new.PDE_IMF_NUMBER_4
       , PDE_IMF_NUMBER_5 = :new.PDE_IMF_NUMBER_5
       , PDE_IMF_TEXT_1 = :new.PDE_IMF_TEXT_1
       , PDE_IMF_TEXT_2 = :new.PDE_IMF_TEXT_2
       , PDE_IMF_TEXT_3 = :new.PDE_IMF_TEXT_3
       , PDE_IMF_TEXT_4 = :new.PDE_IMF_TEXT_4
       , PDE_IMF_TEXT_5 = :new.PDE_IMF_TEXT_5
       , PDE_IMF_DATE_1 = :new.PDE_IMF_DATE_1
       , PDE_IMF_DATE_2 = :new.PDE_IMF_DATE_2
       , PDE_IMF_DATE_3 = :new.PDE_IMF_DATE_3
       , PDE_IMF_DATE_4 = :new.PDE_IMF_DATE_4
       , PDE_IMF_DATE_5 = :new.PDE_IMF_DATE_5
       , PDE_MOVEMENT_DATE = :new.PDE_MOVEMENT_DATE
       , PDE_TRANSFERT_PROPRIETOR = :new.PDE_TRANSFERT_PROPRIETOR
       , POS_GROSS_VALUE = :new.POS_GROSS_VALUE
       , POS_LONG_DESCRIPTION = :new.POS_LONG_DESCRIPTION
       , POS_NET_VALUE_EXCL = :new.POS_NET_VALUE_EXCL
       , POS_SHORT_DESCRIPTION = :new.POS_SHORT_DESCRIPTION
       , FAL_LOT_ID = :new.FAL_LOT_ID
       , PDE_ST_PT_REJECT = :new.PDE_ST_PT_REJECT
       , PDE_ST_CPT_REJECT = :new.PDE_ST_CPT_REJECT
       , GCO_QUALITY_STATUS_ID = :new.GCO_QUALITY_STATUS_ID
   where DOC_POS_DET_COPY_DISCHARGE_ID = :new.DOC_POS_DET_COPY_DISCHARGE_ID;
end;

ALTER TRIGGER "C_ITX"."DOC_V_DCD_IOU_QUANTITY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_V_PDE_IOD"
  instead of delete
  on V_DOC_POSITION_DETAIL_IO
  for each row
/**
* Description
*    Ecriture de journalisation (de la position père) à l'effacement d'une position issue de décharge
* @created NGV 12.2005
* @version 2003
* @lastUpdate
*/
declare
  cursor crLinkedPositionDetail(aPositionID in number, aParentPositionDetailID in number)
  is
    select   PDE.DOC_POSITION_DETAIL_ID
           , PDE.PDE_BALANCE_QUANTITY_PARENT
           , PDE.DOC_DOC_POSITION_DETAIL_ID
           , PDE.DOC2_DOC_POSITION_DETAIL_ID
           , PDE.DOC_GAUGE_FLOW_ID
           , PDE.DOC_GAUGE_RECEIPT_ID
           , PDE.PDE_BALANCE_PARENT
           , PDE_FATHER.PDE_FINAL_QUANTITY
           , PDE_FATHER.PDE_BALANCE_QUANTITY
           , POS.GCO_GOOD_ID
           , POS.PAC_THIRD_ID
           , POS.POS_CONVERT_FACTOR
           , POS.POS_CONVERT_FACTOR2
           , POS_FATHER.POS_CONVERT_FACTOR2 FATHER_CONVERT_FACTOR2
           , POS_FATHER.POS_CONVERT_FACTOR FATHER_CONVERT_FACTOR
           , POS_FATHER.GCO_GOOD_ID FATHER_GOOD_ID
           , POS_FATHER.PAC_THIRD_ID FATHER_THIRD_ID
           , GAU.C_ADMIN_DOMAIN
        from DOC_POSITION_DETAIL PDE
           , DOC_POSITION POS
           , DOC_GAUGE GAU
           , DOC_POSITION_DETAIL PDE_FATHER
           , DOC_POSITION POS_FATHER
       where PDE.DOC_POSITION_ID = aPositionID
         and PDE.DOC_DOC_POSITION_DETAIL_ID = aParentPositionDetailID
         and POS.DOC_POSITION_ID = PDE.DOC_POSITION_ID
         and GAU.DOC_GAUGE_ID = POS.DOC_GAUGE_ID
         and PDE_FATHER.DOC_POSITION_DETAIL_ID = PDE.DOC_DOC_POSITION_DETAIL_ID
         and POS_FATHER.DOC_POSITION_ID = PDE_FATHER.DOC_POSITION_ID
    order by nvl(abs(PDE.PDE_BALANCE_QUANTITY_PARENT), 0) desc
           , nvl(PDE.PDE_BALANCE_PARENT, 0) desc;

  tplLinkedPositionDetail  crLinkedPositionDetail%rowtype;
  numBalanceQuantityParent DOC_POSITION_DETAIL.PDE_BALANCE_QUANTITY_PARENT%type;
  vBalanceQuantity         DOC_POSITION_DETAIL.PDE_BALANCE_QUANTITY%type;
begin
  -- Le détail de posititon courant est-il lié à un détail père ?
  if :old.DOC_DOC_POSITION_DETAIL_ID is not null then   -- Oui
    -- Recherche si des détails avec un lien avec un père existent. C'est uniquement le détail qui possède la
    -- quantité soldée sur parent la plus grande en valeur absolue qui est traitée. C'est toujours ce détail de
    -- position qui reçoit l'éventuelle quantité soldée sur parent de l'ensemble des détails de position d'un
    -- même père.
    open crLinkedPositionDetail(:old.DOC_POSITION_ID, :old.DOC_DOC_POSITION_DETAIL_ID);

    fetch crLinkedPositionDetail
     into tplLinkedPositionDetail;

    if crLinkedPositionDetail%found then
      ----
      -- Effectue la mise à jour éventuelle de la quantité solde du détail père et de la quantité soldée sur parent
      -- du détail fils de "référence" (qui contient les informations solder parent et quantité soldé sur parent).
      --
      numBalanceQuantityParent  := tplLinkedPositionDetail.PDE_BALANCE_QUANTITY_PARENT;

      -- Calcul de la quantité solde à recharger sur le parent. Tient compte des facteurs de conversion si un
      -- changement de bien ou de partenaire est effectif. En effet, dans ce cas, il est possible que l'unité de gestion
      -- (et donc le facteur de conversion) soit différent entre le document père et le document fils. Dans ce cas, il
      -- faut appliquer les calculs ci-dessous :
      --
      if (   tplLinkedPositionDetail.GCO_GOOD_ID <> tplLinkedPositionDetail.FATHER_GOOD_ID
          or tplLinkedPositionDetail.PAC_THIRD_ID <> tplLinkedPositionDetail.FATHER_THIRD_ID
         ) then
        if tplLinkedPositionDetail.POS_CONVERT_FACTOR2 <> tplLinkedPositionDetail.POS_CONVERT_FACTOR then
          --
          -- Si le facteur initial fils est différent du facteur effectif fils -> Changement manuelle du facteur
          --
          -- Cas du changement de bien ou de tiers avec la modification du facteur de conversion.
          --
          -- Données de base : Article A  US=kg Décimal=2 UDC=sac10kg Décimal=2 Facteur 10
          --                   Article B  US=kg Décimal=2 UDC=sac25kg Décimal=2 Facteur 25
          --
          --
          -- Doc   Bien                 Qte   UDC      Facteur  QteUS   US  FacteurDC  Solde parent UDC Mode correction
          --                                                                           Qte soldé
          --
          -- CC    Article A            10    sac10kg  10       100     kg  10
          --
          -- ==> proposition de décharge suivi de modification
          --
          --       Article A->Article B 10    sac10kg  10       100     kg  10->25
          --       Article B            10->5 sac10kg  10       100->50 kg  25
          --       Article B            5     sac10kg  10       50->51  kg  25->25.5   Oui              Oui
          --
          -- ==> décharge avec changement de bien, de quantité de décharge et facteur de conversion
          --
          -- BL    Article B            2     sac25kg  25.5     51      kg  25         5            sac10kg
          --
          -- ==> effacement du BL
          --
          -- Quantité à recharger = Quantité finale fils * Facteur initial fils / Facteur effectif père
          -- 5                    = 2                    * 25                   / 10
          --
          -- ==> mise à jour solde CC
          --
          -- New quantité solde CC = Old quantité solde CC + Quantité à recharger + Quantité soldé sur parent
          -- 10                    = 0                     + 5                    + 5
          --
          vBalanceQuantity  :=
            :old.PDE_FINAL_QUANTITY *   -- quantié finale fils
                                     tplLinkedPositionDetail.POS_CONVERT_FACTOR2 /   -- facteur initial fils
                                                                                  tplLinkedPositionDetail.FATHER_CONVERT_FACTOR;   -- facteur effectif père
        --
        elsif tplLinkedPositionDetail.FATHER_CONVERT_FACTOR <> tplLinkedPositionDetail.POS_CONVERT_FACTOR then
          --
          -- Si le facteur effectif père est différent du facteur effectif fils -> Changement du facteur DC
          -- Attention, c'est peut-être plutôt :
          -- Si le facteur initial père est différent du facteur initial fils -> Changement du facteur DC
          -- A revoir donc.
          --
          --
          -- Cas du changement de bien ou de tiers avec modification du facteur DC mais sans modification manuelle du
          -- facteur.
          --
          -- Données de base : Article A  US=kg Décimal=2 UDC=sac10kg Décimal=2 Facteur 10
          --                   Article B  US=kg Décimal=2 UDC=sac25kg Décimal=2 Facteur 25
          --
          -- Doc   Bien                 Qte     UDC      Facteur  QteUS   US  FacteurDC  Solde parent UDC Mode correction
          --                                                                             Qte soldé
          --
          -- CC    Article A            10      sac10kg  10       100     kg  10
          --
          -- ==> proposition de décharge suivi de modification
          --
          --       Article A->Article B 10      sac10kg  10       100     kg  10->25
          --       Article B            10->7.5 sac10kg  10       100->75 kg  25
          --       Article B            7.5     sac10kg  10       75      kg  25         Oui
          --
          -- ==> décharge sur BL
          --
          -- BL    Article B            3       sac25kg  25       75      kg  25         2.5          sac10kg
          --
          -- ==> effacement du BL
          --
          -- Quantité à recharger = Quantité finale fils US / Facteur effectif fils
          -- 7.5                  = 75                      / 10
          --
          -- ==> mise à jour solde CC
          --
          -- New quantité solde CC = Old quantité solde CC + Quantité à recharger + Quantité soldé sur parent
          -- 10                    = 0                     + 7.5                  + 2.5
          --
          vBalanceQuantity  := :old.PDE_FINAL_QUANTITY_SU / tplLinkedPositionDetail.FATHER_CONVERT_FACTOR;
        --
        else
          -- Cas du changement de bien ou de tiers sans changement du facteur DC et sans modification manuelle du
          -- facteur de conversion. La quantité du fils est exprimé dans la même unité de données complémentaires que
          -- le père.
          --
          -- Donc :
          --
          -- Quantité à recharger = Quantité finale fils
          --
          vBalanceQuantity  := :old.PDE_FINAL_QUANTITY;
        end if;
      else
        -- Cas sans changement de bien ou de tiers et donc sans changement du facteur DC et sans tenir compte de
        -- l'éventuelle modification manuelle du facteur de conversion. La quantité du fils est exprimé dans la même
        -- unité de données complémentaires que le père.
        --
        -- Donc :
        --
        -- Quantité à recharger = Quantité finale fils
        --
        vBalanceQuantity  := :old.PDE_FINAL_QUANTITY;
      end if;

      -- On effectue la mise à jour du détail qui possède la quantité soldé sur parent uniquement si ce
      -- n'est pas le détail en cours de modification.
      if (tplLinkedPositionDetail.DOC_POSITION_DETAIL_ID <> :old.DOC_POSITION_DETAIL_ID) then
        -- Effectue l'éventuelle mise à jour de la quantité solde du détail père
        DOC_POSITION_DETAIL_FUNCTIONS.MajBalanceQtyDetailParent(:old.DOC_DOC_POSITION_DETAIL_ID
                                                              , 0
                                                              , vBalanceQuantity
                                                              , tplLinkedPositionDetail.PDE_BALANCE_PARENT
                                                              , numBalanceQuantityParent
                                                               );

        -- Mise a jour du détail trouvé avec la nouvelle quantité soldée sur parent.
        update DOC_POSITION_DETAIL
           set PDE_BALANCE_QUANTITY_PARENT = numBalanceQuantityParent
         where DOC_POSITION_DETAIL_ID = tplLinkedPositionDetail.DOC_POSITION_DETAIL_ID;
      else
        ---
        -- Recharge la quantité solde du père. Dans ce cas, nous sommes en train d'effacer le détail de "référence". C'est
        -- uniquement possible lorque l'on supprime la position (l'interface interdit la suppression du détail de "référence").
        --
        -- New quantité solde père = Old quantité solde père + Quantité à recharger + Quantité soldé sur parent
        --
        numBalanceQuantityParent  := :old.PDE_BALANCE_QUANTITY_PARENT;

        -- A mettre en place pour vérifier les incohérences
        update DOC_POSITION_DETAIL
           set PDE_BALANCE_QUANTITY =
                 decode(sign(PDE_BASIS_QUANTITY)
                      , -1, least( (PDE_BALANCE_QUANTITY + vBalanceQuantity + numBalanceQuantityParent), 0)
                      , greatest( (PDE_BALANCE_QUANTITY + vBalanceQuantity + numBalanceQuantityParent), 0)
                       )
             , A_DATEMOD = sysdate
             , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
         where DOC_POSITION_DETAIL_ID = :old.DOC_DOC_POSITION_DETAIL_ID;

        -- si il y  a un solde de quantité soldée sur parent, il faut le remettre sur le premier detail position dans l'ordre de création
        if -:old.PDE_BALANCE_QUANTITY_PARENT > :old.PDE_FINAL_QUANTITY then
          update DOC_POSITION_DETAIL
             set PDE_BALANCE_QUANTITY_PARENT = :old.PDE_BALANCE_QUANTITY_PARENT + :old.PDE_FINAL_QUANTITY
           where DOC_POSITION_DETAIL_ID =
                                      (select min(DOC_POSITION_DETAIL_ID)
                                         from DOC_POSITION_DETAIL
                                        where DOC_POSITION_ID = :old.DOC_POSITION_ID
                                          and DOC_POSITION_DETAIL_ID <> tplLinkedPositionDetail.DOC_POSITION_DETAIL_ID);
        end if;
      end if;
    end if;

    close crLinkedPositionDetail;
  end if;

  delete from DOC_POSITION_DETAIL
        where DOC_POSITION_DETAIL_ID = :old.DOC_POSITION_DETAIL_ID;
end DOC_V_PDE_IOD;

ALTER TRIGGER "C_ITX"."DOC_V_PDE_IOD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_V_PDE_IOI_QUANTITY"
  instead of insert
  on V_DOC_POSITION_DETAIL_IO
  for each row
/**
* Description
*    Mise à jour de la quantité soldée sur parent et du lien de décharge
* @created VJ 18.08.2003
* @version 2003
* @lastUpdate
*/
declare
  cursor crLinkedPositionDetail(aPositionID in number)
  is
    select   PDE.DOC_POSITION_DETAIL_ID
           , PDE.PDE_BALANCE_QUANTITY_PARENT
           , PDE.DOC_DOC_POSITION_DETAIL_ID
           , PDE.DOC2_DOC_POSITION_DETAIL_ID
           , PDE.DOC_GAUGE_FLOW_ID
           , PDE.DOC_GAUGE_RECEIPT_ID
           , PDE.PDE_BALANCE_PARENT
           , PDE_FATHER.PDE_FINAL_QUANTITY
           , PDE_FATHER.PDE_BALANCE_QUANTITY
           , POS.POS_CONVERT_FACTOR
           , POS.POS_CONVERT_FACTOR2
           , POS.GCO_GOOD_ID
           , POS.PAC_THIRD_ID
           , POS_FATHER.POS_CONVERT_FACTOR2 FATHER_CONVERT_FACTOR2
           , POS_FATHER.POS_CONVERT_FACTOR FATHER_CONVERT_FACTOR
           , POS_FATHER.GCO_GOOD_ID FATHER_GOOD_ID
           , POS_FATHER.PAC_THIRD_ID FATHER_THIRD_ID
        from DOC_POSITION_DETAIL PDE
           , DOC_POSITION POS
           , DOC_POSITION_DETAIL PDE_FATHER
           , DOC_POSITION POS_FATHER
       where PDE.DOC_POSITION_ID = aPositionID
         and POS.DOC_POSITION_ID = PDE.DOC_POSITION_ID
         and PDE_FATHER.DOC_POSITION_DETAIL_ID = PDE.DOC_DOC_POSITION_DETAIL_ID
         and POS_FATHER.DOC_POSITION_ID = PDE_FATHER.DOC_POSITION_ID
    order by nvl(abs(PDE.PDE_BALANCE_QUANTITY_PARENT), 0) desc
           , nvl(PDE.PDE_BALANCE_PARENT, 0) desc
           , nvl(PDE_FATHER.PDE_BALANCE_QUANTITY, 0) desc;

  tplLinkedPositionDetail   crLinkedPositionDetail%rowtype;
  idPositionDetailFather    DOC_POSITION_DETAIL.DOC_DOC_POSITION_DETAIL_ID%type;
  idPositionDetailOrigin    DOC_POSITION_DETAIL.DOC2_DOC_POSITION_DETAIL_ID%type;
  idFlow                    DOC_GAUGE_FLOW.DOC_GAUGE_FLOW_ID%type;
  idDischargeFlow           DOC_GAUGE_RECEIPT.DOC_GAUGE_RECEIPT_ID%type;
  numBalanceParent          DOC_POSITION_DETAIL.PDE_BALANCE_PARENT%type;
  numBalanceQuantityParent  DOC_POSITION_DETAIL.PDE_BALANCE_QUANTITY_PARENT%type;
  numBalanceQuantityParent2 DOC_POSITION_DETAIL.PDE_BALANCE_QUANTITY_PARENT%type;
  numInitialQuantity        DOC_POSITION_DETAIL.PDE_FINAL_QUANTITY%type;
  /**
  * DSA - Evaluation fournisseurs
  * Déclaration des variables
  */
  vDateDocument             DOC_DOCUMENT.DMT_DATE_DOCUMENT%type;   -- date du document
  vThird                    DOC_POSITION.PAC_THIRD_ID%type;
  vGood                     DOC_POSITION.GCO_GOOD_ID%type;
  vPosStatus                DOC_POSITION.C_DOC_POS_STATUS%type;
  vExpValue                 SQM_PENALTY.SPE_EXPECTED_VALUE%type;
  vEffValue                 SQM_PENALTY.SPE_EFFECTIVE_VALUE%type;
  vAxisValue                SQM_PENALTY.SPE_INIT_VALUE%type;
  datBASIS_DELAY            DOC_POSITION_DETAIL.PDE_BASIS_DELAY%type;
  datINTER_DELAY            DOC_POSITION_DETAIL.PDE_INTERMEDIATE_DELAY%type;
  datFINAL_DELAY            DOC_POSITION_DETAIL.PDE_FINAL_DELAY%type;
  /**
  * NGV - Journalisation des positions
  * Déclaration des variables
  */
  vSrcPosID                 DOC_POSITION.DOC_POSITION_ID%type;
  tplPos                    DOC_POSITION%rowtype;
  vQuantity                 DOC_POSITION_DETAIL.PDE_FINAL_QUANTITY%type;
  vDetailProv               integer                                                default 0;
  vBalanceQuantity          DOC_POSITION_DETAIL.PDE_BALANCE_QUANTITY%type;
  vMovementValue            DOC_POSITION_DETAIL.PDE_MOVEMENT_VALUE%type;
begin
  idPositionDetailFather     := :new.DOC_DOC_POSITION_DETAIL_ID;
  idPositionDetailOrigin     := :new.DOC2_DOC_POSITION_DETAIL_ID;

  -- Garantit une valeur de flux correct.
  -- Evite l'exception ORA-02291:_integrity constraint (DOC_POSITION_DETAIL_S_FLOW) violated - parent key not found
  if     :new.DOC_GAUGE_FLOW_ID is not null
     and (:new.DOC_GAUGE_FLOW_ID = 0) then
    idFlow  := null;
  else
    idFlow  := :new.DOC_GAUGE_FLOW_ID;
  end if;

  idDischargeFlow            := :new.DOC_GAUGE_RECEIPT_ID;
  numBalanceParent           := :new.PDE_BALANCE_PARENT;
  numBalanceQuantityParent   := nvl(:new.PDE_BALANCE_QUANTITY_PARENT, 0);
  numBalanceQuantityParent2  := numBalanceQuantityParent;
  vMovementValue             := :new.PDE_MOVEMENT_VALUE;

  -- Recherche si des détails avec un lien avec un père existent. C'est uniquement le détail qui possède la
  -- quantité soldée sur parent la plus grande en valeur absolue et ensuite celui qui possède le
  -- flag solder parent et ensuite celui qui est lié à un détail père qui possède la quantité solde la plus élevée qui est
  -- utilisé comme référence. Ce sont les informations de ce détail de position père qui sont repris sur le nouveau détail
  -- de position. Et c'est toujours ce détail de position qui reçoit l'éventuelle quantité soldée sur parent de l'ensemble des détails de
  -- position d'un même père.
  open crLinkedPositionDetail(:new.DOC_POSITION_ID);

  fetch crLinkedPositionDetail
   into tplLinkedPositionDetail;

  if     crLinkedPositionDetail%found
     and idPositionDetailFather is null
     and nvl(:new.PDE_FINAL_QUANTITY, 0) <> 0 then
    ----
    -- Effectue la mise à jour du lien père/fils sur le détail en cours de
    -- création uniquement si la quantité soldée sur parent <> 0 ou que
    -- la quantité solde du parent <> 0.
    --
    -- Calcul de la quantité solde à recharger sur parent. Tient compte des facteurs de conversion si un
    -- changement de bien ou de partenaire est effectif. En effet, dans ce cas, il est possible que l'unité de gestion
    -- (et donc le facteur de conversion) soit différent entre le document père et le document fils. Dans ce cas, il
    -- faut appliquer les calculs suivants :
    --
    --  Voir les règles définies dans le trigger DOC_V_PDE_IOD
    --
    if (   tplLinkedPositionDetail.GCO_GOOD_ID <> tplLinkedPositionDetail.FATHER_GOOD_ID
        or tplLinkedPositionDetail.PAC_THIRD_ID <> tplLinkedPositionDetail.FATHER_THIRD_ID
       ) then
      if tplLinkedPositionDetail.POS_CONVERT_FACTOR2 <> tplLinkedPositionDetail.POS_CONVERT_FACTOR then
        vQuantity  := :new.PDE_FINAL_QUANTITY * tplLinkedPositionDetail.POS_CONVERT_FACTOR2 / tplLinkedPositionDetail.FATHER_CONVERT_FACTOR;
      elsif tplLinkedPositionDetail.FATHER_CONVERT_FACTOR <> tplLinkedPositionDetail.POS_CONVERT_FACTOR then
        vQuantity  := :new.PDE_FINAL_QUANTITY_SU / tplLinkedPositionDetail.FATHER_CONVERT_FACTOR;
      else
        vQuantity  := :new.PDE_FINAL_QUANTITY;
      end if;
    else
      vQuantity  := :new.PDE_FINAL_QUANTITY;
    end if;

    if (nvl(tplLinkedPositionDetail.PDE_BALANCE_QUANTITY_PARENT, 0) <> 0) then
      ----
      -- Pour le détail à créer on initialise les différentes informations liées
      -- à la décharge.
      --
      idPositionDetailFather     := tplLinkedPositionDetail.DOC_DOC_POSITION_DETAIL_ID;
      idPositionDetailOrigin     := tplLinkedPositionDetail.DOC2_DOC_POSITION_DETAIL_ID;
      idFlow                     := tplLinkedPositionDetail.DOC_GAUGE_FLOW_ID;
      idDischargeFlow            := tplLinkedPositionDetail.DOC_GAUGE_RECEIPT_ID;
      numBalanceParent           := tplLinkedPositionDetail.PDE_BALANCE_PARENT;
      ----
      -- Recherche la nouvelle quantité soldée sur parent du détail trouvé selon
      -- la formule suivante :
      --
      -- Quantité soldée sur parent = Quantité soldée sur parent - Quantité du détail courant exprimée en unité de gestion du père.
      --
      numBalanceQuantityParent2  := tplLinkedPositionDetail.PDE_BALANCE_QUANTITY_PARENT - vQuantity;

      -- Mise a jour du détail trouvé avec la nouvelle quantité soldée sur parent.
      update DOC_POSITION_DETAIL
         set PDE_BALANCE_QUANTITY_PARENT = numBalanceQuantityParent2
       where DOC_POSITION_DETAIL_ID = tplLinkedPositionDetail.DOC_POSITION_DETAIL_ID;
    --
    elsif(tplLinkedPositionDetail.PDE_BALANCE_QUANTITY <> 0) then   -- Quantité solde du détail père
      --
      if (tplLinkedPositionDetail.PDE_FINAL_QUANTITY > 0) then   -- Quantité positive
        if (tplLinkedPositionDetail.PDE_BALANCE_QUANTITY >= vQuantity) then
          numBalanceQuantityParent  := 0;
        else   -- Dépassement de quantité
          ----
          -- Recherche la nouvelle quantité soldée sur parent du détail à créer selon
          -- la formule suivante :
          --
          -- Quantité soldée sur parent = Quantité solde du père - Quantité finale du détail courant exprimée en unité de gestion du père.
          --
          numBalanceQuantityParent  := tplLinkedPositionDetail.PDE_BALANCE_QUANTITY - vQuantity;
        end if;
      else   -- Quantité négative (ne peut pas être à 0 car, dans ce cas, la
             -- quantité solde du parent est différent de 0).
        if (tplLinkedPositionDetail.PDE_BALANCE_QUANTITY <= vQuantity) then
          numBalanceQuantityParent  := 0;
        else   -- Dépassement de quantité
          ----
          -- Recherche la nouvelle quantité soldée sur parent du détail à créer selon
          -- la formule suivante :
          --
          -- Quantité soldée sur parent = Quantité solde du père - Quantité finale du détail courant exprimée en unité de gestion du père.
          --
          numBalanceQuantityParent  := tplLinkedPositionDetail.PDE_BALANCE_QUANTITY - vQuantity;
        end if;
      end if;

      ----
      -- Pour le détail à créer on initialise les différentes informations liées
      -- à la décharge.
      --
      idPositionDetailFather  := tplLinkedPositionDetail.DOC_DOC_POSITION_DETAIL_ID;
      idPositionDetailOrigin  := tplLinkedPositionDetail.DOC2_DOC_POSITION_DETAIL_ID;
      idFlow                  := tplLinkedPositionDetail.DOC_GAUGE_FLOW_ID;
      idDischargeFlow         := tplLinkedPositionDetail.DOC_GAUGE_RECEIPT_ID;
      numBalanceParent        := tplLinkedPositionDetail.PDE_BALANCE_PARENT;

      if :new.DOC_DOC_POSITION_DETAIL_ID is null then
        DOC_POSITION_DETAIL_FUNCTIONS.MajBalanceQtyDetailParent(idPositionDetailFather, vQuantity, 0, numBalanceParent, numBalanceQuantityParent2);
        numBalanceQuantityParent  := numBalanceQuantityParent2;
      end if;
    end if;
  end if;

  -- Utilisation de variables pour les délais, car interdit de modifier des :new dans ce trigger
  datBASIS_DELAY             := :new.PDE_BASIS_DELAY;
  datINTER_DELAY             := :new.PDE_INTERMEDIATE_DELAY;
  datFINAL_DELAY             := :new.PDE_FINAL_DELAY;

  -- Gestion des délais
  if    (datBASIS_DELAY is null)
     or (datINTER_DELAY is null)
     or (datFINAL_DELAY is null) then
    declare
      cursor crDelayInfo
      is
        select nvl(GAP.GAP_DELAY, 0) GAP_DELAY
             , to_number(GAP.C_GAUGE_SHOW_DELAY) C_GAUGE_SHOW_DELAY
             , to_number(GAP.GAP_POS_DELAY) GAP_POS_DELAY
             , to_number(GAP.GAP_DELAY_COPY_PREV_POS) GAP_DELAY_COPY_PREV_POS
             , DMT.PAC_THIRD_CDA_ID
             , POS.GCO_GOOD_ID
             , POS.STM_STOCK_ID
             , POS.STM_STM_STOCK_ID
             , to_number(GAU.C_ADMIN_DOMAIN) C_ADMIN_DOMAIN
             , to_number(C_GAUGE_TYPE) C_GAUGE_TYPE
             , nvl(GAP_TRANSFERT_PROPRIETOR, 0) GAP_TRANSFERT_PROPRIETOR
          from DOC_GAUGE_POSITION GAP
             , DOC_POSITION POS
             , DOC_DOCUMENT DMT
             , DOC_GAUGE GAU
         where POS.DOC_POSITION_ID = :new.DOC_POSITION_ID
           and POS.DOC_DOCUMENT_ID = DMT.DOC_DOCUMENT_ID
           and DMT.DOC_GAUGE_ID = GAU.DOC_GAUGE_ID
           and GAP.DOC_GAUGE_POSITION_ID = POS.DOC_GAUGE_POSITION_ID;

      tplDelayInfo  crDelayInfo%rowtype;
      aBasisDelayMW varchar2(30)          default null;
      aInterDelayMW varchar2(30)          default null;
      aFinalDelayMW varchar2(30)          default null;
      intForward    integer;
      updatedDelay  varchar2(10);
    begin
      open crDelayInfo;

      fetch crDelayInfo
       into tplDelayInfo;

      close crDelayInfo;

      -- Vérifier si le gabarit gère les délais
      if tplDelayInfo.GAP_DELAY = 1 then
        -- Tous les délais sont vides
        if     (datBASIS_DELAY is null)
           and (datINTER_DELAY is null)
           and (datFINAL_DELAY is null) then
          -- Initialisation des 3 délais
          DOC_POSITION_DETAIL_FUNCTIONS.InitializePDEDelay(tplDelayInfo.C_GAUGE_SHOW_DELAY
                                                         , tplDelayInfo.GAP_POS_DELAY
                                                         , tplDelayInfo.GAP_DELAY_COPY_PREV_POS
                                                         , tplDelayInfo.PAC_THIRD_CDA_ID
                                                         , tplDelayInfo.GCO_GOOD_ID
                                                         , tplDelayInfo.STM_STOCK_ID
                                                         , tplDelayInfo.STM_STM_STOCK_ID
                                                         , tplDelayInfo.C_ADMIN_DOMAIN
                                                         , tplDelayInfo.C_GAUGE_TYPE
                                                         , tplDelayInfo.GAP_TRANSFERT_PROPRIETOR
                                                         , datBASIS_DELAY
                                                         , datINTER_DELAY
                                                         , datFINAL_DELAY
                                                         , null
                                                         , null
                                                         , :new.FAL_SCHEDULE_STEP_ID
                                                          );
        else
          -- il y a au moins un délai initialisé
          if datBASIS_DELAY is not null then
            updatedDelay  := 'BASIS';
            intForward    := 1;
          elsif datINTER_DELAY is not null then
            updatedDelay  := 'INTER';
            intForward    := 0;
          elsif datFINAL_DELAY is not null then
            updatedDelay  := 'FINAL';
            intForward    := 0;
          end if;

          -- Recherche des délais manquants, selon délai passé
          DOC_POSITION_DETAIL_FUNCTIONS.GetPDEDelay(tplDelayInfo.C_GAUGE_SHOW_DELAY
                                                  , tplDelayInfo.GAP_POS_DELAY
                                                  , updatedDelay
                                                  , intForward
                                                  , tplDelayInfo.PAC_THIRD_CDA_ID
                                                  , tplDelayInfo.GCO_GOOD_ID
                                                  , tplDelayInfo.STM_STOCK_ID
                                                  , tplDelayInfo.STM_STM_STOCK_ID
                                                  , tplDelayInfo.C_ADMIN_DOMAIN
                                                  , tplDelayInfo.C_GAUGE_TYPE
                                                  , tplDelayInfo.GAP_TRANSFERT_PROPRIETOR
                                                  , aBasisDelayMW
                                                  , aInterDelayMW
                                                  , aFinalDelayMW
                                                  , datBASIS_DELAY
                                                  , datINTER_DELAY
                                                  , datFINAL_DELAY
                                                  , null
                                                  , null
                                                  , :new.FAL_SCHEDULE_STEP_ID
                                                   );
        end if;
      end if;
    end;
  end if;

  -- Si en vente et que l'installation est renseigée
  --  La valeur mouvement doit être initialisée selon le prix de revient de l'installation
  if :new.DOC_RECORD_ID is not null then
    declare
      cursor crDetail
      is
        (select GAU.C_ADMIN_DOMAIN
              , nvl(GAP.GAP_STOCK_MVT, 0) GAP_STOCK_MVT
              , POS.C_GAUGE_TYPE_POS
              , POS.POS_UNIT_COST_PRICE
              , POS.STM_MOVEMENT_KIND_ID
           from DOC_POSITION POS
              , DOC_DOCUMENT DMT
              , DOC_GAUGE GAU
              , DOC_GAUGE_POSITION GAP
          where POS.DOC_POSITION_ID = :new.DOC_POSITION_ID
            and POS.DOC_DOCUMENT_ID = DMT.DOC_DOCUMENT_ID
            and DMT.DOC_GAUGE_ID = GAU.DOC_GAUGE_ID
            and POS.DOC_GAUGE_POSITION_ID = GAP.DOC_GAUGE_POSITION_ID);

      tplDetail crDetail%rowtype;
    begin
      open crDetail;

      fetch crDetail
       into tplDetail;

      close crDetail;

      if     (tplDetail.STM_MOVEMENT_KIND_ID is not null)
         and (tplDetail.C_ADMIN_DOMAIN = '2')
         and (tplDetail.GAP_STOCK_MVT = 1)
         and (to_number(tplDetail.C_GAUGE_TYPE_POS) in(1, 2, 3, 7, 8, 71, 81, 91, 101) ) then
        select nvl(RCO_COST_PRICE, tplDetail.POS_UNIT_COST_PRICE) * :new.PDE_FINAL_QUANTITY_SU
          into vMovementValue
          from DOC_RECORD
         where DOC_RECORD_ID = :new.DOC_RECORD_ID;
      end if;
    end;
  end if;

  /**
  * DSA - Evaluation fournisseurs
  * Création des notes selon les axes qualités actifs applicables
  */
  if PCS.PC_CONFIG.GETCONFIG('SQM_QUALITY_MGM') = '1' then
    -- Initialisation du record
    SQM_INIT_METHOD.DetailInfo.DOC_POSITION_DETAIL_ID        := :new.DOC_POSITION_DETAIL_ID;
    SQM_INIT_METHOD.DetailInfo.DOC_GAUGE_FLOW_ID             := idFlow;
    SQM_INIT_METHOD.DetailInfo.DOC_POSITION_ID               := :new.DOC_POSITION_ID;
    SQM_INIT_METHOD.DetailInfo.DOC_DOC_POSITION_DETAIL_ID    := :new.DOC_DOC_POSITION_DETAIL_ID;
    SQM_INIT_METHOD.DetailInfo.DOC2_DOC_POSITION_DETAIL_ID   := :new.DOC2_DOC_POSITION_DETAIL_ID;
    SQM_INIT_METHOD.DetailInfo.PDE_BASIS_DELAY               := datBASIS_DELAY;
    SQM_INIT_METHOD.DetailInfo.PDE_BASIS_DELAY_W             := :new.PDE_BASIS_DELAY_W;
    SQM_INIT_METHOD.DetailInfo.PDE_BASIS_DELAY_M             := :new.PDE_BASIS_DELAY_M;
    SQM_INIT_METHOD.DetailInfo.PDE_INTERMEDIATE_DELAY        := datINTER_DELAY;
    SQM_INIT_METHOD.DetailInfo.PDE_INTERMEDIATE_DELAY_W      := :new.PDE_INTERMEDIATE_DELAY_W;
    SQM_INIT_METHOD.DetailInfo.PDE_INTERMEDIATE_DELAY_M      := :new.PDE_INTERMEDIATE_DELAY_M;
    SQM_INIT_METHOD.DetailInfo.PDE_FINAL_DELAY               := datFINAL_DELAY;
    SQM_INIT_METHOD.DetailInfo.PDE_FINAL_DELAY_W             := :new.PDE_FINAL_DELAY_W;
    SQM_INIT_METHOD.DetailInfo.PDE_FINAL_DELAY_M             := :new.PDE_FINAL_DELAY_M;
    SQM_INIT_METHOD.DetailInfo.PDE_BASIS_QUANTITY            := :new.PDE_BASIS_QUANTITY;
    SQM_INIT_METHOD.DetailInfo.PDE_ATTRIB_QUANTITY           := :new.PDE_ATTRIB_QUANTITY;
    SQM_INIT_METHOD.DetailInfo.PDE_INTERMEDIATE_QUANTITY     := :new.PDE_INTERMEDIATE_QUANTITY;
    SQM_INIT_METHOD.DetailInfo.PDE_FINAL_QUANTITY            := :new.PDE_FINAL_QUANTITY;
    SQM_INIT_METHOD.DetailInfo.PDE_BALANCE_QUANTITY          := :new.PDE_BALANCE_QUANTITY;
    SQM_INIT_METHOD.DetailInfo.PDE_MOVEMENT_QUANTITY         := :new.PDE_MOVEMENT_QUANTITY;
    SQM_INIT_METHOD.DetailInfo.PDE_MOVEMENT_VALUE            := vMovementValue;
    SQM_INIT_METHOD.DetailInfo.PDE_CHARACTERIZATION_VALUE_1  := :new.PDE_CHARACTERIZATION_VALUE_1;
    SQM_INIT_METHOD.DetailInfo.PDE_CHARACTERIZATION_VALUE_2  := :new.PDE_CHARACTERIZATION_VALUE_2;
    SQM_INIT_METHOD.DetailInfo.PDE_CHARACTERIZATION_VALUE_3  := :new.PDE_CHARACTERIZATION_VALUE_3;
    SQM_INIT_METHOD.DetailInfo.PDE_CHARACTERIZATION_VALUE_4  := :new.PDE_CHARACTERIZATION_VALUE_4;
    SQM_INIT_METHOD.DetailInfo.PDE_CHARACTERIZATION_VALUE_5  := :new.PDE_CHARACTERIZATION_VALUE_5;
    SQM_INIT_METHOD.DetailInfo.GCO_CHARACTERIZATION_ID       := :new.GCO_CHARACTERIZATION_ID;
    SQM_INIT_METHOD.DetailInfo.GCO_GCO_CHARACTERIZATION_ID   := :new.GCO_GCO_CHARACTERIZATION_ID;
    SQM_INIT_METHOD.DetailInfo.GCO2_GCO_CHARACTERIZATION_ID  := :new.GCO2_GCO_CHARACTERIZATION_ID;
    SQM_INIT_METHOD.DetailInfo.GCO3_GCO_CHARACTERIZATION_ID  := :new.GCO3_GCO_CHARACTERIZATION_ID;
    SQM_INIT_METHOD.DetailInfo.GCO4_GCO_CHARACTERIZATION_ID  := :new.GCO4_GCO_CHARACTERIZATION_ID;
    SQM_INIT_METHOD.DetailInfo.STM_STOCK_MOVEMENT_ID         := :new.STM_STOCK_MOVEMENT_ID;
    SQM_INIT_METHOD.DetailInfo.STM_LOCATION_ID               := :new.STM_LOCATION_ID;
    SQM_INIT_METHOD.DetailInfo.STM_STM_LOCATION_ID           := :new.STM_STM_LOCATION_ID;
    SQM_INIT_METHOD.DetailInfo.A_DATECRE                     := :new.A_DATECRE;
    SQM_INIT_METHOD.DetailInfo.A_DATEMOD                     := :new.A_DATEMOD;
    SQM_INIT_METHOD.DetailInfo.A_IDCRE                       := :new.A_IDCRE;
    SQM_INIT_METHOD.DetailInfo.A_IDMOD                       := :new.A_IDMOD;
    SQM_INIT_METHOD.DetailInfo.A_RECLEVEL                    := :new.A_RECLEVEL;
    SQM_INIT_METHOD.DetailInfo.A_RECSTATUS                   := :new.A_RECSTATUS;
    SQM_INIT_METHOD.DetailInfo.A_CONFIRM                     := :new.A_CONFIRM;
    SQM_INIT_METHOD.DetailInfo.PDE_BALANCE_QUANTITY_PARENT   := :new.PDE_BALANCE_QUANTITY_PARENT;
    SQM_INIT_METHOD.DetailInfo.DIC_PDE_FREE_TABLE_1_ID       := :new.DIC_PDE_FREE_TABLE_1_ID;
    SQM_INIT_METHOD.DetailInfo.DIC_PDE_FREE_TABLE_2_ID       := :new.DIC_PDE_FREE_TABLE_2_ID;
    SQM_INIT_METHOD.DetailInfo.DIC_PDE_FREE_TABLE_3_ID       := :new.DIC_PDE_FREE_TABLE_3_ID;
    SQM_INIT_METHOD.DetailInfo.PDE_DECIMAL_1                 := :new.PDE_DECIMAL_1;
    SQM_INIT_METHOD.DetailInfo.PDE_DECIMAL_2                 := :new.PDE_DECIMAL_2;
    SQM_INIT_METHOD.DetailInfo.PDE_DECIMAL_3                 := :new.PDE_DECIMAL_3;
    SQM_INIT_METHOD.DetailInfo.PDE_TEXT_1                    := :new.PDE_TEXT_1;
    SQM_INIT_METHOD.DetailInfo.PDE_TEXT_2                    := :new.PDE_TEXT_2;
    SQM_INIT_METHOD.DetailInfo.PDE_TEXT_3                    := :new.PDE_TEXT_3;
    SQM_INIT_METHOD.DetailInfo.PDE_DATE_1                    := :new.PDE_DATE_1;
    SQM_INIT_METHOD.DetailInfo.PDE_DATE_2                    := :new.PDE_DATE_2;
    SQM_INIT_METHOD.DetailInfo.PDE_DATE_3                    := :new.PDE_DATE_3;
    SQM_INIT_METHOD.DetailInfo.FAL_SCHEDULE_STEP_ID          := :new.FAL_SCHEDULE_STEP_ID;
    SQM_INIT_METHOD.DetailInfo.DOC_DOCUMENT_ID               := :new.DOC_DOCUMENT_ID;
    SQM_INIT_METHOD.DetailInfo.PAC_THIRD_ID                  := :new.PAC_THIRD_ID;
    SQM_INIT_METHOD.DetailInfo.PAC_THIRD_ACI_ID              := :new.PAC_THIRD_ACI_ID;
    SQM_INIT_METHOD.DetailInfo.PAC_THIRD_DELIVERY_ID         := :new.PAC_THIRD_DELIVERY_ID;
    SQM_INIT_METHOD.DetailInfo.PAC_THIRD_TARIFF_ID           := :new.PAC_THIRD_TARIFF_ID;
    SQM_INIT_METHOD.DetailInfo.DOC_GAUGE_ID                  := :new.DOC_GAUGE_ID;
    SQM_INIT_METHOD.DetailInfo.DOC_GAUGE_RECEIPT_ID          := :new.DOC_GAUGE_RECEIPT_ID;
    SQM_INIT_METHOD.DetailInfo.DOC_GAUGE_COPY_ID             := :new.DOC_GAUGE_COPY_ID;
    SQM_INIT_METHOD.DetailInfo.DIC_DELAY_UPDATE_TYPE_ID      := :new.DIC_DELAY_UPDATE_TYPE_ID;
    SQM_INIT_METHOD.DetailInfo.PDE_DELAY_UPDATE_TEXT         := :new.PDE_DELAY_UPDATE_TEXT;
    SQM_INIT_METHOD.DetailInfo.PDE_BASIS_QUANTITY_SU         := :new.PDE_BASIS_QUANTITY_SU;
    SQM_INIT_METHOD.DetailInfo.PDE_INTERMEDIATE_QUANTITY_SU  := :new.PDE_INTERMEDIATE_QUANTITY_SU;
    SQM_INIT_METHOD.DetailInfo.PDE_FINAL_QUANTITY_SU         := :new.PDE_FINAL_QUANTITY_SU;
    SQM_INIT_METHOD.DetailInfo.PDE_GENERATE_MOVEMENT         := :new.PDE_GENERATE_MOVEMENT;
    SQM_INIT_METHOD.DetailInfo.GCO_GOOD_ID                   := :new.GCO_GOOD_ID;
    SQM_INIT_METHOD.DetailInfo.PDE_PIECE                     := :new.PDE_PIECE;
    SQM_INIT_METHOD.DetailInfo.PDE_SET                       := :new.PDE_SET;
    SQM_INIT_METHOD.DetailInfo.PDE_VERSION                   := :new.PDE_VERSION;
    SQM_INIT_METHOD.DetailInfo.PDE_CHRONOLOGICAL             := :new.PDE_CHRONOLOGICAL;
    SQM_INIT_METHOD.DetailInfo.PDE_STD_CHAR_1                := :new.PDE_STD_CHAR_1;
    SQM_INIT_METHOD.DetailInfo.PDE_STD_CHAR_2                := :new.PDE_STD_CHAR_2;
    SQM_INIT_METHOD.DetailInfo.PDE_STD_CHAR_3                := :new.PDE_STD_CHAR_3;
    SQM_INIT_METHOD.DetailInfo.PDE_STD_CHAR_4                := :new.PDE_STD_CHAR_4;
    SQM_INIT_METHOD.DetailInfo.PDE_STD_CHAR_5                := :new.PDE_STD_CHAR_5;
    SQM_INIT_METHOD.DetailInfo.PDE_BALANCE_PARENT            := :new.PDE_BALANCE_PARENT;
    SQM_INIT_METHOD.DetailInfo.FAL_NETWORK_LINK_ID           := :new.FAL_NETWORK_LINK_ID;
    SQM_INIT_METHOD.DetailInfo.PDE_DATE_1                    := :new.PDE_DATE_1;
    SQM_INIT_METHOD.DetailInfo.PDE_DATE_2                    := :new.PDE_DATE_2;
    SQM_INIT_METHOD.DetailInfo.PDE_DATE_3                    := :new.PDE_DATE_3;
    SQM_INIT_METHOD.DetailInfo.PDE_SQM_ACCEPTED_DELAY        := :new.PDE_SQM_ACCEPTED_DELAY;
    SQM_INIT_METHOD.DetailInfo.PDE_TRANSFERT_PROPRIETOR      := :new.PDE_TRANSFERT_PROPRIETOR;
    SQM_INIT_METHOD.DetailInfo.PDE_ST_PT_REJECT              := :new.PDE_ST_PT_REJECT;
    SQM_INIT_METHOD.DetailInfo.PDE_ST_CPT_REJECT             := :new.PDE_ST_CPT_REJECT;
    SQM_INIT_METHOD.DetailInfo.GCO_QUALITY_STATUS_ID         := :new.GCO_QUALITY_STATUS_ID;

    -- Recherche date du document selon config et autres données de la position
    select decode(upper(PCS.PC_CONFIG.GETCONFIG('SQM_REFERENCE_DATE') ), 'DOC', DOC.DMT_DATE_DOCUMENT, 'VAL', DOC.DMT_DATE_VALUE, DOC.DMT_DATE_DOCUMENT)
         , POS.PAC_THIRD_ID
         , POS.GCO_GOOD_ID
         , POS.C_DOC_POS_STATUS
      into vDateDocument
         , vThird
         , vGood
         , vPosStatus
      from DOC_POSITION POS
         , DOC_DOCUMENT DOC
     where POS.DOC_POSITION_ID = :new.DOC_POSITION_ID
       and POS.DOC_DOCUMENT_ID = DOC.DOC_DOCUMENT_ID;

    -- Curseur sur les axes qualité applicables
    for cr_axis in (select SQM_FUNCTIONS.GetFirstFitScale(SAX.SQM_AXIS_ID, vDateDocument, vGood) SCALE_ID
                         , SAX.SQM_AXIS_ID SQM_AXIS_ID
                      from DOC_POSITION POS
                         , SQM_AXIS SAX
                         , DOC_GAUGE_RECEIPT_S_AXIS GRA
                         , DOC_GAUGE_POSITION GAP
                     where POS.DOC_POSITION_ID = :new.DOC_POSITION_ID
                       and SQM_FUNCTIONS.IsVerified(SAX.PC_SQLST_ID, vGood) = 1   -- Condition d'application de l'axe vérifiée
                       and GRA.SQM_AXIS_ID = SAX.SQM_AXIS_ID   -- Axe défini au niveau du flux
                       and GRA.DOC_GAUGE_RECEIPT_ID = :new.DOC_GAUGE_RECEIPT_ID
                       and POS.DOC_GAUGE_POSITION_ID = GAP.DOC_GAUGE_POSITION_ID
                       and GAP.C_SQM_EVAL_TYPE = '1'   -- Gabarit position gère la qualité
                       and SAX.C_AXIS_STATUS = 'ACT'   -- Axe actif
                                                    ) loop
      if cr_axis.SCALE_ID is not null then
        vExpValue   := null;
        vEffValue   := null;
        vAxisValue  := null;
        SQM_INIT_METHOD.CalcAxisValue(cr_axis.SQM_AXIS_ID, vExpValue, vEffValue, vAxisValue);

        insert into SQM_PENALTY
                    (SQM_PENALTY_ID
                   , SQM_SCALE_ID
                   , DOC_POSITION_DETAIL_ID
                   , DOC_POSITION_ID
                   , PAC_THIRD_ID
                   , GCO_GOOD_ID
                   , SQM_AXIS_ID
                   , C_PENALTY_STATUS
                   , SPE_DATE_REFERENCE
                   , SPE_CALC_PENALTY
                   , SPE_INIT_VALUE
                   , SPE_EXPECTED_VALUE
                   , SPE_EFFECTIVE_VALUE
                   , A_DATECRE
                   , A_IDCRE
                    )
             values (init_id_seq.nextval
                   , cr_axis.SCALE_ID
                   , :new.DOC_POSITION_DETAIL_ID
                   , :new.DOC_POSITION_ID
                   , vThird
                   , vGood
                   , cr_axis.SQM_AXIS_ID
                   , decode(vPosStatus, '01', 'PROV', 'CONF')
                   , vDateDocument
                   , SQM_FUNCTIONS.CalcPenalty(cr_axis.SCALE_ID, vAxisValue)
                   , vAxisValue
                   , vExpValue
                   , vEffValue
                   , sysdate
                   , PCS.PC_I_LIB_SESSION.GetUserIni
                    );
      end if;
    end loop;
  end if;

  /**
  * NGV - Journalisation des positions
  * Création de l'écriture au statut '04' avec la qté du détail fils sur la position père
  */
  if :new.DOC_DOC_POSITION_DETAIL_ID is not null then
    -- Rechercher l'id de la position source
    select PDE_SRC.DOC_POSITION_ID
         , POS.C_DOC_POS_STATUS
      into vSrcPosID
         , vPosStatus
      from DOC_POSITION_DETAIL PDE_SRC
         , DOC_POSITION POS
     where PDE_SRC.DOC_POSITION_DETAIL_ID = :new.DOC_DOC_POSITION_DETAIL_ID
       and POS.DOC_POSITION_ID = :new.DOC_POSITION_ID;

    DOC_JOURNAL_FUNCTIONS.CURRENT_TRANSACTION  := DBMS_TRANSACTION.local_transaction_id;
    DOC_JOURNAL_FUNCTIONS.DISCH_SRC_POS_ID     := vSrcPosID;
    DOC_JOURNAL_FUNCTIONS.DISCH_TGT_POS_ID     := :new.DOC_POSITION_ID;
    DOC_JOURNAL_FUNCTIONS.DISCH_TGT_DOC_ID     := :new.DOC_DOCUMENT_ID;
    DOC_JOURNAL_FUNCTIONS.DISCH_CODE           := 'INSERT';

    -- Vérifier si l'on doit faire la journalisation de la position père
    if DOC_JOURNAL_FUNCTIONS.MustPosJournalize(vSrcPosID) = 1 then
      -- Qté de journal -> Qté du détail - qté soldée sur parent
      vQuantity                                  :=(nvl(vQuantity, :new.PDE_FINAL_QUANTITY) + :new.PDE_BALANCE_QUANTITY_PARENT);

      -- Rechercher les infos de la position père
      select *
        into tplPos
        from DOC_POSITION
       where DOC_POSITION_ID = vSrcPosID;

      -- si la position a le statut à confirmer, il faut journaliser dans la table provisoire
      if vPosStatus = '01' then
        vDetailProv  := 1;
      end if;

      DOC_JOURNAL_FUNCTIONS.SRC_DOC_POSITION_ID  := null;
      DOC_JOURNAL_FUNCTIONS.TGT_DOC_POSITION_ID  := :new.DOC_POSITION_ID;
      --
      DOC_JOURNAL_FUNCTIONS.CURRENT_TRANSACTION  := DBMS_TRANSACTION.local_transaction_id;
      -- Ecriture
      DOC_JOURNAL_FUNCTIONS.CreateDetail(aCode            => 'DISCHARGED'
                                       , aOldPos          => tplPos
                                       , aNewPos          => tplPos
                                       , aDetailProv      => vDetailProv
                                       , aForceStatus     => '04'
                                       , aForceQuantity   => 1
                                       , aQuantity        => vQuantity
                                        );
      DOC_JOURNAL_FUNCTIONS.SRC_DOC_POSITION_ID  := null;
      DOC_JOURNAL_FUNCTIONS.TGT_DOC_POSITION_ID  := null;
    end if;
  end if;

  insert into DOC_POSITION_DETAIL
              (DOC_POSITION_DETAIL_ID
             , DOC_GAUGE_FLOW_ID
             , DOC_POSITION_ID
             , DOC_DOC_POSITION_DETAIL_ID
             , DOC2_DOC_POSITION_DETAIL_ID
             , PDE_BASIS_DELAY
             , PDE_BASIS_DELAY_W
             , PDE_BASIS_DELAY_M
             , PDE_INTERMEDIATE_DELAY
             , PDE_INTERMEDIATE_DELAY_W
             , PDE_INTERMEDIATE_DELAY_M
             , PDE_FINAL_DELAY
             , PDE_FINAL_DELAY_W
             , PDE_FINAL_DELAY_M
             , PDE_SQM_ACCEPTED_DELAY
             , PDE_BASIS_QUANTITY
             , PDE_ATTRIB_QUANTITY
             , PDE_INTERMEDIATE_QUANTITY
             , PDE_FINAL_QUANTITY
             , PDE_BALANCE_QUANTITY
             , PDE_MOVEMENT_QUANTITY
             , PDE_MOVEMENT_VALUE
             , PDE_MOVEMENT_DATE
             , PDE_CHARACTERIZATION_VALUE_1
             , PDE_CHARACTERIZATION_VALUE_2
             , PDE_CHARACTERIZATION_VALUE_3
             , PDE_CHARACTERIZATION_VALUE_4
             , PDE_CHARACTERIZATION_VALUE_5
             , GCO_CHARACTERIZATION_ID
             , GCO_GCO_CHARACTERIZATION_ID
             , GCO2_GCO_CHARACTERIZATION_ID
             , GCO3_GCO_CHARACTERIZATION_ID
             , GCO4_GCO_CHARACTERIZATION_ID
             , STM_STOCK_MOVEMENT_ID
             , STM_LOCATION_ID
             , STM_STM_LOCATION_ID
             , A_DATECRE
             , A_DATEMOD
             , A_IDCRE
             , A_IDMOD
             , A_RECLEVEL
             , A_RECSTATUS
             , A_CONFIRM
             , PDE_BALANCE_QUANTITY_PARENT
             , DIC_PDE_FREE_TABLE_1_ID
             , DIC_PDE_FREE_TABLE_2_ID
             , DIC_PDE_FREE_TABLE_3_ID
             , PDE_DECIMAL_1
             , PDE_DECIMAL_2
             , PDE_DECIMAL_3
             , PDE_TEXT_1
             , PDE_TEXT_2
             , PDE_TEXT_3
             , PDE_DATE_1
             , PDE_DATE_2
             , PDE_DATE_3
             , FAL_SCHEDULE_STEP_ID
             , DOC_DOCUMENT_ID
             , PAC_THIRD_ID
             , PAC_THIRD_ACI_ID
             , PAC_THIRD_DELIVERY_ID
             , PAC_THIRD_TARIFF_ID
             , DOC_GAUGE_ID
             , DOC_GAUGE_RECEIPT_ID
             , DOC_GAUGE_COPY_ID
             , DIC_DELAY_UPDATE_TYPE_ID
             , PDE_DELAY_UPDATE_TEXT
             , PDE_BASIS_QUANTITY_SU
             , PDE_INTERMEDIATE_QUANTITY_SU
             , PDE_FINAL_QUANTITY_SU
             , PDE_GENERATE_MOVEMENT
             , GCO_GOOD_ID
             , PDE_PIECE
             , PDE_SET
             , PDE_VERSION
             , PDE_CHRONOLOGICAL
             , PDE_STD_CHAR_1
             , PDE_STD_CHAR_2
             , PDE_STD_CHAR_3
             , PDE_STD_CHAR_4
             , PDE_STD_CHAR_5
             , PDE_BALANCE_PARENT
             , FAL_NETWORK_LINK_ID
             , FAL_SUPPLY_REQUEST_ID
             , C_PDE_CREATE_MODE
             , DOC_RECORD_ID
             , ACS_FINANCIAL_ACCOUNT_BS_ID
             , ACS_DIVISION_ACCOUNT_BS_ID
             , ACS_CPN_ACCOUNT_BS_ID
             , ACS_PF_ACCOUNT_BS_ID
             , ACS_PJ_ACCOUNT_BS_ID
             , ACS_CDA_ACCOUNT_BS_ID
             , ACS_FINANCIAL_ACCOUNT_PL_ID
             , ACS_DIVISION_ACCOUNT_PL_ID
             , ACS_CPN_ACCOUNT_PL_ID
             , ACS_PF_ACCOUNT_PL_ID
             , ACS_PJ_ACCOUNT_PL_ID
             , ACS_CDA_ACCOUNT_PL_ID
             , HRM_PERSON_ID
             , FAM_FIXED_ASSETS_ID
             , C_FAM_TRANSACTION_TYP
             , DIC_IMP_FREE1_ID
             , DIC_IMP_FREE2_ID
             , DIC_IMP_FREE3_ID
             , DIC_IMP_FREE4_ID
             , DIC_IMP_FREE5_ID
             , DOC_RECORD_BS_ID
             , PDE_IMF_TEXT_1
             , PDE_IMF_TEXT_2
             , PDE_IMF_TEXT_3
             , PDE_IMF_TEXT_4
             , PDE_IMF_TEXT_5
             , PDE_IMF_NUMBER_1
             , PDE_IMF_NUMBER_2
             , PDE_IMF_NUMBER_3
             , PDE_IMF_NUMBER_4
             , PDE_IMF_NUMBER_5
             , PDE_IMF_DATE_1
             , PDE_IMF_DATE_2
             , PDE_IMF_DATE_3
             , PDE_IMF_DATE_4
             , PDE_IMF_DATE_5
             , CML_EVENTS_ID
             , C_GAUGE_TYPE_POS
             , DOC_DOCUMENT_SRC_ID
             , DOC_POSITION_SRC_ID
             , GCO_GCO_GOOD_ID
             , PAC_THIRD_CDA_ID
             , PAC_THIRD_VAT_ID
             , PDE_ADDENDUM_QTY_BALANCED
             , PDE_ADDENDUM_SRC_PDE_ID
             , PDE_TRANSFERT_PROPRIETOR
             , PDE_GAP_PURCHASE_PRICE
             , DOC_PDE_LITIG_ID
             , FAL_LOT_ID
             , PDE_ST_PT_REJECT
             , PDE_ST_CPT_REJECT
             , PDE_CURR_RISK_DISCHARGE_DONE
             , GCO_QUALITY_STATUS_ID
              )
       values (:new.DOC_POSITION_DETAIL_ID
             , idFlow
             , :new.DOC_POSITION_ID
             , idPositionDetailFather
             , idPositionDetailOrigin
             , datBASIS_DELAY
             , :new.PDE_BASIS_DELAY_W
             , :new.PDE_BASIS_DELAY_M
             , datINTER_DELAY
             , :new.PDE_INTERMEDIATE_DELAY_W
             , :new.PDE_INTERMEDIATE_DELAY_M
             , datFINAL_DELAY
             , :new.PDE_FINAL_DELAY_W
             , :new.PDE_FINAL_DELAY_M
             , :new.PDE_SQM_ACCEPTED_DELAY
             , nvl(:new.PDE_BASIS_QUANTITY, 0)
             , nvl(:new.PDE_ATTRIB_QUANTITY, 0)
             , nvl(:new.PDE_INTERMEDIATE_QUANTITY, 0)
             , nvl(:new.PDE_FINAL_QUANTITY, 0)
             , nvl(:new.PDE_BALANCE_QUANTITY, 0)
             , nvl(:new.PDE_MOVEMENT_QUANTITY, 0)
             , nvl(vMovementValue, 0)
             , :new.PDE_MOVEMENT_DATE
             , :new.PDE_CHARACTERIZATION_VALUE_1
             , :new.PDE_CHARACTERIZATION_VALUE_2
             , :new.PDE_CHARACTERIZATION_VALUE_3
             , :new.PDE_CHARACTERIZATION_VALUE_4
             , :new.PDE_CHARACTERIZATION_VALUE_5
             , :new.GCO_CHARACTERIZATION_ID
             , :new.GCO_GCO_CHARACTERIZATION_ID
             , :new.GCO2_GCO_CHARACTERIZATION_ID
             , :new.GCO3_GCO_CHARACTERIZATION_ID
             , :new.GCO4_GCO_CHARACTERIZATION_ID
             , :new.STM_STOCK_MOVEMENT_ID
             , :new.STM_LOCATION_ID
             , :new.STM_STM_LOCATION_ID
             , :new.A_DATECRE
             , :new.A_DATEMOD
             , :new.A_IDCRE
             , :new.A_IDMOD
             , :new.A_RECLEVEL
             , :new.A_RECSTATUS
             , :new.A_CONFIRM
             , numBalanceQuantityParent
             , :new.DIC_PDE_FREE_TABLE_1_ID
             , :new.DIC_PDE_FREE_TABLE_2_ID
             , :new.DIC_PDE_FREE_TABLE_3_ID
             , :new.PDE_DECIMAL_1
             , :new.PDE_DECIMAL_2
             , :new.PDE_DECIMAL_3
             , :new.PDE_TEXT_1
             , :new.PDE_TEXT_2
             , :new.PDE_TEXT_3
             , :new.PDE_DATE_1
             , :new.PDE_DATE_2
             , :new.PDE_DATE_3
             , :new.FAL_SCHEDULE_STEP_ID
             , :new.DOC_DOCUMENT_ID
             , :new.PAC_THIRD_ID
             , :new.PAC_THIRD_ACI_ID
             , :new.PAC_THIRD_DELIVERY_ID
             , :new.PAC_THIRD_TARIFF_ID
             , :new.DOC_GAUGE_ID
             , idDischargeFlow
             , :new.DOC_GAUGE_COPY_ID
             , :new.DIC_DELAY_UPDATE_TYPE_ID
             , :new.PDE_DELAY_UPDATE_TEXT
             , nvl(:new.PDE_BASIS_QUANTITY_SU, 0)
             , nvl(:new.PDE_INTERMEDIATE_QUANTITY_SU, 0)
             , nvl(:new.PDE_FINAL_QUANTITY_SU, 0)
             , nvl(:new.PDE_GENERATE_MOVEMENT, 0)
             , :new.GCO_GOOD_ID
             , :new.PDE_PIECE
             , :new.PDE_SET
             , :new.PDE_VERSION
             , :new.PDE_CHRONOLOGICAL
             , :new.PDE_STD_CHAR_1
             , :new.PDE_STD_CHAR_2
             , :new.PDE_STD_CHAR_3
             , :new.PDE_STD_CHAR_4
             , :new.PDE_STD_CHAR_5
             , nvl(:new.PDE_BALANCE_PARENT, 0)
             , :new.FAL_NETWORK_LINK_ID
             , :new.FAL_SUPPLY_REQUEST_ID
             , :new.C_PDE_CREATE_MODE
             , :new.DOC_RECORD_ID
             , :new.ACS_FINANCIAL_ACCOUNT_BS_ID
             , :new.ACS_DIVISION_ACCOUNT_BS_ID
             , :new.ACS_CPN_ACCOUNT_BS_ID
             , :new.ACS_PF_ACCOUNT_BS_ID
             , :new.ACS_PJ_ACCOUNT_BS_ID
             , :new.ACS_CDA_ACCOUNT_BS_ID
             , :new.ACS_FINANCIAL_ACCOUNT_PL_ID
             , :new.ACS_DIVISION_ACCOUNT_PL_ID
             , :new.ACS_CPN_ACCOUNT_PL_ID
             , :new.ACS_PF_ACCOUNT_PL_ID
             , :new.ACS_PJ_ACCOUNT_PL_ID
             , :new.ACS_CDA_ACCOUNT_PL_ID
             , :new.HRM_PERSON_ID
             , :new.FAM_FIXED_ASSETS_ID
             , :new.C_FAM_TRANSACTION_TYP
             , :new.DIC_IMP_FREE1_ID
             , :new.DIC_IMP_FREE2_ID
             , :new.DIC_IMP_FREE3_ID
             , :new.DIC_IMP_FREE4_ID
             , :new.DIC_IMP_FREE5_ID
             , :new.DOC_RECORD_BS_ID
             , :new.PDE_IMF_TEXT_1
             , :new.PDE_IMF_TEXT_2
             , :new.PDE_IMF_TEXT_3
             , :new.PDE_IMF_TEXT_4
             , :new.PDE_IMF_TEXT_5
             , :new.PDE_IMF_NUMBER_1
             , :new.PDE_IMF_NUMBER_2
             , :new.PDE_IMF_NUMBER_3
             , :new.PDE_IMF_NUMBER_4
             , :new.PDE_IMF_NUMBER_5
             , :new.PDE_IMF_DATE_1
             , :new.PDE_IMF_DATE_2
             , :new.PDE_IMF_DATE_3
             , :new.PDE_IMF_DATE_4
             , :new.PDE_IMF_DATE_5
             , :new.CML_EVENTS_ID
             , :new.C_GAUGE_TYPE_POS
             , :new.DOC_DOCUMENT_SRC_ID
             , :new.DOC_POSITION_SRC_ID
             , :new.GCO_GCO_GOOD_ID
             , :new.PAC_THIRD_CDA_ID
             , :new.PAC_THIRD_VAT_ID
             , :new.PDE_ADDENDUM_QTY_BALANCED
             , :new.PDE_ADDENDUM_SRC_PDE_ID
             , :new.PDE_TRANSFERT_PROPRIETOR
             , :new.PDE_GAP_PURCHASE_PRICE
             , :new.DOC_PDE_LITIG_ID
             , :new.FAL_LOT_ID
             , nvl(:new.PDE_ST_PT_REJECT, decode(PCS.PC_CONFIG.GETCONFIG('FAL_SUBCONTRACT_REJECT'), '1', 0, '2', 1, 0) )
             , nvl(:new.PDE_ST_CPT_REJECT, decode(PCS.PC_CONFIG.GETCONFIG('FAL_SUBCONTRACT_REJECT'), '1', 1, '2', 0, 0) )
             , :new.PDE_CURR_RISK_DISCHARGE_DONE
             , :new.GCO_QUALITY_STATUS_ID
              );

  -- Mise à jour du statut qualité du détail de position courant en fonction du détail de caractérisation lié.
  if :new.GCO_CHARACTERIZATION_ID is not null then
    DOC_PRC_POSITION_DETAIL.SyncDetailQualityStatus(:new.DOC_POSITION_DETAIL_ID);
  end if;

  close crLinkedPositionDetail;
end;

ALTER TRIGGER "C_ITX"."DOC_V_PDE_IOI_QUANTITY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."DOC_V_PDE_IOU_QUANTITY"
  instead of update
  on V_DOC_POSITION_DETAIL_IO
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des quantité des composants en fonction de la quantité du
*    produit terminé
* @author VJ
* @created 18.08.2003
* @version 2003
* @lastUpdate
*/
declare
  cursor crLinkedPositionDetail(aPositionID in number, aParentPositionDetailID in number)
  is
    select   PDE.DOC_POSITION_DETAIL_ID
           , PDE.PDE_BALANCE_QUANTITY_PARENT
           , PDE.DOC_DOC_POSITION_DETAIL_ID
           , PDE.DOC2_DOC_POSITION_DETAIL_ID
           , PDE.DOC_GAUGE_FLOW_ID
           , PDE.DOC_GAUGE_RECEIPT_ID
           , PDE.PDE_BALANCE_PARENT
           , PDE_FATHER.PDE_FINAL_QUANTITY
           , PDE_FATHER.PDE_BALANCE_QUANTITY
           , POS.POS_CONVERT_FACTOR
           , POS.POS_CONVERT_FACTOR2
           , POS.GCO_GOOD_ID
           , POS.PAC_THIRD_ID
           , POS_FATHER.POS_CONVERT_FACTOR2 FATHER_CONVERT_FACTOR2
           , POS_FATHER.POS_CONVERT_FACTOR FATHER_CONVERT_FACTOR
           , POS_FATHER.GCO_GOOD_ID FATHER_GOOD_ID
           , POS_FATHER.PAC_THIRD_ID FATHER_THIRD_ID
           , GAU.C_ADMIN_DOMAIN
           , DMT_FATHER.GAL_CURRENCY_RISK_VIRTUAL_ID
        from DOC_POSITION_DETAIL PDE
           , DOC_POSITION POS
           , DOC_GAUGE GAU
           , DOC_POSITION_DETAIL PDE_FATHER
           , DOC_POSITION POS_FATHER
           , DOC_DOCUMENT DMT_FATHER
       where PDE.DOC_POSITION_ID = aPositionID
         and PDE.DOC_DOC_POSITION_DETAIL_ID = aParentPositionDetailID
         and POS.DOC_POSITION_ID = PDE.DOC_POSITION_ID
         and GAU.DOC_GAUGE_ID = POS.DOC_GAUGE_ID
         and PDE_FATHER.DOC_POSITION_DETAIL_ID = PDE.DOC_DOC_POSITION_DETAIL_ID
         and POS_FATHER.DOC_POSITION_ID = PDE_FATHER.DOC_POSITION_ID
         and DMT_FATHER.DOC_DOCUMENT_ID = POS_FATHER.DOC_DOCUMENT_ID
    order by nvl(abs(PDE.PDE_BALANCE_QUANTITY_PARENT), 0) desc
           , nvl(PDE.PDE_BALANCE_PARENT, 0) desc
           , nvl(PDE_FATHER.PDE_BALANCE_QUANTITY, 0) desc;

  tplLinkedPositionDetail   crLinkedPositionDetail%rowtype;
  numBalanceQuantityParent  DOC_POSITION_DETAIL.PDE_BALANCE_QUANTITY_PARENT%type;
  numBalanceQuantityParent2 DOC_POSITION_DETAIL.PDE_BALANCE_QUANTITY_PARENT%type;
  vEffValue                 SQM_PENALTY.SPE_EFFECTIVE_VALUE%type;
  vAxisValue                SQM_PENALTY.SPE_INIT_VALUE%type;
  /**
  * NGV - Journalisation des positions
  * Déclaration des variables
  */
  vSrcPosID                 DOC_POSITION.DOC_POSITION_ID%type;
  tplPos                    DOC_POSITION%rowtype;
  vQuantity                 DOC_POSITION_DETAIL.PDE_FINAL_QUANTITY%type;
  vDetailProv               integer                                                default 0;
  vPosStatus                DOC_POSITION.C_DOC_POS_STATUS%type;
  vOldBalanceQuantity       DOC_POSITION_DETAIL.PDE_BALANCE_QUANTITY%type;
  vNewBalanceQuantity       DOC_POSITION_DETAIL.PDE_BALANCE_QUANTITY%type;
  vMovementValue            DOC_POSITION_DETAIL.PDE_MOVEMENT_VALUE%type;
  vErrorMsg                 varchar2(2000);
begin
  numBalanceQuantityParent  := nvl(:new.PDE_BALANCE_QUANTITY_PARENT, 0);
  vMovementValue            := :new.PDE_MOVEMENT_VALUE;

  -- Le détail de posititon courant est-il lié à un détail père ?
  if :new.DOC_DOC_POSITION_DETAIL_ID is not null then   -- Oui
    -- La position parent possède-t-elle des détails qui ont générés des mouvements ?
    if not DOC_POSITION_FUNCTIONS.IsFatherMvtGenerated(:new.DOC_POSITION_ID) then   -- Non
      -- La quantité a-t-elle changé ?
      if (:new.PDE_FINAL_QUANTITY <> :old.PDE_FINAL_QUANTITY) then
        -- Recherche si des détails avec un lien avec un père existent. C'est uniquement le détail qui possède la
        -- quantité soldée sur parent la plus grande en valeur absolue qui est traitée. C'est toujours ce détail de
        -- position qui reçoit l'éventuelle quantité soldée sur parent de l'ensemble des détails de position d'un
        -- même père.
        open crLinkedPositionDetail(:new.DOC_POSITION_ID, :new.DOC_DOC_POSITION_DETAIL_ID);

        fetch crLinkedPositionDetail
         into tplLinkedPositionDetail;

        if crLinkedPositionDetail%found then
          ----
          -- Effectue la mise à jour éventuelle de la quantité solde du détail père et de la quantité soldée sur parent
          -- du détail fils de "référence" (qui contient les informations solder parent et quantité soldé sur parent).
          --
          numBalanceQuantityParent2  := tplLinkedPositionDetail.PDE_BALANCE_QUANTITY_PARENT;

          -- Calcul de la quantité solde à recharger sur parent. Tient compte des facteurs de conversion si un
          -- changement de bien ou de partenaire est effectif. En effet, dans ce cas, il est possible que l'unité de gestion
          -- (et donc le facteur de conversion) soit différent entre le document père et le document fils. Dans ce cas, il
          -- faut appliquer les calculs suivants :
          --
          --
          --  Voir les règles définies dans le trigger DOC_V_PDE_IOD
          --
          if (   tplLinkedPositionDetail.GCO_GOOD_ID <> tplLinkedPositionDetail.FATHER_GOOD_ID
              or tplLinkedPositionDetail.PAC_THIRD_ID <> tplLinkedPositionDetail.FATHER_THIRD_ID
             ) then
            if tplLinkedPositionDetail.POS_CONVERT_FACTOR2 <> tplLinkedPositionDetail.POS_CONVERT_FACTOR then
              vNewBalanceQuantity  := :new.PDE_FINAL_QUANTITY * tplLinkedPositionDetail.POS_CONVERT_FACTOR2 / tplLinkedPositionDetail.FATHER_CONVERT_FACTOR;
              vOldBalanceQuantity  := :old.PDE_FINAL_QUANTITY * tplLinkedPositionDetail.POS_CONVERT_FACTOR2 / tplLinkedPositionDetail.FATHER_CONVERT_FACTOR;
            elsif tplLinkedPositionDetail.FATHER_CONVERT_FACTOR <> tplLinkedPositionDetail.POS_CONVERT_FACTOR then
              vNewBalanceQuantity  := :new.PDE_FINAL_QUANTITY_SU / tplLinkedPositionDetail.FATHER_CONVERT_FACTOR;
              vOldBalanceQuantity  := :old.PDE_FINAL_QUANTITY_SU / tplLinkedPositionDetail.FATHER_CONVERT_FACTOR;
            else   -- cas normal
              vNewBalanceQuantity  := :new.PDE_FINAL_QUANTITY;
              vOldBalanceQuantity  := :old.PDE_FINAL_QUANTITY;
            end if;
          else   -- cas normal
            vNewBalanceQuantity  := :new.PDE_FINAL_QUANTITY;
            vOldBalanceQuantity  := :old.PDE_FINAL_QUANTITY;
          end if;

          -- Effectue l'éventuelle mise à jour de la quantité solde du détail père
          DOC_POSITION_DETAIL_FUNCTIONS.MajBalanceQtyDetailParent(:new.DOC_DOC_POSITION_DETAIL_ID
                                                                , vNewBalanceQuantity
                                                                , vOldBalanceQuantity
                                                                , tplLinkedPositionDetail.PDE_BALANCE_PARENT
                                                                , numBalanceQuantityParent2
                                                                 );

          -- On effectue la mise à jour du détail qui possède la quantité soldé sur parent uniquement si ce
          -- n'est pas le détail en cours de modification.
          if (tplLinkedPositionDetail.DOC_POSITION_DETAIL_ID <> :new.DOC_POSITION_DETAIL_ID) then
            -- Mise a jour du détail trouvé avec la nouvelle quantité soldée sur parent.
            update DOC_POSITION_DETAIL
               set PDE_BALANCE_QUANTITY_PARENT = numBalanceQuantityParent2
             where DOC_POSITION_DETAIL_ID = tplLinkedPositionDetail.DOC_POSITION_DETAIL_ID;
          else
            -- Initialise la quantité soldée sur parent du détail courant. Dans ce cas, nous sommes en train de modifier
            -- le détail de "référence".
            numBalanceQuantityParent  := numBalanceQuantityParent2;
          end if;
        end if;

        close crLinkedPositionDetail;
      end if;
    end if;

    -- si risque de change, placement du document dans la liste à mettre à jour
    if tplLinkedPositionDetail.GAL_CURRENCY_RISK_VIRTUAL_ID is not null then
      DOC_PRC_DOCUMENT.AddDocToListParent(iDetailId => tplLinkedPositionDetail.DOC_DOC_POSITION_DETAIL_ID);
    end if;
  end if;

  -- Si en vente et que l'installation est renseigée
  --  La valeur mouvement doit être initialisée selon le prix de revient de l'installation
  if :new.DOC_RECORD_ID is not null then
    declare
      cursor crDetail
      is
        (select GAU.C_ADMIN_DOMAIN
              , nvl(GAP.GAP_STOCK_MVT, 0) GAP_STOCK_MVT
              , POS.C_GAUGE_TYPE_POS
              , POS.POS_UNIT_COST_PRICE
              , POS.STM_MOVEMENT_KIND_ID
           from DOC_POSITION POS
              , DOC_DOCUMENT DMT
              , DOC_GAUGE GAU
              , DOC_GAUGE_POSITION GAP
          where POS.DOC_POSITION_ID = :new.DOC_POSITION_ID
            and POS.DOC_DOCUMENT_ID = DMT.DOC_DOCUMENT_ID
            and DMT.DOC_GAUGE_ID = GAU.DOC_GAUGE_ID
            and POS.DOC_GAUGE_POSITION_ID = GAP.DOC_GAUGE_POSITION_ID);

      tplDetail crDetail%rowtype;
    begin
      open crDetail;

      fetch crDetail
       into tplDetail;

      close crDetail;

      if     (tplDetail.STM_MOVEMENT_KIND_ID is not null)
         and (tplDetail.C_ADMIN_DOMAIN = '2')
         and (tplDetail.GAP_STOCK_MVT = 1)
         and (to_number(tplDetail.C_GAUGE_TYPE_POS) in(1, 2, 3, 7, 8, 71, 81, 91, 101) ) then
        select nvl(RCO_COST_PRICE, tplDetail.POS_UNIT_COST_PRICE) * :new.PDE_FINAL_QUANTITY_SU
          into vMovementValue
          from DOC_RECORD
         where DOC_RECORD_ID = :new.DOC_RECORD_ID;
      end if;
    end;
  end if;

  -- Mise à jour des notes du détail de position lors de la mise à jour de la quantité
  if (:new.PDE_FINAL_QUANTITY <> :old.PDE_FINAL_QUANTITY) then
    if PCS.PC_CONFIG.GETCONFIG('SQM_QUALITY_MGM') = '1' then
      -- Initialisation du record
      SQM_INIT_METHOD.DetailInfo.DOC_POSITION_DETAIL_ID        := :new.DOC_POSITION_DETAIL_ID;
      SQM_INIT_METHOD.DetailInfo.DOC_GAUGE_FLOW_ID             := :new.DOC_GAUGE_FLOW_ID;
      SQM_INIT_METHOD.DetailInfo.DOC_POSITION_ID               := :new.DOC_POSITION_ID;
      SQM_INIT_METHOD.DetailInfo.DOC_DOC_POSITION_DETAIL_ID    := :new.DOC_DOC_POSITION_DETAIL_ID;
      SQM_INIT_METHOD.DetailInfo.DOC2_DOC_POSITION_DETAIL_ID   := :new.DOC2_DOC_POSITION_DETAIL_ID;
      SQM_INIT_METHOD.DetailInfo.PDE_BASIS_DELAY               := :new.PDE_BASIS_DELAY;
      SQM_INIT_METHOD.DetailInfo.PDE_BASIS_DELAY_W             := :new.PDE_BASIS_DELAY_W;
      SQM_INIT_METHOD.DetailInfo.PDE_BASIS_DELAY_M             := :new.PDE_BASIS_DELAY_M;
      SQM_INIT_METHOD.DetailInfo.PDE_INTERMEDIATE_DELAY        := :new.PDE_INTERMEDIATE_DELAY;
      SQM_INIT_METHOD.DetailInfo.PDE_INTERMEDIATE_DELAY_W      := :new.PDE_INTERMEDIATE_DELAY_W;
      SQM_INIT_METHOD.DetailInfo.PDE_INTERMEDIATE_DELAY_M      := :new.PDE_INTERMEDIATE_DELAY_M;
      SQM_INIT_METHOD.DetailInfo.PDE_FINAL_DELAY               := :new.PDE_FINAL_DELAY;
      SQM_INIT_METHOD.DetailInfo.PDE_FINAL_DELAY_W             := :new.PDE_FINAL_DELAY_W;
      SQM_INIT_METHOD.DetailInfo.PDE_FINAL_DELAY_M             := :new.PDE_FINAL_DELAY_M;
      SQM_INIT_METHOD.DetailInfo.PDE_BASIS_QUANTITY            := :new.PDE_BASIS_QUANTITY;
      SQM_INIT_METHOD.DetailInfo.PDE_ATTRIB_QUANTITY           := :new.PDE_ATTRIB_QUANTITY;
      SQM_INIT_METHOD.DetailInfo.PDE_INTERMEDIATE_QUANTITY     := :new.PDE_INTERMEDIATE_QUANTITY;
      SQM_INIT_METHOD.DetailInfo.PDE_FINAL_QUANTITY            := :new.PDE_FINAL_QUANTITY;
      SQM_INIT_METHOD.DetailInfo.PDE_BALANCE_QUANTITY          := :new.PDE_BALANCE_QUANTITY;
      SQM_INIT_METHOD.DetailInfo.PDE_MOVEMENT_QUANTITY         := :new.PDE_MOVEMENT_QUANTITY;
      SQM_INIT_METHOD.DetailInfo.PDE_MOVEMENT_VALUE            := vMovementValue;
      SQM_INIT_METHOD.DetailInfo.PDE_CHARACTERIZATION_VALUE_1  := :new.PDE_CHARACTERIZATION_VALUE_1;
      SQM_INIT_METHOD.DetailInfo.PDE_CHARACTERIZATION_VALUE_2  := :new.PDE_CHARACTERIZATION_VALUE_2;
      SQM_INIT_METHOD.DetailInfo.PDE_CHARACTERIZATION_VALUE_3  := :new.PDE_CHARACTERIZATION_VALUE_3;
      SQM_INIT_METHOD.DetailInfo.PDE_CHARACTERIZATION_VALUE_4  := :new.PDE_CHARACTERIZATION_VALUE_4;
      SQM_INIT_METHOD.DetailInfo.PDE_CHARACTERIZATION_VALUE_5  := :new.PDE_CHARACTERIZATION_VALUE_5;
      SQM_INIT_METHOD.DetailInfo.GCO_CHARACTERIZATION_ID       := :new.GCO_CHARACTERIZATION_ID;
      SQM_INIT_METHOD.DetailInfo.GCO_GCO_CHARACTERIZATION_ID   := :new.GCO_GCO_CHARACTERIZATION_ID;
      SQM_INIT_METHOD.DetailInfo.GCO2_GCO_CHARACTERIZATION_ID  := :new.GCO2_GCO_CHARACTERIZATION_ID;
      SQM_INIT_METHOD.DetailInfo.GCO3_GCO_CHARACTERIZATION_ID  := :new.GCO3_GCO_CHARACTERIZATION_ID;
      SQM_INIT_METHOD.DetailInfo.GCO4_GCO_CHARACTERIZATION_ID  := :new.GCO4_GCO_CHARACTERIZATION_ID;
      SQM_INIT_METHOD.DetailInfo.STM_STOCK_MOVEMENT_ID         := :new.STM_STOCK_MOVEMENT_ID;
      SQM_INIT_METHOD.DetailInfo.STM_LOCATION_ID               := :new.STM_LOCATION_ID;
      SQM_INIT_METHOD.DetailInfo.STM_STM_LOCATION_ID           := :new.STM_STM_LOCATION_ID;
      SQM_INIT_METHOD.DetailInfo.A_DATECRE                     := :new.A_DATECRE;
      SQM_INIT_METHOD.DetailInfo.A_DATEMOD                     := :new.A_DATEMOD;
      SQM_INIT_METHOD.DetailInfo.A_IDCRE                       := :new.A_IDCRE;
      SQM_INIT_METHOD.DetailInfo.A_IDMOD                       := :new.A_IDMOD;
      SQM_INIT_METHOD.DetailInfo.A_RECLEVEL                    := :new.A_RECLEVEL;
      SQM_INIT_METHOD.DetailInfo.A_RECSTATUS                   := :new.A_RECSTATUS;
      SQM_INIT_METHOD.DetailInfo.A_CONFIRM                     := :new.A_CONFIRM;
      SQM_INIT_METHOD.DetailInfo.PDE_BALANCE_QUANTITY_PARENT   := :new.PDE_BALANCE_QUANTITY_PARENT;
      SQM_INIT_METHOD.DetailInfo.DIC_PDE_FREE_TABLE_1_ID       := :new.DIC_PDE_FREE_TABLE_1_ID;
      SQM_INIT_METHOD.DetailInfo.DIC_PDE_FREE_TABLE_2_ID       := :new.DIC_PDE_FREE_TABLE_2_ID;
      SQM_INIT_METHOD.DetailInfo.DIC_PDE_FREE_TABLE_3_ID       := :new.DIC_PDE_FREE_TABLE_3_ID;
      SQM_INIT_METHOD.DetailInfo.PDE_DECIMAL_1                 := :new.PDE_DECIMAL_1;
      SQM_INIT_METHOD.DetailInfo.PDE_DECIMAL_2                 := :new.PDE_DECIMAL_2;
      SQM_INIT_METHOD.DetailInfo.PDE_DECIMAL_3                 := :new.PDE_DECIMAL_3;
      SQM_INIT_METHOD.DetailInfo.PDE_TEXT_1                    := :new.PDE_TEXT_1;
      SQM_INIT_METHOD.DetailInfo.PDE_TEXT_2                    := :new.PDE_TEXT_2;
      SQM_INIT_METHOD.DetailInfo.PDE_TEXT_3                    := :new.PDE_TEXT_3;
      SQM_INIT_METHOD.DetailInfo.PDE_DATE_1                    := :new.PDE_DATE_1;
      SQM_INIT_METHOD.DetailInfo.PDE_DATE_2                    := :new.PDE_DATE_2;
      SQM_INIT_METHOD.DetailInfo.PDE_DATE_3                    := :new.PDE_DATE_3;
      SQM_INIT_METHOD.DetailInfo.FAL_SCHEDULE_STEP_ID          := :new.FAL_SCHEDULE_STEP_ID;
      SQM_INIT_METHOD.DetailInfo.DOC_DOCUMENT_ID               := :new.DOC_DOCUMENT_ID;
      SQM_INIT_METHOD.DetailInfo.PAC_THIRD_ID                  := :new.PAC_THIRD_ID;
      SQM_INIT_METHOD.DetailInfo.PAC_THIRD_ACI_ID              := :new.PAC_THIRD_ACI_ID;
      SQM_INIT_METHOD.DetailInfo.PAC_THIRD_DELIVERY_ID         := :new.PAC_THIRD_DELIVERY_ID;
      SQM_INIT_METHOD.DetailInfo.PAC_THIRD_TARIFF_ID           := :new.PAC_THIRD_TARIFF_ID;
      SQM_INIT_METHOD.DetailInfo.DOC_GAUGE_ID                  := :new.DOC_GAUGE_ID;
      SQM_INIT_METHOD.DetailInfo.DOC_GAUGE_RECEIPT_ID          := :new.DOC_GAUGE_RECEIPT_ID;
      SQM_INIT_METHOD.DetailInfo.DOC_GAUGE_COPY_ID             := :new.DOC_GAUGE_COPY_ID;
      SQM_INIT_METHOD.DetailInfo.DIC_DELAY_UPDATE_TYPE_ID      := :new.DIC_DELAY_UPDATE_TYPE_ID;
      SQM_INIT_METHOD.DetailInfo.PDE_DELAY_UPDATE_TEXT         := :new.PDE_DELAY_UPDATE_TEXT;
      SQM_INIT_METHOD.DetailInfo.PDE_BASIS_QUANTITY_SU         := :new.PDE_BASIS_QUANTITY_SU;
      SQM_INIT_METHOD.DetailInfo.PDE_INTERMEDIATE_QUANTITY_SU  := :new.PDE_INTERMEDIATE_QUANTITY_SU;
      SQM_INIT_METHOD.DetailInfo.PDE_FINAL_QUANTITY_SU         := :new.PDE_FINAL_QUANTITY_SU;
      SQM_INIT_METHOD.DetailInfo.PDE_GENERATE_MOVEMENT         := :new.PDE_GENERATE_MOVEMENT;
      SQM_INIT_METHOD.DetailInfo.GCO_GOOD_ID                   := :new.GCO_GOOD_ID;
      SQM_INIT_METHOD.DetailInfo.PDE_PIECE                     := :new.PDE_PIECE;
      SQM_INIT_METHOD.DetailInfo.PDE_SET                       := :new.PDE_SET;
      SQM_INIT_METHOD.DetailInfo.PDE_VERSION                   := :new.PDE_VERSION;
      SQM_INIT_METHOD.DetailInfo.PDE_CHRONOLOGICAL             := :new.PDE_CHRONOLOGICAL;
      SQM_INIT_METHOD.DetailInfo.PDE_STD_CHAR_1                := :new.PDE_STD_CHAR_1;
      SQM_INIT_METHOD.DetailInfo.PDE_STD_CHAR_2                := :new.PDE_STD_CHAR_2;
      SQM_INIT_METHOD.DetailInfo.PDE_STD_CHAR_3                := :new.PDE_STD_CHAR_3;
      SQM_INIT_METHOD.DetailInfo.PDE_STD_CHAR_4                := :new.PDE_STD_CHAR_4;
      SQM_INIT_METHOD.DetailInfo.PDE_STD_CHAR_5                := :new.PDE_STD_CHAR_5;
      SQM_INIT_METHOD.DetailInfo.PDE_BALANCE_PARENT            := :new.PDE_BALANCE_PARENT;
      SQM_INIT_METHOD.DetailInfo.FAL_NETWORK_LINK_ID           := :new.FAL_NETWORK_LINK_ID;
      SQM_INIT_METHOD.DetailInfo.PDE_SQM_ACCEPTED_DELAY        := :new.PDE_SQM_ACCEPTED_DELAY;
      SQM_INIT_METHOD.DetailInfo.PDE_TRANSFERT_PROPRIETOR      := :new.PDE_TRANSFERT_PROPRIETOR;
      SQM_INIT_METHOD.DetailInfo.PDE_ST_PT_REJECT              := :new.PDE_ST_PT_REJECT;
      SQM_INIT_METHOD.DetailInfo.PDE_ST_CPT_REJECT             := :new.PDE_ST_CPT_REJECT;
      SQM_INIT_METHOD.DetailInfo.GCO_QUALITY_STATUS_ID         := :new.GCO_QUALITY_STATUS_ID;

      for cr_axis in (select SPE_DATE_REFERENCE DATE_REF
                           , SQM_FUNCTIONS.GetFirstFitScale(SPE.SQM_AXIS_ID, SPE_DATE_REFERENCE, SPE.GCO_GOOD_ID) SQM_SCALE_ID
                           , SPE.SQM_AXIS_ID
                           , SPE.DOC_POSITION_DETAIL_ID
                           , SPE.GCO_GOOD_ID GOOD_ID
                           , SPE.SQM_PENALTY_ID
                           , SPE.SPE_EXPECTED_VALUE
                        from SQM_PENALTY SPE
                           , SQM_AXIS SAX
                       where DOC_POSITION_DETAIL_ID = :new.DOC_POSITION_DETAIL_ID
                         and SAX.SQM_AXIS_ID = SPE.SQM_AXIS_ID
                         and SAX.C_AXIS_STATUS = 'ACT'
                         and SPE.SPE_MANUAL_PENALTY = 0) loop
        vEffValue   := null;
        vAxisValue  := null;
        SQM_INIT_METHOD.CalcAxisValue(cr_axis.SQM_AXIS_ID, cr_axis.SPE_EXPECTED_VALUE, vEffValue, vAxisValue);

        update SQM_PENALTY
           set SQM_SCALE_ID = cr_axis.SQM_SCALE_ID
             , SPE_DATE_REFERENCE = cr_axis.DATE_REF
             , SPE_CALC_PENALTY = SQM_FUNCTIONS.CalcPenalty(cr_axis.SQM_SCALE_ID, vAxisValue)
             , SPE_EXPECTED_VALUE = cr_axis.SPE_EXPECTED_VALUE
             , SPE_EFFECTIVE_VALUE = vEffValue
             , SPE_INIT_VALUE = vAxisValue
             , A_DATEMOD = sysdate
             , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
         where SQM_PENALTY_ID = cr_axis.SQM_PENALTY_ID;
      end loop;
    end if;
  end if;

  /**
  * NGV - Journalisation des positions
  * Création des écritures au statut '04' sur la position père concernant la modif. de la position fille
  */
  if     (:old.DOC_DOC_POSITION_DETAIL_ID is not null)
     and (    (nvl(:old.PDE_FINAL_QUANTITY, 0) <> nvl(:new.PDE_FINAL_QUANTITY, 0) )
          or (nvl(:old.PDE_BALANCE_QUANTITY, 0) <> nvl(:new.PDE_BALANCE_QUANTITY, 0) ) ) then
    -- Rechercher l'id de la position source
    select PDE_SRC.DOC_POSITION_ID
         , POS.C_DOC_POS_STATUS
      into vSrcPosID
         , vPosStatus
      from DOC_POSITION_DETAIL PDE_SRC
         , DOC_POSITION POS
     where PDE_SRC.DOC_POSITION_DETAIL_ID = :old.DOC_DOC_POSITION_DETAIL_ID
       and POS.DOC_POSITION_ID = :old.DOC_POSITION_ID;

    DOC_JOURNAL_FUNCTIONS.CURRENT_TRANSACTION  := DBMS_TRANSACTION.local_transaction_id;
    DOC_JOURNAL_FUNCTIONS.DISCH_SRC_POS_ID     := vSrcPosID;
    DOC_JOURNAL_FUNCTIONS.DISCH_TGT_POS_ID     := :new.DOC_POSITION_ID;
    DOC_JOURNAL_FUNCTIONS.DISCH_TGT_DOC_ID     := :new.DOC_DOCUMENT_ID;
    DOC_JOURNAL_FUNCTIONS.DISCH_CODE           := 'UPDATE';

    -- Vérifier si l'on doit faire la journalisation de la position père
    if DOC_JOURNAL_FUNCTIONS.MustPosJournalize(vSrcPosID) = 1 then
      -- Qté de journal -> Qté du détail - qté soldée sur parent
      vQuantity                                  := (nvl(vOldBalanceQuantity, :old.PDE_FINAL_QUANTITY) + :old.PDE_BALANCE_QUANTITY_PARENT) * -1;

      -- Rechercher les infos de la position père
      select *
        into tplPos
        from DOC_POSITION
       where DOC_POSITION_ID = vSrcPosID;

      -- si la position a le statut à confirmer, il faut journaliser dans la table provisoire
      if vPosStatus = '01' then
        vDetailProv  := 1;
      end if;

      DOC_JOURNAL_FUNCTIONS.SRC_DOC_POSITION_ID  := null;
      DOC_JOURNAL_FUNCTIONS.TGT_DOC_POSITION_ID  := :new.DOC_POSITION_ID;
      -- Ecriture d'extourne
      DOC_JOURNAL_FUNCTIONS.CreateDetailExt(aCode            => 'UPD_TGT'
                                          , aOldPos          => tplPos
                                          , aNewPos          => tplPos
                                          , aDetailProv      => vDetailProv
                                          , aForceStatus     => '04'
                                          , aForceQuantity   => 1
                                          , aQuantity        => vQuantity
                                           );
      --
      -- Qté de journal -> Qté du détail + qté soldée sur parent
      vQuantity                                  := nvl(vNewBalanceQuantity, :new.PDE_FINAL_QUANTITY) + numBalanceQuantityParent;
      -- Ecriture
      DOC_JOURNAL_FUNCTIONS.CreateDetail(aCode            => 'UPD_TGT'
                                       , aOldPos          => tplPos
                                       , aNewPos          => tplPos
                                       , aDetailProv      => vDetailProv
                                       , aForceStatus     => '04'
                                       , aForceQuantity   => 1
                                       , aQuantity        => vQuantity
                                        );
      DOC_JOURNAL_FUNCTIONS.SRC_DOC_POSITION_ID  := null;
      DOC_JOURNAL_FUNCTIONS.TGT_DOC_POSITION_ID  := null;
    end if;
  end if;

  update DOC_POSITION_DETAIL
     set DOC_POSITION_DETAIL_ID = :new.DOC_POSITION_DETAIL_ID
       , DOC_GAUGE_FLOW_ID = :new.DOC_GAUGE_FLOW_ID
       , DOC_POSITION_ID = :new.DOC_POSITION_ID
       , DOC_DOC_POSITION_DETAIL_ID = :new.DOC_DOC_POSITION_DETAIL_ID
       , DOC2_DOC_POSITION_DETAIL_ID = :new.DOC2_DOC_POSITION_DETAIL_ID
       , PDE_BASIS_DELAY = :new.PDE_BASIS_DELAY
       , PDE_BASIS_DELAY_W = :new.PDE_BASIS_DELAY_W
       , PDE_BASIS_DELAY_M = :new.PDE_BASIS_DELAY_M
       , PDE_INTERMEDIATE_DELAY = :new.PDE_INTERMEDIATE_DELAY
       , PDE_INTERMEDIATE_DELAY_W = :new.PDE_INTERMEDIATE_DELAY_W
       , PDE_INTERMEDIATE_DELAY_M = :new.PDE_INTERMEDIATE_DELAY_M
       , PDE_FINAL_DELAY = :new.PDE_FINAL_DELAY
       , PDE_FINAL_DELAY_W = :new.PDE_FINAL_DELAY_W
       , PDE_FINAL_DELAY_M = :new.PDE_FINAL_DELAY_M
       , PDE_SQM_ACCEPTED_DELAY = :new.PDE_SQM_ACCEPTED_DELAY
       , PDE_BASIS_QUANTITY = nvl(:new.PDE_BASIS_QUANTITY, 0)
       , PDE_ATTRIB_QUANTITY = nvl(:new.PDE_ATTRIB_QUANTITY, 0)
       , PDE_INTERMEDIATE_QUANTITY = nvl(:new.PDE_INTERMEDIATE_QUANTITY, 0)
       , PDE_FINAL_QUANTITY = nvl(:new.PDE_FINAL_QUANTITY, 0)
       , PDE_BALANCE_QUANTITY = nvl(:new.PDE_BALANCE_QUANTITY, 0)
       , PDE_MOVEMENT_QUANTITY = nvl(:new.PDE_MOVEMENT_QUANTITY, 0)
       , PDE_MOVEMENT_VALUE = nvl(vMovementValue, 0)
       , PDE_MOVEMENT_DATE = :new.PDE_MOVEMENT_DATE
       , PDE_CHARACTERIZATION_VALUE_1 = :new.PDE_CHARACTERIZATION_VALUE_1
       , PDE_CHARACTERIZATION_VALUE_2 = :new.PDE_CHARACTERIZATION_VALUE_2
       , PDE_CHARACTERIZATION_VALUE_3 = :new.PDE_CHARACTERIZATION_VALUE_3
       , PDE_CHARACTERIZATION_VALUE_4 = :new.PDE_CHARACTERIZATION_VALUE_4
       , PDE_CHARACTERIZATION_VALUE_5 = :new.PDE_CHARACTERIZATION_VALUE_5
       , GCO_CHARACTERIZATION_ID = :new.GCO_CHARACTERIZATION_ID
       , GCO_GCO_CHARACTERIZATION_ID = :new.GCO_GCO_CHARACTERIZATION_ID
       , GCO2_GCO_CHARACTERIZATION_ID = :new.GCO2_GCO_CHARACTERIZATION_ID
       , GCO3_GCO_CHARACTERIZATION_ID = :new.GCO3_GCO_CHARACTERIZATION_ID
       , GCO4_GCO_CHARACTERIZATION_ID = :new.GCO4_GCO_CHARACTERIZATION_ID
       , STM_STOCK_MOVEMENT_ID = :new.STM_STOCK_MOVEMENT_ID
       , STM_LOCATION_ID = :new.STM_LOCATION_ID
       , STM_STM_LOCATION_ID = :new.STM_STM_LOCATION_ID
       , A_DATECRE = :new.A_DATECRE
       , A_DATEMOD = :new.A_DATEMOD
       , A_IDCRE = :new.A_IDCRE
       , A_IDMOD = :new.A_IDMOD
       , A_RECLEVEL = :new.A_RECLEVEL
       , A_RECSTATUS = :new.A_RECSTATUS
       , A_CONFIRM = :new.A_CONFIRM
       , PDE_BALANCE_QUANTITY_PARENT = numBalanceQuantityParent
       , DIC_PDE_FREE_TABLE_1_ID = :new.DIC_PDE_FREE_TABLE_1_ID
       , DIC_PDE_FREE_TABLE_2_ID = :new.DIC_PDE_FREE_TABLE_2_ID
       , DIC_PDE_FREE_TABLE_3_ID = :new.DIC_PDE_FREE_TABLE_3_ID
       , PDE_DECIMAL_1 = :new.PDE_DECIMAL_1
       , PDE_DECIMAL_2 = :new.PDE_DECIMAL_2
       , PDE_DECIMAL_3 = :new.PDE_DECIMAL_3
       , PDE_TEXT_1 = :new.PDE_TEXT_1
       , PDE_TEXT_2 = :new.PDE_TEXT_2
       , PDE_TEXT_3 = :new.PDE_TEXT_3
       , PDE_DATE_1 = :new.PDE_DATE_1
       , PDE_DATE_2 = :new.PDE_DATE_2
       , PDE_DATE_3 = :new.PDE_DATE_3
       , FAL_SCHEDULE_STEP_ID = :new.FAL_SCHEDULE_STEP_ID
       , DOC_DOCUMENT_ID = :new.DOC_DOCUMENT_ID
       , PAC_THIRD_ID = :new.PAC_THIRD_ID
       , PAC_THIRD_ACI_ID = :new.PAC_THIRD_ACI_ID
       , PAC_THIRD_DELIVERY_ID = :new.PAC_THIRD_DELIVERY_ID
       , PAC_THIRD_TARIFF_ID = :new.PAC_THIRD_TARIFF_ID
       , DOC_GAUGE_ID = :new.DOC_GAUGE_ID
       , DOC_GAUGE_RECEIPT_ID = :new.DOC_GAUGE_RECEIPT_ID
       , DOC_GAUGE_COPY_ID = :new.DOC_GAUGE_COPY_ID
       , DIC_DELAY_UPDATE_TYPE_ID = :new.DIC_DELAY_UPDATE_TYPE_ID
       , PDE_DELAY_UPDATE_TEXT = :new.PDE_DELAY_UPDATE_TEXT
       , PDE_BASIS_QUANTITY_SU = nvl(:new.PDE_BASIS_QUANTITY_SU, 0)
       , PDE_INTERMEDIATE_QUANTITY_SU = nvl(:new.PDE_INTERMEDIATE_QUANTITY_SU, 0)
       , PDE_FINAL_QUANTITY_SU = nvl(:new.PDE_FINAL_QUANTITY_SU, 0)
       , PDE_GENERATE_MOVEMENT = nvl(:new.PDE_GENERATE_MOVEMENT, 0)
       , GCO_GOOD_ID = :new.GCO_GOOD_ID
       , PDE_PIECE = :new.PDE_PIECE
       , PDE_SET = :new.PDE_SET
       , PDE_VERSION = :new.PDE_VERSION
       , PDE_CHRONOLOGICAL = :new.PDE_CHRONOLOGICAL
       , PDE_STD_CHAR_1 = :new.PDE_STD_CHAR_1
       , PDE_STD_CHAR_2 = :new.PDE_STD_CHAR_2
       , PDE_STD_CHAR_3 = :new.PDE_STD_CHAR_3
       , PDE_STD_CHAR_4 = :new.PDE_STD_CHAR_4
       , PDE_STD_CHAR_5 = :new.PDE_STD_CHAR_5
       , PDE_BALANCE_PARENT = nvl(:new.PDE_BALANCE_PARENT, 0)
       , FAL_NETWORK_LINK_ID = :new.FAL_NETWORK_LINK_ID
       , FAL_SUPPLY_REQUEST_ID = :new.FAL_SUPPLY_REQUEST_ID
       , DOC_RECORD_ID = :new.DOC_RECORD_ID
       , ACS_FINANCIAL_ACCOUNT_BS_ID = :new.ACS_FINANCIAL_ACCOUNT_BS_ID
       , ACS_DIVISION_ACCOUNT_BS_ID = :new.ACS_DIVISION_ACCOUNT_BS_ID
       , ACS_CPN_ACCOUNT_BS_ID = :new.ACS_CPN_ACCOUNT_BS_ID
       , ACS_PF_ACCOUNT_BS_ID = :new.ACS_PF_ACCOUNT_BS_ID
       , ACS_PJ_ACCOUNT_BS_ID = :new.ACS_PJ_ACCOUNT_BS_ID
       , ACS_CDA_ACCOUNT_BS_ID = :new.ACS_CDA_ACCOUNT_BS_ID
       , ACS_FINANCIAL_ACCOUNT_PL_ID = :new.ACS_FINANCIAL_ACCOUNT_PL_ID
       , ACS_DIVISION_ACCOUNT_PL_ID = :new.ACS_DIVISION_ACCOUNT_PL_ID
       , ACS_CPN_ACCOUNT_PL_ID = :new.ACS_CPN_ACCOUNT_PL_ID
       , ACS_PF_ACCOUNT_PL_ID = :new.ACS_PF_ACCOUNT_PL_ID
       , ACS_PJ_ACCOUNT_PL_ID = :new.ACS_PJ_ACCOUNT_PL_ID
       , ACS_CDA_ACCOUNT_PL_ID = :new.ACS_CDA_ACCOUNT_PL_ID
       , HRM_PERSON_ID = :new.HRM_PERSON_ID
       , FAM_FIXED_ASSETS_ID = :new.FAM_FIXED_ASSETS_ID
       , C_FAM_TRANSACTION_TYP = :new.C_FAM_TRANSACTION_TYP
       , DIC_IMP_FREE1_ID = :new.DIC_IMP_FREE1_ID
       , DIC_IMP_FREE2_ID = :new.DIC_IMP_FREE2_ID
       , DIC_IMP_FREE3_ID = :new.DIC_IMP_FREE3_ID
       , DIC_IMP_FREE4_ID = :new.DIC_IMP_FREE4_ID
       , DIC_IMP_FREE5_ID = :new.DIC_IMP_FREE5_ID
       , DOC_RECORD_BS_ID = :new.DOC_RECORD_BS_ID
       , PDE_IMF_TEXT_1 = :new.PDE_IMF_TEXT_1
       , PDE_IMF_TEXT_2 = :new.PDE_IMF_TEXT_2
       , PDE_IMF_TEXT_3 = :new.PDE_IMF_TEXT_3
       , PDE_IMF_TEXT_4 = :new.PDE_IMF_TEXT_4
       , PDE_IMF_TEXT_5 = :new.PDE_IMF_TEXT_5
       , PDE_IMF_NUMBER_1 = :new.PDE_IMF_NUMBER_1
       , PDE_IMF_NUMBER_2 = :new.PDE_IMF_NUMBER_2
       , PDE_IMF_NUMBER_3 = :new.PDE_IMF_NUMBER_3
       , PDE_IMF_NUMBER_4 = :new.PDE_IMF_NUMBER_4
       , PDE_IMF_NUMBER_5 = :new.PDE_IMF_NUMBER_5
       , PDE_IMF_DATE_1 = :new.PDE_IMF_DATE_1
       , PDE_IMF_DATE_2 = :new.PDE_IMF_DATE_2
       , PDE_IMF_DATE_3 = :new.PDE_IMF_DATE_3
       , PDE_IMF_DATE_4 = :new.PDE_IMF_DATE_4
       , PDE_IMF_DATE_5 = :new.PDE_IMF_DATE_5
       , CML_EVENTS_ID = :new.CML_EVENTS_ID
       , C_GAUGE_TYPE_POS = :new.C_GAUGE_TYPE_POS
       , DOC_DOCUMENT_SRC_ID = :new.DOC_DOCUMENT_SRC_ID
       , DOC_POSITION_SRC_ID = :new.DOC_POSITION_SRC_ID
       , GCO_GCO_GOOD_ID = :new.GCO_GCO_GOOD_ID
       , PAC_THIRD_CDA_ID = :new.PAC_THIRD_CDA_ID
       , PAC_THIRD_VAT_ID = :new.PAC_THIRD_VAT_ID
       , PDE_ADDENDUM_QTY_BALANCED = :new.PDE_ADDENDUM_QTY_BALANCED
       , PDE_ADDENDUM_SRC_PDE_ID = :new.PDE_ADDENDUM_SRC_PDE_ID
       , PDE_TRANSFERT_PROPRIETOR = :new.PDE_TRANSFERT_PROPRIETOR
       , PDE_GAP_PURCHASE_PRICE = :new.PDE_GAP_PURCHASE_PRICE
       , FAL_LOT_ID = :new.FAL_LOT_ID
       , PDE_ST_PT_REJECT = :new.PDE_ST_PT_REJECT
       , PDE_ST_CPT_REJECT = :new.PDE_ST_CPT_REJECT
       , PDE_CURR_RISK_DISCHARGE_DONE = :new.PDE_CURR_RISK_DISCHARGE_DONE
       , GCO_QUALITY_STATUS_ID = :new.GCO_QUALITY_STATUS_ID
   where DOC_POSITION_DETAIL_ID = :new.DOC_POSITION_DETAIL_ID;

  -- Mise à jour du statut qualité du détail de position courant en fonction du détail de caractérisation lié.
  if :new.GCO_CHARACTERIZATION_ID is not null then
    DOC_PRC_POSITION_DETAIL.SyncDetailQualityStatus(:new.DOC_POSITION_DETAIL_ID);
  end if;

  -- Mise à jour de la quantité du lot de fabrication associé au détail de position
  if     DOC_LIB_SUBCONTRACTP.IsSUPOGauge(:new.DOC_GAUGE_ID) = 1
     and (:new.PDE_FINAL_QUANTITY <> :old.PDE_FINAL_QUANTITY)
     and (:new.FAL_LOT_ID is not null) then
    FAL_PRC_SUBCONTRACTP.UpdateBatch(:new.DOC_POSITION_DETAIL_ID, vErrorMsg);

    if vErrorMsg is not null then
      raise_application_error(-20901, vErrorMsg);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."DOC_V_PDE_IOU_QUANTITY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."EML_SDQ_BIU_DATE_INTEGRITY"
  before insert or update of SDQ_DATE_TO_SEND, SDQ_DATE_NEXT_TRY
  on EML_TO_SEND_EMAILS_QUEUE
  referencing old as old new as new
  for each row
/**
 * Description
 *     This trigger sets current date and time value if date fields are null,
 *     and replace the date of the next attempt to send the e-mail if it is
 *     sooner than the date wanted for sending.
 * @author JCH
 * @created 22.06.2005
 * @version 2003
 * @lastUpdate
 */
begin
  /* If SDQ_DATE_TO_SEND is null, it is set with sysdate casted from
  sessiontimezone to dbtimezone */
  if :new.SDQ_DATE_TO_SEND is null then
    :new.SDQ_DATE_TO_SEND  := from_tz(cast(sysdate as timestamp), sessiontimezone) at time zone dbtimezone;
  end if;

  /* If SDQ_DATE_NEXT_TRY is null, it is set with sysdate casted from
  sessiontimezone to dbtimezone */
  if :new.SDQ_DATE_NEXT_TRY is null then
    :new.SDQ_DATE_NEXT_TRY  := from_tz(cast(sysdate as timestamp), sessiontimezone) at time zone dbtimezone;
  end if;

  /* If SDQ_DATE_NEXT_TRY is sooner than SDQ_DATE_TO_SEND then SDQ_DATE_NEXT_TRY
  is set with SDQ_DATE_TO_SEND */
  if :new.SDQ_DATE_NEXT_TRY < :new.SDQ_DATE_TO_SEND then
    :new.SDQ_DATE_NEXT_TRY  := :new.SDQ_DATE_TO_SEND;
  end if;
end EML_SDQ_BIU_DATE_INTEGRITY;


ALTER TRIGGER "C_ITX"."EML_SDQ_BIU_DATE_INTEGRITY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_COMPO_LINK_BD_PROVIS_STK"
  before delete
  on FAL_COMPONENT_LINK
  referencing old as old new as new
  for each row
/**
* Description
*     Remise à jour de la sortie stock provisoire pour chaque enregistrement de
*     FAL_COMPONENT_LINK qui ne dépend pas d'une entrée atelier (FAL_FACTORY_IN)
*     et qui n'a pas de réservation sur stock (cas des FAL_NETWORK_LINK_ID <> null)
* @author CLE
* @version 2006
* @lastUpdate
*/
begin
  if nvl(:old.FCL_HOLD_QTY, 0) > 0 then
    if     (:old.STM_STOCK_POSITION_ID is not null)
       and (:old.FAL_NETWORK_LINK_ID is null)
       and (:old.FAL_FACTORY_IN_ID is null) then
      update STM_STOCK_POSITION
         set SPO_PROVISORY_OUTPUT = SPO_PROVISORY_OUTPUT - :old.FCL_HOLD_QTY
           , SPO_AVAILABLE_QUANTITY = SPO_AVAILABLE_QUANTITY + :old.FCL_HOLD_QTY
           , A_DATEMOD = sysdate
           , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
       where STM_STOCK_POSITION_ID = :old.STM_STOCK_POSITION_ID;
    end if;
  end if;
end FAL_COMPO_LINK_BD_PROVIS_STK;

ALTER TRIGGER "C_ITX"."FAL_COMPO_LINK_BD_PROVIS_STK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_COMPO_LINK_BI_PROVIS_STK"
  before insert
  on FAL_COMPONENT_LINK
  referencing old as old new as new
  for each row
/**
* Description
*   - Création d'une sortie stock provisoire pour chaque enregistrement de
*     FAL_COMPONENT_LINK qui ne dépend pas d'une entrée atelier (FAL_FACTORY_IN)
*     et qui n'a pas de réservation sur stock (cas des FAL_NETWORK_LINK_ID <> null)
*   - Mise à jour quantité max réceptionnable du composant
* @author CLE
* @version 2006
* @lastUpdate
*/
begin
  if nvl(:new.FCL_HOLD_QTY, 0) > 0 then
    if     (:new.STM_STOCK_POSITION_ID is not null)
       and (:new.FAL_NETWORK_LINK_ID is null)
       and (:new.FAL_FACTORY_IN_ID is null) then
      update STM_STOCK_POSITION
         set SPO_PROVISORY_OUTPUT = SPO_PROVISORY_OUTPUT + :new.FCL_HOLD_QTY
           , SPO_AVAILABLE_QUANTITY = SPO_AVAILABLE_QUANTITY - :new.FCL_HOLD_QTY
           , A_DATEMOD = sysdate
           , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
       where STM_STOCK_POSITION_ID = :new.STM_STOCK_POSITION_ID;
    end if;
  end if;
end FAL_COMPO_LINK_BI_PROVIS_STK;

ALTER TRIGGER "C_ITX"."FAL_COMPO_LINK_BI_PROVIS_STK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_COMPO_LINK_BIU_DENORM_CHAR"
  before insert or update of
      "FCL_CHARACTERIZATION_VALUE_1",
      "FCL_CHARACTERIZATION_VALUE_2",
      "FCL_CHARACTERIZATION_VALUE_3",
      "FCL_CHARACTERIZATION_VALUE_4",
      "FCL_CHARACTERIZATION_VALUE_5"
  on FAL_COMPONENT_LINK
  referencing old as old new as new
  for each row
/**
* Description
*    Dénormalisation des caractérisations dans l'événement before insert/update
* @created FP/CLG 04.05.2012 (repris de STM_SPO_BIU_DENORM_CHAR)
* @version 2003
* @lastUpdate
*/
begin
  -- vérifie que les informations ne soient pas déjà données
  if :new.GCO_CHARACTERIZATION1_ID is not null then
    -- Mise à jour des champs dénormalisé d'affichage des caractérisations
    GCO_FUNCTIONS.ClassifyCharacterizations(:new.GCO_CHARACTERIZATION1_ID
                                          , :new.GCO_CHARACTERIZATION2_ID
                                          , :new.GCO_CHARACTERIZATION3_ID
                                          , :new.GCO_CHARACTERIZATION4_ID
                                          , :new.GCO_CHARACTERIZATION5_ID
                                          , :new.FCL_CHARACTERIZATION_VALUE_1
                                          , :new.FCL_CHARACTERIZATION_VALUE_2
                                          , :new.FCL_CHARACTERIZATION_VALUE_3
                                          , :new.FCL_CHARACTERIZATION_VALUE_4
                                          , :new.FCL_CHARACTERIZATION_VALUE_5
                                          , :new.FCL_PIECE_NUM
                                          , :new.FCL_BATCH_NUM
                                          , :new.FCL_VERSION
                                          , :new.FCL_CHRONOLOGY
                                          , :new.FCL_STD_CHAR_1
                                          , :new.FCL_STD_CHAR_2
                                          , :new.FCL_STD_CHAR_3
                                          , :new.FCL_STD_CHAR_4
                                          , :new.FCL_STD_CHAR_5
                                           );
  end if;
end FAL_COMPO_LINK_BIU_DENORM_CHAR;

ALTER TRIGGER "C_ITX"."FAL_COMPO_LINK_BIU_DENORM_CHAR" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_COMPO_LINK_BU_PROVIS_STK"
  before update of FCL_HOLD_QTY
  on FAL_COMPONENT_LINK
  referencing old as old new as new
  for each row
/**
* Description
*     Remise à jour de la sortie stock provisoire en fonction de la nouvelle quantité
*     sur le lien de réservation
* @author CLE
* @version 2006
* @lastUpdate
*/
begin
  if     (:new.STM_STOCK_POSITION_ID is not null)
     and (:new.FAL_NETWORK_LINK_ID is null)
     and (:new.FAL_FACTORY_IN_ID is null) then
    update STM_STOCK_POSITION
       set SPO_PROVISORY_OUTPUT = SPO_PROVISORY_OUTPUT +(:new.FCL_HOLD_QTY - :old.FCL_HOLD_QTY)
         , SPO_AVAILABLE_QUANTITY = SPO_AVAILABLE_QUANTITY -(:new.FCL_HOLD_QTY - :old.FCL_HOLD_QTY)
         , A_DATEMOD = sysdate
         , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
     where STM_STOCK_POSITION_ID = :new.STM_STOCK_POSITION_ID;
  end if;
end FAL_COMPO_LINK_BU_PROVIS_STK;

ALTER TRIGGER "C_ITX"."FAL_COMPO_LINK_BU_PROVIS_STK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_DOC_PROP_AU"
  after update of GCO_CHARACTERIZATION1_ID
                , GCO_CHARACTERIZATION2_ID
                , GCO_CHARACTERIZATION3_ID
                , GCO_CHARACTERIZATION4_ID
                , GCO_CHARACTERIZATION5_ID
                , STM_STOCK_ID
                , STM_STM_STOCK_ID
                , PAC_SUPPLIER_PARTNER_ID
                , DOC_GAUGE_ID
                , DOC_RECORD_ID
                , C_PREFIX_PROP
                , GCO_GOOD_ID
                , STM_LOCATION_ID
                , STM_STM_LOCATION_ID
                , FDP_CHARACTERIZATION_VALUE_1
                , FDP_CHARACTERIZATION_VALUE_2
                , FDP_CHARACTERIZATION_VALUE_3
                , FDP_CHARACTERIZATION_VALUE_4
                , FDP_CHARACTERIZATION_VALUE_5
                , FDP_BASIS_QTY
                , FDP_INTERMEDIATE_QTY
                , FDP_FINAL_QTY
                , FDP_BASIS_DELAY
                , FDP_INTERMEDIATE_DELAY
                , FDP_FINAL_DELAY
                , FDP_NUMBER
                , FDP_SECOND_REF
                , FDP_PSHORT_DESCR
                , FAL_SUPPLY_REQUEST_ID
                , FDP_TEXTE
                , FDP_CONVERT_FACTOR
                , FAL_PIC_ID
                , FDP_CONSULT
                , FDP_DATE_CONSULT
                , FAL_PIC_LINE_ID
                , DIC_DOC_PROP_FREE_ID
                , STM_DISTRIBUTION_UNIT_ID
                , STM_STM_DISTRIBUTION_UNIT_ID
                , C_DRP_QTY_RULE
                , STM_STOCK_MOVEMENT_ID
                , FDP_DRP_BALANCE_QUANTITY
                , C_DRP_DOC_MODE
                , FDP_DRP_QUANTITY
                , FDP_DRP_BALANCED
  on FAL_DOC_PROP
  referencing old as old new as new
  for each row
declare
  aNew FAL_DOC_PROP%rowtype;
  aOLd FAL_DOC_PROP%rowtype;
begin
  aNEW.FAL_DOC_PROP_ID               := :new.FAL_DOC_PROP_ID;
  aNEW.GCO_CHARACTERIZATION1_ID      := :new.GCO_CHARACTERIZATION1_ID;
  aNEW.GCO_CHARACTERIZATION2_ID      := :new.GCO_CHARACTERIZATION2_ID;
  aNEW.GCO_CHARACTERIZATION3_ID      := :new.GCO_CHARACTERIZATION2_ID;
  aNEW.GCO_CHARACTERIZATION4_ID      := :new.GCO_CHARACTERIZATION4_ID;
  aNEW.GCO_CHARACTERIZATION5_ID      := :new.GCO_CHARACTERIZATION5_ID;
  aNEW.STM_STOCK_ID                  := :new.STM_STOCK_ID;
  aNEW.STM_STM_STOCK_ID              := :new.STM_STM_STOCK_ID;
  aNEW.PAC_SUPPLIER_PARTNER_ID       := :new.PAC_SUPPLIER_PARTNER_ID;
  aNEW.DOC_GAUGE_ID                  := :new.DOC_GAUGE_ID;
  aNEW.DOC_RECORD_ID                 := :new.DOC_RECORD_ID;
  aNEW.C_PREFIX_PROP                 := :new.C_PREFIX_PROP;
  aNEW.GCO_GOOD_ID                   := :new.GCO_GOOD_ID;
  aNEW.STM_LOCATION_ID               := :new.STM_LOCATION_ID;
  aNEW.STM_STM_LOCATION_ID           := :new.STM_STM_LOCATION_ID;
  aNEW.FDP_CHARACTERIZATION_VALUE_1  := :new.FDP_CHARACTERIZATION_VALUE_1;
  aNEW.FDP_CHARACTERIZATION_VALUE_2  := :new.FDP_CHARACTERIZATION_VALUE_2;
  aNEW.FDP_CHARACTERIZATION_VALUE_3  := :new.FDP_CHARACTERIZATION_VALUE_3;
  aNEW.FDP_CHARACTERIZATION_VALUE_4  := :new.FDP_CHARACTERIZATION_VALUE_4;
  aNEW.FDP_CHARACTERIZATION_VALUE_5  := :new.FDP_CHARACTERIZATION_VALUE_5;
  aNEW.FDP_BASIS_QTY                 := :new.FDP_BASIS_QTY;
  aNEW.FDP_INTERMEDIATE_QTY          := :new.FDP_INTERMEDIATE_QTY;
  aNEW.FDP_FINAL_QTY                 := :new.FDP_FINAL_QTY;
  aNEW.FDP_BASIS_DELAY               := :new.FDP_BASIS_DELAY;
  aNEW.FDP_INTERMEDIATE_DELAY        := :new.FDP_INTERMEDIATE_DELAY;
  aNEW.FDP_FINAL_DELAY               := :new.FDP_FINAL_DELAY;
  aNEW.FDP_NUMBER                    := :new.FDP_NUMBER;
  aNEW.FDP_SECOND_REF                := :new.FDP_SECOND_REF;
  aNEW.FDP_PSHORT_DESCR              := :new.FDP_PSHORT_DESCR;
  aNEW.A_DATECRE                     := :new.A_DATECRE;
  aNEW.A_DATEMOD                     := :new.A_DATEMOD;
  aNEW.A_IDCRE                       := :new.A_IDCRE;
  aNEW.A_IDMOD                       := :new.A_IDMOD;
  aNEW.A_RECLEVEL                    := :new.A_RECLEVEL;
  aNEW.A_RECSTATUS                   := :new.A_RECSTATUS;
  aNEW.A_CONFIRM                     := :new.A_CONFIRM;
  aNEW.FAL_SUPPLY_REQUEST_ID         := :new.FAL_SUPPLY_REQUEST_ID;
  aNEW.FDP_TEXTE                     := :new.FDP_TEXTE;
  aNEW.FDP_CONVERT_FACTOR            := :new.FDP_CONVERT_FACTOR;
  aNEW.FAL_PIC_ID                    := :new.FAL_PIC_ID;
  aNEW.FDP_CONSULT                   := :new.FDP_CONSULT;
  aNEW.FDP_DATE_CONSULT              := :new.FDP_DATE_CONSULT;
  aNEW.FDP_SELECT                    := :new.FDP_SELECT;
  aNEW.FDP_SESSION_VALUE             := :new.FDP_SESSION_VALUE;
  aNEW.FAL_PIC_LINE_ID               := :new.FAL_PIC_LINE_ID;
  aNEW.DIC_DOC_PROP_FREE_ID          := :new.DIC_DOC_PROP_FREE_ID;
  aNEW.FDP_ORACLE_SESSION            := :new.FDP_ORACLE_SESSION;
  aNEW.STM_DISTRIBUTION_UNIT_ID      := :new.STM_DISTRIBUTION_UNIT_ID;
  aNEW.STM_STM_DISTRIBUTION_UNIT_ID  := :new.STM_STM_DISTRIBUTION_UNIT_ID;
  aNEW.C_DRP_QTY_RULE                := :new.C_DRP_QTY_RULE;
  aNEW.STM_STOCK_MOVEMENT_ID         := :new.STM_STOCK_MOVEMENT_ID;
  aNEW.FDP_DRP_BALANCE_QUANTITY      := :new.FDP_DRP_BALANCE_QUANTITY;
  aNEW.C_DRP_DOC_MODE                := :new.C_DRP_DOC_MODE;
  aNEW.FDP_DRP_QUANTITY              := :new.FDP_DRP_QUANTITY;
  aNEW.FDP_DRP_BALANCED              := :new.FDP_DRP_BALANCED;
  aOLD.FAL_DOC_PROP_ID               := :old.FAL_DOC_PROP_ID;
  aOLD.GCO_CHARACTERIZATION1_ID      := :old.GCO_CHARACTERIZATION1_ID;
  aOLD.GCO_CHARACTERIZATION2_ID      := :old.GCO_CHARACTERIZATION2_ID;
  aOLD.GCO_CHARACTERIZATION3_ID      := :old.GCO_CHARACTERIZATION2_ID;
  aOLD.GCO_CHARACTERIZATION4_ID      := :old.GCO_CHARACTERIZATION4_ID;
  aOLD.GCO_CHARACTERIZATION5_ID      := :old.GCO_CHARACTERIZATION5_ID;
  aOLD.STM_STOCK_ID                  := :old.STM_STOCK_ID;
  aOLD.STM_STM_STOCK_ID              := :old.STM_STM_STOCK_ID;
  aOLD.PAC_SUPPLIER_PARTNER_ID       := :old.PAC_SUPPLIER_PARTNER_ID;
  aOLD.DOC_GAUGE_ID                  := :old.DOC_GAUGE_ID;
  aOLD.DOC_RECORD_ID                 := :old.DOC_RECORD_ID;
  aOLD.C_PREFIX_PROP                 := :old.C_PREFIX_PROP;
  aOLD.GCO_GOOD_ID                   := :old.GCO_GOOD_ID;
  aOLD.STM_LOCATION_ID               := :old.STM_LOCATION_ID;
  aOLD.STM_STM_LOCATION_ID           := :old.STM_STM_LOCATION_ID;
  aOLD.FDP_CHARACTERIZATION_VALUE_1  := :old.FDP_CHARACTERIZATION_VALUE_1;
  aOLD.FDP_CHARACTERIZATION_VALUE_2  := :old.FDP_CHARACTERIZATION_VALUE_2;
  aOLD.FDP_CHARACTERIZATION_VALUE_3  := :old.FDP_CHARACTERIZATION_VALUE_3;
  aOLD.FDP_CHARACTERIZATION_VALUE_4  := :old.FDP_CHARACTERIZATION_VALUE_4;
  aOLD.FDP_CHARACTERIZATION_VALUE_5  := :old.FDP_CHARACTERIZATION_VALUE_5;
  aOLD.FDP_BASIS_QTY                 := :old.FDP_BASIS_QTY;
  aOLD.FDP_INTERMEDIATE_QTY          := :old.FDP_INTERMEDIATE_QTY;
  aOLD.FDP_FINAL_QTY                 := :old.FDP_FINAL_QTY;
  aOLD.FDP_BASIS_DELAY               := :old.FDP_BASIS_DELAY;
  aOLD.FDP_INTERMEDIATE_DELAY        := :old.FDP_INTERMEDIATE_DELAY;
  aOLD.FDP_FINAL_DELAY               := :old.FDP_FINAL_DELAY;
  aOLD.FDP_NUMBER                    := :old.FDP_NUMBER;
  aOLD.FDP_SECOND_REF                := :old.FDP_SECOND_REF;
  aOLD.FDP_PSHORT_DESCR              := :old.FDP_PSHORT_DESCR;
  aOLD.A_DATECRE                     := :old.A_DATECRE;
  aOLD.A_DATEMOD                     := :old.A_DATEMOD;
  aOLD.A_IDCRE                       := :old.A_IDCRE;
  aOLD.A_IDMOD                       := :old.A_IDMOD;
  aOLD.A_RECLEVEL                    := :old.A_RECLEVEL;
  aOLD.A_RECSTATUS                   := :old.A_RECSTATUS;
  aOLD.A_CONFIRM                     := :old.A_CONFIRM;
  aOLD.FAL_SUPPLY_REQUEST_ID         := :old.FAL_SUPPLY_REQUEST_ID;
  aOLD.FDP_TEXTE                     := :old.FDP_TEXTE;
  aOLD.FDP_CONVERT_FACTOR            := :old.FDP_CONVERT_FACTOR;
  aOLD.FAL_PIC_ID                    := :old.FAL_PIC_ID;
  aOLD.FDP_CONSULT                   := :old.FDP_CONSULT;
  aOLD.FDP_DATE_CONSULT              := :old.FDP_DATE_CONSULT;
  aOLD.FDP_SELECT                    := :old.FDP_SELECT;
  aOLD.FDP_SESSION_VALUE             := :old.FDP_SESSION_VALUE;
  aOLD.FAL_PIC_LINE_ID               := :old.FAL_PIC_LINE_ID;
  aOLD.DIC_DOC_PROP_FREE_ID          := :old.DIC_DOC_PROP_FREE_ID;
  aOLD.FDP_ORACLE_SESSION            := :old.FDP_ORACLE_SESSION;
  aOLD.STM_DISTRIBUTION_UNIT_ID      := :old.STM_DISTRIBUTION_UNIT_ID;
  aOLD.STM_STM_DISTRIBUTION_UNIT_ID  := :old.STM_STM_DISTRIBUTION_UNIT_ID;
  aOLD.C_DRP_QTY_RULE                := :old.C_DRP_QTY_RULE;
  aOLD.STM_STOCK_MOVEMENT_ID         := :old.STM_STOCK_MOVEMENT_ID;
  aOLD.FDP_DRP_BALANCE_QUANTITY      := :old.FDP_DRP_BALANCE_QUANTITY;
  aOLD.C_DRP_DOC_MODE                := :old.C_DRP_DOC_MODE;
  aOLD.FDP_DRP_QUANTITY              := :old.FDP_DRP_QUANTITY;
  aOLD.FDP_DRP_BALANCED              := :old.FDP_DRP_BALANCED;
  FAL_NETWORk_DOC.ReseauBesoinPropositionMAJ_POA(aNew, aOld);
  FAL_NETWORk_DOC.ReseauApproPropositionMAJ_POA(aNew, aOld);
end FAL_DOC_PROP_AU;

ALTER TRIGGER "C_ITX"."FAL_DOC_PROP_AU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FAC_AIU_FAL_POSITION"
  after insert or update of fac_is_operator, fac_reference
  on fal_factory_floor
  referencing old as old new as new
  for each row
/*----------------------------------------------
 Createur : Cassis Emmanuel .
 Date     : 26/03/2003 ;
 Objet    : Création d'un poste de pesée pour chaque Atelier non opérateur
----------------------------------------------*/
declare
  auto_update       varchar2(255);
  vvaliddescription fal_position.fpo_description%type;
  lnPositionID      FAL_POSITION.FAL_POSITION_ID%type;
begin
  select nvl(pcs.pc_config.getconfig('FAL_AUTO_UPDATE_POSITION'), '0')
    into auto_update
    from dual;

  if auto_update = '1' then
    -- On récupère une description unique poour le poste
    vvaliddescription  := FAL_I_LIB_POSITION.GetValidPositionDescr(:new.fac_reference);

    if updating then
      -- Si changement du status "Opérateur" de la ressource, création ou destruction de poste.
      if     (   :old.fac_is_operator = 0
              or :old.fac_is_person = 0)
         and (   :new.fac_is_operator = 1
              or :new.fac_is_person = 1) then
        delete from fal_position
              where fal_factory_floor_id = :old.fal_factory_floor_id;
      elsif     (   :old.fac_is_operator = 1
                 or :old.fac_is_person = 1)
            and (    :new.fac_is_operator = 0
                 and :new.fac_is_person = 0) then
        -- Création de la position
        FAL_I_PRC_POSITION.createPosition(ivFpoDescription      => vvaliddescription
                                        , inFalFactoryFloorID   => :new.fal_factory_floor_id
                                        , onFalPositionID       => lnPositionID
                                         );
      end if;

      -- Si modification de la référence sur la ressource, alors changement sur le poste
      if     :new.fac_is_operator <> 1
         and :new.fac_is_person <> 1
         and :old.fac_reference <> :new.fac_reference then
        update fal_position
           set fpo_description = vvaliddescription
             , a_datemod = sysdate
             , a_idmod = pcs.PC_I_LIB_SESSION.getuserini
         where fal_factory_floor_id = :new.fal_factory_floor_id;
      end if;
    elsif inserting then
      if     :new.fac_is_operator <> 1
         and :new.fac_is_person <> 1 then
        -- Création de la position
        FAL_I_PRC_POSITION.createPosition(ivFpoDescription      => vvaliddescription
                                        , inFalFactoryFloorID   => :new.fal_factory_floor_id
                                        , onFalPositionID       => lnPositionID
                                         );
      end if;
    end if;
  end if;
end fal_fac_aiu_fal_position;

ALTER TRIGGER "C_ITX"."FAL_FAC_AIU_FAL_POSITION" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FAC_AIU_REPLICATE"
  after insert or update
  on FAL_FACTORY_FLOOR
  referencing old as old new as new
  for each row
/**
 * Replication for table "Workshop"
 * @author spfister
 * @date 02/2013
 * Modifications:
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FAL_TRIGGERS') = 1) then
    if (Nvl(:old.PAC_CALENDAR_TYPE_ID,0) <> Nvl(:new.PAC_CALENDAR_TYPE_ID,0)) or
       (Nvl(:old.FAL_FAL_FACTORY_FLOOR_ID,0) <> Nvl(:new.FAL_FAL_FACTORY_FLOOR_ID,0)) or
       (Nvl(:old.ACS_CDA_ACCOUNT_ID,0) <> Nvl(:new.ACS_CDA_ACCOUNT_ID,0)) or
       (Nvl(:old.HRM_PERSON_ID,0) <> Nvl(:new.HRM_PERSON_ID,0)) or
       (Nvl(:old.GAL_COST_CENTER_ID,0) <> Nvl(:new.GAL_COST_CENTER_ID,0)) or
       (Nvl(:old.PAC_SCHEDULE_ID,0) <> Nvl(:new.PAC_SCHEDULE_ID,0)) or
       (Nvl(:old.FAL_GRP_FACTORY_FLOOR_ID,0) <> Nvl(:new.FAL_GRP_FACTORY_FLOOR_ID,0)) or
       (Nvl(:old.FAM_FIXED_ASSETS_ID,0) <> Nvl(:new.FAM_FIXED_ASSETS_ID,0)) or
       (Nvl(:old.DIC_FLOOR_FREE_CODE_ID,' ') <> Nvl(:new.DIC_FLOOR_FREE_CODE_ID,' ')) or
       (Nvl(:old.DIC_FLOOR_FREE_CODE2_ID,' ') <> Nvl(:new.DIC_FLOOR_FREE_CODE2_ID,' ')) or
       (Nvl(:old.FAC_REFERENCE,' ') <> Nvl(:new.FAC_REFERENCE,' ')) or
       (Nvl(:old.FAC_DESCRIBE,' ') <> Nvl(:new.FAC_DESCRIBE,' ')) or
       (Nvl(:old.FAC_RESOURCE_NUMBER,0) <> Nvl(:new.FAC_RESOURCE_NUMBER,0)) or
       (Nvl(:old.C_TEAM,' ') <> Nvl(:new.C_TEAM,' ')) or
       (Nvl(:old.FAC_PIC,0) <> Nvl(:new.FAC_PIC,0)) or
       (Nvl(:old.FAC_IS_MACHINE,0) <> Nvl(:new.FAC_IS_MACHINE,0)) or
       (Nvl(:old.FAC_INFINITE_FLOOR,0) <> Nvl(:new.FAC_INFINITE_FLOOR,0)) or
       (Nvl(:old.DIC_FLOOR_FREE_CODE3_ID,' ') <> Nvl(:new.DIC_FLOOR_FREE_CODE3_ID,' ')) or
       (Nvl(:old.DIC_FLOOR_FREE_CODE4_ID,' ') <> Nvl(:new.DIC_FLOOR_FREE_CODE4_ID,' ')) or
       (Nvl(:old.DIC_FLOOR_FREE_CODE5_ID,' ') <> Nvl(:new.DIC_FLOOR_FREE_CODE5_ID,' ')) or
       (Nvl(:old.DIC_FLOOR_FREE_CODE6_ID,' ') <> Nvl(:new.DIC_FLOOR_FREE_CODE6_ID,' ')) or
       (Nvl(:old.DIC_FLOOR_FREE_CODE7_ID,' ') <> Nvl(:new.DIC_FLOOR_FREE_CODE7_ID,' ')) or
       (Nvl(:old.DIC_FLOOR_FREE_CODE8_ID,' ') <> Nvl(:new.DIC_FLOOR_FREE_CODE8_ID,' ')) or
       (Nvl(:old.DIC_FLOOR_FREE_CODE9_ID,' ') <> Nvl(:new.DIC_FLOOR_FREE_CODE9_ID,' ')) or
       (Nvl(:old.DIC_FLOOR_FREE_CODE10_ID,' ') <> Nvl(:new.DIC_FLOOR_FREE_CODE10_ID,' ')) or
       (Nvl(:old.FAC_ALPHA01,' ') <> Nvl(:new.FAC_ALPHA01,' ')) or
       (Nvl(:old.FAC_ALPHA02,' ') <> Nvl(:new.FAC_ALPHA02,' ')) or
       (Nvl(:old.FAC_ALPHA03,' ') <> Nvl(:new.FAC_ALPHA03,' ')) or
       (Nvl(:old.FAC_ALPHA04,' ') <> Nvl(:new.FAC_ALPHA04,' ')) or
       (Nvl(:old.FAC_ALPHA05,' ') <> Nvl(:new.FAC_ALPHA05,' ')) or
       (Nvl(:old.FAC_ALPHA06,' ') <> Nvl(:new.FAC_ALPHA06,' ')) or
       (Nvl(:old.FAC_ALPHA07,' ') <> Nvl(:new.FAC_ALPHA07,' ')) or
       (Nvl(:old.FAC_ALPHA08,' ') <> Nvl(:new.FAC_ALPHA08,' ')) or
       (Nvl(:old.FAC_ALPHA09,' ') <> Nvl(:new.FAC_ALPHA09,' ')) or
       (Nvl(:old.FAC_ALPHA10,' ') <> Nvl(:new.FAC_ALPHA10,' ')) or
       (Nvl(:old.FAC_UPDATE_LMU,0) <> Nvl(:new.FAC_UPDATE_LMU,0)) or
       (Nvl(:old.FAC_OUT_OF_ORDER,0) <> Nvl(:new.FAC_OUT_OF_ORDER,0)) or
       (Nvl(:old.FAC_IS_OPERATOR,0) <> Nvl(:new.FAC_IS_OPERATOR,0)) or
       (Nvl(:old.FAC_PIECES_DAY_CAP,0) <> Nvl(:new.FAC_PIECES_DAY_CAP,0)) or
       (Nvl(:old.FAC_PIECES_HOUR_CAP,0) <> Nvl(:new.FAC_PIECES_HOUR_CAP,0)) or
       (Nvl(:old.FAC_IS_PERSON,0) <> Nvl(:new.FAC_IS_PERSON,0)) or
       (Nvl(:old.FAC_IS_BLOCK,0) <> Nvl(:new.FAC_IS_BLOCK,0)) or
       (Nvl(:old.FAC_DAY_CAPACITY,0) <> Nvl(:new.FAC_DAY_CAPACITY,0)) or
       (Nvl(:old.FAC_UNIT_MARGIN_RATE,0) <> Nvl(:new.FAC_UNIT_MARGIN_RATE,0)) then
      rep_functions.PublishFacFloor(:new.FAL_FACTORY_FLOOR_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."FAL_FAC_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FAC_BD_FAL_POSITION"
   BEFORE DELETE
   ON fal_factory_floor
   REFERENCING OLD AS OLD
   FOR EACH ROW
/*--------------------------------------------------------------------------
 Createur : Cassis Emmanuel .
 Date     : 26/03/2003 ;
 Objet    : Création d'un poste de pesée pour chaque Atelier non opérateur
            Si la configuration FAl_AUTO_UPDATE_POSITION = 1
---------------------------------------------------------------------------*/
DECLARE
   auto_update   VARCHAR2 (255);
BEGIN
   SELECT NVL (pcs.pc_config.getconfig ('FAL_AUTO_UPDATE_POSITION'), '0')
     INTO auto_update
     FROM DUAL;

   IF auto_update = '1'
   THEN
      IF :OLD.fac_is_operator <> 1 AND :OLD.fac_is_person <> 1
      THEN
         -- Suppression du poste.
         DELETE FROM fal_position
               WHERE fal_factory_floor_id = :OLD.fal_factory_floor_id;
      END IF;
   END IF;
end fal_fac_bd_fal_position;

ALTER TRIGGER "C_ITX"."FAL_FAC_BD_FAL_POSITION" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FACC_AIU_REPLICATE"
  after insert or update
  on FAL_FACTORY_ACCOUNT
  referencing old as old new as new
  for each row
/**
 * Replication for table "Workshop accounts"
 * @author spfister
 * @date 02/2013
 * Modifications:
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FAL_TRIGGERS') = 1) then
    if (Nvl(:old.FAL_FACTORY_FLOOR_ID,0) <> Nvl(:new.FAL_FACTORY_FLOOR_ID,0)) or
       (Nvl(:old.DOC_RECORD_ID,0) <> Nvl(:new.DOC_RECORD_ID,0)) or
       (Nvl(:old.ACS_CDA_ACCOUNT_ID,0) <> Nvl(:new.ACS_CDA_ACCOUNT_ID,0)) or
       (Nvl(:old.ACS_FINANCIAL_ACCOUNT_ID,0) <> Nvl(:new.ACS_FINANCIAL_ACCOUNT_ID,0)) or
       (Nvl(:old.ACS_DIVISION_ACCOUNT_ID,0) <> Nvl(:new.ACS_DIVISION_ACCOUNT_ID,0)) or
       (Nvl(:old.ACS_CPN_ACCOUNT_ID,0) <> Nvl(:new.ACS_CPN_ACCOUNT_ID,0)) or
       (Nvl(:old.ACS_PF_ACCOUNT_ID,0) <> Nvl(:new.ACS_PF_ACCOUNT_ID,0)) or
       (Nvl(:old.ACS_PJ_ACCOUNT_ID,0) <> Nvl(:new.ACS_PJ_ACCOUNT_ID,0)) or
       (Nvl(:old.ACS_QTY_UNIT_ID,0) <> Nvl(:new.ACS_QTY_UNIT_ID,0)) or
       (Nvl(:old.GAL_COST_CENTER_ID,0) <> Nvl(:new.GAL_COST_CENTER_ID,0)) or
       (Nvl(:old.C_FAL_ENTRY_TYPE,' ') <> Nvl(:new.C_FAL_ENTRY_TYPE,' ')) or
       (Nvl(:old.C_FAL_ENTRY_SIGN,' ') <> Nvl(:new.C_FAL_ENTRY_SIGN,' ')) then
      rep_functions.PublishFacFloor(:new.FAL_FACTORY_FLOOR_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."FAL_FACC_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FACT_FLOOR_BU_GRUPPE"
  before update of FAL_FAL_FACTORY_FLOOR_ID, FAC_INFINITE_FLOOR, FAC_OUT_OF_ORDER
  on FAL_FACTORY_FLOOR
  referencing old as old new as new
  for each row
/**
* Description
*    Gestion des modifications concernant les LMU (Liste des Machines Utilisables - Ortems)
*    - Suppression des LMU pour les ateliers à capacité infini
*    - Suppression des machines dans les LMU au changement d'îlot
*
* @created CLE 09.06.2008
* @version 2003
* @lastUpdate
*/
begin
  -- Si l'atelier est à capacité infini, on supprime les LMU des opérations de gammes et de lot qui passent sur celui-ci
  if     (:new.FAC_INFINITE_FLOOR <> :old.FAC_INFINITE_FLOOR)
     and (nvl(:new.FAC_INFINITE_FLOOR, 0) = 1) then
    delete      FAL_LIST_STEP_USE
          where FAL_SCHEDULE_STEP_ID in(select FAL_SCHEDULE_STEP_ID
                                          from FAL_LIST_STEP_LINK
                                         where FAL_FACTORY_FLOOR_ID = :new.FAL_FACTORY_FLOOR_ID);

    delete      FAL_TASK_LINK_USE
          where FAL_SCHEDULE_STEP_ID in(select FAL_SCHEDULE_STEP_ID
                                          from FAL_TASK_LINK
                                         where FAL_FACTORY_FLOOR_ID = :new.FAL_FACTORY_FLOOR_ID);

    delete      FAL_TASK_LINK_PROP_USE
          where FAL_TASK_LINK_PROP_ID in(select FAL_TASK_LINK_PROP_ID
                                           from FAL_TASK_LINK_PROP
                                          where FAL_FACTORY_FLOOR_ID = :new.FAL_FACTORY_FLOOR_ID);
  end if;

  -- Changement d'îlot ou machine hors service : suppression de la machine des LMU
  if (nvl(:new.FAL_FAL_FACTORY_FLOOR_ID, 0) <> nvl(:old.FAL_FAL_FACTORY_FLOOR_ID, 0) )  or (nvl(:new.FAC_OUT_OF_ORDER, 0) = 1) then
    delete      FAL_LIST_STEP_USE
          where FAL_FACTORY_FLOOR_ID = :new.FAL_FACTORY_FLOOR_ID;

    delete      FAL_TASK_LINK_USE
          where FAL_FACTORY_FLOOR_ID = :new.FAL_FACTORY_FLOOR_ID;

    delete      FAL_TASK_LINK_PROP_USE
          where FAL_FACTORY_FLOOR_ID = :new.FAL_FACTORY_FLOOR_ID;
  end if;
end FAL_FACT_FLOOR_BU_GRUPPE;

ALTER TRIGGER "C_ITX"."FAL_FACT_FLOOR_BU_GRUPPE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FACT_IN_BIU_DENORM_CHAR"
  before insert or update of
      "IN_CHARACTERIZATION_VALUE_1",
      "IN_CHARACTERIZATION_VALUE_2",
      "IN_CHARACTERIZATION_VALUE_3",
      "IN_CHARACTERIZATION_VALUE_4",
      "IN_CHARACTERIZATION_VALUE_5"
  on FAL_FACTORY_IN
  referencing old as old new as new
  for each row
/**
* Description
*    Dénormalisation des caractérisations dans l'événement before insert/update
* @created FP/CLG 04.05.2012 (repris de STM_SPO_BIU_DENORM_CHAR)
* @version 2003
* @lastUpdate
*/
begin
  -- vérifie que les informations ne soient pas déjà données
  if :new.GCO_CHARACTERIZATION_ID is not null then
    -- Mise à jour des champs dénormalisé d'affichage des caractérisations
    GCO_FUNCTIONS.ClassifyCharacterizations(:new.GCO_CHARACTERIZATION_ID
                                          , :new.GCO_GCO_CHARACTERIZATION_ID
                                          , :new.GCO2_GCO_CHARACTERIZATION_ID
                                          , :new.GCO3_GCO_CHARACTERIZATION_ID
                                          , :new.GCO4_GCO_CHARACTERIZATION_ID
                                          , :new.IN_CHARACTERIZATION_VALUE_1
                                          , :new.IN_CHARACTERIZATION_VALUE_2
                                          , :new.IN_CHARACTERIZATION_VALUE_3
                                          , :new.IN_CHARACTERIZATION_VALUE_4
                                          , :new.IN_CHARACTERIZATION_VALUE_5
                                          , :new.IN_PIECE
                                          , :new.IN_LOT
                                          , :new.IN_VERSION
                                          , :new.IN_CHRONOLOGY
                                          , :new.IN_STD_CHAR_1
                                          , :new.IN_STD_CHAR_2
                                          , :new.IN_STD_CHAR_3
                                          , :new.IN_STD_CHAR_4
                                          , :new.IN_STD_CHAR_5
                                           );
  end if;
end FAL_FACT_IN_BIU_DENORM_CHAR;

ALTER TRIGGER "C_ITX"."FAL_FACT_IN_BIU_DENORM_CHAR" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FACT_OUT_BIU_DENORM_CHAR"
  before insert or update of
      "OUT_CHARACTERIZATION_VALUE_1",
      "OUT_CHARACTERIZATION_VALUE_2",
      "OUT_CHARACTERIZATION_VALUE_3",
      "OUT_CHARACTERIZATION_VALUE_4",
      "OUT_CHARACTERIZATION_VALUE_5"
  on FAL_FACTORY_OUT
  referencing old as old new as new
  for each row
/**
* Description
*    Dénormalisation des caractérisations dans l'événement before insert/update
* @created FP/CLG 04.05.2012 (repris de STM_SPO_BIU_DENORM_CHAR)
* @version 2003
* @lastUpdate
*/
begin
  -- vérifie que les informations ne soient pas déjà données
  if :new.GCO_CHARACTERIZATION1_ID is not null then
    -- Mise à jour des champs dénormalisé d'affichage des caractérisations
    GCO_FUNCTIONS.ClassifyCharacterizations(:new.GCO_CHARACTERIZATION1_ID
                                          , :new.GCO_CHARACTERIZATION2_ID
                                          , :new.GCO_CHARACTERIZATION3_ID
                                          , :new.GCO_CHARACTERIZATION4_ID
                                          , :new.GCO_CHARACTERIZATION5_ID
                                          , :new.OUT_CHARACTERIZATION_VALUE_1
                                          , :new.OUT_CHARACTERIZATION_VALUE_2
                                          , :new.OUT_CHARACTERIZATION_VALUE_3
                                          , :new.OUT_CHARACTERIZATION_VALUE_4
                                          , :new.OUT_CHARACTERIZATION_VALUE_5
                                          , :new.OUT_PIECE
                                          , :new.OUT_LOT
                                          , :new.OUT_VERSION
                                          , :new.OUT_CHRONOLOGY
                                          , :new.OUT_STD_CHAR_1
                                          , :new.OUT_STD_CHAR_2
                                          , :new.OUT_STD_CHAR_3
                                          , :new.OUT_STD_CHAR_4
                                          , :new.OUT_STD_CHAR_5
                                           );
  end if;
end FAL_FACT_OUT_BIU_DENORM_CHAR;

ALTER TRIGGER "C_ITX"."FAL_FACT_OUT_BIU_DENORM_CHAR" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FACT_RATE_BU_DECOMP"
before update of
  FFR_RATE1
, FFR_RATE2
, FFR_RATE3
, FFR_RATE4
, FFR_RATE5
on FAL_FACTORY_RATE
referencing old as old new as new
for each row
/**
* Description
*   Reporte la modification des taux sur leur décomposition
*
* @created  ECA 14.01.08
* @version 2003
* @lastUpdate
*/
begin
  -- Taux1
  if UPPER(PCS.PC_CONFIG.GetConfig('FAL_USE_ADV_PRECALCULATION')) = 'YES' then
	  if :new.FFR_RATE1 <> :old.FFR_RATE1 then
	    UPDATE FAL_FACT_RATE_DECOMP
	       SET FRD_VALUE = :New.FFR_RATE1 * FRD_RATE / 100
	     WHERE FAL_FACTORY_RATE_ID = :New.FAL_FACTORY_RATE_ID
	       AND FRD_RATE_NUMBER = 1;
	  end if;

	  -- Taux2
	  if :new.FFR_RATE2 <> :old.FFR_RATE2 then
	    UPDATE FAL_FACT_RATE_DECOMP
	    SET FRD_VALUE = :New.FFR_RATE2 * FRD_RATE / 100
	  WHERE FAL_FACTORY_RATE_ID = :New.FAL_FACTORY_RATE_ID
	    AND FRD_RATE_NUMBER = 2;
	  end if;

	  -- Taux3
	  if :new.FFR_RATE3 <> :old.FFR_RATE3 then
	    UPDATE FAL_FACT_RATE_DECOMP
	    SET FRD_VALUE = :New.FFR_RATE3 * FRD_RATE / 100
	  WHERE FAL_FACTORY_RATE_ID = :New.FAL_FACTORY_RATE_ID
	    AND FRD_RATE_NUMBER = 3;
	  end if;

	  -- Taux4
	  if :new.FFR_RATE4 <> :old.FFR_RATE4 then
	    UPDATE FAL_FACT_RATE_DECOMP
	    SET FRD_VALUE = :New.FFR_RATE4 * FRD_RATE / 100
	  WHERE FAL_FACTORY_RATE_ID = :New.FAL_FACTORY_RATE_ID
	    AND FRD_RATE_NUMBER = 4;
	  end if;

	  -- Taux5
	  if :new.FFR_RATE5 <> :old.FFR_RATE5 then
	    UPDATE FAL_FACT_RATE_DECOMP
	    SET FRD_VALUE = :New.FFR_RATE4 * FRD_RATE / 100
	  WHERE FAL_FACTORY_RATE_ID = :New.FAL_FACTORY_RATE_ID
	    AND FRD_RATE_NUMBER = 4;
	  end if;
  end if;
end FAL_FACT_RATE_BU_DECOMP;

ALTER TRIGGER "C_ITX"."FAL_FACT_RATE_BU_DECOMP" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FAD_AIUD_ELEMENT_NUMBER"
  after insert or delete or update of "FAD_CHARACTERIZATION_VALUE_1"
                                    , "FAD_CHARACTERIZATION_VALUE_2"
                                    , "FAD_CHARACTERIZATION_VALUE_3"
                                    , "FAD_CHARACTERIZATION_VALUE_4"
                                    , "FAD_CHARACTERIZATION_VALUE_5"
  on FAL_LOT_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Maj element number lors de l'effacement d'un detail LOT
* @created fp 21.01.2003
* @version 2003
* @lastUpdate fp 05.07.2005
*/
declare
  vMovementSort     STM_MOVEMENT_KIND.C_MOVEMENT_SORT%type;
  vElementNumberID1 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBEr_ID%type;
  vElementNumberID2 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBEr_ID%type;
  vElementNumberID3 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBEr_ID%type;
  lQualityStatusId  STM_ELEMENT_NUMBER.GCO_QUALITY_STATUS_ID%type;
  updateMode        varchar2(2);
  aC_LOT_STATUS     FAL_LOT.C_LOT_STATUS%type;
begin
  -- si on est pas en mode maintenance, on vérifie que le bien incriminé ne soit pas déjà utilisé
  if GCO_CHARACTERIZATION_FUNCTIONS.gCharManagementMode = 0 then
    -- si on a au moins une caractérization
    if nvl(:new.GCO_CHARACTERIZATION_ID, :old.GCO_CHARACTERIZATION_ID) is not null then
      -- Reception PT => Entrée en stock
      vMovementSort  := 'ENT';

      -- En éffacement il ne faut pas qu'il y ait déjà eu une réception sur ce détai lot
      if deleting then
        if nvl(:old.FAD_RECEPT_QTY, 0) > 0 then
          select C_LOT_STATUS
            into aC_LOT_STATUS
            from FAl_LOT
           where FAl_LOT_ID = :old.FAL_LOT_ID;

          -- Si le lot est planifié ou lancé alors Interdire la suppression
          if    aC_LOT_STATUS = '1'
             or aC_LOT_STATUS = '2' then
            Raise_application_error(-20001, 'You can''t delete this items, Recept quantity must be zero on this item.');
          end if;
        end if;
      end if;

      -- En modification interdire le changement de valeur de caractérisations si des Qtés sur
      -- ce détail ont déjà été réceptionnées.
      if updating then
        if     (   nvl(:new.FAD_CHARACTERIZATION_VALUE_1, '') <> nvl(:old.FAD_CHARACTERIZATION_VALUE_1, '')
                or nvl(:new.FAD_CHARACTERIZATION_VALUE_2, '') <> nvl(:old.FAD_CHARACTERIZATION_VALUE_2, '')
                or nvl(:new.FAD_CHARACTERIZATION_VALUE_3, '') <> nvl(:old.FAD_CHARACTERIZATION_VALUE_3, '')
                or nvl(:new.FAD_CHARACTERIZATION_VALUE_4, '') <> nvl(:old.FAD_CHARACTERIZATION_VALUE_4, '')
                or nvl(:new.FAD_CHARACTERIZATION_VALUE_5, '') <> nvl(:old.FAD_CHARACTERIZATION_VALUE_5, '')
               )
           and nvl(:old.FAD_RECEPT_QTY, 0) > 0 then
          -- Interdire la modification
          Raise_application_error(-20001, 'You can''t modify caracterization values on this items, Recept quantity must be zero on this item.');
        end if;
      end if;

      -- En effacement et en modification, traitement des anciennes valeurs
      if    deleting
         or updating then
        -- Détermine si on est en train d'archiver
        if     deleting
           and (:old.FAD_RECEPT_QTY + :old.FAD_CANCEL_QTY = :old.FAD_QTY)
           and :old.FAD_QTY <> 0 then
          updateMode  := 'DA';   -- mode effacement pour archivage
        else
          updateMode  := 'D';   -- effacement standard
        end if;

        -- Maj STM_ELEMENT_NUMBER en mode suppression
        STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => :old.GCO_GOOD_ID   /* Bien */
                                                , iUpdateMode               => updateMode   /* Mode de mise à jour */
                                                , iMovementSort             => vMovementSort   /* Type de mouvement 'ENT' = Entrée 'SOR' = Sortie */
                                                , iCharacterizationId       => :old.GCO_CHARACTERIZATION_ID   /* Caractérisation 1 */
                                                , iCharacterization2Id      => :old.GCO_GCO_CHARACTERIZATION_ID   /* Caractérisation 2 */
                                                , iCharacterization3Id      => :old.GCO2_GCO_CHARACTERIZATION_ID   /* Caractérisation 3 */
                                                , iCharacterization4Id      => :old.GCO3_GCO_CHARACTERIZATION_ID   /* Caractérisation 4 */
                                                , iCharacterization5Id      => :old.GCO4_GCO_CHARACTERIZATION_ID   /* Caractérisation 5 */
                                                , iCharacterizationValue1   => :old.FAD_CHARACTERIZATION_VALUE_1   /* Valeur de caractérisation 1 */
                                                , iCharacterizationValue2   => :old.FAD_CHARACTERIZATION_VALUE_2   /* Valeur de caractérisation 2 */
                                                , iCharacterizationValue3   => :old.FAD_CHARACTERIZATION_VALUE_3   /* Valeur de caractérisation 3 */
                                                , iCharacterizationValue4   => :old.FAD_CHARACTERIZATION_VALUE_4   /* Valeur de caractérisation 4 */
                                                , iCharacterizationValue5   => :old.FAD_CHARACTERIZATION_VALUE_5   /* Valeur de caractérisation 5 */
                                                , iVerifyChar               => 1   /* Vérification de l'unicité des valeurs de caract. */
                                                , iElementStatus            => null   /* Statut de l'élement après mise à jour */
                                                , ioElementNumberId1        => vElementNumberID1   /* Elément 1 en sortie */
                                                , ioElementNumberId2        => vElementNumberID2   /* Elément 2 en sortie */
                                                , ioElementNumberId3        => vElementNumberID3   /* Elément 3 en sortie */
                                                , ioQualityStatusId         => lQualityStatusId
                                                 );
      end if;

      -- En création et en modification, traitement des nouvelles valeurs
      if    inserting
         or updating then
        -- Maj STM_ELEMENT_NUMBER en mode insertion
        STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => :new.GCO_GOOD_ID   /* Bien */
                                                , iUpdateMode               => 'I'   /* Mode de mise à jour */
                                                , iMovementSort             => vMovementSort   /* Type de mouvement 'ENT' = Entrée 'SOR' = Sortie */
                                                , iCharacterizationId       => :new.GCO_CHARACTERIZATION_ID   /* Caractérisation 1 */
                                                , iCharacterization2Id      => :new.GCO_GCO_CHARACTERIZATION_ID   /* ... */
                                                , iCharacterization3Id      => :new.GCO2_GCO_CHARACTERIZATION_ID   /* ... */
                                                , iCharacterization4Id      => :new.GCO3_GCO_CHARACTERIZATION_ID   /* ... */
                                                , iCharacterization5Id      => :new.GCO4_GCO_CHARACTERIZATION_ID   /* ... */
                                                , iCharacterizationValue1   => :new.FAD_CHARACTERIZATION_VALUE_1   /* Valeur de caractérisation 1 */
                                                , iCharacterizationValue2   => :new.FAD_CHARACTERIZATION_VALUE_2   /* Valeur de caractérisation 2 */
                                                , iCharacterizationValue3   => :new.FAD_CHARACTERIZATION_VALUE_3   /* Valeur de caractérisation 3 */
                                                , iCharacterizationValue4   => :new.FAD_CHARACTERIZATION_VALUE_4   /* Valeur de caractérisation 4 */
                                                , iCharacterizationValue5   => :new.FAD_CHARACTERIZATION_VALUE_5   /* Valeur de caractérisation 5 */
                                                , iVerifyChar               => 1   /* Vérification de l'unicité des valeurs de caract. */
                                                , iElementStatus            => null   /* Statut de l'élement après mise à jour */
                                                , ioElementNumberId1        => vElementNumberID1   /* Elément 1 en sortie */
                                                , ioElementNumberId2        => vElementNumberID2   /* Elément 2 en sortie */
                                                , ioElementNumberId3        => vElementNumberID3   /* Elément 3 en sortie */
                                                , ioQualityStatusId         => lQualityStatusId
                                                 );
      end if;
    end if;
  end if;
end FAL_FAD_AIUD_ELEMENT_NUMBER;

ALTER TRIGGER "C_ITX"."FAL_FAD_AIUD_ELEMENT_NUMBER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FAD_BI_GALEI"
  before insert
  on FAL_LOT_PROP
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour du dossier de la proposition d'ordre de fabrication en fonction du dossier de la demande
*    d'approvisionnement
*
*    1. La proposition d'ordre de fabrication ne doit pas possèder de dossier
*    2. Une demande d'approvisionnement doit être associée à la proposition d'ordre de fabrication
*    3. Un dossier doit être associé à la demande d'approvisionnement
*
* @author VJ
* @created 16/02/2005
* @version 2003
*/
declare
  nResult     number;
  docRecordID DOC_RECORD.DOC_RECORD_ID%type;
begin
  if     :new.FAL_SUPPLY_REQUEST_ID is not null
     and :new.DOC_RECORD_ID is null then
    begin
      select RCO.DOC_RECORD_ID
        into docRecordID
        from DOC_RECORD RCO
           , FAL_SUPPLY_REQUEST FSR
       where FSR.FAL_SUPPLY_REQUEST_ID = :new.FAL_SUPPLY_REQUEST_ID
         and RCO.DOC_RECORD_ID = FSR.DOC_RECORD_ID
         and RCO.GAL_TASK_ID is not null;
    exception
      when no_data_found then
        docRecordID  := null;
    end;

    if docRecordID is not null then
      :new.DOC_RECORD_ID  := docRecordID;
    end if;
  end if;
end FAL_FAD_BI_GALEI;

ALTER TRIGGER "C_ITX"."FAL_FAD_BI_GALEI" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FAD_BIU_DENORM_CHAR"
  before insert or update of "FAD_CHARACTERIZATION_VALUE_1"
                           , "FAD_CHARACTERIZATION_VALUE_2"
                           , "FAD_CHARACTERIZATION_VALUE_3"
                           , "FAD_CHARACTERIZATION_VALUE_4"
                           , "FAD_CHARACTERIZATION_VALUE_5"
  on FAL_LOT_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*    Dénormalisation des caractérisations dans l'événement before insert
* @created fp 29.01.2003
* @version 2003
* @lastUpdate fp 28.10.2003
*/
declare
  charValue1  FAL_LOT_DETAIL.FAD_CHARACTERIZATION_VALUE_1%type;
  charValue2  FAL_LOT_DETAIL.FAD_CHARACTERIZATION_VALUE_2%type;
  charValue3  FAL_LOT_DETAIL.FAD_CHARACTERIZATION_VALUE_3%type;
  charValue4  FAL_LOT_DETAIL.FAD_CHARACTERIZATION_VALUE_4%type;
  charValue5  FAL_LOT_DETAIL.FAD_CHARACTERIZATION_VALUE_5%type;
  charChronos FAL_LOT_DETAIL.FAD_CHARACTERIZATION_VALUE_1%type;
begin
  :new.FAD_CHARACTERIZATION_VALUE_1  := CleanStr(:new.FAD_CHARACTERIZATION_VALUE_1);
  :new.FAD_CHARACTERIZATION_VALUE_2  := CleanStr(:new.FAD_CHARACTERIZATION_VALUE_2);
  :new.FAD_CHARACTERIZATION_VALUE_3  := CleanStr(:new.FAD_CHARACTERIZATION_VALUE_3);
  :new.FAD_CHARACTERIZATION_VALUE_4  := CleanStr(:new.FAD_CHARACTERIZATION_VALUE_4);
  :new.FAD_CHARACTERIZATION_VALUE_5  := CleanStr(:new.FAD_CHARACTERIZATION_VALUE_5);

  -- vérifie qu'on ait au moins une caractérisation
  if :new.GCO_CHARACTERIZATION_ID is not null then
    -- Mise à jour des champs dénormalisé d'affichage des caractérisations
    GCO_I_LIB_CHARACTERIZATION.ClassifyCharacterizations(:new.GCO_CHARACTERIZATION_ID
                                          , :new.GCO_GCO_CHARACTERIZATION_ID
                                          , :new.GCO2_GCO_CHARACTERIZATION_ID
                                          , :new.GCO3_GCO_CHARACTERIZATION_ID
                                          , :new.GCO4_GCO_CHARACTERIZATION_ID
                                          , :new.FAD_CHARACTERIZATION_VALUE_1
                                          , :new.FAD_CHARACTERIZATION_VALUE_2
                                          , :new.FAD_CHARACTERIZATION_VALUE_3
                                          , :new.FAD_CHARACTERIZATION_VALUE_4
                                          , :new.FAD_CHARACTERIZATION_VALUE_5
                                          , :new.FAD_PIECE
                                          , :new.FAD_LOT_CHARACTERIZATION
                                          , :new.FAD_VERSION
                                          , :new.FAD_CHRONOLOGY
                                          , :new.FAD_STD_CHAR_1
                                          , :new.FAD_STD_CHAR_2
                                          , :new.FAD_STD_CHAR_3
                                          , :new.FAD_STD_CHAR_4
                                          , :new.FAD_STD_CHAR_5
                                           );

    if    (    nvl(:new.GCO_CHARACTERIZATION_ID, 0) <> 0
           and nvl(:new.FAD_CHARACTERIZATION_VALUE_1, ' ') = ' ')
       or (    nvl(:new.GCO_GCO_CHARACTERIZATION_ID, 0) <> 0
           and nvl(:new.FAD_CHARACTERIZATION_VALUE_2, ' ') = ' ')
       or (    nvl(:new.GCO2_GCO_CHARACTERIZATION_ID, 0) <> 0
           and nvl(:new.FAD_CHARACTERIZATION_VALUE_3, ' ') = ' ')
       or (    nvl(:new.GCO3_GCO_CHARACTERIZATION_ID, 0) <> 0
           and nvl(:new.FAD_CHARACTERIZATION_VALUE_4, ' ') = ' ')
       or (    nvl(:new.GCO4_GCO_CHARACTERIZATION_ID, 0) <> 0
           and nvl(:new.FAD_CHARACTERIZATION_VALUE_5, ' ') = ' ') then
      :new.A_CONFIRM  := 1;
    else
      :new.A_CONFIRM  := null;
    end if;
  end if;
end FAL_FAD_BIU_DENORM_CHAR;

ALTER TRIGGER "C_ITX"."FAL_FAD_BIU_DENORM_CHAR" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FAI_BD_INIT_DELETE"
BEFORE DELETE
ON FAL_ALLOY_INVENTORY
REFERENCING OLD as OLD NEW as NEW
FOR EACH ROW
/*----------------------------------------------
 Createur : Cassis Emmanuel .
 Date     : 26/03/2003 ;
 Objet    : Suppression des lignes d'inventaire
 					  par alliage
----------------------------------------------*/
BEGIN
  DELETE FROM FAL_LINE_INVENTORY
	WHERE FAL_ALLOY_INVENTORY_ID = :OLD.FAL_ALLOY_INVENTORY_ID;

end FAL_FAI_BD_INIT_DELETE;

ALTER TRIGGER "C_ITX"."FAL_FAI_BD_INIT_DELETE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FANN_BIU_DENORM_CHAR"
  before insert or update of GCO_CHARACTERIZATION1_ID
                           , GCO_CHARACTERIZATION2_ID
                           , GCO_CHARACTERIZATION3_ID
                           , GCO_CHARACTERIZATION4_ID
                           , GCO_CHARACTERIZATION5_ID
                           , FAN_CHAR_VALUE1
                           , FAN_CHAR_VALUE2
                           , FAN_CHAR_VALUE3
                           , FAN_CHAR_VALUE4
                           , FAN_CHAR_VALUE5
  on FAL_NETWORK_NEED
  referencing old as old new as new
  for each row
/**
* Description
*    Dénormalisation des caractérisations dans l'événement before insert/update
* @created 30.05.2005
* @version 2003
* @lastUpdate
*/
begin
  -- on vérifie que ce triggers soit déclenche par une modif d'un des champs ci-dessous
  -- et non pas par un autre trigger instead of
  if    nvl(:old.GCO_CHARACTERIZATION1_ID, -1) <> nvl(:new.GCO_CHARACTERIZATION1_ID, -1)
     or nvl(:old.GCO_CHARACTERIZATION2_ID, -1) <> nvl(:new.GCO_CHARACTERIZATION2_ID, -1)
     or nvl(:old.GCO_CHARACTERIZATION3_ID, -1) <> nvl(:new.GCO_CHARACTERIZATION3_ID, -1)
     or nvl(:old.GCO_CHARACTERIZATION4_ID, -1) <> nvl(:new.GCO_CHARACTERIZATION4_ID, -1)
     or nvl(:old.GCO_CHARACTERIZATION5_ID, -1) <> nvl(:new.GCO_CHARACTERIZATION5_ID, -1)
     or nvl(:old.FAN_CHAR_VALUE1, 'null') <> nvl(:new.FAN_CHAR_VALUE1, 'null')
     or nvl(:old.FAN_CHAR_VALUE2, 'null') <> nvl(:new.FAN_CHAR_VALUE2, 'null')
     or nvl(:old.FAN_CHAR_VALUE3, 'null') <> nvl(:new.FAN_CHAR_VALUE3, 'null')
     or nvl(:old.FAN_CHAR_VALUE4, 'null') <> nvl(:new.FAN_CHAR_VALUE4, 'null')
     or nvl(:old.FAN_CHAR_VALUE5, 'null') <> nvl(:new.FAN_CHAR_VALUE5, 'null') then
    -- vérifie qu'on ait au moins une caractérisation
    if :new.GCO_CHARACTERIZATION1_ID is not null then
      -- Mise à jour des champs dénormalisé d'affichage des caractérisations
      GCO_FUNCTIONS.ClassifyCharacterizations(:new.GCO_CHARACTERIZATION1_ID
                                            , :new.GCO_CHARACTERIZATION2_ID
                                            , :new.GCO_CHARACTERIZATION3_ID
                                            , :new.GCO_CHARACTERIZATION4_ID
                                            , :new.GCO_CHARACTERIZATION5_ID
                                            , :new.FAN_CHAR_VALUE1
                                            , :new.FAN_CHAR_VALUE2
                                            , :new.FAN_CHAR_VALUE3
                                            , :new.FAN_CHAR_VALUE4
                                            , :new.FAN_CHAR_VALUE5
                                            , :new.FAN_PIECE
                                            , :new.FAN_SET
                                            , :new.FAN_VERSION
                                            , :new.FAN_CHRONOLOGICAL
                                            , :new.FAN_STD_CHAR_1
                                            , :new.FAN_STD_CHAR_2
                                            , :new.FAN_STD_CHAR_3
                                            , :new.FAN_STD_CHAR_4
                                            , :new.FAN_STD_CHAR_5
                                             );
    end if;
  end if;
end FAL_FANN_BIU_DENORM_CHAR;

ALTER TRIGGER "C_ITX"."FAL_FANN_BIU_DENORM_CHAR" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FANS_BIU_DENORM_CHAR"
  before insert or update of GCO_CHARACTERIZATION1_ID
                           , GCO_CHARACTERIZATION2_ID
                           , GCO_CHARACTERIZATION3_ID
                           , GCO_CHARACTERIZATION4_ID
                           , GCO_CHARACTERIZATION5_ID
                           , FAN_CHAR_VALUE1
                           , FAN_CHAR_VALUE2
                           , FAN_CHAR_VALUE3
                           , FAN_CHAR_VALUE4
                           , FAN_CHAR_VALUE5
  on FAL_NETWORK_SUPPLY
  referencing old as old new as new
  for each row
/**
* Description
*    Dénormalisation des caractérisations dans l'événement before insert/update
* @created 30.05.2005
* @version 2003
* @lastUpdate
*/
begin
  -- on vérifie que ce triggers soit déclenche par une modif d'un des champs ci-dessous
  -- et non pas par un autre trigger instead of
  if    nvl(:old.GCO_CHARACTERIZATION1_ID, -1) <> nvl(:new.GCO_CHARACTERIZATION1_ID, -1)
     or nvl(:old.GCO_CHARACTERIZATION2_ID, -1) <> nvl(:new.GCO_CHARACTERIZATION2_ID, -1)
     or nvl(:old.GCO_CHARACTERIZATION3_ID, -1) <> nvl(:new.GCO_CHARACTERIZATION3_ID, -1)
     or nvl(:old.GCO_CHARACTERIZATION4_ID, -1) <> nvl(:new.GCO_CHARACTERIZATION4_ID, -1)
     or nvl(:old.GCO_CHARACTERIZATION5_ID, -1) <> nvl(:new.GCO_CHARACTERIZATION5_ID, -1)
     or nvl(:old.FAN_CHAR_VALUE1, 'null') <> nvl(:new.FAN_CHAR_VALUE1, 'null')
     or nvl(:old.FAN_CHAR_VALUE2, 'null') <> nvl(:new.FAN_CHAR_VALUE2, 'null')
     or nvl(:old.FAN_CHAR_VALUE3, 'null') <> nvl(:new.FAN_CHAR_VALUE3, 'null')
     or nvl(:old.FAN_CHAR_VALUE4, 'null') <> nvl(:new.FAN_CHAR_VALUE4, 'null')
     or nvl(:old.FAN_CHAR_VALUE5, 'null') <> nvl(:new.FAN_CHAR_VALUE5, 'null') then
    -- vérifie qu'on ait au moins une caractérisation
    if :new.GCO_CHARACTERIZATION1_ID is not null then
      -- Mise à jour des champs dénormalisé d'affichage des caractérisations
      GCO_FUNCTIONS.ClassifyCharacterizations(:new.GCO_CHARACTERIZATION1_ID
                                            , :new.GCO_CHARACTERIZATION2_ID
                                            , :new.GCO_CHARACTERIZATION3_ID
                                            , :new.GCO_CHARACTERIZATION4_ID
                                            , :new.GCO_CHARACTERIZATION5_ID
                                            , :new.FAN_CHAR_VALUE1
                                            , :new.FAN_CHAR_VALUE2
                                            , :new.FAN_CHAR_VALUE3
                                            , :new.FAN_CHAR_VALUE4
                                            , :new.FAN_CHAR_VALUE5
                                            , :new.FAN_PIECE
                                            , :new.FAN_SET
                                            , :new.FAN_VERSION
                                            , :new.FAN_CHRONOLOGICAL
                                            , :new.FAN_STD_CHAR_1
                                            , :new.FAN_STD_CHAR_2
                                            , :new.FAN_STD_CHAR_3
                                            , :new.FAN_STD_CHAR_4
                                            , :new.FAN_STD_CHAR_5
                                             );
    end if;
  end if;
end FAL_FANS_BIU_DENORM_CHAR;

ALTER TRIGGER "C_ITX"."FAL_FANS_BIU_DENORM_CHAR" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FDP_BI_GALEI"
  before insert
  on FAL_DOC_PROP
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour du dossier de la proposition d'approvisionnement en fonction du dossier de la demande d'approvisionnement
*
*    1. La proposition d'approvisionnement ne doit pas possèder de dossier
*    2. Une demande d'approvisionnement doit être associée à la proposition d'approvisionnement
*    3. Un dossier doit être associé à la demande d'approvisionnement
*
* @author VJ
* @created 14/02/2005
* @version 2003
*/
declare
  nResult     number;
  docRecordID DOC_RECORD.DOC_RECORD_ID%type;
begin
  if     :new.FAL_SUPPLY_REQUEST_ID is not null
     and :new.DOC_RECORD_ID is null then
    begin
      select RCO.DOC_RECORD_ID
        into docRecordID
        from DOC_RECORD RCO
           , FAL_SUPPLY_REQUEST FSR
       where FSR.FAL_SUPPLY_REQUEST_ID = :new.FAL_SUPPLY_REQUEST_ID
         and RCO.DOC_RECORD_ID = FSR.DOC_RECORD_ID
         and RCO.GAL_TASK_ID is not null;
    exception
      when no_data_found then
        docRecordID  := null;
    end;

    if docRecordID is not null then
      :new.DOC_RECORD_ID  := docRecordID;
    end if;
  end if;
end FAL_FDP_BI_GALEI;

ALTER TRIGGER "C_ITX"."FAL_FDP_BI_GALEI" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FFR_AIU_REPLICATE"
  after insert or update
  on FAL_FACTORY_RATE
  referencing old as old new as new
  for each row
/**
 * Replication for table "Resource rate"
 * @author spfister
 * @date 02/2013
 * Modifications:
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FAL_TRIGGERS') = 1) then
    if (Nvl(:old.FAL_FACTORY_FLOOR_ID,0) <> Nvl(:new.FAL_FACTORY_FLOOR_ID,0)) or
       (Nvl(:old.FFR_RATE1,0) <> Nvl(:new.FFR_RATE1,0)) or
       (Nvl(:old.FFR_RATE2,0) <> Nvl(:new.FFR_RATE2,0)) or
       (Nvl(:old.FFR_RATE3,0) <> Nvl(:new.FFR_RATE3,0)) or
       (Nvl(:old.FFR_RATE4,0) <> Nvl(:new.FFR_RATE4,0)) or
       (Nvl(:old.FFR_RATE5,0) <> Nvl(:new.FFR_RATE5,0)) or
       (Nvl(:old.FFR_VALIDITY_DATE,to_date('01.01.1900', 'DD-MM-YYYY')) <> Nvl(:new.FFR_VALIDITY_DATE,to_date('01.01.1900', 'DD-MM-YYYY'))) or
       (Nvl(:old.FFR_USED_IN_PRECALC_FIN,0) <> Nvl(:new.FFR_USED_IN_PRECALC_FIN,0)) then
      rep_functions.PublishFacFloor(:new.FAL_FACTORY_FLOOR_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."FAL_FFR_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FLP_BU_DIC_FREE_FORWARD"
  before update of DIC_LOT_PROP_FREE_ID
  on FAL_LOT_PROP_TEMP
  referencing old as old new as new
  for each row
/**
* Description
*   Reporte la modification du dictionnaire "Codes traitements" sur la table
*   FAL_LOT_PROP de laquelle sont issus les FAL_LOT_PROP_TEMP.
* @created  ECA 16.02.2004
* @version 2003
* @lastUpdate
*/
begin
  if    (    :old.DIC_LOT_PROP_FREE_ID is null
         and :new.DIC_LOT_PROP_FREE_ID is not null)
     or (    :old.DIC_LOT_PROP_FREE_ID is not null
         and :new.DIC_LOT_PROP_FREE_ID is null)
     or (:old.DIC_LOT_PROP_FREE_ID <> :new.DIC_LOT_PROP_FREE_ID) then
    update FAL_LOT_PROP
       set DIC_LOT_PROP_FREE_ID = :new.DIC_LOT_PROP_FREE_ID
         , A_DATEMOD = sysdate
         , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
     where FAL_LOT_PROP_ID = :new.FAL_LOT_PROP_TEMP_ID;
  end if;
end FAL_FLP_BU_DIC_FREE_FORWARD;

ALTER TRIGGER "C_ITX"."FAL_FLP_BU_DIC_FREE_FORWARD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FOC_BI_INIT_FIELDS"
  before insert
  on FAL_OUT_COMPO_BARCODE
  referencing old as old new as new
  for each row
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
-- Trigger Before Insert Record pour la table FAL_OUT_COMPO_BARCODE
--
-- Permet de renseigner les différents champs de la table lors de l'importation du fichier ASCII dans PCS (via SQL*Loader)
--
-- Création FD le 05/03/2001
-- Trigger maintenu par EPICENTRE (en cas de modifications : veuillez prévenir François DUCHEMIN)
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
declare
  -- Type ID valable pour tout ID de la base
  subtype TTypeID is FAL_OUT_COMPO_BARCODE.FAL_OUT_COMPO_BARCODE_ID%type;

  -- Type correspondant aux quantités de la base
  subtype TTypeQty is FAL_OUT_COMPO_BARCODE.FOC_QUANTITY%type;

  -- Type correspondant à la référence principale d'un produit
  subtype TTypeRef is FAL_OUT_COMPO_BARCODE.FOC_GOO_MAJOR_REFERENCE%type;

  -- Variable pour la récupération d'un nouvel ID
  OUT_COMPO_BARCODE_ID TTypeID;
  -- Variable pour la récupération de l'ID du stock
  STOCK_ID             TTypeID;
  -- Variable pour la réference principale du bien
  MAJOR_REFERENCE      TTypeRef;
  -- Variable pour la réference du lot
  LOTREFCOMPL          FAL_LOT.LOT_REFCOMPL%type;
  -- Variable temporaire
  varTemp              integer;

  -- Récupération de toutes les informations selon un FAL_LOT_MATERIAL_LINK_ID
  -- dans les tables : FAL_LOT_MATERIAL_LINK et FAL_LOT
  cursor GetInfosRecord(aMatLinkID in TTypeID)
  is
    select MatLink.FAL_LOT_ID
         , Lot.LOT_REFCOMPL
         , MatLink.GCO_GOOD_ID
         , MatLink.LOM_SEQ
         , MatLink.LOM_PRICE
         , MatLink.STM_LOCATION_ID
      from FAL_LOT_MATERIAL_LINK MatLink
         , FAL_LOT Lot
     where MatLink.FAL_LOT_MATERIAL_LINK_ID = aMatLinkID
       and Lot.FAL_LOT_ID = MatLink.FAL_LOT_ID;

  -- Record de toutes les informations selon un FAL_LOT_MATERIAL_LINK_ID
  aInfosRecord         GetInfosRecord%rowtype;

  -- Récupération de toutes les informations selon un GCO_GOOD_ID
  -- dans la table : GCO_CHARACTERIZATION
  cursor GetGoodInfosRecord(aGoodID in TTypeID)
  is
    select CHA.GCO_CHARACTERIZATION_ID
      from GCO_CHARACTERIZATION CHA
     where CHA.GCO_GOOD_ID(+) = aGoodID;

  -- Record de toutes les informations selon un GCO_GOOD_ID
  aGoodInfosRecord     GetGoodInfosRecord%rowtype;
begin
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Renseigner les champs obligatoires ID table, date création et utilisateur
-------------------------------------------------------------------------------

  -- ID de la table
  if :new.FAL_OUT_COMPO_BARCODE_ID is null then
    -- Récupération d'un nouvel ID
    OUT_COMPO_BARCODE_ID := GetNewId;

    -- Stockage de l'ID
    :new.FAL_OUT_COMPO_BARCODE_ID  := OUT_COMPO_BARCODE_ID;
  end if;

  -- Date de création
  if :new.A_DATECRE is null then
    :new.A_DATECRE  := sysdate;
  end if;

  -- Utilisateur
  if :new.A_IDCRE is null then
    :new.A_IDCRE  := PCS.PC_I_LIB_SESSION.GetUserIni;
  end if;

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Récupération des infos contenues dans les tables : FAL_LOT_MATERIAL_LINK et FAL_LOT
-------------------------------------------------------------------------------

  -- Ouverture du curseur sur toutes les informations selon un FAL_LOT_MATERIAL_LINK_ID
  open GetInfosRecord(:new.FAL_LOT_MATERIAL_LINK_ID);

  fetch GetInfosRecord
   into aInfosRecord;

  -- S'assurer qu'il y ai un enregistrement ...
  if GetInfosRecord%found then
    -- ID lot
    :new.FAL_LOT_ID        := aInfosRecord.FAL_LOT_ID;
    -- Référence lot
    :new.FOC_LOT_REFCOMPL  := aInfosRecord.LOT_REFCOMPL;
    -- ID bien
    :new.GCO_GOOD_ID       := aInfosRecord.GCO_GOOD_ID;
    -- Séquence OP
    :new.FOC_LOM_SEQ       := aInfosRecord.LOM_SEQ;

    -- Si le prix n'a pas été saisi
    if :new.FOC_PRICE is null then
      -- Prix bien
      :new.FOC_PRICE  := aInfosRecord.LOM_PRICE;
    end if;

    -- Si l'emplacement n'est pas renseigné
    if :new.STM_LOCATION_ID is null then
      -- Emplacement
      :new.STM_LOCATION_ID  := aInfosRecord.STM_LOCATION_ID;
    end if;
  else
    -- Si le lien compo n'a pas été trouvé par le biais de l'ID alors peut être que
    -- c'est l'ID du bien du nouveau lien compo
    begin
      select 1
        into varTemp
        from GCO_GOOD
       where GCO_GOOD_ID = :new.FAL_LOT_MATERIAL_LINK_ID;

      :new.GCO_GOOD_ID  := :new.FAL_LOT_MATERIAL_LINK_ID;
    exception
      when no_data_found then
        null;
    end;

    -- RAZ de l'ID du lien compo
    :new.FAL_LOT_MATERIAL_LINK_ID  := null;

    -- Si l'ID du lot a été saisi
    if :new.FAL_LOT_ID is not null then
      select LOT_REFCOMPL
        into LOTREFCOMPL
        from FAL_LOT
       where FAL_LOT_ID = :new.FAL_LOT_ID;

      :new.FOC_LOT_REFCOMPL  := LOTREFCOMPL;
    end if;
  end if;

  -- Fermeture du curseur
  close GetInfosRecord;

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Récupération des infos contenues dans la table : GCO_CHARACTERIZATION
-------------------------------------------------------------------------------

  -- Ouverture du curseur sur toutes les informations selon une GCO_GOOD_ID
  open GetGoodInfosRecord(:new.GCO_GOOD_ID);

  fetch GetGoodInfosRecord
   into aGoodInfosRecord;

  -- S'assurer qu'il y ai un enregistrement ...
  if GetGoodInfosRecord%found then
    -- ID caractérisation 1
    :new.GCO_CHARACTERIZATION_ID  := aGoodInfosRecord.GCO_CHARACTERIZATION_ID;
  end if;

  -- Fermeture du curseur
  close GetGoodInfosRecord;

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Récupération de la réference principale du bien
-------------------------------------------------------------------------------
  if :new.GCO_GOOD_ID is not null then
    select GOO.GOO_MAJOR_REFERENCE
      into MAJOR_REFERENCE
      from GCO_GOOD GOO
     where GOO.GCO_GOOD_ID = :new.GCO_GOOD_ID;

    -- Réference principale du bien
    :new.FOC_GOO_MAJOR_REFERENCE  := MAJOR_REFERENCE;
  end if;

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- Récupération de l'ID de stock
-------------------------------------------------------------------------------
  if     (:new.STM_LOCATION_ID is not null)
     and (:new.STM_STOCK_ID is null) then
    select STM_STOCK_ID
      into STOCK_ID
      from STM_LOCATION
     where STM_LOCATION_ID = :new.STM_LOCATION_ID;

    -- Stockage de l'ID
    :new.STM_STOCK_ID  := STOCK_ID;
  end if;
end FAL_FOC_BI_INIT_FIELDS;

ALTER TRIGGER "C_ITX"."FAL_FOC_BI_INIT_FIELDS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FSR_AIU_REPLICATE"
  after insert or update
  on FAL_SUPPLY_REQUEST
  referencing old as old new as new
  for each row
/**
 * Replication for table "Procurement request"
 * @author spfister
 * @date 02/2013
 * Modifications:
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FAL_TRIGGERS') = 1) then
    if (Nvl(:old.STM_STOCK_ID,0) <> Nvl(:new.STM_STOCK_ID,0)) or
       (Nvl(:old.STM_LOCATION_ID,0) <> Nvl(:new.STM_LOCATION_ID,0)) or
       (Nvl(:old.GCO_GOOD_ID,0) <> Nvl(:new.GCO_GOOD_ID,0)) or
       (Nvl(:old.PAC_SUPPLIER_PARTNER_ID,0) <> Nvl(:new.PAC_SUPPLIER_PARTNER_ID,0)) or
       (Nvl(:old.FAL_LOT_PROP_ID,0) <> Nvl(:new.FAL_LOT_PROP_ID,0)) or
       (Nvl(:old.FAL_DOC_PROP_ID,0) <> Nvl(:new.FAL_DOC_PROP_ID,0)) or
       (Nvl(:old.FAL_SCHEDULE_PLAN_ID,0) <> Nvl(:new.FAL_SCHEDULE_PLAN_ID,0)) or
       (Nvl(:old.PC_USER1_ID,0) <> Nvl(:new.PC_USER1_ID,0)) or
       (Nvl(:old.PC_USER2_ID,0) <> Nvl(:new.PC_USER2_ID,0)) or
       (Nvl(:old.PC_USER3_ID,0) <> Nvl(:new.PC_USER3_ID,0)) or
       (Nvl(:old.STM_DISTRIBUTION_UNIT_ID,0) <> Nvl(:new.STM_DISTRIBUTION_UNIT_ID,0)) or
       (Nvl(:old.STM_STM_DISTRIBUTION_UNIT_ID,0) <> Nvl(:new.STM_STM_DISTRIBUTION_UNIT_ID,0)) or
       (Nvl(:old.DOC_RECORD_ID,0) <> Nvl(:new.DOC_RECORD_ID,0)) or
       (Nvl(:old.GAL_SUPPLY_REQUEST_ID,0) <> Nvl(:new.GAL_SUPPLY_REQUEST_ID,0)) or
       (Nvl(:old.DIC_FAB_CONDITION_ID,' ') <> Nvl(:new.DIC_FAB_CONDITION_ID,' ')) or
       (Nvl(:old.FSR_TEXTE,' ') <> Nvl(:new.FSR_TEXTE,' ')) or
       (Nvl(:old.FSR_ASKED_QTY,0) <> Nvl(:new.FSR_ASKED_QTY,0)) or
       (Nvl(:old.FSR_REJECT_PLAN_QTY,0) <> Nvl(:new.FSR_REJECT_PLAN_QTY,0)) or
       (Nvl(:old.FSR_TOTAL_QTY,0) <> Nvl(:new.FSR_TOTAL_QTY,0)) or
       (Nvl(:old.FSR_DELAY,to_date('01.01.1900', 'DD-MM-YYYY')) <> Nvl(:new.FSR_DELAY,to_date('01.01.1900', 'DD-MM-YYYY'))) or
       (Nvl(:old.FSR_NUMBER,' ') <> Nvl(:new.FSR_NUMBER,' ')) or
       (Nvl(:old.C_REQUEST_STATUS,' ') <> Nvl(:new.C_REQUEST_STATUS,' ')) or
       (Nvl(:old.DIC_POS_FREE_TABLE_1_ID,' ') <> Nvl(:new.DIC_POS_FREE_TABLE_1_ID,' ')) or
       (Nvl(:old.DIC_POS_FREE_TABLE_2_ID,' ') <> Nvl(:new.DIC_POS_FREE_TABLE_2_ID,' ')) or
       (Nvl(:old.DIC_POS_FREE_TABLE_3_ID,' ') <> Nvl(:new.DIC_POS_FREE_TABLE_3_ID,' ')) or
       (Nvl(:old.FSR_REFERENCE,' ') <> Nvl(:new.FSR_REFERENCE,' ')) or
       (Nvl(:old.FSR_SHORT_DESCR,' ') <> Nvl(:new.FSR_SHORT_DESCR,' ')) or
       (Nvl(:old.FSR_FREE_DESCR,' ') <> Nvl(:new.FSR_FREE_DESCR,' ')) or
       (Nvl(:old.FSR_LONG_DESCR,' ') <> Nvl(:new.FSR_LONG_DESCR,' ')) or
       (Nvl(:old.FSR_COMMENT_D,' ') <> Nvl(:new.FSR_COMMENT_D,' ')) or
       (Nvl(:old.FSR_COMMENT_V,' ') <> Nvl(:new.FSR_COMMENT_V,' ')) or
       (Nvl(:old.FSR_DOC_ORDER,' ') <> Nvl(:new.FSR_DOC_ORDER,' ')) or
       (Nvl(:old.FSR_DATE,to_date('01.01.1900', 'DD-MM-YYYY')) <> Nvl(:new.FSR_DATE,to_date('01.01.1900', 'DD-MM-YYYY'))) or
       (Nvl(:old.FSR_VALIDATE_DATE,to_date('01.01.1900', 'DD-MM-YYYY')) <> Nvl(:new.FSR_VALIDATE_DATE,to_date('01.01.1900', 'DD-MM-YYYY'))) or
       (Nvl(:old.FSR_REFUSAL_DATE,to_date('01.01.1900', 'DD-MM-YYYY')) <> Nvl(:new.FSR_REFUSAL_DATE,to_date('01.01.1900', 'DD-MM-YYYY'))) or
       (Nvl(:old.FSR_INTERMEDIATE_DELAY,to_date('01.01.1900', 'DD-MM-YYYY')) <> Nvl(:new.FSR_INTERMEDIATE_DELAY,to_date('01.01.1900', 'DD-MM-YYYY'))) or
       (Nvl(:old.FSR_BASIS_DELAY,to_date('01.01.1900', 'DD-MM-YYYY')) <> Nvl(:new.FSR_BASIS_DELAY,to_date('01.01.1900', 'DD-MM-YYYY'))) then
      rep_functions.PublishSupplyRequest(:new.FAL_SUPPLY_REQUEST_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."FAL_FSR_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FWE_AD_POSITION_ALLOY"
  after delete
  on FAL_WEIGH
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour de la table des matières positions suite à la suppression d'une pesée
* @author VJ
* @created 25.03.2004
* @version 2003
* @lastUpdate 30.01.2002
*/
declare
  bStop        boolean;
  gasWeightMat DOC_GAUGE_STRUCTURED.GAS_WEIGHT_MAT%type;
begin
  if (:old.DOC_POSITION_ID is not null) then
    -- Vérifie si le gabarit du document gère les poids matières précieuses.
    bStop  := false;

    begin
      select GAS.GAS_WEIGHT_MAT
        into gasWeightMat
        from DOC_POSITION POS
           , DOC_DOCUMENT DMT
           , DOC_GAUGE_STRUCTURED GAS
       where POS.DOC_POSITION_ID = :old.DOC_POSITION_ID
         and DMT.DOC_DOCUMENT_ID = POS.DOC_DOCUMENT_ID
         and GAS.DOC_GAUGE_ID = POS.DOC_GAUGE_ID
         and nvl(GAS.GAS_WEIGHT_MAT, 0) = 1;
    exception
      when no_data_found then
        bStop  := true;
    end;

    if not bStop then
      ----
      -- Mise à jour des matières position en fonction de la pesée supprimée.
      -- Voir graphe Suppression Pesée.
      --
      DOC_POSITION_ALLOY_FUNCTIONS.ValidateWeighing(:old.DOC_POSITION_ID
                                                    , null
                                                    , (:old.FWE_WEIGHT) * -1
                                                    , (:old.FWE_WEIGHT_MAT) * -1
                                                    , :old.FAL_POSITION1_ID
                                                    , :old.FAL_POSITION2_ID
                                                    , :old.GCO_ALLOY_ID
                                                     );
    end if;
  end if;
end FAL_FWE_AD_POSITION_ALLOY;

ALTER TRIGGER "C_ITX"."FAL_FWE_AD_POSITION_ALLOY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FWE_AU_POSITION_ALLOY"
  after update of FWE_WEIGHT, FWE_WEIGHT_MAT, FAL_POSITION1_ID, FAL_POSITION2_ID
  on FAL_WEIGH
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour de la table des matières positions suite à la modification d'une pesée
* @author VJ
* @created 25.03.2004
* @version 2003
* @lastUpdate
*/
declare
  bStop        boolean;
  gasWeightMat DOC_GAUGE_STRUCTURED.GAS_WEIGHT_MAT%type;
begin
  if    nvl(:old.FWE_WEIGHT, -1) <> nvl(:new.FWE_WEIGHT, -1)
     or nvl(:old.FWE_WEIGHT_MAT, -1) <> nvl(:new.FWE_WEIGHT_MAT, -1) then
    if (:new.DOC_POSITION_ID is not null) then
      -- Vérifie si le gabarit du document gère les poids matières précieuses.
      bStop  := false;

      begin
        select GAS.GAS_WEIGHT_MAT
          into gasWeightMat
          from DOC_POSITION POS
             , DOC_DOCUMENT DMT
             , DOC_GAUGE_STRUCTURED GAS
         where POS.DOC_POSITION_ID = :new.DOC_POSITION_ID
           and DMT.DOC_DOCUMENT_ID = POS.DOC_DOCUMENT_ID
           and GAS.DOC_GAUGE_ID = POS.DOC_GAUGE_ID
           and nvl(GAS.GAS_WEIGHT_MAT, 0) = 1;
      exception
        when no_data_found then
          bStop  := true;
      end;

      if not bStop then
        ----
        -- Mise à jour des matières position en fonction de la pesée modifiée.
        -- Voir graphe Validation Pesée.
        --
        DOC_POSITION_ALLOY_FUNCTIONS.ValidateWeighing(:new.DOC_POSITION_ID
                                                    , null
                                                    , :old.FWE_WEIGHT *(-1)
                                                    , :old.FWE_WEIGHT_MAT *(-1)
                                                    , :old.FAL_POSITION1_ID
                                                    , :old.FAL_POSITION2_ID
                                                    , :new.GCO_ALLOY_ID
                                                     );
        DOC_POSITION_ALLOY_FUNCTIONS.ValidateWeighing(:new.DOC_POSITION_ID
                                                    , null
                                                    , :new.FWE_WEIGHT
                                                    , :new.FWE_WEIGHT_MAT
                                                    , :new.FAL_POSITION1_ID
                                                    , :new.FAL_POSITION2_ID
                                                    , :new.GCO_ALLOY_ID
                                                     );
      end if;
    end if;
  end if;
end FAL_FWE_AU_POSITION_ALLOY;


ALTER TRIGGER "C_ITX"."FAL_FWE_AU_POSITION_ALLOY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_FWE_BI_POSITION_ALLOY"
  before insert
  on FAL_WEIGH
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour de la table des matières positions suite à la création d'une pesée
* @author VJ
* @created 11.06.2004
* @version 2003
* @lastUpdate
*/
declare
  bStop        boolean;
  gasWeightMat DOC_GAUGE_STRUCTURED.GAS_WEIGHT_MAT%type;
begin
  if (:new.DOC_POSITION_ID is not null) then
    -- Vérifie si le gabarit du document gère les poids matières précieuses.
    bStop  := false;

    begin
      select GAS.GAS_WEIGHT_MAT
        into gasWeightMat
        from DOC_POSITION POS
           , DOC_DOCUMENT DMT
           , DOC_GAUGE_STRUCTURED GAS
       where POS.DOC_POSITION_ID = :new.DOC_POSITION_ID
         and DMT.DOC_DOCUMENT_ID = POS.DOC_DOCUMENT_ID
         and GAS.DOC_GAUGE_ID = POS.DOC_GAUGE_ID
         and nvl(GAS.GAS_WEIGHT_MAT, 0) = 1;
    exception
      when no_data_found then
        bStop  := true;
    end;

    if not bStop then
      ----
      -- Mise à jour des matières position en fonction de la pesée créée.
      -- Voir graphe Validation Pesée.
      --
      -- On ne passe pas l'id de la pesée dans ce context, car la pesée n'est pas encore disponible avec un select.
      -- C'est donc les poids spécifiés qui sont utilisé pour la mise à jour de la matière position.
      --
      DOC_POSITION_ALLOY_FUNCTIONS.ValidateWeighing(:new.DOC_POSITION_ID
                                                  , null
                                                  , :new.FWE_WEIGHT
                                                  , :new.FWE_WEIGHT_MAT
                                                  , :new.FAL_POSITION1_ID
                                                  , :new.FAL_POSITION2_ID
                                                  , :new.GCO_ALLOY_ID
                                                   );
    end if;
  end if;
end FAL_FWE_BI_POSITION_ALLOY;


ALTER TRIGGER "C_ITX"."FAL_FWE_BI_POSITION_ALLOY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_LIST_STEP_AIUD_HISTO"
  after insert or update or delete
  on FAL_LIST_STEP_LINK
  referencing old as old new as new
  for each row
begin
  -- Insertion d'une opération
  if inserting then
    FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:new.FAL_SCHEDULE_PLAN_ID
                                       , :new.SCS_STEP_NUMBER
                                       , :new.FAL_TASK_ID
                                       , '01'
                                       , null
                                       , null
                                        );
  elsif updating then
    -- Determiner les champs modifiés et création d'un enreg dans la table historique pour chaque champ modifié
    if nvl(:old.SCS_STEP_NUMBER, -1) <> nvl(:new.SCS_STEP_NUMBER, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '03'
                                         , :old.SCS_STEP_NUMBER
                                         , :new.SCS_STEP_NUMBER
                                          );
    end if;

    -- FAL_TASK_ID ?
    if nvl(:old.FAL_TASK_ID, -1) <> nvl(:new.FAL_TASK_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '04'
                                         , :old.FAL_TASK_ID
                                         , :new.FAL_TASK_ID
                                          );
    end if;

    -- C_OPERATION_TYPE ?
    if nvl(:old.C_OPERATION_TYPE, -1) <> nvl(:new.C_OPERATION_TYPE, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '05'
                                         , :old.C_OPERATION_TYPE
                                         , :new.C_OPERATION_TYPE
                                          );
    end if;

    -- PPS_OPERATION_PROCEDURE_ID ?
    if nvl(:old.PPS_OPERATION_PROCEDURE_ID, -1) <> nvl(:new.PPS_OPERATION_PROCEDURE_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '06'
                                         , :old.PPS_OPERATION_PROCEDURE_ID
                                         , :new.PPS_OPERATION_PROCEDURE_ID
                                          );
    end if;

    -- PPS_PPS_OPERATION_PROCEDURE_ID ?
    if nvl(:old.PPS_PPS_OPERATION_PROCEDURE_ID, -1) <> nvl(:new.PPS_PPS_OPERATION_PROCEDURE_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '07'
                                         , :old.PPS_PPS_OPERATION_PROCEDURE_ID
                                         , :new.PPS_PPS_OPERATION_PROCEDURE_ID
                                          );
    end if;

    -- PPS_TOOLS1_ID
    if nvl(:old.PPS_TOOLS1_ID, -1) <> nvl(:new.PPS_TOOLS1_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '08'
                                         , :old.PPS_TOOLS1_ID
                                         , :new.PPS_TOOLS1_ID
                                          );
    end if;

    -- PPS_TOOLS2_ID.
    if nvl(:old.PPS_TOOLS2_ID, -1) <> nvl(:new.PPS_TOOLS2_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '09'
                                         , :old.PPS_TOOLS2_ID
                                         , :new.PPS_TOOLS2_ID
                                          );
    end if;

    -- FAL_FACTORY_FLOOR_ID ?
    if nvl(:old.FAL_FACTORY_FLOOR_ID, -1) <> nvl(:new.FAL_FACTORY_FLOOR_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '10'
                                         , :old.FAL_FACTORY_FLOOR_ID
                                         , :new.FAL_FACTORY_FLOOR_ID
                                          );
    end if;

    -- PAC_SUPPLIER_PARTNER_ID ?
    if nvl(:old.PAC_SUPPLIER_PARTNER_ID, -1) <> nvl(:new.PAC_SUPPLIER_PARTNER_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '11'
                                         , :old.PAC_SUPPLIER_PARTNER_ID
                                         , :new.PAC_SUPPLIER_PARTNER_ID
                                          );
    end if;

    -- GCO_GCO_GOOD_ID ?
    if nvl(:old.GCO_GCO_GOOD_ID, -1) <> nvl(:new.GCO_GCO_GOOD_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '12'
                                         , :old.GCO_GCO_GOOD_ID
                                         , :new.GCO_GCO_GOOD_ID
                                          );
    end if;

    -- SCS_ADJUSTING_TIME ?
    if nvl(:old.SCS_ADJUSTING_TIME, -1) <> nvl(:new.SCS_ADJUSTING_TIME, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '13'
                                         , :old.SCS_ADJUSTING_TIME
                                         , :new.SCS_ADJUSTING_TIME
                                          );
    end if;

    -- SCS_WORK_TIME ?
    if nvl(:old.SCS_WORK_TIME, -1) <> nvl(:new.SCS_WORK_TIME, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '14'
                                         , :old.SCS_WORK_TIME
                                         , :new.SCS_WORK_TIME
                                          );
    end if;

    -- SCS_QTY_REF_WORK ?
    if nvl(:old.SCS_QTY_REF_WORK, -1) <> nvl(:new.SCS_QTY_REF_WORK, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '15'
                                         , :old.SCS_QTY_REF_WORK
                                         , :new.SCS_QTY_REF_WORK
                                          );
    end if;

    -- SCS_WORK_RATE ?
    if nvl(:old.SCS_WORK_RATE, -1) <> nvl(:new.SCS_WORK_RATE, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '16'
                                         , :old.SCS_WORK_RATE
                                         , :new.SCS_WORK_RATE
                                          );
    end if;

    -- SCS_AMOUNT ?
    if nvl(:old.SCS_AMOUNT, -1) <> nvl(:new.SCS_AMOUNT, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '17'
                                         , :old.SCS_AMOUNT
                                         , :new.SCS_AMOUNT
                                          );
    end if;

    -- SCS_QTY_REF_AMOUNT ?
    if nvl(:old.SCS_QTY_REF_AMOUNT, -1) <> nvl(:new.SCS_QTY_REF_AMOUNT, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '18'
                                         , :old.SCS_QTY_REF_AMOUNT
                                         , :new.SCS_QTY_REF_AMOUNT
                                          );
    end if;

    -- SCS_DIVISOR_AMOUNT ?
    if nvl(:old.SCS_DIVISOR_AMOUNT, -1) <> nvl(:new.SCS_DIVISOR_AMOUNT, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '19'
                                         , :old.SCS_DIVISOR_AMOUNT
                                         , :new.SCS_DIVISOR_AMOUNT
                                          );
    end if;

    -- SCS_PLAN_RATE ?
    if nvl(:old.SCS_PLAN_RATE, -1) <> nvl(:new.SCS_PLAN_RATE, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '20'
                                         , :old.SCS_PLAN_RATE
                                         , :new.SCS_PLAN_RATE
                                          );
    end if;

    -- FAL_FAL_FACTORY_FLOOR_ID ?
    if nvl(:old.FAL_FAL_FACTORY_FLOOR_ID, -1) <> nvl(:new.FAL_FAL_FACTORY_FLOOR_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '21'
                                         , :old.FAL_FAL_FACTORY_FLOOR_ID
                                         , :new.FAL_FAL_FACTORY_FLOOR_ID
                                          );
    end if;

    -- SCS_NUM_FLOOR ?
    if nvl(:old.SCS_NUM_FLOOR, -1) <> nvl(:new.SCS_NUM_FLOOR, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '22'
                                         , :old.SCS_NUM_FLOOR
                                         , :new.SCS_NUM_FLOOR
                                          );
    end if;

    -- SCS_ADJUSTING_FLOOR ?
    if nvl(:old.SCS_ADJUSTING_FLOOR, -1) <> nvl(:new.SCS_ADJUSTING_FLOOR, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '23'
                                         , :old.SCS_ADJUSTING_FLOOR
                                         , :new.SCS_ADJUSTING_FLOOR
                                          );
    end if;

    -- SCS_ADJUSTING_OPERATOR ?
    if nvl(:old.SCS_ADJUSTING_OPERATOR, -1) <> nvl(:new.SCS_ADJUSTING_OPERATOR, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '24'
                                         , :old.SCS_ADJUSTING_OPERATOR
                                         , :new.SCS_ADJUSTING_OPERATOR
                                          );
    end if;

    -- SCS_NUM_ADJUST_OPERATOR ?
    if nvl(:old.SCS_NUM_ADJUST_OPERATOR, -1) <> nvl(:new.SCS_NUM_ADJUST_OPERATOR, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '25'
                                         , :old.SCS_NUM_ADJUST_OPERATOR
                                         , :new.SCS_NUM_ADJUST_OPERATOR
                                          );
    end if;

    -- SCS_PERCENT_ADJUST_OPER ?
    if nvl(:old.SCS_PERCENT_ADJUST_OPER, -1) <> nvl(:new.SCS_PERCENT_ADJUST_OPER, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '26'
                                         , :old.SCS_PERCENT_ADJUST_OPER
                                         , :new.SCS_PERCENT_ADJUST_OPER
                                          );
    end if;

    -- SCS_WORK_FLOOR ?
    if nvl(:old.SCS_WORK_FLOOR, -1) <> nvl(:new.SCS_WORK_FLOOR, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '27'
                                         , :old.SCS_WORK_FLOOR
                                         , :new.SCS_WORK_FLOOR
                                          );
    end if;

    -- SCS_WORK_OPERATOR ?
    if nvl(:old.SCS_WORK_OPERATOR, -1) <> nvl(:new.SCS_WORK_OPERATOR, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '28'
                                         , :old.SCS_WORK_OPERATOR
                                         , :new.SCS_WORK_OPERATOR
                                          );
    end if;

    -- SCS_NUM_WORK_OPERATOR ?
    if nvl(:old.SCS_NUM_WORK_OPERATOR, -1) <> nvl(:new.SCS_NUM_WORK_OPERATOR, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '29'
                                         , :old.SCS_NUM_WORK_OPERATOR
                                         , :new.SCS_NUM_WORK_OPERATOR
                                          );
    end if;

    -- SCS_PERCENT_WORK_OPER ?
    if nvl(:old.SCS_PERCENT_WORK_OPER, -1) <> nvl(:new.SCS_PERCENT_WORK_OPER, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '30'
                                         , :old.SCS_PERCENT_WORK_OPER
                                         , :new.SCS_PERCENT_WORK_OPER
                                          );
    end if;

    -- PPS_TOOLS3_ID ?
    if nvl(:old.PPS_TOOLS3_ID, -1) <> nvl(:new.PPS_TOOLS3_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '31'
                                         , :old.PPS_TOOLS3_ID
                                         , :new.PPS_TOOLS3_ID
                                          );
    end if;

    -- PPS_TOOLS4_ID ?
    if nvl(:old.PPS_TOOLS4_ID, -1) <> nvl(:new.PPS_TOOLS4_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '32'
                                         , :old.PPS_TOOLS4_ID
                                         , :new.PPS_TOOLS4_ID
                                          );
    end if;

    -- PPS_TOOLS5_ID ?
    if nvl(:old.PPS_TOOLS5_ID, -1) <> nvl(:new.PPS_TOOLS5_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '33'
                                         , :old.PPS_TOOLS5_ID
                                         , :new.PPS_TOOLS5_ID
                                          );
    end if;

    -- PPS_TOOLS6_ID ?
    if nvl(:old.PPS_TOOLS6_ID, -1) <> nvl(:new.PPS_TOOLS6_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '34'
                                         , :old.PPS_TOOLS6_ID
                                         , :new.PPS_TOOLS6_ID
                                          );
    end if;

    -- PPS_TOOLS7_ID ?
    if nvl(:old.PPS_TOOLS7_ID, -1) <> nvl(:new.PPS_TOOLS7_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '35'
                                         , :old.PPS_TOOLS7_ID
                                         , :new.PPS_TOOLS7_ID
                                          );
    end if;

    -- PPS_TOOLS8_ID ?
    if nvl(:old.PPS_TOOLS8_ID, -1) <> nvl(:new.PPS_TOOLS8_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '36'
                                         , :old.PPS_TOOLS8_ID
                                         , :new.PPS_TOOLS8_ID
                                          );
    end if;

    -- PPS_TOOLS9_ID ?
    if nvl(:old.PPS_TOOLS9_ID, -1) <> nvl(:new.PPS_TOOLS9_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '37'
                                         , :old.PPS_TOOLS9_ID
                                         , :new.PPS_TOOLS9_ID
                                          );
    end if;

    -- PPS_TOOLS10_ID ?
    if nvl(:old.PPS_TOOLS10_ID, -1) <> nvl(:new.PPS_TOOLS10_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '38'
                                         , :old.PPS_TOOLS10_ID
                                         , :new.PPS_TOOLS10_ID
                                          );
    end if;

    -- PPS_TOOLS11_ID ?
    if nvl(:old.PPS_TOOLS11_ID, -1) <> nvl(:new.PPS_TOOLS11_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '39'
                                         , :old.PPS_TOOLS11_ID
                                         , :new.PPS_TOOLS11_ID
                                          );
    end if;

    -- PPS_TOOLS12_ID ?
    if nvl(:old.PPS_TOOLS12_ID, -1) <> nvl(:new.PPS_TOOLS12_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '40'
                                         , :old.PPS_TOOLS12_ID
                                         , :new.PPS_TOOLS12_ID
                                          );
    end if;

    -- PPS_TOOLS13_ID ?
    if nvl(:old.PPS_TOOLS13_ID, -1) <> nvl(:new.PPS_TOOLS13_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '41'
                                         , :old.PPS_TOOLS13_ID
                                         , :new.PPS_TOOLS13_ID
                                          );
    end if;

    -- PPS_TOOLS14_ID ?
    if nvl(:old.PPS_TOOLS14_ID, -1) <> nvl(:new.PPS_TOOLS14_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '42'
                                         , :old.PPS_TOOLS14_ID
                                         , :new.PPS_TOOLS14_ID
                                          );
    end if;

    -- PPS_TOOLS15_ID ?
    if nvl(:old.PPS_TOOLS15_ID, -1) <> nvl(:new.PPS_TOOLS15_ID, -1) then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '43'
                                         , :old.PPS_TOOLS15_ID
                                         , :new.PPS_TOOLS15_ID
                                          );
    end if;

    -- SCS_SHORT_DESCR
    if nvl(:old.SCS_SHORT_DESCR, '') <> nvl(:new.SCS_SHORT_DESCR, '') then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '48'
                                         , :old.SCS_SHORT_DESCR
                                         , :new.SCS_SHORT_DESCR
                                          );
    end if;

    -- SCS_LONG_DESCR
    if nvl(:old.SCS_LONG_DESCR, '') <> nvl(:new.SCS_LONG_DESCR, '') then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '49'
                                         , :old.SCS_LONG_DESCR
                                         , :new.SCS_LONG_DESCR
                                          );
    end if;

    -- SCS_FREE_DESCR
    if nvl(:old.SCS_FREE_DESCR, '') <> nvl(:new.SCS_FREE_DESCR, '') then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , :old.SCS_STEP_NUMBER
                                         , :old.FAL_TASK_ID
                                         , '50'
                                         , :old.SCS_FREE_DESCR
                                         , :new.SCS_FREE_DESCR
                                          );
    end if;

  elsif deleting then
    FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                       , :old.SCS_STEP_NUMBER
                                       , :old.FAL_TASK_ID
                                       , '02'
                                       , null
                                       , null
                                        );
  end if;
end FAL_LIST_STEP_AIUD_HISTO;

ALTER TRIGGER "C_ITX"."FAL_LIST_STEP_AIUD_HISTO" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_LIST_STEP_BI_STEP"
  before insert
  on FAL_LIST_STEP_LINK
  referencing old as old new as new
  for each row
declare
begin
  if :new.FAL_SCHEDULE_STEP_ID is not null then
    :new.FAL_LIST_STEP_LINK_ID  := :new.FAL_SCHEDULE_STEP_ID;
  else
    :new.FAL_SCHEDULE_STEP_ID  := :new.FAL_LIST_STEP_LINK_ID;
  end if;
end FAL_LIST_STEP_BI_STEP;

ALTER TRIGGER "C_ITX"."FAL_LIST_STEP_BI_STEP" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_LIST_STEP_LINK_BU_MACHINE"
  before update of FAL_FACTORY_FLOOR_ID
  on FAL_LIST_STEP_LINK
  referencing old as old new as new
  for each row
/**
* Description
*    En modification de l'atelier sur l'opération d'OF, suppression des machines des LMU qui ne
*    sont pas liées au nouvel atelier (si atelier est un îlot) ou liées au même îlot que l'atelier
*    ( si atelier est une machine)
* @created CLE 09.06.2008
* @version 2003
* @lastUpdate
*/
declare
begin
  if (nvl(:new.FAL_FACTORY_FLOOR_ID, 0) <> nvl(:old.FAL_FACTORY_FLOOR_ID, 0) ) then
    delete      FAL_LIST_STEP_USE FLSU
          where FAL_SCHEDULE_STEP_ID = :new.FAL_SCHEDULE_STEP_ID
            and (select FAL_FAL_FACTORY_FLOOR_ID
                   from FAL_FACTORY_FLOOR
                  where FAL_FACTORY_FLOOR_ID = FLSU.FAL_FACTORY_FLOOR_ID) <>
                       nvl( (select max(FAL_FAL_FACTORY_FLOOR_ID)
                               from FAL_FACTORY_FLOOR
                              where FAL_FACTORY_FLOOR_ID = :new.FAL_FACTORY_FLOOR_ID)
                         , nvl(:new.FAL_FACTORY_FLOOR_ID, 0) );
  end if;
end FAL_LIST_STEP_LINK_BU_MACHINE;

ALTER TRIGGER "C_ITX"."FAL_LIST_STEP_LINK_BU_MACHINE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_LOM_BUD_COMPONENT"
  after update or delete
  on FAL_LOT_MATERIAL_LINK
  referencing old as old new as new
  for each row
/****
 * CRéATEUR : ECA.
 * DATE     : 10/01/2006.
 * OBJET    : FLAGUER LE LOT SI LE COMPOSANT EST MODIFIé MANUELLEMENT
 */
declare
  blnDoUpdate    boolean;
begin
  blnDoUpdate  := false;

  -- Suppression d'un composant
  if deleting then
    blnDoUpdate  := true;
  -- Modification de la quantité
  elsif updating then
    if    (:new.LOM_BOM_REQ_QTY <> :old.LOM_BOM_REQ_QTY)
       or (:new.LOM_ADJUSTED_QTY <> :old.LOM_ADJUSTED_QTY) then
      blnDoUpdate  := true;
    end if;
  end if;

  --- Flag de l'indication de modification.
  if blnDoUpdate = true then
    begin
      update FAL_LOT
         set LOT_UPDATED_COMPONENTS = 1
       where FAL_LOT_ID = :old.FAL_LOT_ID;
    exception
      when ex.TABLE_MUTATING then
        null;
    end;
  end if;
end FAL_LOM_BUD_COMPONENT;

ALTER TRIGGER "C_ITX"."FAL_LOM_BUD_COMPONENT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_LOM_TMP_BU_ADJ_QTY"
  before update of LOM_ADJUSTED_QTY
  on FAL_LOT_MAT_LINK_TMP
  referencing old as old new as new
  for each row
/**
* Description
*     Calcul des compteurs du composant temporaire après modification
*     de la quantité sup inf
*
* @author ECA
* @version 2006
* @lastUpdate
*/
begin
  /* Le Drop sera fait dans le prochain Patchset, afin de ne pas tenter de supprimer ce trigger qui n'aurait pas déjà été créé */
  null;
end FAL_LOM_TMP_BU_ADJ_QTY;

ALTER TRIGGER "C_ITX"."FAL_LOM_TMP_BU_ADJ_QTY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_LOT_BD_CONTROL"
  before delete
  on FAL_LOT
  referencing old as old new as new
  for each row
/*----------------------------------------------
 Createur : Denis JEANNERET .
 Date     : 29/11/2004 ;
 Objet    : Contrôler qu'il n'existe plus de need ou de supply sur un lot au moment de sa destruction
----------------------------------------------*/
declare
  OneID FAl_NETWORK_NEED.FAL_NETWORK_NEED_ID%type;
  ln_Count integer;
begin
  if nvl(:old.C_FAB_TYPE, '0') <> '1' then
    OneID  := null;

    -- controle si le bien est utilisé dans les Needs. (FAL_NETWORK_NEED)
    select max(FAL_NETWORK_NEED_ID)
      into OneID
      from FAL_NETWORk_NEED
     where FAL_LOT_ID = :old.FAL_LOT_ID;

    if OneID is not null then
      raise_application_error(-20100
                            , PCS.PC_FUNCTIONS.TRANSLATEWORD('Des besoins (FAL_NETWORK_NEED) existent pour ce lot')
                             );
    end if;

    -- controle si le bien est utilisé dans les Supplys. (FAL_NETWORK_SUPPLY)
    select max(FAL_NETWORK_SUPPLY_ID)
      into OneID
      from FAL_NETWORk_SUPPLY
     where FAL_LOT_ID = :old.FAL_LOT_ID;

    if OneID is not null then
      raise_application_error(-20100
                            , PCS.PC_FUNCTIONS.TRANSLATEWORD('Des Appros (FAL_NETWORK_SUPPLY) existent pour ce lot')
                             );
    end if;
  end if;

  -- Bloquer l'effacement d'un lot sous-traitance d'achat s'il est utilisé dans
  -- une position de document
  select sign(nvl(max(PDE.FAL_LOT_ID), 0)) POS_LOT
    into ln_Count
    from DOC_POSITION_DETAIL PDE
       , DOC_POSITION POS
   where PDE.FAL_LOT_ID = :old.FAL_LOT_ID
     and PDE.DOC_POSITION_ID = POS.DOC_POSITION_ID
     and POS.C_DOC_POS_STATUS in ('01', '02', '03');

  if ln_Count > 0 then
      raise_application_error(-20100
                            , PCS.PC_FUNCTIONS.TRANSLATEWORD('Ce lot est utilisé dans une position de sous-traitance d''achat !')
                             );
  end if;
end FAL_LOT_BD_CONTROL;

ALTER TRIGGER "C_ITX"."FAL_LOT_BD_CONTROL" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_LOT_PRG_DETAIL_BD"
  before delete
  on FAL_LOT_PROGRESS_DETAIL
  referencing old as old new as new
  for each row
/**
* Description
*     - Remise à null du détail de suivi d'avancement sur les appairages
*     - Mise à jour de la quantité rebut et quantité solde du détail lot lié
* @author CLE
* @version 2003
* @lastUpdate
*/
begin
  update FAL_LOT_DETAIL_LINK
     set FAL_LOT_PROGRESS_DETAIL_ID = null
   where FAL_LOT_PROGRESS_DETAIL_ID = :old.FAL_LOT_PROGRESS_DETAIL_ID;

  -- Mise à jour de la quantité rebut du détail lot lié
  if :old.C_LOT_DETAIL_TYPE in('02', '03') then
    update FAL_LOT_DETAIL
       set FAD_MORPHO_REJECT_QTY = nvl(FAD_MORPHO_REJECT_QTY, 0) - :old.LPD_QTY
         , FAD_BALANCE_QTY = nvl(FAD_BALANCE_QTY, 0) + :old.LPD_QTY
     where FAL_LOT_DETAIL_ID = :old.FAL_LOT_DETAIL_ID;
  end if;
end FAL_LOT_PRG_DETAIL_BD;

ALTER TRIGGER "C_ITX"."FAL_LOT_PRG_DETAIL_BD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_LOT_PROGR_BD"
    BEFORE DELETE
    ON FAL_LOT_PROGRESS
    REFERENCING OLD AS OLD
    FOR EACH ROW
BEGIN
  Delete from fal_weigh
	where fal_lot_progress_id = :old.FAL_LOT_PROGRESS_ID;
end FAL_LOT_PROGR_BD;

ALTER TRIGGER "C_ITX"."FAL_LOT_PROGR_BD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_LSU_AIU_REPLICATE"
  after insert or update
  on FAL_LIST_STEP_USE
  referencing old as old new as new
  for each row
/**
 * Replication for table "Machine set"
 * @author spfister
 * @date 02/2013
 * Modifications:
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FAL_TRIGGERS') = 1) then
    if (Nvl(:old.FAL_FACTORY_FLOOR_ID,0) <> Nvl(:new.FAL_FACTORY_FLOOR_ID,0)) or
       (Nvl(:old.FAL_SCHEDULE_STEP_ID,0) <> Nvl(:new.FAL_SCHEDULE_STEP_ID,0)) or
       (Nvl(:old.LSU_WORK_TIME,0) <> Nvl(:new.LSU_WORK_TIME,0)) or
       (Nvl(:old.LSU_QTY_REF_WORK,0) <> Nvl(:new.LSU_QTY_REF_WORK,0)) or
       (Nvl(:old.LSU_PRIORITY,0) <> Nvl(:new.LSU_PRIORITY,0)) or
       (Nvl(:old.LSU_EXCEPT_MACH,0) <> Nvl(:new.LSU_EXCEPT_MACH,0)) then
      rep_functions.PublishSchedulePlan(:new.FAL_SCHEDULE_STEP_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."FAL_LSU_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_PFG_BI"
  before insert
  on FAL_LOT_PROGRESS_FOG
  referencing old as old new as new
  for each row
/**
* Description
*    Permet de renseigner l'ID, A_DATECRE, A_IDCRE s'ils ne sont pas renseignés.
*    Contrôle et mise à jour de l'origine de l'avancement et du statut s'ils ne
*    sont pas renseignés (principalement utilisé pour les importations de
*    données de systèmes BDE).
* @author FD / JCH
* @created FD 25.10.1999
* @updated JCH 03.06.2008
* @version 2003
*/
declare
  PFG_ID FAL_LOT_PROGRESS_FOG.FAL_LOT_PROGRESS_FOG_ID%type;
begin
  -- ID de la table
  if :new.FAL_LOT_PROGRESS_FOG_ID is null then
    -- Récupération d'un nouvel ID
    PFG_ID := GetNewId;

    -- Stockage de l'ID
    :new.FAL_LOT_PROGRESS_FOG_ID  := PFG_ID;
  end if;

  -- Date de création
  if :new.A_DATECRE is null then
    :new.A_DATECRE  := sysdate;
  end if;

  -- Utilisateur
  if :new.A_IDCRE is null then
    :new.A_IDCRE  := PCS.PC_I_LIB_SESSION.GetUserIni;
  end if;

  -- Si le statut n'est pas renseigné, on utilise la valeur de la config FAL_PFG_DEFAULT_STATUS
  if :new.C_PFG_STATUS is null then
    :new.C_PFG_STATUS  := FAL_PFG_ENTRY_SYSTEMS.cDefaultPfgStatus;
  end if;

  -- Si l'origine n'est pas renseignée, on essaie de la deviner, sinon la valeur
  -- par défaut "10 - Production" est utilisée.
  if :new.C_PROGRESS_ORIGIN is null then
    if :new.PFG_GAL_REFCOMPL is not null then
      :new.C_PROGRESS_ORIGIN  := FAL_PFG_ENTRY_SYSTEMS.poProject;
    else
      :new.C_PROGRESS_ORIGIN  := FAL_PFG_ENTRY_SYSTEMS.poProduction;
    end if;
  end if;
end FAL_PFG_BI;

ALTER TRIGGER "C_ITX"."FAL_PFG_BI" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_POS_AI_INV_CREATE"
AFTER INSERT
ON FAL_POSITION
REFERENCING NEW as NEW
FOR EACH ROW
/*----------------------------------------------
 Createur : Cassis Emmanuel .
 Date     : 26/03/2003 ;
 Objet    : Création des positions d'inventaire
            par alliage
----------------------------------------------*/
BEGIN
  null;
		-- Initialisation des poids par alliage
-- 		FAL_POSITION_FUNCTIONS.INIT_POSITION_WEIGHT(:NEW.FAL_POSITION_ID,
-- 		                                            null);

end FAL_POS_AI_INV_CREATE;

ALTER TRIGGER "C_ITX"."FAL_POS_AI_INV_CREATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_POS_BD_INV_DELETE"
BEFORE DELETE
ON FAL_POSITION
REFERENCING OLD as OLD NEW as NEW
FOR EACH ROW

/*----------------------------------------------
 Createur : Cassis Emmanuel .
 Date     : 26/03/2003 ;
 Objet    : Suppression des lignes d'inventaire
 					  par alliage
----------------------------------------------*/

BEGIN
  DELETE FROM FAL_POSITION_INIT_QTY
	WHERE FAL_POSITION_ID = :OLD.FAL_POSITION_ID;

end FAL_POS_BD_INV_DELETE;

ALTER TRIGGER "C_ITX"."FAL_POS_BD_INV_DELETE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_SCH_AIU_REPLICATE"
  after insert or update
  on FAL_SCHEDULE_PLAN
  referencing old as old new as new
  for each row
/**
 * Replication for table "TASK LIST"
 * @author spfister
 * @date 02/2013
 * Modifications:
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FAL_TRIGGERS') = 1) then
    if (Nvl(:old.C_SCHEDULE_PLANNING,' ') <> Nvl(:new.C_SCHEDULE_PLANNING,' ')) or
       (Nvl(:old.SCH_REF,' ') <> Nvl(:new.SCH_REF,' ')) or
       (Nvl(:old.SCH_SHORT_DESCR,' ') <> Nvl(:new.SCH_SHORT_DESCR,' ')) or
       (Nvl(:old.SCH_LONG_DESCR,' ') <> Nvl(:new.SCH_LONG_DESCR,' ')) or
       (Nvl(:old.SCH_FREE_DESCR,' ') <> Nvl(:new.SCH_FREE_DESCR,' ')) or
       (Nvl(:old.SCH_GENERIC_SUBCONTRACT,0) <> Nvl(:new.SCH_GENERIC_SUBCONTRACT,0)) then
      rep_functions.PublishSchedulePlan(:new.FAL_SCHEDULE_PLAN_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."FAL_SCH_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_SCHE_PLAN_AU_HISTO"
  after update
  on FAL_SCHEDULE_PLAN
  referencing old as old new as new
  for each row
declare
begin
  if updating then
    if nvl(:old.SCH_SHORT_DESCR, '') <> nvl(:new.SCH_SHORT_DESCR, '') then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , null
                                         , null
                                         , '44'
                                         , :old.SCH_SHORT_DESCR
                                         , :new.SCH_SHORT_DESCR
                                          );
    end if;

    if nvl(:old.SCH_LONG_DESCR, '') <> nvl(:new.SCH_LONG_DESCR, '') then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , null
                                         , null
                                         , '45'
                                         , :old.SCH_LONG_DESCR
                                         , :new.SCH_LONG_DESCR
                                          );
    end if;

    if nvl(:old.SCH_FREE_DESCR, '') <> nvl(:new.SCH_FREE_DESCR, '') then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , null
                                         , null
                                         , '46'
                                         , :old.SCH_FREE_DESCR
                                         , :new.SCH_FREE_DESCR
                                          );
    end if;

    if nvl(:old.C_SCHEDULE_PLANNING, '') <> nvl(:new.C_SCHEDULE_PLANNING, '') then
      FAL_SCHEDULE_PLAN_TOOLS.INSERT_HISTO(:old.FAL_SCHEDULE_PLAN_ID
                                         , null
                                         , null
                                         , '47'
                                         , :old.C_SCHEDULE_PLANNING
                                         , :new.C_SCHEDULE_PLANNING
                                          );
    end if;
  end if;
end FAL_SCHE_PLAN_AU_HISTO;

ALTER TRIGGER "C_ITX"."FAL_SCHE_PLAN_AU_HISTO" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_SCH_PLAN_BD_GENERIC_SUBC"
before delete
on FAL_SCHEDULE_PLAN
referencing old as old
for each row
/*
 Createur : CLG
 Date     : 03/01/2011
 Objet    : Empêcher la suppression de la gamme générique de sous-traitance
*/
begin
  if :old.SCH_GENERIC_SUBCONTRACT = 1 then
    Raise_application_error(-20000,'PCS - '
                                 || PCS.PC_PUBLIC.TranslateWord('La gamme générique de sous-traitance ne peut-être supprimée.'));
  end if;
end FAL_SCH_PLAN_BD_GENERIC_SUBC;

ALTER TRIGGER "C_ITX"."FAL_SCH_PLAN_BD_GENERIC_SUBC" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_SCH_PLAN_BU_GENERIC_SUBC"
before update of SCH_GENERIC_SUBCONTRACT
on FAL_SCHEDULE_PLAN
referencing old as old new as new
for each row
/*
 Createur : CLG
 Date     : 03/01/2011
 Objet    : Empêcher la modification de la gamme générique de sous-traitance
*/
begin
  if :old.SCH_GENERIC_SUBCONTRACT <> :new.SCH_GENERIC_SUBCONTRACT then
    Raise_application_error(-20000,'PCS - '
                                 || PCS.PC_PUBLIC.TranslateWord('La gamme générique de sous-traitance ne peut-être modifiée.'));
  end if;
end FAL_SCH_PLAN_BU_GENERIC_SUBC;

ALTER TRIGGER "C_ITX"."FAL_SCH_PLAN_BU_GENERIC_SUBC" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_SCS_AIU_REPLICATE"
  after insert or update
  on FAL_LIST_STEP_LINK
  referencing old as old new as new
  for each row
/**
 * Replication for table "Task list link"
 * @author spfister
 * @date 02/2013
 * Modifications:
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FAL_TRIGGERS') = 1) then
    if (Nvl(:old.FAL_SCHEDULE_STEP_ID,0) <> Nvl(:new.FAL_SCHEDULE_STEP_ID,0)) or
       (Nvl(:old.FAL_SCHEDULE_PLAN_ID,0) <> Nvl(:new.FAL_SCHEDULE_PLAN_ID,0)) or
       (Nvl(:old.PAC_SUPPLIER_PARTNER_ID,0) <> Nvl(:new.PAC_SUPPLIER_PARTNER_ID,0)) or
       (Nvl(:old.PPS_OPERATION_PROCEDURE_ID,0) <> Nvl(:new.PPS_OPERATION_PROCEDURE_ID,0)) or
       (Nvl(:old.PPS_PPS_OPERATION_PROCEDURE_ID,0) <> Nvl(:new.PPS_PPS_OPERATION_PROCEDURE_ID,0)) or
       (Nvl(:old.FAL_FACTORY_FLOOR_ID,0) <> Nvl(:new.FAL_FACTORY_FLOOR_ID,0)) or
       (Nvl(:old.FAL_TASK_ID,0) <> Nvl(:new.FAL_TASK_ID,0)) or
       (Nvl(:old.PPS_TOOLS1_ID,0) <> Nvl(:new.PPS_TOOLS1_ID,0)) or
       (Nvl(:old.PPS_TOOLS2_ID,0) <> Nvl(:new.PPS_TOOLS2_ID,0)) or
       (Nvl(:old.GCO_GCO_GOOD_ID,0) <> Nvl(:new.GCO_GCO_GOOD_ID,0)) or
       (Nvl(:old.FAL_FAL_FACTORY_FLOOR_ID,0) <> Nvl(:new.FAL_FAL_FACTORY_FLOOR_ID,0)) or
       (Nvl(:old.PPS_TOOLS3_ID,0) <> Nvl(:new.PPS_TOOLS3_ID,0)) or
       (Nvl(:old.PPS_TOOLS4_ID,0) <> Nvl(:new.PPS_TOOLS4_ID,0)) or
       (Nvl(:old.PPS_TOOLS5_ID,0) <> Nvl(:new.PPS_TOOLS5_ID,0)) or
       (Nvl(:old.PPS_TOOLS6_ID,0) <> Nvl(:new.PPS_TOOLS6_ID,0)) or
       (Nvl(:old.PPS_TOOLS7_ID,0) <> Nvl(:new.PPS_TOOLS7_ID,0)) or
       (Nvl(:old.PPS_TOOLS8_ID,0) <> Nvl(:new.PPS_TOOLS8_ID,0)) or
       (Nvl(:old.PPS_TOOLS9_ID,0) <> Nvl(:new.PPS_TOOLS9_ID,0)) or
       (Nvl(:old.PPS_TOOLS10_ID,0) <> Nvl(:new.PPS_TOOLS10_ID,0)) or
       (Nvl(:old.PPS_TOOLS11_ID,0) <> Nvl(:new.PPS_TOOLS11_ID,0)) or
       (Nvl(:old.PPS_TOOLS12_ID,0) <> Nvl(:new.PPS_TOOLS12_ID,0)) or
       (Nvl(:old.PPS_TOOLS13_ID,0) <> Nvl(:new.PPS_TOOLS13_ID,0)) or
       (Nvl(:old.PPS_TOOLS14_ID,0) <> Nvl(:new.PPS_TOOLS14_ID,0)) or
       (Nvl(:old.PPS_TOOLS15_ID,0) <> Nvl(:new.PPS_TOOLS15_ID,0)) or
       (Nvl(:old.C_TASK_TYPE,' ') <> Nvl(:new.C_TASK_TYPE,' ')) or
       (Nvl(:old.SCS_STEP_NUMBER,0) <> Nvl(:new.SCS_STEP_NUMBER,0)) or
       (Nvl(:old.SCS_WORK_TIME,0) <> Nvl(:new.SCS_WORK_TIME,0)) or
       (Nvl(:old.SCS_QTY_REF_WORK,0) <> Nvl(:new.SCS_QTY_REF_WORK,0)) or
       (Nvl(:old.SCS_WORK_RATE,0) <> Nvl(:new.SCS_WORK_RATE,0)) or
       (Nvl(:old.SCS_AMOUNT,0) <> Nvl(:new.SCS_AMOUNT,0)) or
       (Nvl(:old.SCS_QTY_REF_AMOUNT,0) <> Nvl(:new.SCS_QTY_REF_AMOUNT,0)) or
       (Nvl(:old.SCS_DIVISOR_AMOUNT,0) <> Nvl(:new.SCS_DIVISOR_AMOUNT,0)) or
       (Nvl(:old.SCS_PLAN_RATE,0) <> Nvl(:new.SCS_PLAN_RATE,0)) or
       (Nvl(:old.SCS_SHORT_DESCR,' ') <> Nvl(:new.SCS_SHORT_DESCR,' ')) or
       (Nvl(:old.SCS_LONG_DESCR,' ') <> Nvl(:new.SCS_LONG_DESCR,' ')) or
       (Nvl(:old.SCS_FREE_DESCR,' ') <> Nvl(:new.SCS_FREE_DESCR,' ')) or
       (Nvl(:old.C_OPERATION_TYPE,' ') <> Nvl(:new.C_OPERATION_TYPE,' ')) or
       (Nvl(:old.SCS_ADJUSTING_TIME,0) <> Nvl(:new.SCS_ADJUSTING_TIME,0)) or
       (Nvl(:old.DIC_FREE_TASK_CODE2_ID,' ') <> Nvl(:new.DIC_FREE_TASK_CODE2_ID,' ')) or
       (Nvl(:old.DIC_FREE_TASK_CODE_ID,' ') <> Nvl(:new.DIC_FREE_TASK_CODE_ID,' ')) or
       (Nvl(:old.SCS_PLAN_PROP,0) <> Nvl(:new.SCS_PLAN_PROP,0)) or
       (Nvl(:old.C_TASK_IMPUTATION,' ') <> Nvl(:new.C_TASK_IMPUTATION,' ')) or
       (Nvl(:old.SCS_TRANSFERT_TIME,0) <> Nvl(:new.SCS_TRANSFERT_TIME,0)) or
       (Nvl(:old.SCS_QTY_FIX_ADJUSTING,0) <> Nvl(:new.SCS_QTY_FIX_ADJUSTING,0)) or
       (Nvl(:old.SCS_ADJUSTING_RATE,0) <> Nvl(:new.SCS_ADJUSTING_RATE,0)) or
       (Nvl(:old.C_RELATION_TYPE,' ') <> Nvl(:new.C_RELATION_TYPE,' ')) or
       (Nvl(:old.SCS_DELAY,0) <> Nvl(:new.SCS_DELAY,0)) or
       (Nvl(:old.DIC_FREE_TASK_CODE3_ID,' ') <> Nvl(:new.DIC_FREE_TASK_CODE3_ID,' ')) or
       (Nvl(:old.DIC_FREE_TASK_CODE4_ID,' ') <> Nvl(:new.DIC_FREE_TASK_CODE4_ID,' ')) or
       (Nvl(:old.DIC_FREE_TASK_CODE5_ID,' ') <> Nvl(:new.DIC_FREE_TASK_CODE5_ID,' ')) or
       (Nvl(:old.DIC_FREE_TASK_CODE6_ID,' ') <> Nvl(:new.DIC_FREE_TASK_CODE6_ID,' ')) or
       (Nvl(:old.DIC_FREE_TASK_CODE7_ID,' ') <> Nvl(:new.DIC_FREE_TASK_CODE7_ID,' ')) or
       (Nvl(:old.DIC_FREE_TASK_CODE8_ID,' ') <> Nvl(:new.DIC_FREE_TASK_CODE8_ID,' ')) or
       (Nvl(:old.DIC_FREE_TASK_CODE9_ID,' ') <> Nvl(:new.DIC_FREE_TASK_CODE9_ID,' ')) or
       (Nvl(:old.SCS_NUM_FLOOR,0) <> Nvl(:new.SCS_NUM_FLOOR,0)) or
       (Nvl(:old.SCS_ADJUSTING_FLOOR,0) <> Nvl(:new.SCS_ADJUSTING_FLOOR,0)) or
       (Nvl(:old.SCS_ADJUSTING_OPERATOR,0) <> Nvl(:new.SCS_ADJUSTING_OPERATOR,0)) or
       (Nvl(:old.SCS_NUM_ADJUST_OPERATOR,0) <> Nvl(:new.SCS_NUM_ADJUST_OPERATOR,0)) or
       (Nvl(:old.SCS_PERCENT_ADJUST_OPER,0) <> Nvl(:new.SCS_PERCENT_ADJUST_OPER,0)) or
       (Nvl(:old.SCS_WORK_FLOOR,0) <> Nvl(:new.SCS_WORK_FLOOR,0)) or
       (Nvl(:old.SCS_WORK_OPERATOR,0) <> Nvl(:new.SCS_WORK_OPERATOR,0)) or
       (Nvl(:old.SCS_NUM_WORK_OPERATOR,0) <> Nvl(:new.SCS_NUM_WORK_OPERATOR,0)) or
       (Nvl(:old.SCS_PERCENT_WORK_OPER,0) <> Nvl(:new.SCS_PERCENT_WORK_OPER,0)) or
       (Nvl(:old.DIC_UNIT_OF_MEASURE_ID,' ') <> Nvl(:new.DIC_UNIT_OF_MEASURE_ID,' ')) or
       (Nvl(:old.SCS_CONVERSION_FACTOR,0) <> Nvl(:new.SCS_CONVERSION_FACTOR,0)) or
       (Nvl(:old.SCS_QTY_REF2_WORK,0) <> Nvl(:new.SCS_QTY_REF2_WORK,0)) or
       (Nvl(:old.SCS_FREE_NUM1,0) <> Nvl(:new.SCS_FREE_NUM1,0)) or
       (Nvl(:old.SCS_FREE_NUM2,0) <> Nvl(:new.SCS_FREE_NUM2,0)) or
       (Nvl(:old.SCS_FREE_NUM3,0) <> Nvl(:new.SCS_FREE_NUM3,0)) or
       (Nvl(:old.SCS_FREE_NUM4,0) <> Nvl(:new.SCS_FREE_NUM4,0)) or
       (Nvl(:old.SCS_WEIGH,0) <> Nvl(:new.SCS_WEIGH,0)) or
       (Nvl(:old.SCS_WEIGH_MANDATORY,0) <> Nvl(:new.SCS_WEIGH_MANDATORY,0)) or
       (Nvl(:old.SCS_OPEN_TIME_MACHINE,0) <> Nvl(:new.SCS_OPEN_TIME_MACHINE,0)) then
      rep_functions.PublishSchedulePlan(:new.FAL_SCHEDULE_PLAN_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."FAL_SCS_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_TAL_BIU_CALC_AMOUNT"
  before insert or update of SCS_AMOUNT, TAL_CST_UNIT_PRICE_B, SCS_DIVISOR_AMOUNT, SCS_QTY_REF_AMOUNT, TAL_PLAN_QTY, TAL_RELEASE_QTY, TAL_DUE_QTY
  on FAL_TASK_LINK
  referencing old as old new as new
  for each row
/**
* Description
*    En modification des quantité, quantité de référence, diviseur et montant
* @created AGA 24.04.2014
* @version 2014
* @lastUpdate
*/
declare
  nUnitPrice number;
begin
  nUnitPrice             := :new.TAL_CST_UNIT_PRICE_B;

  if nUnitPrice is null then
    if :new.SCS_DIVISOR_AMOUNT = 1 then
      nUnitPrice  := nvl(:new.SCS_AMOUNT, 0) / FAL_TOOLS.nvlA(:new.SCS_QTY_REF_AMOUNT, 1);
    else
      nUnitPrice  := nvl(:new.SCS_AMOUNT, 0) * FAL_TOOLS.nvlA(:new.SCS_QTY_REF_AMOUNT, 1);
    end if;
  end if;

  :new.TAL_DUE_AMT       := nvl(:new.TAL_PLAN_QTY, 0) * nUnitPrice;
  :new.TAL_ACHIEVED_AMT  := nvl(:new.TAL_RELEASE_QTY, 0) * nUnitPrice;
  :new.TAL_AMT_BALANCE   := nvl(:new.TAL_DUE_QTY, 0) * nUnitPrice;
end FAL_TAL_BIU_CALC_AMOUNT;

ALTER TRIGGER "C_ITX"."FAL_TAL_BIU_CALC_AMOUNT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_TAL_PCST_AU_FREE_NUMBER"
  after update
  of TAL_PCST_NUMBER
  on FAL_TASK_LINK
  referencing old as old new as new
  for each row
/**
* Description
*    Suppression du numéro de la PCST dans la table doc_free_number
* @author Matthey Stéphanie
* @lastUpdate SMA DEZ.2012
* @version 2012
*/
begin
  -- supression coute que coute de la table des numéros libres
  if :new.TAL_PCST_NUMBER is not null then
    DOC_PRC_DOCUMENT.DeleteFreeNumber(:new.TAL_PCST_NUMBER);
  end if;
end FAL_TAL_PCST_AU_FREE_NUMBER;

ALTER TRIGGER "C_ITX"."FAL_TAL_PCST_AU_FREE_NUMBER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_TAL_PR_PCST_AU_FREE_NUMBER"
  after update
  of TAL_PCST_NUMBER
  on FAL_TASK_LINK_PROP
  referencing old as old new as new
  for each row
/**
* Description
*    Suppression du numéro de la PCST dans la table doc_free_number
* @author Matthey Stéphanie
* @lastUpdate SMA DEZ.2012
* @version 2012
*/
begin
  -- supression coute que coute de la table des numéros libres
  if :new.TAL_PCST_NUMBER is not null then
    DOC_PRC_DOCUMENT.DeleteFreeNumber(:new.TAL_PCST_NUMBER);
  end if;
end FAL_TAL_PR_PCST_AU_FREE_NUMBER;

ALTER TRIGGER "C_ITX"."FAL_TAL_PR_PCST_AU_FREE_NUMBER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_TAS_AIU_REPLICATE"
  after insert or update
  on FAL_TASK
  referencing old as old new as new
  for each row
/**
 * Replication for table "Task"
 * @author spfister
 * @date 02/2013
 * Modifications:
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_FAL_TRIGGERS') = 1) then
    if (Nvl(:old.FAL_FACTORY_FLOOR_ID,0) <> Nvl(:new.FAL_FACTORY_FLOOR_ID,0)) or
       (Nvl(:old.PPS_TOOLS1_ID,0) <> Nvl(:new.PPS_TOOLS1_ID,0)) or
       (Nvl(:old.PPS_TOOLS2_ID,0) <> Nvl(:new.PPS_TOOLS2_ID,0)) or
       (Nvl(:old.PAC_SUPPLIER_PARTNER_ID,0) <> Nvl(:new.PAC_SUPPLIER_PARTNER_ID,0)) or
       (Nvl(:old.GCO_GCO_GOOD_ID,0) <> Nvl(:new.GCO_GCO_GOOD_ID,0)) or
       (Nvl(:old.PPS_OPERATION_PROCEDURE_ID,0) <> Nvl(:new.PPS_OPERATION_PROCEDURE_ID,0)) or
       (Nvl(:old.PPS_PPS_OPERATION_PROCEDURE_ID,0) <> Nvl(:new.PPS_PPS_OPERATION_PROCEDURE_ID,0)) or
       (Nvl(:old.FAL_FAL_FACTORY_FLOOR_ID,0) <> Nvl(:new.FAL_FAL_FACTORY_FLOOR_ID,0)) or
       (Nvl(:old.PPS_TOOLS3_ID,0) <> Nvl(:new.PPS_TOOLS3_ID,0)) or
       (Nvl(:old.PPS_TOOLS4_ID,0) <> Nvl(:new.PPS_TOOLS4_ID,0)) or
       (Nvl(:old.PPS_TOOLS5_ID,0) <> Nvl(:new.PPS_TOOLS5_ID,0)) or
       (Nvl(:old.PPS_TOOLS6_ID,0) <> Nvl(:new.PPS_TOOLS6_ID,0)) or
       (Nvl(:old.PPS_TOOLS7_ID,0) <> Nvl(:new.PPS_TOOLS7_ID,0)) or
       (Nvl(:old.PPS_TOOLS8_ID,0) <> Nvl(:new.PPS_TOOLS8_ID,0)) or
       (Nvl(:old.PPS_TOOLS9_ID,0) <> Nvl(:new.PPS_TOOLS9_ID,0)) or
       (Nvl(:old.PPS_TOOLS10_ID,0) <> Nvl(:new.PPS_TOOLS10_ID,0)) or
       (Nvl(:old.PPS_TOOLS11_ID,0) <> Nvl(:new.PPS_TOOLS11_ID,0)) or
       (Nvl(:old.PPS_TOOLS12_ID,0) <> Nvl(:new.PPS_TOOLS12_ID,0)) or
       (Nvl(:old.PPS_TOOLS13_ID,0) <> Nvl(:new.PPS_TOOLS13_ID,0)) or
       (Nvl(:old.PPS_TOOLS14_ID,0) <> Nvl(:new.PPS_TOOLS14_ID,0)) or
       (Nvl(:old.PPS_TOOLS15_ID,0) <> Nvl(:new.PPS_TOOLS15_ID,0)) or
       (Nvl(:old.DIC_FREE_TASK_CODE2_ID,' ') <> Nvl(:new.DIC_FREE_TASK_CODE2_ID,' ')) or
       (Nvl(:old.C_TASK_TYPE,' ') <> Nvl(:new.C_TASK_TYPE,' ')) or
       (Nvl(:old.TAS_REF,' ') <> Nvl(:new.TAS_REF,' ')) or
       (Nvl(:old.TAS_SHORT_DESCR,' ') <> Nvl(:new.TAS_SHORT_DESCR,' ')) or
       (Nvl(:old.TAS_LONG_DESCR,' ') <> Nvl(:new.TAS_LONG_DESCR,' ')) or
       (Nvl(:old.TAS_FREE_DESCR,' ') <> Nvl(:new.TAS_FREE_DESCR,' ')) or
       (Nvl(:old.DIC_FREE_TASK_CODE_ID,' ') <> Nvl(:new.DIC_FREE_TASK_CODE_ID,' ')) or
       (Nvl(:old.C_TASK_IMPUTATION,' ') <> Nvl(:new.C_TASK_IMPUTATION,' ')) or
       (Nvl(:old.DIC_UNIT_OF_MEASURE_ID,' ') <> Nvl(:new.DIC_UNIT_OF_MEASURE_ID,' ')) or
       (Nvl(:old.C_SCHEDULE_PLANNING,' ') <> Nvl(:new.C_SCHEDULE_PLANNING,' ')) or
       (Nvl(:old.DIC_FREE_TASK_CODE3_ID,' ') <> Nvl(:new.DIC_FREE_TASK_CODE3_ID,' ')) or
       (Nvl(:old.DIC_FREE_TASK_CODE4_ID,' ') <> Nvl(:new.DIC_FREE_TASK_CODE4_ID,' ')) or
       (Nvl(:old.DIC_FREE_TASK_CODE5_ID,' ') <> Nvl(:new.DIC_FREE_TASK_CODE5_ID,' ')) or
       (Nvl(:old.DIC_FREE_TASK_CODE6_ID,' ') <> Nvl(:new.DIC_FREE_TASK_CODE6_ID,' ')) or
       (Nvl(:old.DIC_FREE_TASK_CODE7_ID,' ') <> Nvl(:new.DIC_FREE_TASK_CODE7_ID,' ')) or
       (Nvl(:old.DIC_FREE_TASK_CODE8_ID,' ') <> Nvl(:new.DIC_FREE_TASK_CODE8_ID,' ')) or
       (Nvl(:old.DIC_FREE_TASK_CODE9_ID,' ') <> Nvl(:new.DIC_FREE_TASK_CODE9_ID,' ')) or
       (Nvl(:old.TAS_ADJUSTING_RATE,0) <> Nvl(:new.TAS_ADJUSTING_RATE,0)) or
       (Nvl(:old.TAS_WORK_RATE,0) <> Nvl(:new.TAS_WORK_RATE,0)) or
       (Nvl(:old.TAS_NUM_FLOOR,0) <> Nvl(:new.TAS_NUM_FLOOR,0)) or
       (Nvl(:old.TAS_ADJUSTING_FLOOR,0) <> Nvl(:new.TAS_ADJUSTING_FLOOR,0)) or
       (Nvl(:old.TAS_ADJUSTING_OPERATOR,0) <> Nvl(:new.TAS_ADJUSTING_OPERATOR,0)) or
       (Nvl(:old.TAS_NUM_ADJUST_OPERATOR,0) <> Nvl(:new.TAS_NUM_ADJUST_OPERATOR,0)) or
       (Nvl(:old.TAS_PERCENT_ADJUST_OPER,0) <> Nvl(:new.TAS_PERCENT_ADJUST_OPER,0)) or
       (Nvl(:old.TAS_WORK_FLOOR,0) <> Nvl(:new.TAS_WORK_FLOOR,0)) or
       (Nvl(:old.TAS_WORK_OPERATOR,0) <> Nvl(:new.TAS_WORK_OPERATOR,0)) or
       (Nvl(:old.TAS_NUM_WORK_OPERATOR,0) <> Nvl(:new.TAS_NUM_WORK_OPERATOR,0)) or
       (Nvl(:old.TAS_PERCENT_WORK_OPER,0) <> Nvl(:new.TAS_PERCENT_WORK_OPER,0)) or
       (Nvl(:old.TAS_CONVERSION_FACTOR,0) <> Nvl(:new.TAS_CONVERSION_FACTOR,0)) or
       (Nvl(:old.TAS_FREE_NUM1,0) <> Nvl(:new.TAS_FREE_NUM1,0)) or
       (Nvl(:old.TAS_FREE_NUM2,0) <> Nvl(:new.TAS_FREE_NUM2,0)) or
       (Nvl(:old.TAS_FREE_NUM3,0) <> Nvl(:new.TAS_FREE_NUM3,0)) or
       (Nvl(:old.TAS_FREE_NUM4,0) <> Nvl(:new.TAS_FREE_NUM4,0)) or
       (Nvl(:old.TAS_WEIGH,0) <> Nvl(:new.TAS_WEIGH,0)) or
       (Nvl(:old.TAS_WEIGH_MANDATORY,0) <> Nvl(:new.TAS_WEIGH_MANDATORY,0)) or
       (Nvl(:old.TAS_AJUSTING_RATE,0) <> Nvl(:new.TAS_AJUSTING_RATE,0)) or
       (Nvl(:old.TAS_GENERIC_SUBCONTRACT,0) <> Nvl(:new.TAS_GENERIC_SUBCONTRACT,0)) or
       (Nvl(:old.TAS_OPEN_TIME_MACHINE,0) <> Nvl(:new.TAS_OPEN_TIME_MACHINE,0)) or
       (Nvl(:old.TAS_TRANSFERT_TIME,0) <> Nvl(:new.TAS_TRANSFERT_TIME,0)) or
       (Nvl(:old.TAS_AMOUNT,0) <> Nvl(:new.TAS_AMOUNT,0)) or
       (Nvl(:old.TAS_QTY_REF_AMOUNT,0) <> Nvl(:new.TAS_QTY_REF_AMOUNT,0)) or
       (Nvl(:old.TAS_DIVISOR_AMOUNT,0) <> Nvl(:new.TAS_DIVISOR_AMOUNT,0)) or
       (Nvl(:old.TAS_PLAN_RATE,0) <> Nvl(:new.TAS_PLAN_RATE,0)) or
       (Nvl(:old.TAS_PLAN_PROP,0) <> Nvl(:new.TAS_PLAN_PROP,0)) then
      rep_functions.PublishTask(:new.FAL_TASK_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."FAL_TAS_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_TASK_BD_GENERIC_SUBC_OPE"
before delete
on FAL_TASK
referencing old as old
for each row
/*
 Createur : CLG
 Date     : 03/01/2011
 Objet    : Empêcher la suppression de l'opération générique de sous-traitance
*/
begin
  if :old.TAS_GENERIC_SUBCONTRACT = 1 then
    Raise_application_error(-20000,'PCS - '
                                 || PCS.PC_PUBLIC.TranslateWord('L''opération générique de sous-traitance ne peut-être supprimée.'));
  end if;
end FAL_TASK_BD_GENERIC_SUBC_OPE;

ALTER TRIGGER "C_ITX"."FAL_TASK_BD_GENERIC_SUBC_OPE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_TASK_BU_GENERIC_SUBC_OPE"
before update of TAS_GENERIC_SUBCONTRACT
on FAL_TASK
referencing old as old new as new
for each row
/*
 Createur : CLG
 Date     : 03/01/2011
 Objet    : Empêcher la modification de l'opération générique de sous-traitance
*/
begin
  if :old.TAS_GENERIC_SUBCONTRACT <> :new.TAS_GENERIC_SUBCONTRACT then
    Raise_application_error(-20000,'PCS - '
                                 || PCS.PC_PUBLIC.TranslateWord('L''opération générique de sous-traitance ne peut-être modifiée.'));
  end if;
end FAL_TASK_BU_GENERIC_SUBC_OPE;

ALTER TRIGGER "C_ITX"."FAL_TASK_BU_GENERIC_SUBC_OPE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_TASK_LINK_BD_DOC_POS_DET"
  before delete
  on FAL_TASK_LINK
  referencing old as old
  for each row
/*
 Createur : ECA
 Update   : SMA 06.2012
 Date     : 22/09/2006
 Objet    : Empêcher la suppression d'une opération liée à un détail de position
            qui ne soit pas liquidée ou annulée (Exception quand le status du lot est planifé).
*/
declare
  aDOC_POSITION_DETAIL_ID DOC_POSITION_DETAIL.DOC_POSITION_DETAIL_ID%type;
  lnExistLotId            FAL_LOT.FAL_LOT_ID%type;
  lvBatchStatus           FAL_LOT.C_LOT_STATUS%type;
  lbIsBatchPlanified      boolean;
begin
  aDOC_POSITION_DETAIL_ID  := 0;

  begin
    select FAL_LOT_ID
      into lnExistLotId
      from FAL_LOT
     where FAL_LOT_ID = :old.FAL_LOT_ID;
  exception
    when others then
      lnExistLotId  := null;
  end;

  if lnExistLotId is not null then
    -- Récupération du status du lot
    lvBatchStatus := COM_I_LIB_LIST_ID_TEMP.getGlobalVar(iVarName => 'BATCH_STATUS');
    if lvBatchStatus is not null then
      lbIsBatchPlanified := lvBatchStatus = FAL_LIB_BATCH.cLotStatusPlanified;
    else
      lbIsBatchPlanified := FAL_LIB_BATCH.IsBatchPlanified_Autonomus(lnExistLotId);
    end if;

    if not lbIsBatchPlanified then
      -- Opération liée à un détail de position non liquidé ou annulé
      select max(PDE.DOC_POSITION_DETAIL_ID)
        into aDOC_POSITION_DETAIL_ID
        from DOC_POSITION_DETAIL PDE
           , DOC_POSITION POS
       where PDE.FAL_SCHEDULE_STEP_ID = :old.FAL_SCHEDULE_STEP_ID
         and PDE.DOC_POSITION_ID = POS.DOC_POSITION_ID
         and POS.C_DOC_POS_STATUS not in('04', '05');

      if aDOC_POSITION_DETAIL_ID <> 0 then
        Raise_application_error(-20000
                              , 'PCS - ' ||
                                PCS.PC_FUNCTIONS.TranslateWord('L''opération n°') ||
                                :old.SCS_STEP_NUMBER ||
                                ' ' ||
                                PCS.PC_FUNCTIONS.TranslateWord('ne peut être supprimée car elle est liée à un document non soldé!')
                               );
      end if;
    else
      -- Opération liée à un détail de position ayant généré un mouvement
      select max(PDE.DOC_POSITION_DETAIL_ID)
        into aDOC_POSITION_DETAIL_ID
        from DOC_POSITION_DETAIL PDE
           , DOC_POSITION POS
       where PDE.FAL_SCHEDULE_STEP_ID = :old.FAL_SCHEDULE_STEP_ID
         and PDE.DOC_POSITION_ID = POS.DOC_POSITION_ID
         and POS.POS_GENERATE_MOVEMENT = 1;

      if aDOC_POSITION_DETAIL_ID <> 0 then
        Raise_application_error(-20000
                              , 'PCS - ' ||
                                PCS.PC_FUNCTIONS.TranslateWord('L''opération n°') ||
                                :old.SCS_STEP_NUMBER ||
                                ' ' ||
                                PCS.PC_FUNCTIONS.TranslateWord('ne peut être supprimée car elle est liée à un document contenant des mouvements!')
                               );
      end if;
    end if;
  end if;
end FAL_TASK_LINK_BD_DOC_POS_DET;

ALTER TRIGGER "C_ITX"."FAL_TASK_LINK_BD_DOC_POS_DET" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_TASK_LINK_BIU_ORT"
  before insert or update
  on FAL_TASK_LINK
  referencing old as old new as new
  for each row
/**
* Description
*    Permet d'affecter un code libre 1 sur les opérations de gamme qui portent sur un atelier ayant le paramètre 'CODEOP' actif. Ceci est nécessaire pour
*    l'exportation vers Ortems en config FAL_ORT_ADJUSTING = 4:
* @created CLG 11.2001
* @updated AGE 30.03.2015
*    Affectation de l'article et du code op comme CODEOP. Mise à jour doit se faire dans les OFs et les POFs et non plus dans les gammes.
* @version 2014
* @lastUpdate
*/
declare
  lParamCodeOp    integer;
  lFreeTaskCodeId DIC_FREE_TASK_CODE.DIC_FREE_TASK_CODE_ID%type;
  lGt1Describe    DIC_FREE_TASK_CODE.GT1_DESCRIBE%type;
begin
  -- Ne rien faire si la valeur de la config 'FAL_ORT_ADJUSTING' est différente de '4'.
  if pcs.PC_CONFIG.GetConfig('FAL_ORT_ADJUSTING') <> '4' then
    return;
  end if;

  -- On regarde si l'opération dépend d'un atelier qui porte le paramètre 'CODEOP'
  select count(*)
    into lParamCodeOp
    from FAL_FACTORY_FLOOR FFF
       , FAL_FACTORY_PARAMETER FFP
   where FFF.FAL_FACTORY_FLOOR_ID = FFP.FAL_FACTORY_FLOOR_ID
     and FFF.FAL_FACTORY_FLOOR_ID = :new.FAL_FACTORY_FLOOR_ID
     and FFP.DIC_GCO_CHAR_CODE_TYPE_ID = 'CODEOP';

  if lParamCodeOp > 0 then
    select max(GCO.GOO_MAJOR_REFERENCE || '/' || TAS.TAS_REF)
      into lGt1Describe
      from FAL_LOT LOT
         , GCO_GOOD GCO
         , FAL_TASK TAS
     where LOT.FAL_LOT_ID = :new.FAL_LOT_ID
       and LOT.GCO_GOOD_ID = GCO.GCO_GOOD_ID
       and TAS.FAL_TASK_ID = :new.FAL_TASK_ID;

    select max(DIC_FREE_TASK_CODE_ID)
      into lFreeTaskCodeId
      from DIC_FREE_TASK_CODE
     where GT1_DESCRIBE(+) = lGt1Describe;

    if lFreeTaskCodeId is null then
      lFreeTaskCodeId  := GetNewId;

      insert into DIC_FREE_TASK_CODE
                  (DIC_FREE_TASK_CODE_ID
                 , GT1_DESCRIBE
                 , A_DATECRE
                 , A_IDCRE
                  )
           values (lFreeTaskCodeId
                 , lGt1Describe
                 , sysdate
                 , PCS.PC_I_LIB_SESSION.GetUserIni
                  );
    end if;

    :new.DIC_FREE_TASK_CODE_ID  := lFreeTaskCodeId;
  else
    :new.DIC_FREE_TASK_CODE_ID  := null;
  end if;
end;

ALTER TRIGGER "C_ITX"."FAL_TASK_LINK_BIU_ORT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_TASK_LINK_BU_MACHINE"
  before update of FAL_FACTORY_FLOOR_ID
  on FAL_TASK_LINK
  referencing old as old new as new
  for each row
/**
* Description
*    En modification de l'atelier sur l'opération de gamme, suppression des machines des LMU qui ne
*    sont pas liées au nouvel atelier (si atelier est un îlot) ou liées au même îlot que l'atelier
*    ( si atelier est une machine)
* @created CLE 09.06.2008
* @version 2003
* @lastUpdate
*/
declare
begin
  if (nvl(:new.FAL_FACTORY_FLOOR_ID, 0) <> nvl(:old.FAL_FACTORY_FLOOR_ID, 0) ) then
    delete      FAL_TASK_LINK_USE FTLU
          where FAL_SCHEDULE_STEP_ID = :new.FAL_SCHEDULE_STEP_ID
            and (select FAL_FAL_FACTORY_FLOOR_ID
                   from FAL_FACTORY_FLOOR
                  where FAL_FACTORY_FLOOR_ID = FTLU.FAL_FACTORY_FLOOR_ID) <>
                       nvl( (select max(FAL_FAL_FACTORY_FLOOR_ID)
                               from FAL_FACTORY_FLOOR
                              where FAL_FACTORY_FLOOR_ID = :new.FAL_FACTORY_FLOOR_ID)
                         , nvl(:new.FAL_FACTORY_FLOOR_ID, 0) );
  end if;
end FAL_TASK_LINK_BU_MACHINE;

ALTER TRIGGER "C_ITX"."FAL_TASK_LINK_BU_MACHINE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAL_TASK_LINK_PROP_BIU_ORT"
  before insert or update
  on FAL_TASK_LINK_PROP
  referencing old as old new as new
  for each row
/**
* Description
*    Permet d'affecter un code libre 1 sur les opérations de gamme qui portent sur un atelier ayant le paramètre 'CODEOP' actif. Ceci est nécessaire pour
*    l'exportation vers Ortems en config FAL_ORT_ADJUSTING = 4:
* @created CLG 11.2001
* @updated AGE 30.03.2015
*    Affectation de l'article et du code op comme CODEOP. Mise à jour doit se faire dans les OFs et les POFs et non plus dans les gammes.
* @version 2014
* @lastUpdate
*/
declare
  lParamCodeOp    integer;
  lFreeTaskCodeId DIC_FREE_TASK_CODE.DIC_FREE_TASK_CODE_ID%type;
  lGt1Describe    DIC_FREE_TASK_CODE.GT1_DESCRIBE%type;
begin
  -- Ne rien faire si la valeur de la config 'FAL_ORT_ADJUSTING' est différente de '4'.
  if pcs.PC_CONFIG.GetConfig('FAL_ORT_ADJUSTING') <> '4' then
    return;
  end if;

  -- On regarde si l'opération dépend d'un atelier qui porte le paramètre 'CODEOP'
  select count(*)
    into lParamCodeOp
    from FAL_FACTORY_FLOOR FFF
       , FAL_FACTORY_PARAMETER FFP
   where FFF.FAL_FACTORY_FLOOR_ID = FFP.FAL_FACTORY_FLOOR_ID
     and FFF.FAL_FACTORY_FLOOR_ID = :new.FAL_FACTORY_FLOOR_ID
     and FFP.DIC_GCO_CHAR_CODE_TYPE_ID = 'CODEOP';

  if lParamCodeOp > 0 then
    select max(GCO.GOO_MAJOR_REFERENCE || '/' || TAS.TAS_REF)
      into lGt1Describe
      from FAL_LOT_PROP PROP
         , GCO_GOOD GCO
         , FAL_TASK TAS
     where PROP.FAL_LOT_PROP_ID = :new.FAL_LOT_PROP_ID
       and PROP.GCO_GOOD_ID = GCO.GCO_GOOD_ID
       and TAS.FAL_TASK_ID = :new.FAL_TASK_ID;

    select max(DIC_FREE_TASK_CODE_ID)
      into lFreeTaskCodeId
      from DIC_FREE_TASK_CODE
     where GT1_DESCRIBE(+) = lGt1Describe;

    if lFreeTaskCodeId is null then
      lFreeTaskCodeId  := GetNewId;

      insert into DIC_FREE_TASK_CODE
                  (DIC_FREE_TASK_CODE_ID
                 , GT1_DESCRIBE
                 , A_DATECRE
                 , A_IDCRE
                  )
           values (lFreeTaskCodeId
                 , lGt1Describe
                 , sysdate
                 , PCS.PC_I_LIB_SESSION.GetUserIni
                  );
    end if;

    :new.DIC_FREE_TASK_CODE_ID  := lFreeTaskCodeId;
  else
    :new.DIC_FREE_TASK_CODE_ID  := null;
  end if;
end;

ALTER TRIGGER "C_ITX"."FAL_TASK_LINK_PROP_BIU_ORT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_ACT_FIM_AD_TOT_BY_PERIOD"
  after delete
  on FAM_ACT_IMPUTATION
  referencing old as old new as new
  for each row
/**
* Description
*
* @version 2003
* @lastUpdate
*/
declare
  vAssetsId    FAM_IMPUTATION.FAM_FIXED_ASSETS_ID%type;
  vPeriodId    FAM_IMPUTATION.ACS_PERIOD_ID%type;
  vLCurrencyId FAM_IMPUTATION.ACS_ACS_FINANCIAL_CURRENCY_ID%type;
begin
  select IMP.FAM_FIXED_ASSETS_ID
       , IMP.ACS_PERIOD_ID
       , IMP.ACS_ACS_FINANCIAL_CURRENCY_ID
    into vAssetsId
       , vPeriodId
       , vLCurrencyId
    from FAM_IMPUTATION IMP
   where IMP.FAM_IMPUTATION_ID = :old.FAM_IMPUTATION_ID;

  FAM_TOT_BY_PERIOD.UpdateACT_TotalByPeriod(:old.FAM_DOCUMENT_ID
                                          , vAssetsId
                                          , null
                                          , vPeriodId
                                          , null
                                          , vLCurrencyId
                                          , null
                                          , :old.C_FAM_IMPUTATION_TYP
                                          , null
                                          , :old.ACS_FINANCIAL_ACCOUNT_ID
                                          , null
                                          , :old.ACS_DIVISION_ACCOUNT_ID
                                          , null
                                          , :old.ACS_CPN_ACCOUNT_ID
                                          , null
                                          , :old.ACS_CDA_ACCOUNT_ID
                                          , null
                                          , :old.ACS_PF_ACCOUNT_ID
                                          , null
                                          , :old.ACS_PJ_ACCOUNT_ID
                                          , null
                                          , :old.FIM_AMOUNT_LC_D
                                          , null
                                          , :old.FIM_AMOUNT_LC_C
                                          , null
                                           );
exception
  when ex.TABLE_MUTATING then
    null;
end FAM_ACT_FIM_AD_TOT_BY_PERIOD;

ALTER TRIGGER "C_ITX"."FAM_ACT_FIM_AD_TOT_BY_PERIOD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_ACT_FIM_AI_TOT_BY_PERIOD"
  after insert
  on FAM_ACT_IMPUTATION
  referencing old as old new as new
  for each row
/**
* Description
*
* @version 2003
* @lastUpdate
*/
declare
  vAssetsId    FAM_IMPUTATION.FAM_FIXED_ASSETS_ID%type;
  vPeriodId    FAM_IMPUTATION.ACS_PERIOD_ID%type;
  vLCurrencyId FAM_IMPUTATION.ACS_ACS_FINANCIAL_CURRENCY_ID%type;
begin
  select IMP.FAM_FIXED_ASSETS_ID
       , IMP.ACS_PERIOD_ID
       , IMP.ACS_ACS_FINANCIAL_CURRENCY_ID
    into vAssetsId
       , vPeriodId
       , vLCurrencyId
    from FAM_IMPUTATION IMP
   where IMP.FAM_IMPUTATION_ID = :new.FAM_IMPUTATION_ID;

  FAM_TOT_BY_PERIOD.UpdateACT_TotalByPeriod(:NEW.FAM_DOCUMENT_ID,
                                            null,                vAssetsId,
                                            null,                vPeriodId,
                                            null,                vLCurrencyId,
                                            null,                :NEW.C_FAM_IMPUTATION_TYP,
                                            null,                :NEW.ACS_FINANCIAL_ACCOUNT_ID,
                                            null,                :NEW.ACS_DIVISION_ACCOUNT_ID,
                                            null,                :NEW.ACS_CPN_ACCOUNT_ID,
                                            null,                :NEW.ACS_CDA_ACCOUNT_ID,
                                            null,                :NEW.ACS_PF_ACCOUNT_ID,
                                            null,                :NEW.ACS_PJ_ACCOUNT_ID,
                                            null,                :NEW.FIM_AMOUNT_LC_D,
                                            null,                :NEW.FIM_AMOUNT_LC_C);

end FAM_ACT_FIM_AI_TOT_BY_PERIOD;

ALTER TRIGGER "C_ITX"."FAM_ACT_FIM_AI_TOT_BY_PERIOD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_ACT_FIM_AU_TOT_BY_PERIOD"
  after update of C_FAM_IMPUTATION_TYP
                , ACS_FINANCIAL_ACCOUNT_ID
                , ACS_DIVISION_ACCOUNT_ID
                , ACS_CPN_ACCOUNT_ID
                , ACS_CDA_ACCOUNT_ID
                , ACS_PF_ACCOUNT_ID
                , ACS_PJ_ACCOUNT_ID
                , FIM_AMOUNT_LC_D
                , FIM_AMOUNT_LC_C
                , FIM_AMOUNT_FC_D
                , FIM_AMOUNT_FC_C
  on FAM_ACT_IMPUTATION
  referencing old as old new as new
  for each row
/**
* Description
*
* @version 2003
* @lastUpdate
*/
declare
  vAssetsId    FAM_IMPUTATION.FAM_FIXED_ASSETS_ID%type;
  vPeriodId    FAM_IMPUTATION.ACS_PERIOD_ID%type;
  vLCurrencyId FAM_IMPUTATION.ACS_ACS_FINANCIAL_CURRENCY_ID%type;
begin
  select IMP.FAM_FIXED_ASSETS_ID
       , IMP.ACS_PERIOD_ID
       , IMP.ACS_ACS_FINANCIAL_CURRENCY_ID
    into vAssetsId
       , vPeriodId
       , vLCurrencyId
    from FAM_IMPUTATION IMP
   where IMP.FAM_IMPUTATION_ID = :old.FAM_IMPUTATION_ID;

  FAM_TOT_BY_PERIOD.UpdateACT_TotalByPeriod(:NEW.FAM_DOCUMENT_ID,
                                            vAssetsId,                           vAssetsId,
                                            vPeriodId,                           vPeriodId,
                                            vLCurrencyId,                        vLCurrencyId,
                                            :OLD.C_FAM_IMPUTATION_TYP,          :NEW.C_FAM_IMPUTATION_TYP,
                                            :OLD.ACS_FINANCIAL_ACCOUNT_ID,      :NEW.ACS_FINANCIAL_ACCOUNT_ID,
                                            :OLD.ACS_DIVISION_ACCOUNT_ID,       :NEW.ACS_DIVISION_ACCOUNT_ID,
                                            :OLD.ACS_CPN_ACCOUNT_ID,            :NEW.ACS_CPN_ACCOUNT_ID,
                                            :OLD.ACS_CDA_ACCOUNT_ID,            :NEW.ACS_CDA_ACCOUNT_ID,
                                            :OLD.ACS_PF_ACCOUNT_ID,             :NEW.ACS_PF_ACCOUNT_ID,
                                            :OLD.ACS_PJ_ACCOUNT_ID,             :NEW.ACS_PJ_ACCOUNT_ID,
                                            :OLD.FIM_AMOUNT_LC_D,               :NEW.FIM_AMOUNT_LC_D,
                                            :OLD.FIM_AMOUNT_LC_C,               :NEW.FIM_AMOUNT_LC_C);
end FAM_ACT_FIM_AU_TOT_BY_PERIOD;

ALTER TRIGGER "C_ITX"."FAM_ACT_FIM_AU_TOT_BY_PERIOD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_AMO_APPLICATION_AU"
  after update of APP_AMORTIZATION_BEGIN
                , APP_LIN_AMORTIZATION
                , APP_DEC_AMORTIZATION
                , APP_NEGATIVE_BASE
                , DIC_FAM_COEFFICIENT_ID
  on FAM_AMO_APPLICATION
  referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour / Calcul  des plans d'amortissement suite à saisie / changement
*   d'une exception sur la fiche immo
* @author Sener Kalayci
* @version 2003
* @lastUpdate
*/
declare
  --Curseur des immobilisations ayant un lien sur la valeur gérée donnée
  --Ne pas prendre Min et Max, des immobilisations se trouvant dasn la fourchette
  --ne gèrent pas forcément la valeur gérée
  cursor crFamFixedAssets
  is
    select   FIX.FAM_FIXED_ASSETS_ID   -- Immobilisation
           , AMO.FAM_AMORTIZATION_METHOD_ID   -- Méthode d'amortissement
           , AMO.AMO_ROUNDED_AMOUNT   -- Montant arrondi
           , AMO.C_AMORTIZATION_PERIOD   -- Cadence d'amortissment
           , AMO.C_AMORTIZATION_TYP   -- Type d'amortissment
           , AMO.C_ROUND_TYPE   -- Type d'arrondi
           , nvl(DEF.DEF_MIN_RESIDUAL_VALUE, 0) DEF_MIN_RESIDUAL_VALUE   -- Valeur résiduelle minimum
           , case   --Taux 1 selon type amortissement
               when AMO.C_AMORTIZATION_TYP in('1', '3', '5', '6', '9', '60') then nvl(:NEW.APP_LIN_AMORTIZATION
                                                                                    , DEF.DEF_LIN_AMORTIZATION)
               when AMO.C_AMORTIZATION_TYP in('2', '4') then nvl(:NEW.APP_DEC_AMORTIZATION, DEF.DEF_DEC_AMORTIZATION)
               else 0
             end Rate1
           , case   --Taux 2 selon type amortissement
               when AMO.C_AMORTIZATION_TYP in('5', '6', '9', '60') then nvl(:NEW.APP_DEC_AMORTIZATION
                                                                          , DEF.DEF_DEC_AMORTIZATION
                                                                           )
               else null
             end Rate2
           , case   --Coeeficient pour types 6,60
               when AMO.C_AMORTIZATION_TYP in('6', '60') then nvl(:NEW.DIC_FAM_COEFFICIENT_ID
                                                                , DEF.DIC_FAM_COEFFICIENT_ID
                                                                 )
               else null
             end COEFFICIENT
           ,
             -- Durée d'amortissement systématiquement calculée(100/taux1)même si renseignée sur la fiche Arrondi à 2 déc. comme définie
             round(100 /
                   decode(decode(:new.APP_LIN_AMORTIZATION, 0, null, :new.APP_LIN_AMORTIZATION)
                        , null, decode(DEF.DEF_LIN_AMORTIZATION, 0, null, DEF.DEF_LIN_AMORTIZATION)
                        , :new.APP_LIN_AMORTIZATION
                         )
                 , 2
                  ) APP_MONTH_DURATION
           , nvl(DEF.FAM_STRUCTURE_ELEMENT1_ID, VAL.FAM_STRUCTURE_ELEMENT_ID) FAM_STRUCTURE_ELEMENT1_ID  -- Base amortissement 1
           , nvl(DEF.FAM_STRUCTURE_ELEMENT6_ID, VAL.FAM_STRUCTURE_ELEMENT6_ID) FAM_STRUCTURE_ELEMENT6_ID  -- Base amortissement 2
           , nvl(DEF.FAM_STRUCTURE_ELEMENT3_ID, VAL.FAM_STRUCTURE_ELEMENT3_ID) FAM_STRUCTURE_ELEMENT3_ID  --Limite amortissement
           , nvl(DEF.FAM_STRUCTURE_ELEMENT2_ID, VAL.FAM_STRUCTURE_ELEMENT2_ID) FAM_STRUCTURE_ELEMENT2_ID  -- Base intérêts
           , nvl(DEF.FAM_STRUCTURE_ELEMENT4_ID, VAL.FAM_STRUCTURE_ELEMENT4_ID) FAM_STRUCTURE_ELEMENT4_ID  -- Acquisition
        from FAM_FIXED_ASSETS FIX
           , FAM_AMORTIZATION_METHOD AMO
           , FAM_DEFAULT DEF
           , FAM_MANAGED_VALUE VAL
       where FIX.FAM_FIXED_ASSETS_ID = :new.FAM_FIXED_ASSETS_ID
         and FIX.C_FIXED_ASSETS_STATUS = '01'
         and FIX.C_OWNERSHIP <> '9'
         and AMO.FAM_AMORTIZATION_METHOD_ID = :new.FAM_AMORTIZATION_METHOD_ID
         and AMO.AMO_AMORTIZATION_PLAN = 1
         and DEF.FAM_MANAGED_VALUE_ID = :new.FAM_MANAGED_VALUE_ID
         and DEF.FAM_FIXED_ASSETS_CATEG_ID = FIX.FAM_FIXED_ASSETS_CATEG_ID
         and DEF.FAM_AMORTIZATION_METHOD_ID = AMO.FAM_AMORTIZATION_METHOD_ID
         and VAL.FAM_MANAGED_VALUE_ID = :new.FAM_MANAGED_VALUE_ID
    order by FIX.FIX_NUMBER;

  tplFixedAssets crFamFixedAssets%rowtype;   --Réceptionne les données immob. du curseur
begin
  --Ouverture et parcours du curseur des immobilisations liées à la valeur gérée courante
  --Traitement pour chaque immobilisation retournée par le curseur...et non pas pour une fourchette donnée
  open crFamFixedAssets;

  fetch crFamFixedAssets
   into tplFixedAssets;

  while crFamFixedAssets%found loop
    FAM_AMORTIZATION_PLAN.CalculateAmortizationPlan
                                             (tplFixedAssets.FAM_FIXED_ASSETS_ID   --Immobilisation
                                            , :new.FAM_MANAGED_VALUE_ID   --Valeur gérée
                                            , tplFixedAssets.FAM_AMORTIZATION_METHOD_ID   --Méthode amortissement
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT1_ID   --Elément "Base amortissement"
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT2_ID   --Elément "Base intérêts"
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT3_ID   --Elément "Limite amortissement"
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT4_ID   --Elément "Acquisition"
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT6_ID   --Elément "Base amortissement 6"
                                            , tplFixedAssets.C_AMORTIZATION_TYP   --Type amortissement
                                            , tplFixedAssets.C_AMORTIZATION_PERIOD   --Cadence
                                            , :new.APP_AMORTIZATION_BEGIN   --Début amortissement
                                            , tplFixedAssets.APP_MONTH_DURATION   --Durée amortissement
                                            , tplFixedAssets.Rate1   --Taux 1
                                            , tplFixedAssets.Rate2   --Taux 2
                                            , tplFixedAssets.COEFFICIENT   --Coefficient
                                            , tplFixedAssets.DEF_MIN_RESIDUAL_VALUE   --Valeur résiduelle
                                            , tplFixedAssets.C_ROUND_TYPE   --Type arrondi
                                            , tplFixedAssets.AMO_ROUNDED_AMOUNT   --Montant arrondi
                                            , 1   --Activation plan
                                            , 0   --Indique si position budétisée (1) ou non(0)
                                             );

    fetch crFamFixedAssets
     into tplFixedAssets;
  end loop;

  close crFamFixedAssets;
end FAM_AMO_APPLICATION_AU;

ALTER TRIGGER "C_ITX"."FAM_AMO_APPLICATION_AU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_AMORTIZATION_METHOD_AU"
  after update of C_AMORTIZATION_PERIOD
                , C_AMORTIZATION_TYP
                , AMO_AMORTIZATION_PLAN
                , FAM_CATALOGUE_ID
                , C_ROUND_TYPE
                , AMO_ROUNDED_AMOUNT
  on FAM_AMORTIZATION_METHOD
  referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour / Calcul  des plans d'amortissement suite à changement
*   des méthodes d'amortissement pour la partie amortissement
* @author Sener Kalayci
* @version 2003
* @lastUpdate
*/
declare
  --Curseur des immobilisations ayant un lien sur la valeur gérée donnée
  --Ne pas prendre Min et Max, des immobilisations se trouvant dans la fourchette
  --ne gèrent pas forcément la valeur gérée
  cursor crFamFixedAssets
  is
    select   FIX.FAM_FIXED_ASSETS_ID   -- Immobilisation
           , AAP.APP_AMORTIZATION_BEGIN   -- Début d'amortissement
           , AAP.FAM_MANAGED_VALUE_ID   -- Valeur gérée
           , nvl(DEF.DEF_MIN_RESIDUAL_VALUE, 0) DEF_MIN_RESIDUAL_VALUE   -- Valeur résiduelle minimum
           , case   --Taux 1 selon type amortissement
               when :new.C_AMORTIZATION_TYP in('1', '3', '5', '6', '9', '60') then nvl(AAP.APP_LIN_AMORTIZATION
                                                                                     , DEF.DEF_LIN_AMORTIZATION
                                                                                      )
               when :new.C_AMORTIZATION_TYP in('2', '4') then nvl(AAP.APP_DEC_AMORTIZATION, DEF.DEF_DEC_AMORTIZATION)
               else 0
             end Rate1
           , case   --Taux 2 selon type amortissement
               when :new.C_AMORTIZATION_TYP in('5', '6', '9', '60') then nvl(AAP.APP_DEC_AMORTIZATION
                                                                           , DEF.DEF_DEC_AMORTIZATION
                                                                            )
               else null
             end Rate2
           , case   --Coeeficient pour types 6,60
               when :new.C_AMORTIZATION_TYP in('6', '60') then nvl(AAP.DIC_FAM_COEFFICIENT_ID
                                                                 , DEF.DIC_FAM_COEFFICIENT_ID
                                                                  )
               else null
             end COEFFICIENT
           ,
             -- Durée d'amortissement systématiquement calculée(100/taux1)même si renseignée sur la fiche Arrondi à 2 déc. comme définie
             round(100 /
                   decode(decode(AAP.APP_LIN_AMORTIZATION, 0, null, AAP.APP_LIN_AMORTIZATION)
                        , null, decode(DEF.DEF_LIN_AMORTIZATION, 0, null, DEF.DEF_LIN_AMORTIZATION)
                        , AAP.APP_LIN_AMORTIZATION
                         )
                 , 2
                  ) APP_MONTH_DURATION
           , nvl(DEF.FAM_STRUCTURE_ELEMENT1_ID, VAL.FAM_STRUCTURE_ELEMENT_ID) FAM_STRUCTURE_ELEMENT1_ID   -- Base amortissement 1
           , nvl(DEF.FAM_STRUCTURE_ELEMENT6_ID, VAL.FAM_STRUCTURE_ELEMENT6_ID) FAM_STRUCTURE_ELEMENT6_ID   -- Base amortissement 2
           , nvl(DEF.FAM_STRUCTURE_ELEMENT3_ID, VAL.FAM_STRUCTURE_ELEMENT3_ID) FAM_STRUCTURE_ELEMENT3_ID   --Limite amortissement
           , nvl(DEF.FAM_STRUCTURE_ELEMENT2_ID, VAL.FAM_STRUCTURE_ELEMENT2_ID) FAM_STRUCTURE_ELEMENT2_ID   -- Base intérêts
           , nvl(DEF.FAM_STRUCTURE_ELEMENT4_ID, VAL.FAM_STRUCTURE_ELEMENT4_ID) FAM_STRUCTURE_ELEMENT4_ID   -- Acquisition
        from FAM_FIXED_ASSETS FIX
           , FAM_AMO_APPLICATION AAP
           , FAM_DEFAULT DEF
           , FAM_MANAGED_VALUE VAL
       where AAP.FAM_AMORTIZATION_METHOD_ID = :new.FAM_AMORTIZATION_METHOD_ID
         and FIX.FAM_FIXED_ASSETS_ID = AAP.FAM_FIXED_ASSETS_ID
         and FIX.C_FIXED_ASSETS_STATUS = '01'
         and FIX.C_OWNERSHIP <> '9'
         and DEF.FAM_AMORTIZATION_METHOD_ID = AAP.FAM_AMORTIZATION_METHOD_ID
         and DEF.FAM_MANAGED_VALUE_ID = AAP.FAM_MANAGED_VALUE_ID
         and DEF.FAM_FIXED_ASSETS_CATEG_ID = FIX.FAM_FIXED_ASSETS_CATEG_ID
         and VAL.FAM_MANAGED_VALUE_ID = AAP.FAM_MANAGED_VALUE_ID
    order by FIX.FIX_NUMBER;

  tplFixedAssets crFamFixedAssets%rowtype;   --Réceptionne les données immob. du curseur
begin
  --Méthode avec gestion de plans
  -- => Calcul des plans
  if (:new.AMO_AMORTIZATION_PLAN = 1) then
    --Ouverture et parcours du curseur des immobilisations liées à la valeur gérée courante
    --Traitement pour chaque immobilisation retournée par le curseur...et non pas pour une fourchette donnée
    open crFamFixedAssets;

    fetch crFamFixedAssets
     into tplFixedAssets;

    while crFamFixedAssets%found loop
      FAM_AMORTIZATION_PLAN.CalculateAmortizationPlan
                                             (tplFixedAssets.FAM_FIXED_ASSETS_ID   --Immobilisation
                                            , tplFixedAssets.FAM_MANAGED_VALUE_ID   --Valeur gérée
                                            , :new.FAM_AMORTIZATION_METHOD_ID   --Méthode amortissement
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT1_ID   --Elément "Base amortissement"
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT2_ID   --Elément "Base intérêts"
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT3_ID   --Elément "Limite amortissement"
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT4_ID   --Elément "Acquisition"
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT6_ID   --Elément "Base amortissement 6"
                                            , :new.C_AMORTIZATION_TYP   --Type amortissement
                                            , :new.C_AMORTIZATION_PERIOD   --Cadence
                                            , tplFixedAssets.APP_AMORTIZATION_BEGIN   --Début amortissement
                                            , tplFixedAssets.APP_MONTH_DURATION   --Durée amortissement
                                            , tplFixedAssets.Rate1   --Taux 1
                                            , tplFixedAssets.Rate2   --Taux 2
                                            , tplFixedAssets.COEFFICIENT   --Coefficient
                                            , tplFixedAssets.DEF_MIN_RESIDUAL_VALUE   --Valeur résiduelle
                                            , :new.C_ROUND_TYPE   --Type arrondi
                                            , :new.AMO_ROUNDED_AMOUNT   --Montant arrondi
                                            , 1   --Activation plan
                                            , 0   --Indique si position budétisée (1) ou non(0)
                                             );

      fetch crFamFixedAssets
       into tplFixedAssets;
    end loop;

    close crFamFixedAssets;
  --Passage de géré à non géré
  -- => Historier les plans
  elsif     (:old.AMO_AMORTIZATION_PLAN = 1)
        and (:new.AMO_AMORTIZATION_PLAN = 0) then
    update FAM_PLAN_HEADER
       set C_AMO_PLAN_STATUS = 2
     where FAM_AMORTIZATION_METHOD_ID = :new.FAM_AMORTIZATION_METHOD_ID
       and C_AMO_PLAN_STATUS <> 2;
  end if;
end FAM_AMORTIZATION_METHOD_AU;

ALTER TRIGGER "C_ITX"."FAM_AMORTIZATION_METHOD_AU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_CALC_AMO_BIU_IMPUTATION"
  before insert or update of FAM_IMPUTATION_ID, FAM_FAM_IMPUTATION_ID, FAM2_FAM_IMPUTATION_ID
  on FAM_CALC_AMORTIZATION
  referencing old as old new as new
  for each row
/**
* Description
*     Remplace les contraintes d'intégrité présentes jusqu'à maintenant.
*     Rendu nécessaire par le trigger FAM_FIM_BD_TOT_BY_PERIOD.
* @version 2003
* @lastUpdate
*/
declare
  vFamImputationId FAM_IMPUTATION.FAM_IMPUTATION_ID%type;
begin
  --Réception de l'id modifié, ajouté
  if (nvl(:old.FAM_IMPUTATION_ID, 0) <> nvl(:new.FAM_IMPUTATION_ID, 0) ) then
    vFamImputationId  := nvl(:new.FAM_IMPUTATION_ID, 0);
  elsif(nvl(:old.FAM_FAM_IMPUTATION_ID, 0) <> nvl(:new.FAM_FAM_IMPUTATION_ID, 0) ) then
    vFamImputationId  := nvl(:new.FAM_FAM_IMPUTATION_ID, 0);
  elsif(nvl(:old.FAM2_FAM_IMPUTATION_ID, 0) <> nvl(:new.FAM2_FAM_IMPUTATION_ID, 0) ) then
    vFamImputationId  := nvl(:new.FAM2_FAM_IMPUTATION_ID, 0);
  end if;

  --Nouvel id <> null
  if vFamImputationId <> 0 then
    select nvl(max(FAM_IMPUTATION_ID), 0)
      into vFamImputationId
      from FAM_IMPUTATION
     where FAM_IMPUTATION_ID = vFamImputationId;
    --Id n'existe pas
    if vFamImputationId = 0 then
      raise_application_error
                            (-20010
                           , PCS.PC_FUNCTIONS.TRANSLATEWORD(substr('Lien sur imputation : Clé parente non trouvée'
                                                                 , 1
                                                                 , 80
                                                                  )
                                                          , PCS.PC_I_LIB_SESSION.USER_LANG_ID
                                                           )
                            );
    end if;
  end if;
end FAM_CALC_AMO_BIU_IMPUTATION;

ALTER TRIGGER "C_ITX"."FAM_CALC_AMO_BIU_IMPUTATION" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_DEFAULT_AU"
  after update of FAM_AMORTIZATION_METHOD_ID
                , DEF_LIN_AMORTIZATION
                , DEF_DEC_AMORTIZATION
                , DIC_FAM_COEFFICIENT_ID
                , DEF_MIN_RESIDUAL_VALUE
                , FAM_STRUCTURE_ELEMENT1_ID
                , FAM_STRUCTURE_ELEMENT3_ID
                , FAM_STRUCTURE_ELEMENT4_ID
                , FAM_STRUCTURE_ELEMENT6_ID
  on FAM_DEFAULT
  referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour / Calcul  des plans d'amortissement suite à changement
*   des éléments méthodes d'amortissement dans le lien Valeur gérée / Catégorie
* @author Sener Kalayci
* @version 2003
* @lastUpdate
*/
declare
  --Curseur des immobilisations ayant un lien sur les éléments / défaut de la catégorie donnée
  --Ne pas prendre Min et Max, des immobilisations se trouvant dans la fourchette
  --peuvent ne pas être de la catégorie sélectionnée
  cursor crFamFixedAssets
  is
    select   FIX.FAM_FIXED_ASSETS_ID   -- Immobilisation
           , AMO.FAM_AMORTIZATION_METHOD_ID   -- Méthode d'amortissement
           , AMO.AMO_ROUNDED_AMOUNT   -- Montant arrondi
           , AMO.C_AMORTIZATION_PERIOD   -- Cadence d'amortissment
           , AMO.C_AMORTIZATION_TYP   -- Type d'amortissment
           , AMO.C_ROUND_TYPE   -- Type d'arrondi
           , AAP.APP_AMORTIZATION_BEGIN   -- Début d'amortissement
           , AAP.FAM_MANAGED_VALUE_ID   -- Valeur gérée
           , nvl(:new.DEF_MIN_RESIDUAL_VALUE, 0) DEF_MIN_RESIDUAL_VALUE   -- Valeur résiduelle minimum
           , case   --Taux 1 selon type amortissement
               when AMO.C_AMORTIZATION_TYP in('1', '3', '5', '6', '9', '60') then nvl(AAP.APP_LIN_AMORTIZATION
                                                                                    , :new.DEF_LIN_AMORTIZATION
                                                                                     )
               when AMO.C_AMORTIZATION_TYP in('2', '4') then nvl(AAP.APP_DEC_AMORTIZATION, :new.DEF_DEC_AMORTIZATION)
               else 0
             end Rate1
           , case   --Taux 2 selon type amortissement
               when AMO.C_AMORTIZATION_TYP in('5', '6', '9', '60') then nvl(AAP.APP_DEC_AMORTIZATION
                                                                          , :new.DEF_DEC_AMORTIZATION
                                                                           )
               else null
             end Rate2
           , case   --Coeeficient pour types 6,60
               when AMO.C_AMORTIZATION_TYP in('6', '60') then nvl(AAP.DIC_FAM_COEFFICIENT_ID
                                                                , :new.DIC_FAM_COEFFICIENT_ID
                                                                 )
               else null
             end COEFFICIENT
           ,
             -- Durée d'amortissement systématiquement calculée(100/taux1)même si renseignée sur la fiche Arrondi à 2 déc. comme définie
             round(100 /
                   decode(decode(AAP.APP_LIN_AMORTIZATION, 0, null, AAP.APP_LIN_AMORTIZATION)
                        , null, decode(:new.DEF_LIN_AMORTIZATION, 0, null, :new.DEF_LIN_AMORTIZATION)
                        , AAP.APP_LIN_AMORTIZATION
                         )
                 , 2
                  ) APP_MONTH_DURATION
           , nvl(:new.FAM_STRUCTURE_ELEMENT1_ID, VAL.FAM_STRUCTURE_ELEMENT_ID) FAM_STRUCTURE_ELEMENT1_ID   -- Base amortissement 1
           , nvl(:new.FAM_STRUCTURE_ELEMENT6_ID, VAL.FAM_STRUCTURE_ELEMENT6_ID) FAM_STRUCTURE_ELEMENT6_ID   -- Base amortissement 2
           , nvl(:new.FAM_STRUCTURE_ELEMENT3_ID, VAL.FAM_STRUCTURE_ELEMENT3_ID) FAM_STRUCTURE_ELEMENT3_ID   --Limite amortissement
           , nvl(:new.FAM_STRUCTURE_ELEMENT2_ID, VAL.FAM_STRUCTURE_ELEMENT2_ID) FAM_STRUCTURE_ELEMENT2_ID   -- Base intérêts
           , nvl(:new.FAM_STRUCTURE_ELEMENT4_ID, VAL.FAM_STRUCTURE_ELEMENT4_ID) FAM_STRUCTURE_ELEMENT4_ID   -- Acquisition
        from FAM_FIXED_ASSETS FIX
           , FAM_AMO_APPLICATION AAP
           , FAM_AMORTIZATION_METHOD AMO
           , FAM_MANAGED_VALUE VAL
       where FIX.FAM_FIXED_ASSETS_CATEG_ID = :new.FAM_FIXED_ASSETS_CATEG_ID
         and FIX.C_FIXED_ASSETS_STATUS = '01'
         and FIX.C_OWNERSHIP <> '9'
         and AAP.FAM_FIXED_ASSETS_ID = FIX.FAM_FIXED_ASSETS_ID
         and AAP.FAM_MANAGED_VALUE_ID = :new.FAM_MANAGED_VALUE_ID
         and AAP.FAM_AMORTIZATION_METHOD_ID = :new.FAM_AMORTIZATION_METHOD_ID
         and AMO.FAM_AMORTIZATION_METHOD_ID = AAP.FAM_AMORTIZATION_METHOD_ID
         and AMO.AMO_AMORTIZATION_PLAN = 1
         and VAL.FAM_MANAGED_VALUE_ID = AAP.FAM_MANAGED_VALUE_ID
    order by FIX.FIX_NUMBER;

  tplFixedAssets crFamFixedAssets%rowtype;   --Réceptionne les données immob. du curseur
begin
  --Ouverture et parcours du curseur des immobilisations liées à la valeur gérée/ Catégorie courante
  --Traitement pour chaque immobilisation retournée par le curseur...et non pas pour une fourchette donnée
  open crFamFixedAssets;

  fetch crFamFixedAssets
   into tplFixedAssets;

  while crFamFixedAssets%found loop
    FAM_AMORTIZATION_PLAN.CalculateAmortizationPlan
                                             (tplFixedAssets.FAM_FIXED_ASSETS_ID   --Immobilisation
                                            , tplFixedAssets.FAM_MANAGED_VALUE_ID   --Valeur gérée
                                            , tplFixedAssets.FAM_AMORTIZATION_METHOD_ID   --Méthode amortissement
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT1_ID   --Elément "Base amortissement"
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT2_ID   --Elément "Base intérêts"
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT3_ID   --Elément "Limite amortissement"
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT4_ID   --Elément "Acquisition"
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT6_ID   --Elément "Base amortissement 6"
                                            , tplFixedAssets.C_AMORTIZATION_TYP   --Type amortissement
                                            , tplFixedAssets.C_AMORTIZATION_PERIOD   --Cadence
                                            , tplFixedAssets.APP_AMORTIZATION_BEGIN   --Début amortissement
                                            , tplFixedAssets.APP_MONTH_DURATION   --Durée amortissement
                                            , tplFixedAssets.Rate1   --Taux 1
                                            , tplFixedAssets.Rate2   --Taux 2
                                            , tplFixedAssets.COEFFICIENT   --Coefficient
                                            , tplFixedAssets.DEF_MIN_RESIDUAL_VALUE   --Valeur résiduelle
                                            , tplFixedAssets.C_ROUND_TYPE   --Type arrondi
                                            , tplFixedAssets.AMO_ROUNDED_AMOUNT   --Montant arrondi
                                            , 1   --Activation plan
                                            , 0   --Indique si position budétisée (1) ou non(0)
                                             );

    fetch crFamFixedAssets
     into tplFixedAssets;
  end loop;
end FAM_DEFAULT_AU;

ALTER TRIGGER "C_ITX"."FAM_DEFAULT_AU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_FDO_AD_FREE_NUMBER"
  after delete
  on FAM_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*    Gestion des numéros libres
* @author
* @created
* @lastUpdate
*/
declare
  YearId ACS_FINANCIAL_YEAR.ACS_FINANCIAL_YEAR_ID%type;
begin
  YearId  := ACS_FUNCTION.GetFinancialYearID(:old.FDO_DOCUMENT_DATE);
  ACT_FUNCTIONS.AddFreeNumber(:old.FAM_CATALOGUE_ID, YearId, :old.FDO_INT_NUMBER, 0, null, true, false, false);
end FAM_FDO_AD_FREE_NUMBER;

ALTER TRIGGER "C_ITX"."FAM_FDO_AD_FREE_NUMBER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_FDO_BD_TOT_BY_PERIOD"
  before delete
  on FAM_DOCUMENT
  referencing old as old new as new
  for each row
/**
* Description
*
* @version 2003
* @lastUpdate
*/
begin
  FAM_TOT_BY_PERIOD.gCatalogIdOfDeletedDocument  := :old.FAM_CATALOGUE_ID;
end FAM_FDO_BD_TOT_BY_PERIOD;

ALTER TRIGGER "C_ITX"."FAM_FDO_BD_TOT_BY_PERIOD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_FIM_AU_TOT_BY_PERIOD"
  after update of FAM_DOCUMENT_ID
                , ACS_FINANCIAL_CURRENCY_ID
                , ACS_ACS_FINANCIAL_CURRENCY_ID
                , ACS_PERIOD_ID
                , FAM_JOURNAL_ID
                , FAM_FIXED_ASSETS_ID
                , FIM_AMOUNT_LC_D
                , FIM_AMOUNT_LC_C
  on FAM_IMPUTATION
  referencing old as old new as new
  for each row
/**
* Description
*
* @version 2003
* @lastUpdate
*/
declare
  cursor ACT_ImputationsCursor(aFAM_IMPUTATION_ID FAM_IMPUTATION.FAM_IMPUTATION_ID%type)
  is
    select C_FAM_IMPUTATION_TYP
         , ACS_FINANCIAL_ACCOUNT_ID
         , ACS_DIVISION_ACCOUNT_ID
         , ACS_CPN_ACCOUNT_ID
         , ACS_CDA_ACCOUNT_ID
         , ACS_PF_ACCOUNT_ID
         , ACS_PJ_ACCOUNT_ID
         , FIM_AMOUNT_LC_D
         , FIM_AMOUNT_LC_C
         , FIM_AMOUNT_FC_D
         , FIM_AMOUNT_FC_C
      from FAM_ACT_IMPUTATION
     where FAM_IMPUTATION_ID = aFAM_IMPUTATION_ID;

  cursor VAL_ImputationsCursor(aFAM_IMPUTATION_ID FAM_IMPUTATION.FAM_IMPUTATION_ID%type)
  is
    select FAM_VAL_IMPUTATION_ID
         , FAM_MANAGED_VALUE_ID
      from FAM_VAL_IMPUTATION
     where FAM_IMPUTATION_ID = aFAM_IMPUTATION_ID;

  ACT_Imputations ACT_ImputationsCursor%rowtype;
  VAL_Imputations VAL_ImputationsCursor%rowtype;
  FamTransaction  FAM_CATALOGUE.C_FAM_TRANSACTION_TYP%type;
begin
  open VAL_ImputationsCursor(:old.FAM_IMPUTATION_ID);

  fetch VAL_ImputationsCursor
   into VAL_Imputations;

  while VAL_ImputationsCursor%found loop
    FAM_TOT_BY_PERIOD.WriteFamTotalByPeriod(:old.FAM_FIXED_ASSETS_ID
                                          , :old.FAM_FIXED_ASSETS_CATEG_ID
                                          , VAL_Imputations.FAM_MANAGED_VALUE_ID
                                          , :old.ACS_PERIOD_ID
                                          , :old.ACS_ACS_FINANCIAL_CURRENCY_ID
                                          , :new.C_FAM_TRANSACTION_TYP
                                          , -:old.FIM_AMOUNT_LC_D
                                          , -:old.FIM_AMOUNT_LC_C
                                           );
    FAM_TOT_BY_PERIOD.WriteFamTotalByPeriod(:new.FAM_FIXED_ASSETS_ID
                                          , :old.FAM_FIXED_ASSETS_CATEG_ID
                                          , VAL_Imputations.FAM_MANAGED_VALUE_ID
                                          , :new.ACS_PERIOD_ID
                                          , :new.ACS_ACS_FINANCIAL_CURRENCY_ID
                                          , :new.C_FAM_TRANSACTION_TYP
                                          , :new.FIM_AMOUNT_LC_D
                                          , :new.FIM_AMOUNT_LC_C
                                           );

    --Même traitement que dasn le trigger FAM_VAL_IMP_AIUD_FAM_PLAN...
    --l'update ne mettant pas à jour les imp. Val.
    --Désactiver/Historier tout plan existant ayant le statut "actif" ('1') ou "à activer" ('0')
    --Renseigner le FAM_PLAN_HEADER.C_INACTIVATION_REASON:
    update FAM_PLAN_HEADER
       set C_AMO_PLAN_STATUS = '2'
         , C_INACTIVATION_REASON = '02'
     where FAM_FIXED_ASSETS_ID = :new.FAM_FIXED_ASSETS_ID
       and FAM_MANAGED_VALUE_ID = VAL_Imputations.FAM_MANAGED_VALUE_ID
       and (    (C_AMO_PLAN_STATUS = '0')
            or (C_AMO_PLAN_STATUS = '1') );

    --Maintenir la table "temporaire" listant les plans à recalculer FAM_PLAN_TO_COMPUTE
    insert into FAM_PLAN_TO_COMPUTE
                (FAM_PLAN_TO_COMPUTE_ID
               , FAM_FIXED_ASSETS_ID
               , FAM_MANAGED_VALUE_ID
               , C_INACTIVATION_REASON
                )
      select userenv('SESSIONID')
           , :new.FAM_FIXED_ASSETS_ID
           , VAL_Imputations.FAM_MANAGED_VALUE_ID
           , '02'
        from dual
       where not exists(
               select 1
                 from FAM_PLAN_TO_COMPUTE PTC
                where PTC.FAM_FIXED_ASSETS_ID = :new.FAM_FIXED_ASSETS_ID
                  and PTC.FAM_MANAGED_VALUE_ID = VAL_Imputations.FAM_MANAGED_VALUE_ID
                  and PTC.FAM_PLAN_TO_COMPUTE_ID = userenv('SESSIONID') );

    fetch VAL_ImputationsCursor
     into VAL_Imputations;
  end loop;

  close VAL_ImputationsCursor;

  open ACT_ImputationsCursor(:old.FAM_IMPUTATION_ID);

  fetch ACT_ImputationsCursor
   into ACT_Imputations;

  while ACT_ImputationsCursor%found loop
    FAM_TOT_BY_PERIOD.UpdateACT_TotalByPeriod(:old.FAM_DOCUMENT_ID
                                            , :old.FAM_FIXED_ASSETS_ID
                                            , :new.FAM_FIXED_ASSETS_ID
                                            , :old.ACS_PERIOD_ID
                                            , :new.ACS_PERIOD_ID
                                            , :old.ACS_ACS_FINANCIAL_CURRENCY_ID
                                            , :new.ACS_ACS_FINANCIAL_CURRENCY_ID
                                            , ACT_Imputations.C_FAM_IMPUTATION_TYP
                                            , ACT_Imputations.C_FAM_IMPUTATION_TYP
                                            , ACT_Imputations.ACS_FINANCIAL_ACCOUNT_ID
                                            , ACT_Imputations.ACS_FINANCIAL_ACCOUNT_ID
                                            , ACT_Imputations.ACS_DIVISION_ACCOUNT_ID
                                            , ACT_Imputations.ACS_DIVISION_ACCOUNT_ID
                                            , ACT_Imputations.ACS_CPN_ACCOUNT_ID
                                            , ACT_Imputations.ACS_CPN_ACCOUNT_ID
                                            , ACT_Imputations.ACS_CDA_ACCOUNT_ID
                                            , ACT_Imputations.ACS_CDA_ACCOUNT_ID
                                            , ACT_Imputations.ACS_PF_ACCOUNT_ID
                                            , ACT_Imputations.ACS_PF_ACCOUNT_ID
                                            , ACT_Imputations.ACS_PJ_ACCOUNT_ID
                                            , ACT_Imputations.ACS_PJ_ACCOUNT_ID
                                            , ACT_Imputations.FIM_AMOUNT_LC_D
                                            , ACT_Imputations.FIM_AMOUNT_LC_D
                                            , ACT_Imputations.FIM_AMOUNT_LC_C
                                            , ACT_Imputations.FIM_AMOUNT_LC_C
                                             );

    fetch ACT_ImputationsCursor
     into ACT_Imputations;
  end loop;

  close ACT_ImputationsCursor;
end FAM_FIM_AU_TOT_BY_PERIOD;

ALTER TRIGGER "C_ITX"."FAM_FIM_AU_TOT_BY_PERIOD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_FIM_BD_TOT_BY_PERIOD"
  before delete
  on FAM_IMPUTATION
  referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour des totaux des immobilisations
* @author
* @version 2003
* @lastUpdate
*/
declare
  cursor crACT_Imputations(aFAM_IMPUTATION_ID FAM_IMPUTATION.FAM_IMPUTATION_ID%type)
  is
    select FAM_ACT_IMPUTATION_ID
         , FAM_DOCUMENT_ID
         , C_FAM_IMPUTATION_TYP
         , ACS_FINANCIAL_ACCOUNT_ID
         , ACS_DIVISION_ACCOUNT_ID
         , ACS_CPN_ACCOUNT_ID
         , ACS_CDA_ACCOUNT_ID
         , ACS_PF_ACCOUNT_ID
         , ACS_PJ_ACCOUNT_ID
         , FIM_AMOUNT_LC_D
         , FIM_AMOUNT_LC_C
      from FAM_ACT_IMPUTATION
     where FAM_IMPUTATION_ID = aFAM_IMPUTATION_ID;

  cursor crVAL_Imputations(aFAM_IMPUTATION_ID FAM_IMPUTATION.FAM_IMPUTATION_ID%type)
  is
    select FAM_VAL_IMPUTATION_ID
         , FAM_DOCUMENT_ID
         , FAM_MANAGED_VALUE_ID
      from FAM_VAL_IMPUTATION
     where FAM_IMPUTATION_ID = aFAM_IMPUTATION_ID;

  tplACT_Imputations crACT_Imputations%rowtype;
  tplVAL_Imputations crVAL_Imputations%rowtype;
begin
  /*Suite à la suppression des contraintes d'effacement en cascade on provoque manuellement la
    suppression des records des tables act et val et la mise à jour des compteurs
  */
  open crACT_Imputations(:old.FAM_IMPUTATION_ID);

  fetch crACT_Imputations
   into tplACT_Imputations;

  while crACT_Imputations%found loop
    delete from FAM_ACT_IMPUTATION
          where FAM_ACT_IMPUTATION_ID = tplACT_Imputations.FAM_ACT_IMPUTATION_ID;

    FAM_TOT_BY_PERIOD.UpdateACT_TotalByPeriod(tplACT_Imputations.FAM_DOCUMENT_ID
                                            , :old.FAM_FIXED_ASSETS_ID
                                            , null
                                            , :old.ACS_PERIOD_ID
                                            , null
                                            , :old.ACS_ACS_FINANCIAL_CURRENCY_ID
                                            , null
                                            , tplACT_Imputations.C_FAM_IMPUTATION_TYP
                                            , null
                                            , tplACT_Imputations.ACS_FINANCIAL_ACCOUNT_ID
                                            , null
                                            , tplACT_Imputations.ACS_DIVISION_ACCOUNT_ID
                                            , null
                                            , tplACT_Imputations.ACS_CPN_ACCOUNT_ID
                                            , null
                                            , tplACT_Imputations.ACS_CDA_ACCOUNT_ID
                                            , null
                                            , tplACT_Imputations.ACS_PF_ACCOUNT_ID
                                            , null
                                            , tplACT_Imputations.ACS_PJ_ACCOUNT_ID
                                            , null
                                            , tplACT_Imputations.FIM_AMOUNT_LC_D
                                            , null
                                            , tplACT_Imputations.FIM_AMOUNT_LC_C
                                            , null
                                             );

    fetch crACT_Imputations
     into tplACT_Imputations;
  end loop;

  close crACT_Imputations;

  open crVAL_Imputations(:old.FAM_IMPUTATION_ID);

  fetch crVAL_Imputations
   into tplVAL_Imputations;

  while crVAL_Imputations%found loop
    delete from FAM_VAL_IMPUTATION
          where FAM_VAL_IMPUTATION_ID = tplVAL_Imputations.FAM_VAL_IMPUTATION_ID;

    --Même traitement que dasn le trigger FAM_VAL_IMP_AIUD_FAM_PLAN...l'exception Table_Mutating faisant
    --que le traitement ne se fait plus dans le trigger.
    --Désactiver/Historier tout plan existant ayant le statut "actif" ('1') ou "à activer" ('0')
    --Renseigner le FAM_PLAN_HEADER.C_INACTIVATION_REASON:
    update FAM_PLAN_HEADER
       set C_AMO_PLAN_STATUS = '2'
         , C_INACTIVATION_REASON = '03'
     where FAM_FIXED_ASSETS_ID = :old.FAM_FIXED_ASSETS_ID
       and FAM_MANAGED_VALUE_ID = tplVAL_Imputations.FAM_MANAGED_VALUE_ID
       and (    (C_AMO_PLAN_STATUS = '0')
            or (C_AMO_PLAN_STATUS = '1') );

    --Maintenir la table "temporaire" listant les plans à recalculer FAM_PLAN_TO_COMPUTE
    insert into FAM_PLAN_TO_COMPUTE
                (FAM_PLAN_TO_COMPUTE_ID
               , FAM_FIXED_ASSETS_ID
               , FAM_MANAGED_VALUE_ID
               , C_INACTIVATION_REASON
                )
      select userenv('SESSIONID')
           , :old.FAM_FIXED_ASSETS_ID
           , tplVAL_Imputations.FAM_MANAGED_VALUE_ID
           , '03'
        from dual
       where not exists(
               select 1
                 from FAM_PLAN_TO_COMPUTE PTC
                where PTC.FAM_FIXED_ASSETS_ID = :old.FAM_FIXED_ASSETS_ID
                  and PTC.FAM_MANAGED_VALUE_ID = tplVAL_Imputations.FAM_MANAGED_VALUE_ID
                  and PTC.FAM_PLAN_TO_COMPUTE_ID = userenv('SESSIONID') );

    FAM_TOT_BY_PERIOD.WriteFamTotalByPeriod(:old.FAM_FIXED_ASSETS_ID
                                          , :old.FAM_FIXED_ASSETS_CATEG_ID
                                          , tplVAL_Imputations.FAM_MANAGED_VALUE_ID
                                          , :old.ACS_PERIOD_ID
                                          , :old.ACS_ACS_FINANCIAL_CURRENCY_ID
                                          , :old.C_FAM_TRANSACTION_TYP
                                          , -:old.FIM_AMOUNT_LC_D
                                          , -:old.FIM_AMOUNT_LC_C
                                           );

    fetch crVAL_Imputations
     into tplVAL_Imputations;
  end loop;

  close crVAL_Imputations;
end FAM_FIM_BD_TOT_BY_PERIOD;

ALTER TRIGGER "C_ITX"."FAM_FIM_BD_TOT_BY_PERIOD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_FIX_AD_FREE_NUMBER"
  after delete
  on FAM_FIXED_ASSETS
  referencing old as old new as new
  for each row
/**
* Description
*   Gestion des numéros libres
* @author
* @created
* @lastUpdate
*/
begin
  FAM_FUNCTIONS.AddFreeNumber(:old.FAM_FIXED_ASSETS_CATEG_ID, :old.FIX_NUMBER);
end FAM_FIX_AD_FREE_NUMBER;

ALTER TRIGGER "C_ITX"."FAM_FIX_AD_FREE_NUMBER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_FJO_AU_ACI_TRANSFERT"
  after update of C_JOURNAL_STATUS
  on FAM_JOURNAL
  referencing old as old new as new
  for each row
/**
* Description
*     transfert en ACI
* @version 2003
* @lastUpdate
*/
begin
  if     :old.C_JOURNAL_STATUS = 'PROV'
     and :new.C_JOURNAL_STATUS = 'DEF' then
    ACI_FAM_IMPUTATIONS.FAM_to_ACI_Transfer(:old.FAM_JOURNAL_ID);
  end if;
end FAM_FJO_AU_ACI_TRANSFERT;

ALTER TRIGGER "C_ITX"."FAM_FJO_AU_ACI_TRANSFERT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_FJO_AU_FAM_PLAN"
  after update of PC_USER_ID
  on FAM_JOURNAL
  referencing old as old new as new
  for each row
/**
* Description
*
* @version 2003
* @lastUpdate
*/
declare
  cursor crJournalImputations(aJournalId FAM_JOURNAL.FAM_JOURNAL_ID%type)
  is
    select   PTC.FAM_FIXED_ASSETS_ID
           , PTC.FAM_MANAGED_VALUE_ID
           , PTC.C_INACTIVATION_REASON
        from FAM_PLAN_TO_COMPUTE PTC
       where PTC.FAM_PLAN_TO_COMPUTE_ID = userenv('SESSIONID')
    group by PTC.FAM_FIXED_ASSETS_ID
           , PTC.FAM_MANAGED_VALUE_ID
           , PTC.C_INACTIVATION_REASON;

  /*Recherche des données nécessaires aux calculs d'amortissement **/
  cursor crFixedAssets(
    aFixAssetsId    FAM_FIXED_ASSETS.FAM_FIXED_ASSETS_ID%type
  , aManagedValueId FAM_MANAGED_VALUE.FAM_MANAGED_VALUE_ID%type
  )
  is
    select   FIX.FAM_FIXED_ASSETS_ID   -- Immobilisation
           , AMO.FAM_AMORTIZATION_METHOD_ID   -- Méthode d'amortissement
           , AMO.AMO_ROUNDED_AMOUNT   -- Montant arrondi
           , AMO.C_AMORTIZATION_PERIOD   -- Cadence d'amortissment
           , AMO.C_AMORTIZATION_TYP   -- Type d'amortissment
           , AMO.C_ROUND_TYPE   -- Type d'arrondi
           , AAP.APP_AMORTIZATION_BEGIN   -- Début d'amortissement
           , AAP.FAM_MANAGED_VALUE_ID   -- Valeur gérée
           , nvl(DEF.DEF_MIN_RESIDUAL_VALUE, 0) DEF_MIN_RESIDUAL_VALUE   -- Valeur résiduelle minimum
           , case
               when AMO.C_AMORTIZATION_TYP in('1', '3', '5', '6', '9', '60') then nvl(AAP.APP_LIN_AMORTIZATION
                                                                                    , DEF.DEF_LIN_AMORTIZATION
                                                                                     )
               when AMO.C_AMORTIZATION_TYP in('2', '4') then nvl(AAP.APP_DEC_AMORTIZATION, DEF.DEF_DEC_AMORTIZATION)
               else 0
             end Rate1
           , case
               when AMO.C_AMORTIZATION_TYP in('5', '6', '9', '60') then nvl(AAP.APP_DEC_AMORTIZATION
                                                                          , DEF.DEF_DEC_AMORTIZATION
                                                                           )
               else null
             end Rate2
           , case   --Coeeficient pour types 6,60
               when AMO.C_AMORTIZATION_TYP in('6', '60') then nvl(AAP.DIC_FAM_COEFFICIENT_ID
                                                                , DEF.DIC_FAM_COEFFICIENT_ID)
               else null
             end COEFFICIENT
           ,
             -- Durée d'amortissement systématiquement calculée(100/taux1)même si renseignée sur la fiche Arrondi à 2 déc. comme définie
             round(100 /
                   decode(decode(AAP.APP_LIN_AMORTIZATION, 0, null, AAP.APP_LIN_AMORTIZATION)
                        , null, decode(DEF.DEF_LIN_AMORTIZATION, 0, null, DEF.DEF_LIN_AMORTIZATION)
                        , AAP.APP_LIN_AMORTIZATION
                         )
                 , 2
                  ) APP_MONTH_DURATION
           ,   --Eléments de structure nécessaires au calcul selon cascade Catégories par valeur / valeur gérée
             nvl(DEF.FAM_STRUCTURE_ELEMENT1_ID, VAL.FAM_STRUCTURE_ELEMENT_ID) FAM_STRUCTURE_ELEMENT1_ID   -- Base amortissement 1
           , nvl(DEF.FAM_STRUCTURE_ELEMENT6_ID, VAL.FAM_STRUCTURE_ELEMENT6_ID) FAM_STRUCTURE_ELEMENT6_ID   -- Base amortissement 2
           , nvl(DEF.FAM_STRUCTURE_ELEMENT3_ID, VAL.FAM_STRUCTURE_ELEMENT3_ID) FAM_STRUCTURE_ELEMENT3_ID   --Limite amortissement
           , nvl(DEF.FAM_STRUCTURE_ELEMENT2_ID, VAL.FAM_STRUCTURE_ELEMENT2_ID) FAM_STRUCTURE_ELEMENT2_ID   -- Base intérêts
           , nvl(DEF.FAM_STRUCTURE_ELEMENT4_ID, VAL.FAM_STRUCTURE_ELEMENT4_ID) FAM_STRUCTURE_ELEMENT4_ID   -- Acquisition
        from FAM_FIXED_ASSETS FIX
           , FAM_AMO_APPLICATION AAP
           , FAM_AMORTIZATION_METHOD AMO
           , FAM_DEFAULT DEF
           , FAM_MANAGED_VALUE VAL
       where FIX.FAM_FIXED_ASSETS_ID = aFixAssetsId
         and FIX.C_FIXED_ASSETS_STATUS = '01'
         and FIX.C_OWNERSHIP <> '9'
         and AAP.FAM_FIXED_ASSETS_ID = FIX.FAM_FIXED_ASSETS_ID
         and AAP.FAM_MANAGED_VALUE_ID = aManagedValueId
         and AMO.FAM_AMORTIZATION_METHOD_ID = AAP.FAM_AMORTIZATION_METHOD_ID
         and AMO.AMO_AMORTIZATION_PLAN = 1
         and DEF.FAM_MANAGED_VALUE_ID = AAP.FAM_MANAGED_VALUE_ID
         and DEF.FAM_FIXED_ASSETS_CATEG_ID = FIX.FAM_FIXED_ASSETS_CATEG_ID
         and DEF.FAM_AMORTIZATION_METHOD_ID = AMO.FAM_AMORTIZATION_METHOD_ID
         and VAL.FAM_MANAGED_VALUE_ID = AAP.FAM_MANAGED_VALUE_ID
    order by FIX.FIX_NUMBER;

  tplFixedAssets        crFixedAssets%rowtype;   --Réceptionne les données immob. du curseur
  tplJournalImputations crJournalImputations%rowtype;
  vTraTyp               FAM_IMPUTATION.C_FAM_TRANSACTION_TYP%type;
begin
  if :new.PC_USER_ID is null then
    open crJournalImputations(:new.FAM_JOURNAL_ID);

    fetch crJournalImputations
     into tplJournalImputations;

    while crJournalImputations%found loop
        --Traitement de l'immobilisation et valeur de l'imputation courante
        open crFixedAssets(tplJournalImputations.FAM_FIXED_ASSETS_ID, tplJournalImputations.FAM_MANAGED_VALUE_ID);

        fetch crFixedAssets
         into tplFixedAssets;

        while crFixedAssets%found loop
          FAM_AMORTIZATION_PLAN.CalculateAmortizationPlan
                                             (tplFixedAssets.FAM_FIXED_ASSETS_ID   --Immobilisation
                                            , tplFixedAssets.FAM_MANAGED_VALUE_ID   --Valeur gérée
                                            , tplFixedAssets.FAM_AMORTIZATION_METHOD_ID   --Méthode amortissement
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT1_ID   --Elément "Base amortissement"
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT2_ID   --Elément "Base intérêts"
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT3_ID   --Elément "Limite amortissement"
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT4_ID   --Elément "Acquisition"
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT6_ID   --Elément "Base amortissement 6"
                                            , tplFixedAssets.C_AMORTIZATION_TYP   --Type amortissement
                                            , tplFixedAssets.C_AMORTIZATION_PERIOD   --Cadence
                                            , tplFixedAssets.APP_AMORTIZATION_BEGIN   --Début amortissement
                                            , tplFixedAssets.APP_MONTH_DURATION   --Durée amortissement
                                            , tplFixedAssets.Rate1   --Taux 1
                                            , tplFixedAssets.Rate2   --Taux 2
                                            , tplFixedAssets.COEFFICIENT   --Coefficient
                                            , tplFixedAssets.DEF_MIN_RESIDUAL_VALUE   --Valeur résiduelle
                                            , tplFixedAssets.C_ROUND_TYPE   --Type arrondi
                                            , tplFixedAssets.AMO_ROUNDED_AMOUNT   --Montant arrondi
                                            , 1   --Activation plan
                                            , 0   --Indique si position budétisée (1) ou non(0)
                                             );

          fetch crFixedAssets
           into tplFixedAssets;
        end loop;

        close crFixedAssets;

      fetch crJournalImputations
       into tplJournalImputations;
    end loop;

    delete from FAM_PLAN_TO_COMPUTE PTC
       where PTC.FAM_PLAN_TO_COMPUTE_ID = userenv('SESSIONID');
  end if;
end FAM_FJO_AU_FAM_PLAN;

ALTER TRIGGER "C_ITX"."FAM_FJO_AU_FAM_PLAN" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_MANAGED_VALUE_AU_ELEMENT"
  after update of FAM_STRUCTURE_ELEMENT_ID
                , FAM_STRUCTURE_ELEMENT3_ID
                , FAM_STRUCTURE_ELEMENT4_ID
                , FAM_STRUCTURE_ELEMENT6_ID
  on FAM_MANAGED_VALUE
  referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour / Calcul  des plans d'amortissement suite à changement des éléments de structure
*   des valeurs gérées
* @author Sener Kalayci
* @version 2003
* @lastUpdate
*/
declare
  --Curseur des immobilisations ayant un lien sur la valeur gérée donnée
  --Ne pas prendre Min et Max, des immobilisations se trouvant dans la fourchette
  --ne gèrent pas forcément la valeur gérée
  cursor crFamFixedAssets
  is
    select   FIX.FAM_FIXED_ASSETS_ID   -- Immobilisation
           , AMO.FAM_AMORTIZATION_METHOD_ID   -- Méthode d'amortissement
           , AMO.AMO_ROUNDED_AMOUNT   -- Montant arrondi
           , AMO.C_AMORTIZATION_PERIOD   -- Cadence d'amortissment
           , AMO.C_AMORTIZATION_TYP   -- Type d'amortissment
           , AMO.C_ROUND_TYPE   -- Type d'arrondi
           , AAP.APP_AMORTIZATION_BEGIN   -- Début d'amortissement
           , AAP.FAM_MANAGED_VALUE_ID   -- Valeur gérée
           , nvl(DEF.DEF_MIN_RESIDUAL_VALUE, 0) DEF_MIN_RESIDUAL_VALUE   -- Valeur résiduelle minimum
           , case   --Taux 1 selon type amortissement
               when AMO.C_AMORTIZATION_TYP in('1', '3', '5', '6', '9', '60') then nvl(AAP.APP_LIN_AMORTIZATION
                                                                                    , DEF.DEF_LIN_AMORTIZATION
                                                                                     )
               when AMO.C_AMORTIZATION_TYP in('2', '4') then nvl(AAP.APP_DEC_AMORTIZATION, DEF.DEF_DEC_AMORTIZATION)
               else 0
             end Rate1
           , case   --Taux 2 selon type amortissement
               when AMO.C_AMORTIZATION_TYP in('5', '6', '9', '60') then nvl(AAP.APP_DEC_AMORTIZATION
                                                                          , DEF.DEF_DEC_AMORTIZATION
                                                                           )
               else null
             end Rate2
           , case   --Coeeficient pour types 6,60 cascade Application / Défaut
               when AMO.C_AMORTIZATION_TYP in('6', '60') then nvl(AAP.DIC_FAM_COEFFICIENT_ID
                                                                , DEF.DIC_FAM_COEFFICIENT_ID)
               else null
             end COEFFICIENT
           ,
             -- Durée d'amortissement systématiquement calculée(100/taux1)même si renseignée sur la fiche Arrondi à 2 déc. comme définie
             round(100 /
                   decode(decode(AAP.APP_LIN_AMORTIZATION, 0, null, AAP.APP_LIN_AMORTIZATION)
                        , null, decode(DEF.DEF_LIN_AMORTIZATION, 0, null, DEF.DEF_LIN_AMORTIZATION)
                        , AAP.APP_LIN_AMORTIZATION
                         )
                 , 2
                  ) APP_MONTH_DURATION
           , nvl(DEF.FAM_STRUCTURE_ELEMENT1_ID, :new.FAM_STRUCTURE_ELEMENT_ID) FAM_STRUCTURE_ELEMENT1_ID   -- Base amortissement 1
           , nvl(DEF.FAM_STRUCTURE_ELEMENT6_ID, :new.FAM_STRUCTURE_ELEMENT6_ID) FAM_STRUCTURE_ELEMENT6_ID   -- Base amortissement 2
           , nvl(DEF.FAM_STRUCTURE_ELEMENT3_ID, :new.FAM_STRUCTURE_ELEMENT3_ID) FAM_STRUCTURE_ELEMENT3_ID   --Limite amortissement
           , nvl(DEF.FAM_STRUCTURE_ELEMENT2_ID, :new.FAM_STRUCTURE_ELEMENT2_ID) FAM_STRUCTURE_ELEMENT2_ID   -- Base intérêts
           , nvl(DEF.FAM_STRUCTURE_ELEMENT4_ID, :new.FAM_STRUCTURE_ELEMENT4_ID) FAM_STRUCTURE_ELEMENT4_ID   -- Acquisition
        from FAM_FIXED_ASSETS FIX
           , FAM_AMO_APPLICATION AAP
           , FAM_AMORTIZATION_METHOD AMO
           , FAM_DEFAULT DEF
       where AAP.FAM_MANAGED_VALUE_ID = :new.FAM_MANAGED_VALUE_ID
         and FIX.FAM_FIXED_ASSETS_ID = AAP.FAM_FIXED_ASSETS_ID
         and FIX.C_FIXED_ASSETS_STATUS = '01'
         and FIX.C_OWNERSHIP <> '9'
         and AMO.FAM_AMORTIZATION_METHOD_ID = AAP.FAM_AMORTIZATION_METHOD_ID
         and AMO.AMO_AMORTIZATION_PLAN = 1
         and DEF.FAM_MANAGED_VALUE_ID = AAP.FAM_MANAGED_VALUE_ID
         and DEF.FAM_FIXED_ASSETS_CATEG_ID = FIX.FAM_FIXED_ASSETS_CATEG_ID
         and DEF.FAM_AMORTIZATION_METHOD_ID = AMO.FAM_AMORTIZATION_METHOD_ID
    order by FIX.FIX_NUMBER;

  tplFixedAssets crFamFixedAssets%rowtype;   --Réceptionne les données immob. du curseur
begin
  --Ouverture et parcours du curseur des immobilisations liées à la valeur gérée courante
  --Traitement pour chaque immobilisation retournée par le curseur...et non pas pour une fourchette donnée
  open crFamFixedAssets;

  fetch crFamFixedAssets
   into tplFixedAssets;

  while crFamFixedAssets%found loop
    FAM_AMORTIZATION_PLAN.CalculateAmortizationPlan
                                             (tplFixedAssets.FAM_FIXED_ASSETS_ID   --Immobilisation
                                            , tplFixedAssets.FAM_MANAGED_VALUE_ID   --Valeur gérée
                                            , tplFixedAssets.FAM_AMORTIZATION_METHOD_ID   --Méthode amortissement
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT1_ID   --Elément "Base amortissement"
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT2_ID   --Elément "Base intérêts"
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT3_ID   --Elément "Limite amortissement"
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT4_ID   --Elément "Acquisition"
                                            , tplFixedAssets.FAM_STRUCTURE_ELEMENT6_ID   --Elément "Base amortissement 6"
                                            , tplFixedAssets.C_AMORTIZATION_TYP   --Type amortissement
                                            , tplFixedAssets.C_AMORTIZATION_PERIOD   --Cadence
                                            , tplFixedAssets.APP_AMORTIZATION_BEGIN   --Début amortissement
                                            , tplFixedAssets.APP_MONTH_DURATION   --Durée amortissement
                                            , tplFixedAssets.Rate1   --Taux 1
                                            , tplFixedAssets.Rate2   --Taux 2
                                            , tplFixedAssets.COEFFICIENT   --Coefficient
                                            , tplFixedAssets.DEF_MIN_RESIDUAL_VALUE   --Valeur résiduelle
                                            , tplFixedAssets.C_ROUND_TYPE   --Type arrondi
                                            , tplFixedAssets.AMO_ROUNDED_AMOUNT   --Montant arrondi
                                            , 1 --Activation du plan
                                            , 0   --Indique si position budétisée (1) ou non(0)
                                             );

    fetch crFamFixedAssets
     into tplFixedAssets;
  end loop;

  close crFamFixedAssets;
end FAM_MANAGED_VALUE_AU_ELEMENT;

ALTER TRIGGER "C_ITX"."FAM_MANAGED_VALUE_AU_ELEMENT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_PLAN_EXERCISE_AD"
  after delete
  on FAM_PLAN_EXERCISE
  referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour du statut du plan d'amortissement à '0 - A activer' lors de la suppression d'un plan / exercice
* @author Sener Kalayci
* @version 2003
* @lastUpdate
*/
declare
begin
  --Suppression de FAM_PLAN_HEADER qui par CASCADE DELETE entraîne suppression de FAM_PLAN_EXERCISE
  update FAM_PLAN_HEADER FPH
     set C_AMO_PLAN_STATUS = '0'
   where C_AMO_PLAN_STATUS <> '0'
     and FPH.FAM_PLAN_HEADER_ID = :old.FAM_PLAN_HEADER_ID;
exception
  when ex.TABLE_MUTATING then
    null;
end FAM_PLAN_EXERCISE_AD;

ALTER TRIGGER "C_ITX"."FAM_PLAN_EXERCISE_AD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_PLAN_EXERCISE_AU"
  after update
  on FAM_PLAN_EXERCISE
  referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour du statut du plan d'amortissement à '0 - A activer' lors de toute modification des plans par exercice
* @author Sener Kalayci
* @version 2003
* @lastUpdate
*/
declare
begin
  update FAM_PLAN_HEADER FPH
     set C_AMO_PLAN_STATUS = '0'
   where C_AMO_PLAN_STATUS <> '0'
     and FPH.FAM_PLAN_HEADER_ID = :new.FAM_PLAN_HEADER_ID;
end FAM_PLAN_EXERCISE_AU;


ALTER TRIGGER "C_ITX"."FAM_PLAN_EXERCISE_AU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_PLAN_HEADER_AU_STATUS"
  after update of "C_AMO_PLAN_STATUS"
  on FAM_PLAN_HEADER
  referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour des champs FAM_AMO_APPLICATION.APP_YEAR_DURATION   (Durée en année)
                           FAM_AMO_APPLICATION.APP_MONTH_DURATION  (Durée en mois)
*                          FAM_AMO_APPLICATION.APP_AMORTIZATION_END(Date de Fin d'amortissement
*   lors du passage d'un plan au statut actif en se basant sur la période / exercice max. selon mode de gestion
* @author Sener Kalayci
* @version 2003
* @lastUpdate
*/
declare
  vAmoToUpdateId FAM_AMO_APPLICATION.FAM_AMO_APPLICATION_ID%type;   --Id position à modifier
  vAmoStartDate  FAM_PLAN_EXERCISE.FPE_AMORTIZATION_BEGIN%type;   --Date début amortissement
  vAmoEndDate    FAM_PLAN_EXERCISE.FPE_AMORTIZATION_BEGIN%type;   --Date fin amortissement
  vMonths        FAM_AMO_APPLICATION.APP_MONTH_DURATION%type;   --Durée en mois
  vYears         FAM_AMO_APPLICATION.APP_YEAR_DURATION%type;   --Durée en année
begin
  --traitement uniquement si passage d'un état non-actif à un état actif du plan d'amortissement
  if (:new.C_AMO_PLAN_STATUS = 1) then
    --Réception cadence amortissement et Id position à mettre à jour
    select max(AMO.FAM_AMO_APPLICATION_ID)
      into vAmoToUpdateId
      from FAM_AMO_APPLICATION AMO
     where AMO.FAM_FIXED_ASSETS_ID = :new.FAM_FIXED_ASSETS_ID
       and AMO.FAM_MANAGED_VALUE_ID = :new.FAM_MANAGED_VALUE_ID;

    --Réception date début amortissement
    select min(FPE_AMORTIZATION_BEGIN)
      into vAmoStartDate
      from FAM_PLAN_EXERCISE
     where FAM_PLAN_HEADER_ID = :new.FAM_PLAN_HEADER_ID;

    --Réception date de fin amortissement
    select max(FPE_AMORTIZATION_END)
      into vAmoEndDate
      from FAM_PLAN_EXERCISE
     where FAM_PLAN_HEADER_ID = :new.FAM_PLAN_HEADER_ID;

    --Calcul nombre de mois, nombre d'années (floor prend la partie entière)
    select floor(months_between(vAmoEndDate, vAmoStartDate) ) + 1
         , (floor(months_between(vAmoEndDate, vAmoStartDate) ) + 1) / 12
      into vMonths
         , vYears
      from dual;

    --Mise à jour
    update FAM_AMO_APPLICATION
       set APP_MONTH_DURATION = vMonths
         , APP_YEAR_DURATION = vYears
         , APP_AMORTIZATION_END = vAmoEndDate
     where FAM_AMO_APPLICATION_ID = vAmoToUpdateId;
  end if;
exception
  --Exception dans le cas ou l'on obtient le message table is mutating, trigger cannot see it
  --Si calcul lancé depuis FAM_AMO_APPLICATION_AIU
  when ex.TABLE_MUTATING then
    null;
end FAM_PLAN_HEADER_AU_STATUS;

ALTER TRIGGER "C_ITX"."FAM_PLAN_HEADER_AU_STATUS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_PLAN_HEADER_BU_STATUS"
  before update of "C_AMO_PLAN_STATUS", "C_FPH_BLOCKING_REASON"
  on FAM_PLAN_HEADER
  referencing old as old new as new
  for each row
/**
* Description
* @author Sener Kalayci
* @version 2003
* @lastUpdate
*/
declare
begin
  if (:old.C_AMO_PLAN_STATUS) <>(:new.C_AMO_PLAN_STATUS) then
    if (:new.C_AMO_PLAN_STATUS = 1) then
      if (:new.C_FPH_BLOCKING_REASON <> '04') then
        :new.C_FPH_BLOCKING_REASON  := '00';
      end if;
    elsif(:new.C_AMO_PLAN_STATUS = 0) then
      if (:new.C_FPH_BLOCKING_REASON <> '04') then
        :new.C_FPH_BLOCKING_REASON  := '01';
      end if;
    end if;
  end if;

  if (:old.C_FPH_BLOCKING_REASON) <>(:new.C_FPH_BLOCKING_REASON) then
    if (:new.C_FPH_BLOCKING_REASON = '00') then
      :new.C_AMO_PLAN_STATUS  := '1';
    elsif(:new.C_FPH_BLOCKING_REASON = '01') then
      :new.C_AMO_PLAN_STATUS  := '0';
    elsif(:new.C_FPH_BLOCKING_REASON = '02') then
      :new.C_AMO_PLAN_STATUS  := '0';
    elsif(:new.C_FPH_BLOCKING_REASON = '03') then
      :new.C_AMO_PLAN_STATUS  := '0';
    elsif(:new.C_FPH_BLOCKING_REASON = '04') then
      :new.C_AMO_PLAN_STATUS  := '0';
    end if;
  end if;
end FAM_PLAN_HEADER_BU_STATUS;

ALTER TRIGGER "C_ITX"."FAM_PLAN_HEADER_BU_STATUS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_PLAN_PERIOD_AD"
  after delete
  on FAM_PLAN_PERIOD
  referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour du statut du plan d'amortissement à '0 - A activer' lors de suppression de plans / période
* @author Sener Kalayci
* @version 2003
* @lastUpdate
*/
begin
  update FAM_PLAN_HEADER FPH
     set C_AMO_PLAN_STATUS = '0'
   where C_AMO_PLAN_STATUS <> '0'
     and exists(
           select 1
             from FAM_PLAN_EXERCISE FPE
            where FPE.FAM_PLAN_EXERCISE_ID = :old.FAM_PLAN_EXERCISE_ID
              and FPH.FAM_PLAN_HEADER_ID = FPE.FAM_PLAN_HEADER_ID);
exception
  -- exception dans le cas ou l'on obtient le message table is mutating, trigger cannot see it
  --Suppression de FAM_PLAN_EXERCISE qui par CASCADE DELETE entraîne suppression de FAM_PLAN_PERIOD
  when ex.TABLE_MUTATING then
    null;
end FAM_PLAN_PERIOD_AD;

ALTER TRIGGER "C_ITX"."FAM_PLAN_PERIOD_AD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_PLAN_PERIOD_AU"
  after update
  on FAM_PLAN_PERIOD
  referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour du statut du plan d'amortissement à '0 - A activer' lors de toute modifIcation des plans par période
* @author Sener Kalayci
* @version 2003
* @lastUpdate
*/
declare
begin
  update FAM_PLAN_HEADER FPH
     set C_AMO_PLAN_STATUS = '0'
   where C_AMO_PLAN_STATUS <> '0'
     and exists(
           select 1
             from FAM_PLAN_EXERCISE FPE
            where FPE.FAM_PLAN_EXERCISE_ID = :new.FAM_PLAN_EXERCISE_ID
              and FPH.FAM_PLAN_HEADER_ID = FPE.FAM_PLAN_HEADER_ID);
end FAM_PLAN_PERIOD_AU;


ALTER TRIGGER "C_ITX"."FAM_PLAN_PERIOD_AU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_VAL_IMP_AD_TOT_BY_PERIOD"
  after delete
  on FAM_VAL_IMPUTATION
  referencing old as old new as new
  for each row
/**
* Description
*
* @version 2003
* @lastUpdate
*/
declare
  vAssetsId    FAM_IMPUTATION.FAM_FIXED_ASSETS_ID%type;
  vFixCategId  FAM_IMPUTATION.FAM_FIXED_ASSETS_CATEG_ID%type;
  vPeriodId    FAM_IMPUTATION.ACS_PERIOD_ID%type;
  vLCurrencyId FAM_IMPUTATION.ACS_ACS_FINANCIAL_CURRENCY_ID%type;
  vAmountLC_D  FAM_IMPUTATION.FIM_AMOUNT_LC_D%type;
  vAmountLC_C  FAM_IMPUTATION.FIM_AMOUNT_LC_C%type;
  vTraTyp      FAM_IMPUTATION.C_FAM_TRANSACTION_TYP%type;
begin
  select FAM_FIXED_ASSETS_ID
       , FAM_FIXED_ASSETS_CATEG_ID
       , C_FAM_TRANSACTION_TYP
       , ACS_PERIOD_ID
       , ACS_ACS_FINANCIAL_CURRENCY_ID
       , FIM_AMOUNT_LC_D
       , FIM_AMOUNT_LC_C
    into vAssetsId
       , vFixCategId
       , vTraTyp
       , vPeriodId
       , vLCurrencyId
       , vAmountLC_D
       , vAmountLC_C
    from FAM_IMPUTATION
   where FAM_IMPUTATION_ID = :old.FAM_IMPUTATION_ID;

  FAM_TOT_BY_PERIOD.WriteFamTotalByPeriod(vAssetsId
                                        , vFixCategId
                                        , :old.FAM_MANAGED_VALUE_ID
                                        , vPeriodId
                                        , vLCurrencyId
                                        , vTraTyp
                                        , -vAmountLC_D
                                        , -vAmountLC_C
                                         );
exception
  when ex.TABLE_MUTATING then
    null;
end FAM_VAL_IMP_AD_TOT_BY_PERIOD;

ALTER TRIGGER "C_ITX"."FAM_VAL_IMP_AD_TOT_BY_PERIOD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_VAL_IMP_AI_TOT_BY_PERIOD"
  after insert
  on FAM_VAL_IMPUTATION
  referencing old as old new as new
  for each row
/**
* Description
*
* @version 2003
* @lastUpdate
*/
declare
  vAssetsId    FAM_IMPUTATION.FAM_FIXED_ASSETS_ID%type;
  vFixCategId  FAM_IMPUTATION.FAM_FIXED_ASSETS_CATEG_ID%type;
  vPeriodId    FAM_IMPUTATION.ACS_PERIOD_ID%type;
  vLCurrencyId FAM_IMPUTATION.ACS_ACS_FINANCIAL_CURRENCY_ID%type;
  vAmountLC_D  FAM_IMPUTATION.FIM_AMOUNT_LC_D%type;
  vAmountLC_C  FAM_IMPUTATION.FIM_AMOUNT_LC_C%type;
  vTraTyp      FAM_IMPUTATION.C_FAM_TRANSACTION_TYP%type;
begin
  select FAM_FIXED_ASSETS_ID
       , FAM_FIXED_ASSETS_CATEG_ID
       , C_FAM_TRANSACTION_TYP
       , ACS_PERIOD_ID
       , ACS_ACS_FINANCIAL_CURRENCY_ID
       , FIM_AMOUNT_LC_D
       , FIM_AMOUNT_LC_C
    into vAssetsId
       , vFixCategId
       , vTraTyp
       , vPeriodId
       , vLCurrencyId
       , vAmountLC_D
       , vAmountLC_C
    from FAM_IMPUTATION
   where FAM_IMPUTATION_ID = :new.FAM_IMPUTATION_ID;

  FAM_TOT_BY_PERIOD.WriteFamTotalByPeriod(vAssetsId
                                        , vFixCategId
                                        , :new.FAM_MANAGED_VALUE_ID
                                        , vPeriodId
                                        , vLCurrencyId
                                        , vTraTyp
                                        , vAmountLC_D
                                        , vAmountLC_C
                                         );
end FAM_VAL_IMP_AI_TOT_BY_PERIOD;

ALTER TRIGGER "C_ITX"."FAM_VAL_IMP_AI_TOT_BY_PERIOD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_VAL_IMP_AIUD_FAM_PLAN"
  after insert or update or delete
  on FAM_VAL_IMPUTATION
  referencing old as old new as new
  for each row
/**
* Description
*
* @version 2003
* @lastUpdate
*/
declare
  vTraTyp          FAM_IMPUTATION.C_FAM_TRANSACTION_TYP%type;
  vFixCategId      FAM_IMPUTATION.FAM_FIXED_ASSETS_CATEG_ID%type;
  vAssetsId        FAM_IMPUTATION.FAM_FIXED_ASSETS_ID%type;
  vInactivation    FAM_PLAN_HEADER.C_INACTIVATION_REASON%type;
  vPlanToComputeId FAM_PLAN_TO_COMPUTE.FAM_PLAN_TO_COMPUTE_ID%type;
begin
  select FAM_FIXED_ASSETS_ID
       , FAM_FIXED_ASSETS_CATEG_ID
       , C_FAM_TRANSACTION_TYP
    into vAssetsId
       , vFixCategId
       , vTraTyp
    from FAM_IMPUTATION
   where FAM_IMPUTATION_ID = nvl(:new.FAM_IMPUTATION_ID, :old.FAM_IMPUTATION_ID);

  -- Les valeurs amortissement de type 605,610, 650 changent OU Un des 5 montants basés sur les éléments de structure change
  -- Type de transaction 605,610,650 --> OK
  -- sinon vérifier que le type de transaction
  -- fait partie d'un élément de structure utilisé dasn le calcul des amortissements
  if vTraTyp not in('605', '610', '650', '600') then
    select max(DET.C_FAM_TRANSACTION_TYP)
      into vTraTyp
      from FAM_ELEMENT_DETAIL DET
     where DET.C_FAM_TRANSACTION_TYP = vTraTyp
       and (   exists(
                 select 1
                   from FAM_DEFAULT DEF
                  where DEF.FAM_FIXED_ASSETS_CATEG_ID = vFixCategId
                    and (   DEF.FAM_STRUCTURE_ELEMENT1_ID = DET.FAM_STRUCTURE_ELEMENT_ID
                         or DEF.FAM_STRUCTURE_ELEMENT3_ID = DET.FAM_STRUCTURE_ELEMENT_ID
                         or DEF.FAM_STRUCTURE_ELEMENT4_ID = DET.FAM_STRUCTURE_ELEMENT_ID
                         or DEF.FAM_STRUCTURE_ELEMENT6_ID = DET.FAM_STRUCTURE_ELEMENT_ID
                        ) )
            or exists(
                 select 1
                   from FAM_MANAGED_VALUE VAL
                  where VAL.FAM_MANAGED_VALUE_ID = nvl(:new.FAM_MANAGED_VALUE_ID, :old.FAM_MANAGED_VALUE_ID)
                    and (   VAL.FAM_STRUCTURE_ELEMENT_ID = DET.FAM_STRUCTURE_ELEMENT_ID
                         or VAL.FAM_STRUCTURE_ELEMENT3_ID = DET.FAM_STRUCTURE_ELEMENT_ID
                         or VAL.FAM_STRUCTURE_ELEMENT4_ID = DET.FAM_STRUCTURE_ELEMENT_ID
                         or VAL.FAM_STRUCTURE_ELEMENT6_ID = DET.FAM_STRUCTURE_ELEMENT_ID
                        ) )
           );
  end if;

  if     (vTraTyp is not null)
     and (vTraTyp <> '600') then
    if inserting then
      vInactivation  := '01';
    elsif updating then
      vInactivation  := '02';
    elsif deleting then
      vInactivation  := '03';
    end if;

    --Désactiver/Historier tout plan existant ayant le statut "actif" ('1') ou "à activer" ('0')
    --Renseigner le FAM_PLAN_HEADER.C_INACTIVATION_REASON:
    update FAM_PLAN_HEADER
       set C_AMO_PLAN_STATUS = '2'
         , C_INACTIVATION_REASON = vInactivation
     where FAM_FIXED_ASSETS_ID = vAssetsId
       and FAM_MANAGED_VALUE_ID = nvl(:new.FAM_MANAGED_VALUE_ID, :old.FAM_MANAGED_VALUE_ID)
       and (    (C_AMO_PLAN_STATUS = '0')
            or (C_AMO_PLAN_STATUS = '1') );

    --Maintenir la table "temporaire" listant les plans à recalculer FAM_PLAN_TO_COMPUTE
    insert into FAM_PLAN_TO_COMPUTE
                (FAM_PLAN_TO_COMPUTE_ID
               , FAM_FIXED_ASSETS_ID
               , FAM_MANAGED_VALUE_ID
               , C_INACTIVATION_REASON
                )
      select userenv('SESSIONID')
           , vAssetsId
           , nvl(:new.FAM_MANAGED_VALUE_ID, :old.FAM_MANAGED_VALUE_ID)
           , vInactivation
        from dual
       where not exists(
               select 1
                 from FAM_PLAN_TO_COMPUTE PTC
                where PTC.FAM_FIXED_ASSETS_ID = vAssetsId
                  and PTC.FAM_MANAGED_VALUE_ID = nvl(:new.FAM_MANAGED_VALUE_ID, :old.FAM_MANAGED_VALUE_ID)
                  and PTC.FAM_PLAN_TO_COMPUTE_ID = userenv('SESSIONID') );
  end if;
exception
  -- exception dans le cas ou l'on obtient le message table is mutating, trigger cannot see it
  --Suppression de FAM_IMPUTATION dans le trigger FAM_FIM_BD_TOT_BY_PERIOD où l'on supprime manuellement FAM_VAL_IMPUTATION
  when ex.TABLE_MUTATING then
    null;
end FAM_VAL_IMP_AIUD_FAM_PLAN;

ALTER TRIGGER "C_ITX"."FAM_VAL_IMP_AIUD_FAM_PLAN" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."FAM_VAL_IMP_AU_TOT_BY_PERIOD"
  after update of FAM_MANAGED_VALUE_ID
  on FAM_VAL_IMPUTATION
  referencing old as old new as new
  for each row
/**
* Description
*
* @version 2003
* @lastUpdate
*/
declare
  vAssetsId    FAM_IMPUTATION.FAM_FIXED_ASSETS_ID%type;
  vFixCategId  FAM_IMPUTATION.FAM_FIXED_ASSETS_CATEG_ID%type;
  vPeriodId    FAM_IMPUTATION.ACS_PERIOD_ID%type;
  vLCurrencyId FAM_IMPUTATION.ACS_ACS_FINANCIAL_CURRENCY_ID%type;
  vAmountLC_D  FAM_IMPUTATION.FIM_AMOUNT_LC_D%type;
  vAmountLC_C  FAM_IMPUTATION.FIM_AMOUNT_LC_C%type;
  vTraTyp      FAM_IMPUTATION.C_FAM_TRANSACTION_TYP%type;
begin
  select FAM_FIXED_ASSETS_ID
       , FAM_FIXED_ASSETS_CATEG_ID
       , C_FAM_TRANSACTION_TYP
       , ACS_PERIOD_ID
       , ACS_ACS_FINANCIAL_CURRENCY_ID
       , FIM_AMOUNT_LC_D
       , FIM_AMOUNT_LC_C
    into vAssetsId
       , vFixCategId
       , vTraTyp
       , vPeriodId
       , vLCurrencyId
       , vAmountLC_D
       , vAmountLC_C
    from FAM_IMPUTATION
   where FAM_IMPUTATION_ID = :old.FAM_IMPUTATION_ID;

  FAM_TOT_BY_PERIOD.WriteFamTotalByPeriod(vAssetsId
                                        , vFixCategId
                                        , :old.FAM_MANAGED_VALUE_ID
                                        , vPeriodId
                                        , vLCurrencyId
                                        , vTraTyp
                                        , -vAmountLC_D
                                        , -vAmountLC_C
                                         );
  FAM_TOT_BY_PERIOD.WriteFamTotalByPeriod(vAssetsId
                                        , vFixCategId
                                        , :new.FAM_MANAGED_VALUE_ID
                                        , vPeriodId
                                        , vLCurrencyId
                                        , vTraTyp
                                        , vAmountLC_D
                                        , vAmountLC_C
                                         );
end FAM_VAL_IMP_AU_TOT_BY_PERIOD;

ALTER TRIGGER "C_ITX"."FAM_VAL_IMP_AU_TOT_BY_PERIOD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_BDG_AD_DOC_RECORD"
  AFTER DELETE
  ON GAL_BUDGET
DECLARE
  v_exist char(1);
BEGIN
   FOR i IN 1 .. gal_bdg_aiu_doc_record.bdg_index
   LOOP
    BEGIN
      -- On regarde si le père du code budget supprimé a lui-même un père
      -- Si ça n'est pas le cas, on simule une màj sur ce code budget père afin de le répliquer en dossier
      SELECT '*' INTO v_exist FROM gal_budget
      WHERE gal_father_budget_id = gal_bdg_aiu_doc_record.table_rowid_budget(i).new_gal_budget_id
      and rownum = 1;
    EXCEPTION WHEN no_data_found THEN
	  UPDATE GAL_BUDGET SET BDG_CODE = BDG_CODE WHERE GAL_BUDGET_ID = gal_bdg_aiu_doc_record.table_rowid_budget(i).new_gal_budget_id;
    END;
   END LOOP;
   gal_bdg_aiu_doc_record.bdg_index := 0;
end GAL_BDG_AD_DOC_RECORD;

ALTER TRIGGER "C_ITX"."GAL_BDG_AD_DOC_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_BDG_AIU_DOC_RECORD"
   after insert or
         update of GAL_PROJECT_ID,
                   C_BDG_STATE,
                   GAL_FATHER_BUDGET_ID,
                   BDG_CODE,
                   BDG_WORDING,
                   BDG_DESCRIPTION,
                   GAL_BUDGET_CATEGORY_ID,
                   BDG_RESERVE
   on GAL_BUDGET
   referencing new as NEW old as OLD
declare
   V_SHORT1        DOC_RECORD.RCO_ALPHA_SHORT1%type;
   V_RCO_TITLE     DOC_RECORD.RCO_TITLE%type;
   V_CUSTOMER_ID   GAL_PROJECT.PAC_CUSTOM_PARTNER_ID%type;
   V_RCO_STATUS    DOC_RECORD.C_RCO_STATUS%type;
   V_RCO_LONG1     DOC_RECORD.RCO_ALPHA_LONG1%type;
   V_RCO_LONG2     DOC_RECORD.RCO_ALPHA_LONG2%type;
   V_PRJ_STATE     GAL_PROJECT.C_PRJ_STATE%type;
   V_TYPE_TAS      char (1);
   V_EXIST         char (1);
begin
   for I in 1 .. GAL_BDG_AIU_DOC_RECORD.BDG_INDEX
   loop
      if GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).NEW_BDG_RESERVE = 0
      then
         begin
            --si le budget a un fils alors pas de creation de record
            select '*'
              into V_EXIST
              from GAL_BUDGET
             where GAL_FATHER_BUDGET_ID =
                      GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).
                      NEW_GAL_BUDGET_ID
                   and ROWNUM = 1;
         exception
            when NO_DATA_FOUND
            then
               begin
                  select PRJ_CODE,
                         case
                            when LENGTH (
                                    TRIM (PRJ_CODE) || '::'
                                    || TRIM (
                                          GAL_BDG_AIU_DOC_RECORD.
                                          TABLE_ROWID_BUDGET (I).NEW_BDG_CODE)) <=
                                    30
                            then
                               PRJ_CODE || '::'
                               || GAL_BDG_AIU_DOC_RECORD.
                                  TABLE_ROWID_BUDGET (I).NEW_BDG_CODE
                            else
                               TRIM (
                                  RPAD (
                                     TRIM (PRJ_CODE) || '::'
                                     || TRIM (
                                           GAL_BDG_AIU_DOC_RECORD.
                                           TABLE_ROWID_BUDGET (I).
                                           NEW_BDG_CODE),
                                     30))
                         end,
                         PAC_CUSTOM_PARTNER_ID,
                         DECODE (
                            C_PRJ_STATE,
                            '10', '2',
                            DECODE (
                               GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).
                               NEW_C_BDG_STATE,
                               '40', '1',
                               '0')),
                            PRJ_WORDING
                         || CHR (10)
                         || SUBSTR (PRJ_DESCRIPTION,
                                    1,
                                    3930),
                         GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).
                         NEW_BDG_WORDING
                         || CHR (10)
                         || SUBSTR (
                               GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).
                               NEW_BDG_DESCRIPTION,
                               1,
                               3930),
                         GAL_PROJECT.C_PRJ_STATE
                    into V_SHORT1,
                         V_RCO_TITLE,
                         V_CUSTOMER_ID,
                         V_RCO_STATUS,
                         V_RCO_LONG1,
                         V_RCO_LONG2,
                         V_PRJ_STATE
                    from GAL_PROJECT
                   where GAL_PROJECT.GAL_PROJECT_ID =
                            GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).
                            NEW_GAL_PROJECT_ID;

                  DOC_RECORD_FUNCTIONS.
                  UPDATERECORDPROJECT (
                     GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).
                     NEW_GAL_PROJECT_ID,
                     null,
                     GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).
                     NEW_GAL_BUDGET_ID,
                     null,
                     V_CUSTOMER_ID,
                     '4',
                     V_RCO_STATUS,
                     V_RCO_TITLE,
                     GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).
                     NEW_BDG_WORDING,
                     V_SHORT1,
                     GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).
                     NEW_BDG_CODE,
                     V_RCO_LONG1,
                     V_RCO_LONG2,
                     GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).
                     NEW_BUD_CAT_ID);
               exception
                  when NO_DATA_FOUND
                  then
                     null;
               end;

               update GAL_BUDGET
                  set DOC_RECORD_ID =
                         (select DOC_RECORD_ID
                            from DOC_RECORD
                           where GAL_BUDGET_ID =
                                    GAL_BDG_AIU_DOC_RECORD.
                                    TABLE_ROWID_BUDGET (I).NEW_GAL_BUDGET_ID)
                where GAL_BUDGET_ID =
                         GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).
                         NEW_GAL_BUDGET_ID;

               if INSERTING
                  and GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).
                      NEW_GAL_FATHER_BUDGET_ID
                         is not null
               then
                  update GAL_BUDGET
                     set DOC_RECORD_ID = null
                   where GAL_BUDGET_ID =
                            GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).
                            NEW_GAL_FATHER_BUDGET_ID;

                  DOC_RECORD_FUNCTIONS.
                  DELETERECORDPROJECT (
                     null,
                     null,
                     GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).
                     NEW_GAL_FATHER_BUDGET_ID,
                     null);
               end if;

               -- ML 12.01.06 ajout cas modif de père
               if UPDATING
                  and NVL (
                         GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).
                         OLD_GAL_FATHER_BUDGET_ID,
                         0) <>
                         NVL (
                            GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).
                            NEW_GAL_FATHER_BUDGET_ID,
                            0)
               then
                  if GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).
                     NEW_GAL_FATHER_BUDGET_ID
                        is not null
                  then
                     -- new père : sans dossier
                     update GAL_BUDGET
                        set DOC_RECORD_ID = null
                      where GAL_BUDGET_ID =
                               GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).
                               NEW_GAL_FATHER_BUDGET_ID;

                     -- new père : suppression dossier si existe
                     DOC_RECORD_FUNCTIONS.
                     DELETERECORDPROJECT (
                        null,
                        null,
                        GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).
                        NEW_GAL_FATHER_BUDGET_ID,
                        null);
                  end if;

                  if GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).
                     OLD_GAL_FATHER_BUDGET_ID
                        is not null
                  then
                     -- old père : ajout dossier si plus de fils
                     begin
                        select '*'
                          into V_EXIST
                          from GAL_BUDGET
                         where GAL_FATHER_BUDGET_ID =
                                  GAL_BDG_AIU_DOC_RECORD.
                                  TABLE_ROWID_BUDGET (I).
                                  OLD_GAL_FATHER_BUDGET_ID
                               and ROWNUM = 1;
                     exception
                        when NO_DATA_FOUND
                        then
                           update GAL_BUDGET
                              set BDG_CODE = BDG_CODE
                            where GAL_BUDGET_ID =
                                     GAL_BDG_AIU_DOC_RECORD.
                                     TABLE_ROWID_BUDGET (I).
                                     OLD_GAL_FATHER_BUDGET_ID;
                     end;
                  end if;
               end if;
         end;
      -- ML 12.01.06 FIN ajout cas modif de père
      end if;

      if GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).NEW_BDG_RESERVE = 1
      then
         -- new père : sans dossier
         update GAL_BUDGET
            set DOC_RECORD_ID = null
          where GAL_BUDGET_ID =
                   GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).NEW_GAL_BUDGET_ID;

         -- Supprime le dossier budget
         DOC_RECORD_FUNCTIONS.
         DELETERECORDPROJECT (
            null,
            null,
            GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET (I).NEW_GAL_BUDGET_ID,
            null);
      end if;
   end loop;

   GAL_BDG_AIU_DOC_RECORD.BDG_INDEX := 0;
end GAL_BDG_AIU_DOC_RECORD;

ALTER TRIGGER "C_ITX"."GAL_BDG_AIU_DOC_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_BDG_AIU_ROW_DOC_RECORD"
AFTER INSERT OR UPDATE
OF GAL_PROJECT_ID
  ,C_BDG_STATE
  ,GAL_FATHER_BUDGET_ID
  ,BDG_CODE
  ,BDG_WORDING
  ,BDG_DESCRIPTION
  ,GAL_BUDGET_CATEGORY_ID
  ,BDG_RESERVE
ON GAL_BUDGET
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
declare


  v_gal_task_id   gal_task.gal_task_id%type;
  v_rco_title     doc_record.rco_title%type;
  v_tas_wording   gal_task.tas_wording%type;
  v_tas_code      gal_task.tas_code%type;
  v_rco_long1     doc_record.rco_alpha_long1%TYPE;
  v_rco_long2     doc_record.rco_alpha_long1%type;
  v_type_tas      char(1);
  v_c_tas_STATE   gal_task.c_tas_state%type;
  v_pac_custom_partner_id gal_project.pac_custom_partner_id%type;
  v_prj_code      gal_project.prj_code%type;
  v_prj_wording   gal_project.prj_wording%type;
  v_prj_description gal_project.prj_description%type;
  v_BudCat_Id     gal_budget.gal_budget_category_id%type;
  v_scs_short_descr gal_task_link.scs_short_descr%type;
  v_scs_step_number gal_task_link.scs_step_number%type;
  v_gal_task_link_id gal_task_link.gal_task_link_id%type;
  v_rco_status    doc_record.c_rco_status%type;
  v_task_type     gal_task_category.c_tca_task_type%TYPE;

  cursor c_task
  is
    select gal_task_id
         , case
             when length(trim(prj_code) || ':' || trim(tas_code) ) <= 30 then trim(prj_code) ||
                                                                                     ':' ||
                                                                                     trim(tas_code)
             else trim(rpad(trim(prj_code) || ':' || trim(tas_code), 30) )
           end
         , tas_wording
         , tas_code
         , tas_wording || chr(10) || substr(tas_description,1,3930)
         , decode(c_tca_task_type, '1', '2', '3')
         , decode(c_prj_state,'10','2',decode(:new.c_bdg_state,'40','1','0'))
         , :new.gal_budget_category_id
         , pac_custom_partner_id
         , prj_code
         , prj_wording
         , prj_description
      from gal_project
         , gal_task_category
         , gal_task
     where gal_task.gal_budget_id = :new.gal_budget_id
       and c_tca_task_type in('1', '2')
       and gal_task_category.gal_task_category_id = gal_task.gal_task_category_id
       and gal_task.gal_project_id = gal_project.gal_project_id;

    cursor c_ope
    is
      select CASE
                WHEN LENGTH (   TRIM (prj_code)
                             || ':::'
                             || TRIM (tas_code)
                             || ':::'
                             || TRIM (TO_CHAR (scs_step_number))
                            ) <= 30
                   THEN    TRIM (prj_code)
                        || ':::'
                        || TRIM (tas_code)
                        || ':::'
                        || TRIM (TO_CHAR (scs_step_number))
                ELSE TRIM (RPAD (   TRIM (prj_code)
                                 || ':::'
                                 || TRIM (tas_code)
                                 || ':::'
                                 || TRIM (TO_CHAR (scs_step_number)),
                                 30
                                )
                          )
             END,
             decode(c_prj_state,'10','2',decode(:new.c_bdg_state,'40','1','0')),
             tas_wording || CHR (10) || SUBSTR (tas_description, 1, 3930),
             to_char(scs_step_number) || CHR (10) || SUBSTR (scs_long_descr, 1, 3980),
             gal_task_category.c_tca_task_type,
             decode(gal_task_category.c_tca_task_type, '1', '2', '3'),
             :new.gal_budget_category_id,
             scs_short_descr,
             scs_step_number,
             gal_task_link_id,
             pac_custom_partner_id,
             prj_code
        FROM gal_task_link, gal_task_category, gal_task, gal_project
       WHERE gal_task.gal_budget_id = :new.gal_budget_id
         AND gal_task_category.gal_task_category_id = gal_task.gal_task_category_id
         AND gal_task_link.gal_task_id = gal_task.gal_task_id
         AND gal_task_link.c_task_type = '2' --externe
         AND gal_task.gal_project_id = gal_project.gal_project_id;

begin

  gal_bdg_aiu_doc_record.bdg_index := gal_bdg_aiu_doc_record.bdg_index + 1;
  gal_bdg_aiu_doc_record.table_rowid_budget(gal_bdg_aiu_doc_record.bdg_index).new_gal_budget_id := :new.gal_budget_id;
  gal_bdg_aiu_doc_record.table_rowid_budget(gal_bdg_aiu_doc_record.bdg_index).new_gal_father_budget_id := :new.gal_father_budget_id;
  gal_bdg_aiu_doc_record.table_rowid_budget(gal_bdg_aiu_doc_record.bdg_index).new_gal_project_id := :new.gal_project_id;
  gal_bdg_aiu_doc_record.table_rowid_budget(gal_bdg_aiu_doc_record.bdg_index).new_bdg_code := :new.bdg_code;
  gal_bdg_aiu_doc_record.table_rowid_budget(gal_bdg_aiu_doc_record.bdg_index).new_bdg_wording := :new.bdg_wording;
  gal_bdg_aiu_doc_record.table_rowid_budget(gal_bdg_aiu_doc_record.bdg_index).new_bdg_reserve := :new.bdg_reserve;
  gal_bdg_aiu_doc_record.table_rowid_budget(gal_bdg_aiu_doc_record.bdg_index).new_bdg_description := :new.bdg_description;
  gal_bdg_aiu_doc_record.table_rowid_budget(gal_bdg_aiu_doc_record.bdg_index).new_c_bdg_state := :new.c_bdg_state;
  gal_bdg_aiu_doc_record.table_rowid_budget(gal_bdg_aiu_doc_record.bdg_index).old_gal_father_budget_id := :old.gal_father_budget_id;
  gal_bdg_aiu_doc_record.table_rowid_budget(gal_bdg_aiu_doc_record.bdg_index).new_bud_cat_id := :new.gal_budget_category_id;

  if (:new.bdg_reserve = '1') then
    return;
  end if;

  if (:old.c_bdg_state <> '40' and :new.c_bdg_state = '40')--Solde bdg
  or (:old.c_bdg_state = '40' and :new.c_bdg_state <> '40')--Réactive bdg
  then
    -- On fait la mise à jour des dossiers tâches de l'affaire
    open c_task;
      loop
        fetch c_task
         into v_gal_task_id
            , v_rco_title
            , v_tas_wording
            , v_tas_code
            , v_rco_long2
            , v_type_tas
            , v_c_tas_state
            , v_BudCat_Id
            , v_pac_custom_partner_id
            , v_prj_code
            , v_prj_wording
            , v_prj_description;
        exit when c_task%notfound;

        doc_record_functions.updaterecordproject(
                                      null --gal_project_id
                                    , v_gal_task_id
                                    , NULL --gal_budget_id
                                    , null
                                    , v_pac_custom_partner_id
                                    , v_type_tas
                                    , v_c_tas_state
                                    , v_rco_title
                                    , v_tas_wording
                                    , v_prj_code
                                    , v_tas_code
                                    , v_prj_wording || chr(10) || substr(v_prj_description,1,3930)
                                    , v_rco_long2
                                    , v_BudCat_Id
                                     );

      end loop;
    close c_task;
    ------------------------------------------------------------

    -- On fait la mise à jour des dossiers ope externe de l'affaire
    open c_ope;
      loop
        fetch c_ope
        into v_rco_title,
             v_rco_status,
             v_rco_long1,
             v_rco_long2,
             v_task_type,
             v_type_tas,
             v_BudCat_Id,
             v_scs_short_descr,
             v_scs_step_number,
             v_gal_task_link_id,
             v_pac_custom_partner_id,
             v_prj_code;
        exit when c_ope%notfound;

            doc_record_functions.updaterecordproject (:new.gal_project_id,
                                                      NULL,
                                                      NULL,
                                                      v_gal_task_link_id,
                                                      v_pac_custom_partner_id,
                                                      v_type_tas,
                                                      v_rco_status,
                                                      v_rco_title,
                                                      v_scs_short_descr,
                                                      v_prj_code,
                                                      v_scs_step_number,
                                                      v_rco_long1,
                                                      v_rco_long2,
                                                      v_BudCat_Id
                                                     );
      end loop;
    close c_ope;

  end if;

end GAL_BDG_AIU_ROW_DOC_RECORD;

ALTER TRIGGER "C_ITX"."GAL_BDG_AIU_ROW_DOC_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_BDG_BD_DOC_RECORD"
  BEFORE DELETE
  ON GAL_BUDGET
begin
   gal_bdg_aiu_doc_record.bdg_index := 0;
   gal_bdg_aiu_doc_record.table_rowid_budget.DELETE;
end GAL_BDG_BD_DOC_RECORD;

ALTER TRIGGER "C_ITX"."GAL_BDG_BD_DOC_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_BDG_BD_ROW_DOC_RECORD"
  BEFORE DELETE
  ON GAL_BUDGET
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
declare
begin
  -- Supprime le dossier budget
  DOC_RECORD_FUNCTIONS.DeleteRecordProject(null, null, :old.GAL_BUDGET_ID, null);
  --Creer un nouveau doc_record avec la père du budget supprimé
  if :old.GAL_FATHER_BUDGET_ID IS NOT NULL THEN
    gal_bdg_aiu_doc_record.bdg_index := gal_bdg_aiu_doc_record.bdg_index + 1;
    gal_bdg_aiu_doc_record.table_rowid_budget(gal_bdg_aiu_doc_record.bdg_index).new_gal_budget_id := :old.gal_father_budget_id;
	gal_bdg_aiu_doc_record.table_rowid_budget(gal_bdg_aiu_doc_record.bdg_index).new_gal_father_budget_id := null;
    gal_bdg_aiu_doc_record.table_rowid_budget(gal_bdg_aiu_doc_record.bdg_index).new_gal_project_id := :old.gal_project_id;
  end if;
end GAL_BDG_BD_ROW_DOC_RECORD;

ALTER TRIGGER "C_ITX"."GAL_BDG_BD_ROW_DOC_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_BDG_BIU_DOC_RECORD"
   before insert or
          update of BDG_CODE,
                    BDG_WORDING,
                    C_BDG_STATE,
                    BDG_DESCRIPTION,
                    BDG_RESERVE,
                    GAL_FATHER_BUDGET_ID,
                    GAL_BUDGET_CATEGORY_ID
   on GAL_BUDGET
declare
begin
   GAL_BDG_AIU_DOC_RECORD.BDG_INDEX := 0;
   GAL_BDG_AIU_DOC_RECORD.TABLE_ROWID_BUDGET.DELETE;
end GAL_BDG_BIU_DOC_RECORD;

ALTER TRIGGER "C_ITX"."GAL_BDG_BIU_DOC_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_BLI_AIUD_JOURNAL"
  after insert or delete or update of "GAL_COST_CENTER_ID"
                                    , "BLI_BUDGET_QUANTITY"
                                    , "BLI_BUDGET_AMOUNT"
                                    , "BLI_BUDGET_PRICE"
                                    , "BLI_REMAINING_QUANTITY"
                                    , "BLI_REMAINING_AMOUNT"
                                    , "BLI_REMAINING_PRICE"
                                    , "BLI_LAST_BUDGET_DATE"
                                    , "BLI_HANGING_SPENDING_QUANTITY"
                                    , "BLI_HANGING_SPENDING_AMOUNT"
                                    , "BLI_HANGING_SPENDING_AMOUNT_B"
                                    , "BLI_LAST_ESTIMATION_QUANTITY"
                                    , "BLI_LAST_ESTIMATION_AMOUNT"
                                    , "BLI_LAST_REMAINING_DATE"
  on gal_budget_line
  referencing old as old new as new
  for each row
declare
  v_flag           number;
  v_date_budget    date;
  v_date_remaining date;
/**
* Description
*    Journalisation de la table
* @created fp 22.03.2007
* @version 2003
* màj hmo 12.04.07: on déclenche le trigger sur le changement de date, peut être important pour reconstitution de l'historique
* màj hmo 09.07.10: On déclenche sur"BLI_HANGING_SPENDING_QUANTITY","BLI_HANGING_SPENDING_AMOUNT",LI_LAST_ESTIMATION_QUANTITY","BLI_LAST_ESTIMATION_AMOUNT"
*             si rentrée d'un reste identique mais avec changement dans les imputation -> le reste doit être historisé
*/
begin
  if PCS.PC_CONFIG.getbooleanconfig('GAL_SNAPSHOT_ON') then
    -- Création d'un ligne de suppression
    v_flag            := -1;
    v_date_budget     := :OLD.BLI_LAST_BUDGET_DATE;
    v_date_remaining  := sysdate;

    if    deleting
       or updating then
      if deleting then
        v_flag         := 0;
        v_date_budget  := sysdate;
      end if;

      insert into GAL_BUDGET_LINE_JOURNAL
                  (GAL_BUDGET_LINE_JOURNAL_ID
                 , GAL_BUDGET_LINE_ID
                 , GAL_BUDGET_ID
                 , GAL_COST_CENTER_ID
                 , BLI_BUDGET_QUANTITY
                 , BLI_BUDGET_PRICE
                 , BLI_BUDGET_AMOUNT
                 , BLI_REMAINING_QUANTITY
                 , BLI_REMAINING_PRICE
                 , BLI_REMAINING_AMOUNT
                 , BLI_HANGING_SPENDING_QUANTITY
                 , BLI_HANGING_SPENDING_AMOUNT
                 , BLI_HANGING_SPENDING_AMOUNT_B
                 , BLI_LAST_BUDGET_DATE
                 , BLI_LAST_REMAINING_DATE
                 , BLI_LAST_ESTIMATION_QUANTITY
                 , BLI_LAST_ESTIMATION_AMOUNT
                 , BLI_DESCRIPTION
                 , BLI_COMMENT
                 , BLJ_NEW_VALUE
                 , A_DATECRE
                 , A_IDCRE
                 , GAL_BUDGET_PERIOD_ID
                  )
           values (INIT_ID_SEQ.NEXTVAL
                 , :OLD.GAL_BUDGET_LINE_ID
                 , :OLD.GAL_BUDGET_ID
                 , :OLD.GAL_COST_CENTER_ID
                 , -:OLD.BLI_BUDGET_QUANTITY
                 , :OLD.BLI_BUDGET_PRICE
                 , -:OLD.BLI_BUDGET_AMOUNT
                 , :OLD.BLI_REMAINING_QUANTITY
                 , :OLD.BLI_REMAINING_PRICE
                 , :OLD.BLI_REMAINING_AMOUNT
                 , :OLD.BLI_HANGING_SPENDING_QUANTITY
                 , :OLD.BLI_HANGING_SPENDING_AMOUNT
                 , :old.BLI_HANGING_SPENDING_AMOUNT_B
                 , v_date_budget
                 , v_date_remaining
                 , -:OLD.BLI_LAST_ESTIMATION_QUANTITY
                 , -:OLD.BLI_LAST_ESTIMATION_AMOUNT
                 , :OLD.BLI_DESCRIPTION
                 , :OLD.BLI_COMMENT
                 , v_flag
                 , sysdate
                 , pcs.PC_I_LIB_SESSION.getuserini
                 , :OLD.GAL_BUDGET_PERIOD_ID
                  );
    end if;

    -- Création d'un ligne d'ajout
    if    updating
       or inserting then
      insert into GAL_BUDGET_LINE_JOURNAL
                  (GAL_BUDGET_LINE_JOURNAL_ID
                 , GAL_BUDGET_LINE_ID
                 , GAL_BUDGET_ID
                 , GAL_COST_CENTER_ID
                 , BLI_BUDGET_QUANTITY
                 , BLI_BUDGET_PRICE
                 , BLI_BUDGET_AMOUNT
                 , BLI_REMAINING_QUANTITY
                 , BLI_REMAINING_PRICE
                 , BLI_REMAINING_AMOUNT
                 , BLI_HANGING_SPENDING_QUANTITY
                 , BLI_HANGING_SPENDING_AMOUNT
                 , BLI_HANGING_SPENDING_AMOUNT_B
                 , BLI_LAST_BUDGET_DATE
                 , BLI_LAST_REMAINING_DATE
                 , BLI_LAST_ESTIMATION_QUANTITY
                 , BLI_LAST_ESTIMATION_AMOUNT
                 , BLI_DESCRIPTION
                 , BLI_COMMENT
                 , BLJ_NEW_VALUE
                 , A_DATECRE
                 , A_IDCRE
                 , GAL_BUDGET_PERIOD_ID
                  )
           values (INIT_ID_SEQ.NEXTVAL
                 , :NEW.GAL_BUDGET_LINE_ID
                 , :NEW.GAL_BUDGET_ID
                 , :NEW.GAL_COST_CENTER_ID
                 , :NEW.BLI_BUDGET_QUANTITY
                 , :NEW.BLI_BUDGET_PRICE
                 , :NEW.BLI_BUDGET_AMOUNT
                 , :NEW.BLI_REMAINING_QUANTITY
                 , :NEW.BLI_REMAINING_PRICE
                 , :NEW.BLI_REMAINING_AMOUNT
                 , :NEW.BLI_HANGING_SPENDING_QUANTITY
                 , :NEW.BLI_HANGING_SPENDING_AMOUNT
                 , :new.BLI_HANGING_SPENDING_AMOUNT_B
                 , :NEW.BLI_LAST_BUDGET_DATE
                 , v_date_remaining
                 , :NEW.BLI_LAST_ESTIMATION_QUANTITY
                 , :NEW.BLI_LAST_ESTIMATION_AMOUNT
                 , :NEW.BLI_DESCRIPTION
                 , :NEW.BLI_COMMENT
                 , 1
                 , sysdate
                 , pcs.PC_I_LIB_SESSION.getuserini
                 , :NEW.GAL_BUDGET_PERIOD_ID
                  );
    end if;
  end if;
end GAL_BLI_AIUD_JOURNAL;

ALTER TRIGGER "C_ITX"."GAL_BLI_AIUD_JOURNAL" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_GML_AIUD_GAL_TASK_GOOD"
   AFTER INSERT OR DELETE OR UPDATE OF GCO_GOOD_ID,GML_QUANTITY,
-- 18/12/07 CMI Ajout du cas de modification de la nomenclature
                                       PPS_NOMENCLATURE_ID
   ON gal_task_good for each row
DECLARE
BEGIN
  IF INSERTING OR UPDATING THEN
    UPDATE GAL_TASK SET TAS_TASK_MUST_BE_LAUNCH = '1'
    WHERE GAL_TASK_ID = :NEW.GAL_TASK_ID
    AND NVL(TAS_TASK_MUST_BE_LAUNCH,0) <> '1'
    AND '1' = (SELECT C_TCA_TASK_TYPE FROM GAL_TASK_CATEGORY TCA
                 WHERE TCA.GAL_TASK_CATEGORY_ID = (SELECT GAL_TASK_CATEGORY_ID FROM GAL_TASK WHERE GAL_TASK_ID = :NEW.GAL_TASK_ID));
  END IF;

  IF DELETING THEN
    UPDATE GAL_TASK SET TAS_TASK_MUST_BE_LAUNCH = '1'
    WHERE GAL_TASK_ID = :OLD.GAL_TASK_ID
    AND NVL(TAS_TASK_MUST_BE_LAUNCH,0) <> '1'
    AND '1' = (SELECT C_TCA_TASK_TYPE FROM GAL_TASK_CATEGORY TCA
                 WHERE TCA.GAL_TASK_CATEGORY_ID = (SELECT GAL_TASK_CATEGORY_ID FROM GAL_TASK WHERE GAL_TASK_ID = :OLD.GAL_TASK_ID));
  END IF;

end GAL_GML_AIUD_GAL_TASK_GOOD;

ALTER TRIGGER "C_ITX"."GAL_GML_AIUD_GAL_TASK_GOOD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_GML_AIU_SUPPLY_MODE"
BEFORE UPDATE OF C_PROJECT_SUPPLY_MODE
ON GAL_PROJECT_SUPPLY_MODE
declare
BEGIN
   gal_gml_au_supply_mode.gml_index := 0;
   gal_gml_au_supply_mode.table_rowid_supply.DELETE;
end GAL_GML_AIU_SUPPLY_MODE;

ALTER TRIGGER "C_ITX"."GAL_GML_AIU_SUPPLY_MODE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_GML_AU_ROW_SUPPLY_MODE"
AFTER UPDATE OF C_PROJECT_SUPPLY_MODE
ON GAL_PROJECT_SUPPLY_MODE
FOR EACH ROW
declare
BEGIN
  if :NEW.C_PROJECT_SUPPLY_MODE <> :OLD.C_PROJECT_SUPPLY_MODE
  then
    gal_gml_au_supply_mode.gml_index := gal_gml_au_supply_mode.gml_index + 1;
    gal_gml_au_supply_mode.table_rowid_supply(gal_gml_au_supply_mode.gml_index).new_c_project_supply_mode := :NEW.C_PROJECT_SUPPLY_MODE;
    gal_gml_au_supply_mode.table_rowid_supply(gal_gml_au_supply_mode.gml_index).new_gal_father_task_id    := :NEW.gal_father_task_id;
    gal_gml_au_supply_mode.table_rowid_supply(gal_gml_au_supply_mode.gml_index).new_gco_good_id           := :NEW.gco_good_id;
    gal_gml_au_supply_mode.table_rowid_supply(gal_gml_au_supply_mode.gml_index).new_gsm_id                := :NEW.gal_project_supply_mode_id;
    gal_gml_au_supply_mode.table_rowid_supply(gal_gml_au_supply_mode.gml_index).new_path                  := :NEW.gsm_nom_path;

    --UPDATE GAL_TASK_GOOD
    --SET C_PROJECT_SUPPLY_MODE = :NEW.C_PROJECT_SUPPLY_MODE
    --WHERE GAL_TASK_ID in (SELECT GAL_TASK_ID FROM GAL_TASK WHERE GAL_FATHER_TASK_ID = :NEW.gal_father_task_id)
    --AND GCO_GOOD_ID = :NEW.gco_good_id;

  END IF;
end GAL_GML_AU_ROW_SUPPLY_MODE;

ALTER TRIGGER "C_ITX"."GAL_GML_AU_ROW_SUPPLY_MODE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_GML_AU_SUPPLY_MODE"
  after update of C_PROJECT_SUPPLY_MODE
  on GAL_PROJECT_SUPPLY_MODE
declare
  j            number;
  v_test_exist varchar2(10);
begin
  j                                 := gal_gml_au_supply_mode.gml_index;

  for i in 1 .. gal_gml_au_supply_mode.gml_index loop
    begin
      select gal_gml_au_supply_mode.table_rowid_supply(i).NEW_C_PROJECT_SUPPLY_MODE
        into v_test_exist
        from dual;

      update GAL_TASK_GOOD
         set C_PROJECT_SUPPLY_MODE = gal_gml_au_supply_mode.table_rowid_supply(i).NEW_C_PROJECT_SUPPLY_MODE
       where GAL_TASK_ID in(select GAL_TASK_ID
                              from GAL_TASK
                             where GAL_FATHER_TASK_ID = gal_gml_au_supply_mode.table_rowid_supply(i).NEW_gal_father_task_id)
         and GCO_GOOD_ID = gal_gml_au_supply_mode.table_rowid_supply(i).NEW_gco_good_id;
    exception
      when no_data_found then
        null;
    end;

    begin
      select gal_gml_au_supply_mode.table_rowid_supply(i).NEW_C_PROJECT_SUPPLY_MODE
        into v_test_exist
        from dual;

      update GAL_PROJECT_SUPPLY_MODE
         set A_DATEMOD = sysdate
           , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
       where GAL_PROJECT_SUPPLY_MODE_ID = gal_gml_au_supply_mode.table_rowid_supply(i).new_gsm_id;
    exception
      when no_data_found then
        null;
    end;
  end loop;

  for k in 1 .. j loop
    begin
      select gal_gml_au_supply_mode.table_rowid_supply(k).NEW_C_PROJECT_SUPPLY_MODE
        into v_test_exist
        from dual;

      --Mise a jour du mode d'appro pour les memes articles sur un meme niveau de nomenclature
      update GAL_PROJECT_SUPPLY_MODE
         set   --A_DATEMOD = SYSDATE,
            --A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni,
            C_PROJECT_SUPPLY_MODE = gal_gml_au_supply_mode.table_rowid_supply(k).NEW_C_PROJECT_SUPPLY_MODE
       where GAL_PROJECT_SUPPLY_MODE_ID <> gal_gml_au_supply_mode.table_rowid_supply(k).new_gsm_id
         and C_PROJECT_SUPPLY_MODE <> gal_gml_au_supply_mode.table_rowid_supply(k).new_C_PROJECT_SUPPLY_MODE
         and GAL_FATHER_TASK_ID = gal_gml_au_supply_mode.table_rowid_supply(k).new_gal_father_task_id
         and gal_project_calculation.GetPathNoSeq(GSM_NOM_PATH) = gal_project_calculation.GetPathNoSeq(gal_gml_au_supply_mode.table_rowid_supply(k).new_path)
         and GCO_GOOD_ID = gal_gml_au_supply_mode.table_rowid_supply(k).new_gco_good_id;
    exception
      when no_data_found then
        null;
    end;
  end loop;

  gal_gml_au_supply_mode.gml_index  := 0;
end GAL_GML_AU_SUPPLY_MODE;

ALTER TRIGGER "C_ITX"."GAL_GML_AU_SUPPLY_MODE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_GSM_AU_GAL_TASK_GOOD"
AFTER UPDATE OF C_PROJECT_SUPPLY_MODE
ON GAL_TASK_GOOD
declare
BEGIN

   FOR i IN 1 .. GAL_GSM_AU_GAL_TASK_GOOD.gsm_index
   LOOP
     BEGIN
	  UPDATE GAL_PROJECT_SUPPLY_MODE
      SET C_PROJECT_SUPPLY_MODE = GAL_GSM_AU_GAL_TASK_GOOD.table_rowid_gsm(i).NEW_C_PROJECT_SUPPLY_MODE
      WHERE GAL_FATHER_TASK_ID IN (SELECT GAL_FATHER_TASK_ID
                                   FROM GAL_TASK
                                   WHERE GAL_TASK_ID = GAL_GSM_AU_GAL_TASK_GOOD.table_rowid_gsm(i).NEW_gal_task_id)
      AND GCO_GOOD_ID = GAL_GSM_AU_GAL_TASK_GOOD.table_rowid_gsm(i).NEW_gco_good_id
      AND EXISTS (SELECT '*' FROM GAL_TASK_GOOD GTG
                  WHERE (GTG.PPS_NOMENCLATURE_ID = GAL_PROJECT_SUPPLY_MODE.PPS_NOMENCLATURE_HEADER_ID
		  		      OR GTG.GCO_GOOD_ID = GAL_PROJECT_SUPPLY_MODE.PPS_NOMENCLATURE_HEADER_ID)
                  AND GTG.GAL_TASK_GOOD_ID = GAL_PROJECT_SUPPLY_MODE.GAL_TASK_GOOD_ID AND ROWNUM = 1);
	 EXCEPTION WHEN NO_DATA_FOUND THEN NULL; END;
   END LOOP;

   gal_gml_au_supply_mode.gml_index := 0;

end GAL_GSM_AU_GAL_TASK_GOOD;

ALTER TRIGGER "C_ITX"."GAL_GSM_AU_GAL_TASK_GOOD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_GSM_AU_ROW_GAL_TASK_GOOD"
AFTER UPDATE OF C_PROJECT_SUPPLY_MODE
ON GAL_TASK_GOOD
FOR EACH ROW
declare
BEGIN
  if :NEW.C_PROJECT_SUPPLY_MODE <> :OLD.C_PROJECT_SUPPLY_MODE
  then
    GAL_GSM_AU_GAL_TASK_GOOD.gsm_index := GAL_GSM_AU_GAL_TASK_GOOD.gsm_index + 1;
    GAL_GSM_AU_GAL_TASK_GOOD.table_rowid_gsm(GAL_GSM_AU_GAL_TASK_GOOD.gsm_index).new_c_project_supply_mode := :NEW.C_PROJECT_SUPPLY_MODE;
    GAL_GSM_AU_GAL_TASK_GOOD.table_rowid_gsm(GAL_GSM_AU_GAL_TASK_GOOD.gsm_index).new_gal_task_id    := :NEW.gal_task_id;
    GAL_GSM_AU_GAL_TASK_GOOD.table_rowid_gsm(GAL_GSM_AU_GAL_TASK_GOOD.gsm_index).new_gco_good_id    := :NEW.gco_good_id;

  END IF;
end GAL_GSM_AU_ROW_GAL_TASK_GOOD;

ALTER TRIGGER "C_ITX"."GAL_GSM_AU_ROW_GAL_TASK_GOOD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_GSM_BU_GAL_TASK_GOOD"
BEFORE UPDATE OF C_PROJECT_SUPPLY_MODE
ON GAL_TASK_GOOD
declare
BEGIN
   GAL_GSM_AU_GAL_TASK_GOOD.gsm_index := 0;
   GAL_GSM_AU_GAL_TASK_GOOD.table_rowid_gsm.DELETE;
end GAL_GSM_BU_GAL_TASK_GOOD;

ALTER TRIGGER "C_ITX"."GAL_GSM_BU_GAL_TASK_GOOD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_GTL_AIU_DOC_RECORD"
   AFTER INSERT OR UPDATE OF scs_step_number,
                              c_task_type,
                              c_tal_state,
                              scs_long_descr
   ON gal_task_link
DECLARE

BEGIN

   FOR i IN 1 .. gal_gtl_aiu_doc_record.gtl_index
   LOOP

      UPDATE   GAL_TASK_LINK
               SET   DOC_RECORD_ID = (SELECT
                                      DOC_RECORD_ID FROM DOC_RECORD
                                      WHERE GAL_TASK_LINK_ID = gal_gtl_aiu_doc_record.table_rowid_task_link(i).new_gal_task_link_id
                                     )
               WHERE GAL_TASK_LINK_ID = gal_gtl_aiu_doc_record.table_rowid_task_link(i).new_gal_task_link_id;

   END LOOP;
   gal_gtl_aiu_doc_record.gtl_index := 0;
end gal_gtl_aiu_doc_record;

ALTER TRIGGER "C_ITX"."GAL_GTL_AIU_DOC_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_GTL_AIU_ROW_DOC_RECORD"
   AFTER INSERT OR UPDATE OF c_tal_state,
                             scs_step_number,
                             scs_long_descr,
                             c_task_type
   ON gal_task_link
   REFERENCING NEW AS NEW OLD AS OLD
   FOR EACH ROW
DECLARE
   v_short1        doc_record.rco_alpha_short1%TYPE;
   v_project_id    gal_project.gal_project_id%TYPE;
   v_rco_title     doc_record.rco_title%TYPE;
   v_customer_id   gal_project.pac_custom_partner_id%TYPE;
   v_rco_status    doc_record.c_rco_status%TYPE;
   v_rco_long1     doc_record.rco_alpha_long1%TYPE;
   v_rco_long2     doc_record.rco_alpha_long2%TYPE;
   v_task_type     gal_task_category.c_tca_task_type%TYPE;
   v_prj_state     gal_project.c_prj_state%TYPE;
   v_BudCat_Id     gal_budget.gal_budget_category_id%type;
   v_type_tas      CHAR (1);
   v_gal_father_task_id gal_budget.gal_budget_category_id%type;
BEGIN
   BEGIN
      SELECT prj_code, gal_project.gal_project_id,
             CASE
                WHEN LENGTH (   TRIM (prj_code)
                             || ':::'
                             || TRIM (tas_code)
                             || ':::'
                             || TRIM (TO_CHAR (:NEW.scs_step_number))
                            ) <= 30
                   THEN    TRIM (prj_code)
                        || ':::'
                        || TRIM (tas_code)
                        || ':::'
                        || TRIM (TO_CHAR (:NEW.scs_step_number))
                ELSE TRIM (RPAD (   TRIM (prj_code)
                                 || ':::'
                                 || TRIM (tas_code)
                                 || ':::'
                                 || TRIM (TO_CHAR (:NEW.scs_step_number)),
                                 30
                                )
                          )
             END,
             pac_custom_partner_id,
             decode(c_prj_state,'10','2',decode(c_bdg_state,'40','1','0')),
             tas_wording || CHR (10) || SUBSTR (tas_description, 1, 3930),
                TO_CHAR (:NEW.scs_step_number)
             || CHR (10)
             || SUBSTR (:NEW.scs_long_descr, 1, 3980),
             gal_task_category.c_tca_task_type, gal_project.c_prj_state,
             DECODE (gal_task_category.c_tca_task_type, '1', '2', '3'),
			 gal_budget.gal_budget_category_id,
			 gal_task.gal_father_task_id
        INTO v_short1, v_project_id,
             v_rco_title,
             v_customer_id,
             v_rco_status,
             v_rco_long1,
             v_rco_long2,
             v_task_type, v_prj_state,
             v_type_tas,
			 v_BudCat_Id,
			 v_gal_father_task_id
        FROM gal_task_category, gal_task, gal_budget, gal_project
       WHERE gal_budget.gal_budget_id = gal_task.gal_budget_id
	     AND gal_task_category.gal_task_category_id = gal_task.gal_task_category_id
         AND gal_project.gal_project_id = gal_task.gal_project_id
         AND gal_task.gal_task_id = :NEW.gal_task_id;

      IF v_task_type = '1'
      THEN
         gal_gtl_aiu_doc_record.gtl_index := gal_gtl_aiu_doc_record.gtl_index + 1;
         gal_gtl_aiu_doc_record.table_rowid_task_link(gal_gtl_aiu_doc_record.gtl_index).new_gal_task_link_id := :NEW.gal_task_link_id;
         gal_gtl_aiu_doc_record.table_rowid_task_link(gal_gtl_aiu_doc_record.gtl_index).new_gal_task_id := :NEW.gal_task_id;

		 /*Suppression de tous les liens Dossier pour ope externe (recreer ensuite) */
		 DELETE FROM DOC_RECORD_LINK WHERE DOC_RECORD_FATHER_ID = :NEW.DOC_RECORD_ID OR DOC_RECORD_SON_ID = :NEW.DOC_RECORD_ID;

         IF :NEW.c_task_type = '2'
         THEN

		    IF v_gal_father_task_id IS NOT NULL
		    THEN
		      select bud.gal_budget_category_id into v_BudCat_Id from gal_budget bud,gal_task tas
              where bud.gal_budget_id = tas.gal_budget_id and tas.gal_task_id = v_gal_father_task_id;
		    END IF;

            doc_record_functions.updaterecordproject (v_project_id,
                                                      NULL,
                                                      NULL,
                                                      :NEW.gal_task_link_id,
                                                      v_customer_id,
                                                      v_type_tas,
                                                      v_rco_status,
                                                      v_rco_title,
                                                      :NEW.scs_short_descr,
                                                      v_short1,
                                                      :NEW.scs_step_number,
                                                      v_rco_long1,
                                                      v_rco_long2,
													  v_BudCat_Id
                                                     );

         END IF;

         IF :OLD.c_task_type = '2' AND :NEW.c_task_type = '1'
         THEN
            doc_record_functions.deleterecordproject (NULL,
                                                      NULL,
                                                      NULL,
                                                      :NEW.gal_task_link_id
                                                     );
         END IF;
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         NULL;
   END;
end gal_gtl_aiu_row_doc_record;

ALTER TRIGGER "C_ITX"."GAL_GTL_AIU_ROW_DOC_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_GTL_BD_DOC_RECORD"
  BEFORE DELETE
  ON GAL_TASK_LINK
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
/**
* DESCRIPTION
*    SUPPRESSION DU LIEN ENTRE LE DOSSIER AFFAIRE ET LES DOSSIERS DE TYPE TâCHE D'APPROVISIONNEMENT, TâCHE DE
*    MAIN D'OEUVRE ET CODE BUDGET.
*
* @AUTHOR VJ
* @CREATED 17.05.2005
* @VERSION 2003
*/
begin
  -- Suppression du dossier tâche
  DOC_RECORD_FUNCTIONS.DeleteRecordProject(null, null, null,:old.GAL_TASK_LINK_ID);
end GAL_GTL_BD_DOC_RECORD;

ALTER TRIGGER "C_ITX"."GAL_GTL_BD_DOC_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_GTL_BIU_DOC_RECORD"
   BEFORE INSERT OR UPDATE OF scs_step_number,
                              c_task_type,
                              c_tal_state,
                              scs_long_descr
   ON gal_task_link
DECLARE
BEGIN
   gal_gtl_aiu_doc_record.gtl_index := 0;
   gal_gtl_aiu_doc_record.table_rowid_task_link.DELETE;
end gal_gtl_biu_doc_record;

ALTER TRIGGER "C_ITX"."GAL_GTL_BIU_DOC_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_HOU_AIUD_GAL_TASK_LINK"
  after insert or delete or update of GAL_TASK_ID, GAL_TASK_LINK_ID, HOU_WORKED_TIME, HOU_POINTING_DATE
  on GAL_HOURS
  for each row
/**
* Description
*    Mise à jour des tables GAL_TASK_LINK (opérations de tâches)
*    et GAL_TASK (tâches) suite à saisie des heures
* @author Christian Minjollet
* Màj 21/03/07 CMI Débuggage du cas IF UPDATING --> màj du :OLD.gal_task_link ET DU :NEW.gal_task_link !!!
* Màj 19/05/08 CMI Débuggage du cas IF UPDATING (produit chez REEL)
*                  --> si la date de pointage est modifiée mais pas le nb d'heures passées,
*                  --> alors la charge restante était remise à 0 !!!!!!!!!!!!!!!!!!
*                  Exemple:
*                  --> Situation initiale
*                      Prévu=10, Consommé=0, Restant=0
*                  --> Saisie de 8h passées
*                      Prévu=10, Consommé=8, Restant=2 --> Cas du INSERTING = OK
*                  --> Modification de la date de pointage (soit manuellement, soit via le passage des heures en compta)
*                      Prévu=10, Consommé=8, Restant=0 !!! --> Cas du UPDATING = KO (2 - 8 étant négatif, on force à 0 !!!)
*                  CORRECTION PAR UNE SIMPLE INVERSION DES 2 BOUCLES DELETING et INSERTING
*                  (on fait du PLUS avant de faire du MOINS, le MOINS étant borné à ZERO...)
*                  Reste un cas métier non traité, volontairement écarté pour l'instant...
*                  La suppression ne passe jamais la charge
* Fin Màj 19/05/08 CMI Débuggage du cas IF UPDATING (produit chez REEL)
*/
begin
  if    deleting
     or updating then
    -- Heure sur opération
    -- Il n'est pas prévu de "marche arrière" sur le code état et la date de début réel
    -- Cela serait possible par une relecture des heures, mais on obtient un message MUTATING...
    if :old.GAL_TASK_LINK_ID is not null then
      update GAL_TASK_LINK
         set TAL_ACHIEVED_TSK = TAL_ACHIEVED_TSK - :old.HOU_WORKED_TIME
           , TAL_TSK_BALANCE =
               decode(C_TAL_STATE
                    , '40', TAL_TSK_BALANCE
                    ,
                      -- Ce DECODE ne remet jamais de charge restante dès que celle-ci est passée par ZERO
                      decode(TAL_TSK_BALANCE, 0, 0, TAL_TSK_BALANCE + :old.HOU_WORKED_TIME)
                     )
       where GAL_TASK_LINK_ID = :old.GAL_TASK_LINK_ID;
    end if;
  -- Heure sur tâche
  -- Il n'est pas prévu de "marche arrière" sur le code état et la date de début réel
  -- Cela serait possible par une relecture des heures, mais on obtient un message MUTATING...
  end if;

  if    inserting
     or updating then
    -- Heure sur opération
    if :new.GAL_TASK_LINK_ID is not null then
      update GAL_TASK_LINK
         set TAL_ACHIEVED_TSK = nvl(TAL_ACHIEVED_TSK, 0) + :new.HOU_WORKED_TIME
           , TAL_TSK_BALANCE =
               decode(C_TAL_STATE
                    , '40', TAL_TSK_BALANCE
                    , decode(sign(nvl(TAL_TSK_BALANCE, 0) - :new.HOU_WORKED_TIME)
                           , -1, 0
                           , (nvl(TAL_TSK_BALANCE, 0) - :new.HOU_WORKED_TIME)
                            )
                     )
           , C_TAL_STATE = greatest(C_TAL_STATE, '30')
           , TAL_BEGIN_REAL_DATE =
               decode(TAL_BEGIN_REAL_DATE
                    , null, :new.HOU_POINTING_DATE
                    , least(TAL_BEGIN_REAL_DATE, :new.HOU_POINTING_DATE)
                     )
       where GAL_TASK_LINK_ID = :new.GAL_TASK_LINK_ID;
    end if;

    -- Heure sur opération ou sur tâche
    if    :new.GAL_TASK_LINK_ID is not null
       or :new.GAL_TASK_ID is not null then
      update GAL_TASK
         set C_TAS_STATE = greatest(C_TAS_STATE, '30')
           , TAS_ACTUAL_START_DATE =
               decode(TAS_ACTUAL_START_DATE
                    , null, :new.HOU_POINTING_DATE
                    , least(TAS_ACTUAL_START_DATE, :new.HOU_POINTING_DATE)
                     )
       where GAL_TASK_ID = :new.GAL_TASK_ID;
    end if;
  end if;
end GAL_HOU_AIUD_GAL_TASK_LINK;

ALTER TRIGGER "C_ITX"."GAL_HOU_AIUD_GAL_TASK_LINK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_HOU_AIUD_JOURNAL"
  after insert or delete or update of "HRM_PERSON_ID"
                                    , "GAL_PROJECT_ID"
                                    , "GAL_TASK_ID"
                                    , "GAL_TASK_LINK_ID"
                                    , "GAL_COST_CENTER_ID"
                                    , "GAL_BUDGET_ID"
                                    , "HOU_POINTING_DATE"
                                    , "HOU_WORKED_TIME"
  on GAL_HOURS
  referencing old as old new as new
  for each row
/**
* Description
*    Journalisation de la table
* @created fp 22.03.2007
* @version 2003
*/
declare
  vBudgetId GAL_BUDGET.GAL_BUDGET_ID%type;
begin
  if PCS.PC_CONFIG.GetBooleanConfig('GAL_SNAPSHOT_ON') then
    -- Création d'un ligne de suppression
    if     (   deleting
            or updating)
       and :old.GAL_PROJECT_ID is not null then
      -- recherche du budget de la tache
      if :old.GAL_BUDGET_ID is not null then
        vBudgetId  := :old.GAL_BUDGET_ID;
      elsif :old.GAL_TASK_ID is not null then
        select GAL_BUDGET_ID
          into vBudgetId
          from GAL_TASK
         where GAL_TASK_ID = :old.GAL_TASK_ID;
      else
        select TSK.GAL_BUDGET_ID
          into vBudgetId
          from GAL_TASK_LINK TSL
             , GAL_TASK TSK
         where TSL.GAL_TASK_LINK_ID = :old.GAL_TASK_LINK_ID
           and TSK.GAL_TASK_ID = TSL.GAL_TASK_ID;
      end if;

      insert into GAL_HOURS_JOURNAL
                  (GAL_HOURS_JOURNAL_ID
                 , GAL_HOURS_ID
                 , HRM_PERSON_ID
                 , GAL_PROJECT_ID
                 , GAL_TASK_ID
                 , GAL_TASK_LINK_ID
                 , GAL_COST_CENTER_ID
                 , GAL_BUDGET_ID
                 , GAL_TASK_BUDGET_ID
                 , HOU_POINTING_DATE
                 , HOU_WORKED_TIME
                 , HOU_HOURLY_RATE
                 , HOU_HOURLY_RATE_ECO
                 , HOJ_NEW_VALUE
                 , A_DATECRE
                 , A_IDCRE
                  )
           values (INIT_ID_SEQ.nextval
                 , :old.GAL_HOURS_ID
                 , :old.HRM_PERSON_ID
                 , :old.GAL_PROJECT_ID
                 , :old.GAL_TASK_ID
                 , :old.GAL_TASK_LINK_ID
                 , :old.GAL_COST_CENTER_ID
                 , :old.GAL_BUDGET_ID
                 , vBudgetId
                 , :old.HOU_POINTING_DATE
                 , -:old.HOU_WORKED_TIME
                 , :old.HOU_HOURLY_RATE
                 , :old.HOU_HOURLY_RATE_ECO
                 , -1
                 , sysdate
                 , PCS.PC_I_LIB_SESSION.GetUserIni
                  );
    end if;

    -- Création d'un ligne d'ajout
    if     (   updating
            or inserting)
       and :new.GAL_PROJECT_ID is not null then
      -- recherche du budget de la tache
      if :new.GAL_BUDGET_ID is not null then
        vBudgetId  := :new.GAL_BUDGET_ID;
      elsif :new.GAL_TASK_ID is not null then
        select GAL_BUDGET_ID
          into vBudgetId
          from GAL_TASK
         where GAL_TASK_ID = :new.GAL_TASK_ID;
      else
        select TSK.GAL_BUDGET_ID
          into vBudgetId
          from GAL_TASK_LINK TSL
             , GAL_TASK TSK
         where TSL.GAL_TASK_LINK_ID = :new.GAL_TASK_LINK_ID
           and TSK.GAL_TASK_ID = TSL.GAL_TASK_ID;
      end if;

      insert into GAL_HOURS_JOURNAL
                  (GAL_HOURS_JOURNAL_ID
                 , GAL_HOURS_ID
                 , HRM_PERSON_ID
                 , GAL_PROJECT_ID
                 , GAL_TASK_ID
                 , GAL_TASK_LINK_ID
                 , GAL_COST_CENTER_ID
                 , GAL_BUDGET_ID
                 , GAL_TASK_BUDGET_ID
                 , HOU_POINTING_DATE
                 , HOU_WORKED_TIME
                 , HOU_HOURLY_RATE
                 , HOU_HOURLY_RATE_ECO
                 , HOJ_NEW_VALUE
                 , A_DATECRE
                 , A_IDCRE
                  )
           values (INIT_ID_SEQ.nextval
                 , :new.GAL_HOURS_ID
                 , :new.HRM_PERSON_ID
                 , :new.GAL_PROJECT_ID
                 , :new.GAL_TASK_ID
                 , :new.GAL_TASK_LINK_ID
                 , :new.GAL_COST_CENTER_ID
                 , :new.GAL_BUDGET_ID
                 , vBudgetId
                 , :new.HOU_POINTING_DATE
                 , :new.HOU_WORKED_TIME
                 , :new.HOU_HOURLY_RATE
                 , :new.HOU_HOURLY_RATE_ECO
                 , 1
                 , sysdate
                 , PCS.PC_I_LIB_SESSION.GetUserIni
                  );
    end if;
  end if;
end GAL_HOU_AIUD_JOURNAL;

ALTER TRIGGER "C_ITX"."GAL_HOU_AIUD_JOURNAL" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_LOT_AU_GAL_TASK_LOT_LINK"
  AFTER UPDATE OF GTL_QUANTITY
  ON GAL_TASK_LOT
  FOR EACH ROW
  /*
  * Description
  *    Mise à jour de la matrice opération en cas d'update de quantité (la différence est porté sur la 1er opé)
  */
begin
  --La quantité augmente
  if :NEW.GTL_QUANTITY > :OLD.GTL_QUANTITY
  then
    --Maj Qty
    UPDATE GAL_TASK_LOT_LINK SET GLL_QUANTITY = GLL_QUANTITY + (:NEW.GTL_QUANTITY - :OLD.GTL_QUANTITY)
	WHERE GAL_TASK_ID = :NEW.GAL_TASK_ID
	AND GAL_TASK_LOT_ID = :NEW.GAL_TASK_LOT_ID
	AND GAL_TASK_LINK_ID = (SELECT B.GAL_TASK_LINK_ID FROM GAL_TASK_LINK A,GAL_TASK_LOT_LINK B
      WHERE A.GAL_TASK_LINK_ID = B.GAL_TASK_LINK_ID AND B.GAL_TASK_ID = :NEW.GAL_TASK_ID AND B.GAL_TASK_LOT_ID = :NEW.GAL_TASK_LOT_ID
      AND A.SCS_STEP_NUMBER = (SELECT MIN(D.SCS_STEP_NUMBER) FROM GAL_TASK_LINK D,GAL_TASK_LOT_LINK C
        WHERE D.GAL_TASK_LINK_ID = C.GAL_TASK_LINK_ID AND C.GAL_TASK_ID = :NEW.GAL_TASK_ID AND C.GAL_TASK_LOT_ID = :NEW.GAL_TASK_LOT_ID  ) );
    --Désolde des opérations
	UPDATE GAL_TASK_LOT_LINK SET GLL_BALANCE_FLAG = 0 WHERE GAL_TASK_ID = :NEW.GAL_TASK_ID AND GAL_TASK_LOT_ID = :NEW.GAL_TASK_LOT_ID;

  end if;

  --La quantité diminue
  if :NEW.GTL_QUANTITY < :OLD.GTL_QUANTITY
  then
    --Maj Qty
    UPDATE GAL_TASK_LOT_LINK SET GLL_QUANTITY = DECODE(SIGN(GLL_QUANTITY + (:NEW.GTL_QUANTITY - :OLD.GTL_QUANTITY)),-1,0,GLL_QUANTITY + (:NEW.GTL_QUANTITY - :OLD.GTL_QUANTITY))
	WHERE GAL_TASK_ID = :NEW.GAL_TASK_ID
	AND GAL_TASK_LOT_ID = :NEW.GAL_TASK_LOT_ID
	AND GAL_TASK_LINK_ID = (SELECT B.GAL_TASK_LINK_ID FROM GAL_TASK_LINK A,GAL_TASK_LOT_LINK B
      WHERE A.GAL_TASK_LINK_ID = B.GAL_TASK_LINK_ID AND B.GAL_TASK_ID = :NEW.GAL_TASK_ID AND B.GAL_TASK_LOT_ID = :NEW.GAL_TASK_LOT_ID
      AND A.SCS_STEP_NUMBER = (SELECT MIN(D.SCS_STEP_NUMBER) FROM GAL_TASK_LINK D,GAL_TASK_LOT_LINK C
        WHERE D.GAL_TASK_LINK_ID = C.GAL_TASK_LINK_ID AND C.GAL_TASK_ID = :NEW.GAL_TASK_ID AND C.GAL_TASK_LOT_ID = :NEW.GAL_TASK_LOT_ID  ) );
	--AND GLL_QUANTITY + (:NEW.GTL_QUANTITY - :OLD.GTL_QUANTITY) >= 0;

  end if;

end GAL_LOT_AU_GAL_TASK_LOT_LINK;

ALTER TRIGGER "C_ITX"."GAL_LOT_AU_GAL_TASK_LOT_LINK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_PRJ_AD_GAL_PROJECT"
  after delete
  on GAL_PROJECT
  referencing old as old new as new
  for each row
/**************************************************************
***              Numérotation automatique affaire           ***
**************************************************************/
declare
  v_numbering_id  DOC_GAUGE.DOC_GAUGE_NUMBERING_ID%TYPE;
begin
  if deleting
  then
    --Update d'un numero libre (numerotation auto)
    select min(DOC_GAUGE_NUMBERING_ID)
    into   v_numbering_id
    from   DIC_GAL_PRJ_CATEGORY
    where  DIC_GAL_PRJ_CATEGORY_ID = :OLD.DIC_GAL_PRJ_CATEGORY_ID;

    if v_numbering_id is not null
    then
      -- Maj DOC_FREE_NUMBER CREA = 0
      update DOC_FREE_NUMBER
      set    DOF_CREATING = 0
      where  DOF_NUMBER = :old.PRJ_CODE;
    end if;

  end if;
end GAL_PRJ_AD_GAL_PROJECT;

ALTER TRIGGER "C_ITX"."GAL_PRJ_AD_GAL_PROJECT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_PRJ_AIU_DOC_RECORD"
   AFTER INSERT OR UPDATE OF c_prj_state,
                             pac_custom_partner_id,
                             prj_code,
                             prj_wording,
                             prj_description
   ON gal_project
DECLARE

BEGIN

   FOR i IN 1 .. gal_prj_aiu_doc_record.prj_index
   LOOP

      UPDATE gal_project
         SET doc_record_id =
                (SELECT doc_record_id
                   FROM doc_record
                  WHERE gal_project_id =
                           gal_prj_aiu_doc_record.table_rowid_project (i).new_gal_project_id)
       WHERE gal_project_id =
                gal_prj_aiu_doc_record.table_rowid_project(i).new_gal_project_id;

   END LOOP;

   gal_prj_aiu_doc_record.prj_index := 0;
end gal_prj_aiu_doc_record;

ALTER TRIGGER "C_ITX"."GAL_PRJ_AIU_DOC_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_PRJ_AIU_ROW_DOC_RECORD"
  after insert or update of C_PRJ_STATE, PRJ_CODE, PRJ_WORDING, PRJ_DESCRIPTION, PAC_CUSTOM_PARTNER_ID, GAL_PROJECT_ID
  on GAL_PROJECT
  referencing new as new old as old
  for each row
declare
  v_prj_state        gal_project.c_prj_state%type;
  v_gal_task_id      gal_task.gal_task_id%type;
  v_gal_budget_id    gal_task.gal_task_id%type;
  v_rco_title        doc_record.rco_title%type;
  v_tas_wording      gal_task.tas_wording%type;
  v_tas_code         gal_task.tas_code%type;
  v_rco_long2        doc_record.rco_alpha_long1%type;
  v_type_tas         char(1);
  v_c_tas_STATE      gal_task.c_tas_state%type;
  v_bdg_wording      gal_budget.bdg_wording%type;
  v_bdg_code         gal_budget.bdg_code%type;
  v_c_bdg_STATE      gal_budget.c_bdg_state%type;
  v_rco_status       doc_record.c_rco_status%type;
  v_BudCat_Id        gal_budget.gal_budget_category_id%type;
  v_scs_short_descr  gal_task_link.scs_short_descr%type;
  v_scs_step_number  gal_task_link.scs_step_number%type;
  v_rco_long1        doc_record.rco_alpha_long1%type;
  v_task_type        gal_task_category.c_tca_task_type%type;
  v_gal_task_link_id gal_task_link.gal_task_link_id%type;

  cursor c_task
  is
    select gal_task_id
         , case
             when length(trim(:new.prj_code) || ':' || trim(tas_code) ) <= 30 then trim(:new.prj_code) || ':' || trim(tas_code)
             else trim(rpad(trim(:new.prj_code) || ':' || trim(tas_code), 30) )
           end
         , tas_wording
         , tas_code
         , tas_wording || chr(10) || substr(tas_description, 1, 3930)
         , decode(c_tca_task_type, '1', '2', '3')
         , decode(:new.c_prj_state, '10', '2', decode(c_bdg_state, '40', '1', '0') )
         , gal_budget.gal_budget_category_id
      from gal_task_category
         , gal_task
         , gal_budget
     where gal_task.gal_budget_id = gal_budget.gal_budget_id
       and c_tca_task_type in('1', '2')
       and gal_task_category.gal_task_category_id = gal_task.gal_task_category_id
       and gal_task.gal_project_id = :new.gal_project_id;

  cursor c_budget
  is
    select gal_budget_id
         , case
             when length(trim(:new.prj_code) || '::' || trim(bdg_code) ) <= 30 then trim(:new.prj_code) || '::' || trim(bdg_code)
             else trim(rpad(trim(:new.prj_code) || '::' || trim(bdg_code), 30) )
           end
         , bdg_wording
         , bdg_code
         , bdg_wording || chr(10) || substr(bdg_description, 1, 3930)
         , '4'
         , decode(:new.c_prj_state, '10', '2', decode(c_bdg_state, '40', '1', '0') )
         , gal_budget_category_id
      from gal_budget
     where gal_budget.gal_project_id = :new.gal_project_id
       and not exists(select GAL_BUDGET_ID
                        from GAL_BUDGET child
                       where child.GAL_FATHER_BUDGET_ID = GAL_BUDGET.GAL_BUDGET_ID);

  cursor c_ope
  is
    select case
             when length(trim(:new.prj_code) || ':::' || trim(tas_code) || ':::' || trim(to_char(scs_step_number) ) ) <= 30 then trim(:new.prj_code) ||
                                                                                                                                 ':::' ||
                                                                                                                                 trim(tas_code) ||
                                                                                                                                 ':::' ||
                                                                                                                                 trim
                                                                                                                                   (to_char(scs_step_number) )
             else trim(rpad(trim(:new.prj_code) || ':::' || trim(tas_code) || ':::' || trim(to_char(scs_step_number) ), 30) )
           end
         , decode(:new.c_prj_state, '10', '2', decode(c_bdg_state, '40', '1', '0') )
         , tas_wording || chr(10) || substr(tas_description, 1, 3930)
         , to_char(scs_step_number) || chr(10) || substr(scs_long_descr, 1, 3980)
         , gal_task_category.c_tca_task_type
         , decode(gal_task_category.c_tca_task_type, '1', '2', '3')
         , gal_budget.gal_budget_category_id
         , scs_short_descr
         , scs_step_number
         , gal_task_link_id
      from gal_task_link
         , gal_task_category
         , gal_task
         , gal_budget
     where gal_budget.gal_budget_id = gal_task.gal_budget_id
       and gal_task_category.gal_task_category_id = gal_task.gal_task_category_id
       and gal_task_link.gal_task_id = gal_task.gal_task_id
       and gal_task_link.c_task_type = '2'   --externe
       and gal_task.gal_project_id = :new.gal_project_id;
begin
  /**************************************************************
    ***    Gestion numéro auto d'affaire                        ***
    ***************************************************************/
  if inserting then
    delete      DOC_FREE_NUMBER
          where DOF_NUMBER = :new.PRJ_CODE;
  end if;

  /**************************************************************
  ***    Gestion numero auto d'affaire                        ***
  ***************************************************************/
  -- On positionne le status du dossier en fonction du status de l'affaire
  select decode(:new.c_prj_state, '40', '1', '10', '2', '0')
    into v_prj_state
    from dual;

  -- On fait la mise à jour du dossier de l'affaire
  doc_record_functions.updaterecordproject(:new.gal_project_id
                                         , null
                                         , null
                                         , null
                                         , :new.pac_custom_partner_id
                                         , '1'
                                         , v_prj_state
                                         , :new.prj_code
                                         , :new.prj_wording
                                         , :new.prj_code
                                         , null   --Short2
                                         , :new.prj_description
                                         , null   --Long2
                                         , null
                                          );
  gal_prj_aiu_doc_record.prj_index                                                                 := gal_prj_aiu_doc_record.prj_index + 1;
  gal_prj_aiu_doc_record.table_rowid_project(gal_prj_aiu_doc_record.prj_index).new_gal_project_id  := :new.gal_project_id;

  -- On fait la mise à jour des dossiers tâches de l'affaire
  open c_task;

  loop
    fetch c_task
     into v_gal_task_id
        , v_rco_title
        , v_tas_wording
        , v_tas_code
        , v_rco_long2
        , v_type_tas
        , v_c_tas_state
        , v_BudCat_Id;

    exit when c_task%notfound;
    doc_record_functions.updaterecordproject(null   --gal_project_id
                                           , v_gal_task_id
                                           , null   --gal_budget_id
                                           , null
                                           , :new.pac_custom_partner_id
                                           , v_type_tas
                                           , v_c_tas_state
                                           , v_rco_title
                                           , v_tas_wording
                                           , :new.prj_code
                                           , v_tas_code
                                           , :new.prj_wording || chr(10) || substr(:new.prj_description, 1, 3930)
                                           , v_rco_long2
                                           , v_BudCat_Id
                                            );
  end loop;

  close c_task;

------------------------------------------------------------

  -- On fait la mise à jour des dossiers budget de l'affaire
  open c_budget;

  loop
    fetch c_budget
     into v_gal_budget_id
        , v_rco_title
        , v_bdg_wording
        , v_bdg_code
        , v_rco_long2
        , v_type_tas
        , v_c_bdg_state
        , v_BudCat_Id;

    exit when c_budget%notfound;
    doc_record_functions.updaterecordproject(null   --gal_project_id
                                           , null   --gal_task_id
                                           , v_gal_budget_id
                                           , null
                                           , :new.pac_custom_partner_id
                                           , v_type_tas
                                           , v_c_bdg_state
                                           , v_rco_title
                                           , v_bdg_wording
                                           , :new.prj_code
                                           , v_bdg_code
                                           , :new.prj_wording || chr(10) || substr(:new.prj_description, 1, 3930)
                                           , v_rco_long2
                                           , v_BudCat_Id
                                            );
  end loop;

  close c_budget;

------------------------------------------------------------

  -- On fait la mise à jour des dossiers ope externe de l'affaire
  open c_ope;

  loop
    fetch c_ope
     into v_rco_title
        , v_rco_status
        , v_rco_long1
        , v_rco_long2
        , v_task_type
        , v_type_tas
        , v_BudCat_Id
        , v_scs_short_descr
        , v_scs_step_number
        , v_gal_task_link_id;

    exit when c_ope%notfound;
    doc_record_functions.updaterecordproject(:new.gal_project_id
                                           , null
                                           , null
                                           , v_gal_task_link_id
                                           , :new.pac_custom_partner_id
                                           , v_type_tas
                                           , v_rco_status
                                           , v_rco_title
                                           , v_scs_short_descr
                                           , :new.prj_code
                                           , v_scs_step_number
                                           , v_rco_long1
                                           , v_rco_long2
                                           , v_BudCat_Id
                                            );
  end loop;

  close c_ope;
end GAL_PRJ_AIU_ROW_DOC_RECORD;

ALTER TRIGGER "C_ITX"."GAL_PRJ_AIU_ROW_DOC_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_PRJ_BD_DOC_RECORD"
  BEFORE DELETE
  ON GAL_PROJECT
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
declare
  v_numbering_id  DOC_GAUGE.DOC_GAUGE_NUMBERING_ID%TYPE;
  v_cpt number;
/**
* DESCRIPTION
*    SUPPRESSION DU LIEN ENTRE LE DOSSIER AFFAIRE ET LES DOSSIERS DE TYPE TâCHE D'APPROVISIONNEMENT, TâCHE DE
*    MAIN D'OEUVRE ET CODE BUDGET.
*
* @AUTHOR LS
* @CREATED 23.09.2005
* @VERSION 2003
*/
begin
  --Creation d'un numero libre (numerotation auto)
  select min(DOC_GAUGE_NUMBERING_ID)
  into   v_numbering_id
  from   DIC_GAL_PRJ_CATEGORY
  where  DIC_GAL_PRJ_CATEGORY_ID = :OLD.DIC_GAL_PRJ_CATEGORY_ID;

  if v_numbering_id is not null
  then
    -- Maj DOC_FREE_NUMBER CREA = 0
    update DOC_FREE_NUMBER
    set    DOF_CREATING = 0
    where  DOF_NUMBER = :old.PRJ_CODE;

	if sql%notfound then
      -- Création DOC_FREE_NUMBER
	  /* --> Trop limite comme controle !
	  begin
        select instr(:old.PRJ_CODE,GAN_PREFIX)
		into v_cpt
	    from   DOC_GAUGE_NUMBERING
	    where  DOC_GAUGE_NUMBERING_ID = v_numbering_id;

		if v_cpt <> 0
		then
      */
	      insert into DOC_FREE_NUMBER
                     (DOC_FREE_NUMBER_ID
                    , DOC_GAUGE_NUMBERING_ID
                    , DOF_NUMBER
                    , DOF_CREATING
                     )
              values (init_id_seq.nextval
                    , v_numbering_id
                    , :old.PRJ_CODE
                    , 0
                    );
      /*
	    end if;
	  exception when no_data_found then
	    null;
	  end;
	  */
    end if;
  end if;

  -- Suppression du dossier affaire
  DOC_RECORD_FUNCTIONS.DeleteRecordProject(:old.gal_project_id, null, null,null);
end GAL_PRJ_BD_DOC_RECORD;

ALTER TRIGGER "C_ITX"."GAL_PRJ_BD_DOC_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_PRJ_BIU_DOC_RECORD"
   BEFORE INSERT OR UPDATE OF c_prj_state,
                             pac_custom_partner_id,
                             prj_code,
                             prj_wording,
                             prj_description
   ON gal_project
DECLARE
BEGIN
  gal_prj_aiu_doc_record.prj_index := 0;
  gal_prj_aiu_doc_record.table_rowid_project.DELETE;
end gal_prj_biu_doc_record;

ALTER TRIGGER "C_ITX"."GAL_PRJ_BIU_DOC_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_PRJ_BIU_ROW_GAL_PROJECT"
  before insert or update
  of PRJ_CODE
  on GAL_PROJECT referencing old as old new as new
  for each row
declare
  v_numbering_id  DOC_GAUGE.DOC_GAUGE_NUMBERING_ID%TYPE;
  v_gan_prefix    DOC_GAUGE_NUMBERING.GAN_PREFIX%TYPE;
begin

/******************************************************************************/
/*                    Numerotation auto des affaires                          */
/******************************************************************************/

  if inserting then
    if trim(:new.PRJ_CODE) is null then
      -- Recherche de l'ID de la numérotation associée au gabarit + société

	  select nvl(min(DOC_GAUGE_NUMBERING_ID),0)
	  into   v_numbering_id
	  from   DIC_GAL_PRJ_CATEGORY
	  where  DIC_GAL_PRJ_CATEGORY_ID = :new.DIC_GAL_PRJ_CATEGORY_ID;

	  if v_numbering_id <> 0
	  then
	    -- Numéro document = Numéro obtenu avec le numéroteur associé au gabarit + société
	    DOC_DOCUMENT_FUNCTIONS.GetDocumentNumber(
		                       null            --DOC_GAUGE.DOC_GAUGE_ID
		    				  ,v_numbering_id  --DOC_GAUGE.DOC_GAUGE_NUMBERING_ID
			  			      ,:new.PRJ_CODE   --PrjCode
						      );
        :new.PRJ_CODE := UPPER(:new.PRJ_CODE);
		if trim(:new.PRJ_WORDING) is null then :new.PRJ_WORDING := :new.PRJ_CODE; end if;
	  end if;
	else
	  --Depuis delphi, on initialise avec GAN_PREFIX + '******'
      select nvl(min(GAN_PREFIX),' '),nvl(min(DOC_GAUGE_NUMBERING_ID),0)
	  into   v_gan_prefix,v_numbering_id
	  from   DOC_GAUGE_NUMBERING
	  where  DOC_GAUGE_NUMBERING_ID
	         = (SELECT nvl(min(DOC_GAUGE_NUMBERING_ID),0) from DIC_GAL_PRJ_CATEGORY where DIC_GAL_PRJ_CATEGORY_ID = :new.DIC_GAL_PRJ_CATEGORY_ID);

	  if trim(v_gan_prefix) ||'******' = :new.PRJ_CODE and v_numbering_id <> 0
	  then
        -- Numéro document = Numéro obtenu avec le numéroteur associé au gabarit + société
	    DOC_DOCUMENT_FUNCTIONS.GetDocumentNumber(
		                       null            --DOC_GAUGE.DOC_GAUGE_ID
		    				  ,v_numbering_id  --DOC_GAUGE.DOC_GAUGE_NUMBERING_ID
			  			      ,:new.PRJ_CODE   --PrjCode
						      );
        :new.PRJ_CODE := UPPER(:new.PRJ_CODE);
		if trim(v_gan_prefix) ||'******' = :new.PRJ_WORDING then :new.PRJ_WORDING := :new.PRJ_CODE; end if;
	  end if;
	end if;
  end if;

  if updating and :old.PRJ_CODE <> :new.PRJ_CODE then --Upshift PRJ_CODE
    :new.PRJ_CODE := UPPER(:new.PRJ_CODE);
  end if;

end GAL_PRJ_BIU_ROW_GAL_PROJECT;

ALTER TRIGGER "C_ITX"."GAL_PRJ_BIU_ROW_GAL_PROJECT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_TAL_AIUD_JOURNAL"
  after insert or delete or update of "C_TAL_STATE", "FAL_FACTORY_FLOOR_ID", "FAL_FAL_FACTORY_FLOOR_ID", "TAL_TSK_BALANCE", "TAL_DUE_TSK"
  --     , "TAL_ACHIEVED_TSK"
on gal_task_link
  referencing old as old new as new
  for each row
declare
  v_is_from_gal_hours boolean;
-- peret de savoir si l'entrée provient d'une modiofication d'une saisie d'heures ou d'une modification d'une info de l'OP
  v_date_imputation   date;
/**
* Description
*    Journalisation de la table
* @created fp 22.03.2007
* @version 2003
* màj: hmo: 12.04.07 on déclenche le trigger sur TAL_DUE_TSK" et  TAL_ACHIEVED_TSK" afin d'avoir un historique de la planification hors date, n doit donc enlenver aussi le test sur tal_tsk_balance
*/
begin
  if pcs.pc_config.getbooleanconfig('GAL_SNAPSHOT_ON') then
    -- Création d'un ligne de suppression
    v_is_from_gal_hours  :=     (nvl(:new.tal_achieved_tsk, 0) <> nvl(:old.tal_achieved_tsk, 0) )
                            and nvl(:new.TAL_TSK_BALANCE, 0) > 0;

-- on ne met à jour que les infos de changement de d'info sur les opérations -> calcul du reste à réaliser = reste à engager
    if not v_is_from_gal_hours then
      if    (    :old.c_tal_state = '10'
             and :new.c_tal_state > '10')
         or (    nvl(:old.c_tal_state, 0) = 0
             and :new.c_tal_state > '10') then
        select tsk.tas_launching_date
          into v_date_imputation
          from gal_task tsk
         where tsk.gal_task_id = :new.gal_task_id;
      elsif :new.c_tal_state = '40' then
        v_date_imputation  := :new.tal_balance_date;
      else
        v_date_imputation  := sysdate;
      end if;

      if     (   deleting
              or updating)
         and ( (   :old.c_tal_state between '20' and '39'
                or :old.c_tal_state = '99') ) then
        --and (:old.TAL_TSK_BALANCE > 0) ) then hmo 12.04.07
        insert into gal_task_link_journal
                    (gal_task_link_journal_id
                   , gal_task_link_id
                   , gal_task_id
                   , c_tal_state
                   , fal_factory_floor_id
                   , fal_fal_factory_floor_id
                   , gal_task_budget_id
                   , scs_step_number
                   , scs_short_descr
                   , scs_long_descr
                   , tal_due_tsk
                   , tal_achieved_tsk
                   , tal_tsk_balance
                   , tal_hourly_rate
                   , taj_new_value
                   , a_datecre
                   , a_idcre
                   , taj_imputation_date
                    )
             values (init_id_seq.nextval
                   , :old.gal_task_link_id
                   , :old.gal_task_id
                   , :old.c_tal_state
                   , :old.fal_factory_floor_id
                   , :old.fal_fal_factory_floor_id
                   , (select tsk.gal_budget_id
                        from gal_task tsk
                       where tsk.gal_task_id = :old.gal_task_id)
                   , :old.scs_step_number
                   , :old.scs_short_descr
                   , :old.scs_long_descr
                   , :old.tal_due_tsk
                   , :old.tal_achieved_tsk
                   , :old.tal_tsk_balance
                   , :old.tal_hourly_rate
                   , -1
                   , sysdate
                   , pcs.PC_I_LIB_SESSION.getuserini
                   , v_date_imputation
                    );
      end if;

      -- Création d'un ligne d'ajout
      if     (   updating
              or inserting)
         and (   :new.c_tal_state between '20' and '39'
              or :new.c_tal_state = '99') then
        --and (:new.TAL_TSK_BALANCE > 0) ) then hmo
        insert into gal_task_link_journal
                    (gal_task_link_journal_id
                   , gal_task_link_id
                   , gal_task_id
                   , c_tal_state
                   , fal_factory_floor_id
                   , fal_fal_factory_floor_id
                   , gal_task_budget_id
                   , scs_step_number
                   , scs_short_descr
                   , scs_long_descr
                   , tal_due_tsk
                   , tal_achieved_tsk
                   , tal_tsk_balance
                   , tal_hourly_rate
                   , taj_new_value
                   , a_datecre
                   , a_idcre
                   , taj_imputation_date
                    )
             values (init_id_seq.nextval
                   , :new.gal_task_link_id
                   , :new.gal_task_id
                   , :new.c_tal_state
                   , :new.fal_factory_floor_id
                   , :new.fal_fal_factory_floor_id
                   , (select tsk.gal_budget_id
                        from gal_task tsk
                       where tsk.gal_task_id = :new.gal_task_id)
                   , :new.scs_step_number
                   , :new.scs_short_descr
                   , :new.scs_long_descr
                   , :new.tal_due_tsk
                   , :new.tal_achieved_tsk
                   , :new.tal_tsk_balance
                   , :new.tal_hourly_rate
                   , 1
                   , sysdate
                   , pcs.PC_I_LIB_SESSION.getuserini
                   , v_date_imputation
                    );
      end if;
    end if;
  end if;
end gal_tal_aiud_journal;

ALTER TRIGGER "C_ITX"."GAL_TAL_AIUD_JOURNAL" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_TAS_AI_FREE_NUMBER"
  after insert
  on GAL_TASK
  referencing old as old new as new
  for each row
/**
* Description
*    Suppression du numéro de DF la table doc_free_number
* @author Antoine Gabus
* @lastUpdate AGA 31.05.2013
* @version 2013
*/
begin
  -- supression systématique de la table des numéros libres
  if :new.GAL_FATHER_TASK_ID is not null then
    DOC_PRC_DOCUMENT.DeleteFreeNumber(:new.TAS_CODE);
  end if;
end GAL_TAS_AI_FREE_NUMBER;

ALTER TRIGGER "C_ITX"."GAL_TAS_AI_FREE_NUMBER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_TAS_AIU_DOC_RECORD"
   AFTER INSERT OR UPDATE OF tas_code,
                              tas_wording,
                              c_tas_state,
                              tas_description,
                              gal_task_category_id,
                              gal_budget_id,
                              GAL_PROJECT_ID
   ON gal_task
DECLARE
  v_prj_state     gal_project.c_prj_state%type;
  v_gal_task_id   gal_task.gal_task_id%type;
  v_gal_budget_id gal_task.gal_task_id%type;
  v_rco_title     doc_record.rco_title%type;
  v_tas_wording   gal_task.tas_wording%type;
  v_tas_code      gal_task.tas_code%type;
  v_rco_long2     doc_record.rco_alpha_long1%type;
  v_type_tas      char(1);
  v_c_tas_STATE   gal_task.c_tas_state%type;
  v_bdg_wording   gal_task.tas_wording%type;
  v_bdg_code      gal_task.tas_code%type;
  v_c_bdg_STATE   gal_budget.c_bdg_state%type;
  v_rco_status    doc_record.c_rco_status%type;
  v_BudCat_Id     gal_budget.gal_budget_category_id%type;
  v_prj_wording_d doc_record.rco_alpha_long2%type;
  v_prj_code      gal_project.prj_code%type;
  v_pac_custom_partner_id gal_project.pac_custom_partner_id%type;

  cursor c_task(FatherId gal_project.gal_project_id%type)
  is
    select gal_task_id
         , case
             when length(trim(prj_code) || ':' || trim(tas_code) ) <= 30 then trim(prj_code) ||
                                                                                     ':' ||
                                                                                     trim(tas_code)
             else trim(rpad(trim(prj_code) || ':' || trim(tas_code), 30) )
           end
         , tas_wording
         , tas_code
         , tas_wording || chr(10) || substr(tas_description,1,3930)
         , decode(c_tca_task_type, '1', '2', '3')
         , decode(c_prj_state,'10','2',decode(c_bdg_state,'40','1','0'))
		 --, gal_budget.gal_budget_category_id
		 , pac_custom_partner_id
		 , prj_code
		 , prj_wording || chr(10) || substr(prj_description,1,3930)
      from gal_project
	     , gal_task_category
         , gal_task
		 , gal_budget
     where gal_project.gal_project_id = gal_task.gal_project_id
	   and gal_task.gal_budget_id = gal_budget.gal_budget_id
	   and c_tca_task_type in('1', '2')
       and gal_task_category.gal_task_category_id = gal_task.gal_task_category_id
       and gal_task.gal_father_task_id = FatherId FOR UPDATE;

BEGIN

   FOR i IN 1 .. gal_tas_aiu_doc_record.tas_index
   LOOP

      UPDATE   GAL_TASK
               SET   DOC_RECORD_ID = (SELECT
                                      DOC_RECORD_ID FROM DOC_RECORD
                                      WHERE GAL_TASK_ID = gal_tas_aiu_doc_record.table_rowid_task(i).new_gal_task_id
                                     )
               WHERE GAL_TASK_ID = gal_tas_aiu_doc_record.table_rowid_task(i).new_gal_task_id;

    /*Declencheur maj Ope externe*/
	  UPDATE gal_task_link SET scs_step_number = scs_step_number
	                       WHERE gal_task_id = gal_tas_aiu_doc_record.table_rowid_task(i).new_gal_task_id
	                       AND c_task_type = '2';

    -- On fait la mise à jour des dossiers tâches fab de l'affaire
    open c_task(gal_tas_aiu_doc_record.table_rowid_task(i).new_gal_task_id);
      loop
        fetch c_task
         into v_gal_task_id
            , v_rco_title
            , v_tas_wording
            , v_tas_code
            , v_rco_long2
            , v_type_tas
            , v_c_tas_state
			--, v_BudCat_Id
			, v_pac_custom_partner_id
			, v_prj_code
			, v_prj_wording_d;
        exit when c_task%notfound;

        doc_record_functions.updaterecordproject(
                                      null --gal_project_id
                                    , v_gal_task_id
                                    , NULL --gal_budget_id
                                    , null
                                    , v_pac_custom_partner_id
                                    , v_type_tas
                                    , v_c_tas_state
                                    , v_rco_title
                                    , v_tas_wording
                                    , v_prj_code
                                    , v_tas_code
                                    , v_prj_wording_d
                                    , v_rco_long2
									--, v_BudCat_Id
                                    , gal_tas_aiu_doc_record.table_rowid_task(i).new_gal_bud_cat_id
									 );

		/*Declencheur maj Ope externe*/
        update gal_task_link set scs_step_number = scs_step_number where gal_task_id = v_gal_task_id;

      end loop;
    close c_task;
    ------------------------------------------------------------
	--Manque encore la mise à jour du budget_id des dossiers de fab--> mutating

   END LOOP;
   gal_tas_aiu_doc_record.tas_index := 0;

end gal_tas_aiu_doc_record;

ALTER TRIGGER "C_ITX"."GAL_TAS_AIU_DOC_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_TAS_AIU_GAL_TASK_LINK"
AFTER INSERT OR UPDATE OF tas_start_date,
                          tas_end_date
ON gal_task
FOR EACH ROW
declare
v_planification_mode gal_task_category.C_TCA_PLANIFICATION_MODE%type;
BEGIN
  begin
    select C_TCA_PLANIFICATION_MODE into v_planification_mode
    from GAL_TASK_CATEGORY
    where GAL_TASK_CATEGORY_ID = :NEW.GAL_TASK_CATEGORY_ID;
    exception when no_data_found then
    v_planification_mode := null;
  end;
  -- Si le mode de planif de la tâche est 1 (= dates de tâche)
  if v_planification_mode = '1'
  then
    UPDATE GAL_TASK_LINK
    SET TAL_BEGIN_PLAN_DATE = :NEW.TAS_START_DATE,
        TAL_END_PLAN_DATE   = :NEW.TAS_END_DATE
    WHERE GAL_TASK_ID = :NEW.gal_task_id;
  END IF;
end gal_tas_aiu_gal_task_link;

ALTER TRIGGER "C_ITX"."GAL_TAS_AIU_GAL_TASK_LINK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_TAS_AIU_ROW_DOC_RECORD"
  after insert or update
  of tas_code,tas_wording,c_tas_state,tas_description, GAL_PROJECT_ID
     -- **************************************************************
     -- ATTENTION, il reste à traiter la modif de la catégorie:
     -- Si MO --> APPRO ou APPRO --> MO, alors modif catégorie dossier
     -- Si MO ou APPRO --> DIVERS, alors suppression du dossier
     -- Si DIVERS --> MO ou APPRO, alors création du dossier
     -- **************************************************************
     ,gal_task_category_id,gal_budget_id
  ON GAL_TASK   for each row
declare
  v_short1      doc_record.rco_alpha_short1%type;
  v_rco_title   doc_record.rco_title%type;
  v_customer_id gal_project.pac_custom_partner_id%type;
  v_rco_status  doc_record.c_rco_status%type;
  v_rco_long1   doc_record.rco_alpha_long1%type;
  v_rco_long2   doc_record.rco_alpha_long2%type;
  v_task_type   gal_task_category.c_tca_task_type%type;
  v_prj_state   gal_project.c_prj_state%type;
  v_BudCat_Id   gal_budget.gal_budget_category_id%type;
  v_type_tas    char(1);

begin
  begin
    select prj_code
         , case
             when length(trim(prj_code) || ':' || trim(:new.tas_code) ) <= 30 then prj_code || ':' || :new.tas_code
             else trim(rpad(trim(prj_code) || ':' || trim(:new.tas_code), 30) )
           end
         , pac_custom_partner_id
         , decode(c_prj_state,'10','2',decode(c_bdg_state,'40','1','0'))
		 , prj_wording || chr(10) || substr(prj_description,1,3930)
         , :new.tas_wording || chr(10) || substr(:new.tas_description,1,3930)
         , gal_task_category.c_tca_task_type
         , gal_project.c_prj_state
         , decode(gal_task_category.c_tca_task_type, '1', '2', '3')
      into v_short1
         , v_rco_title
         , v_customer_id
         , v_rco_status
         , v_rco_long1
         , v_rco_long2
         , v_task_type
         , v_prj_state
         , v_type_tas
      from gal_task_category
	     , gal_budget
         , gal_project
     where gal_task_category.gal_task_category_id = :new.gal_task_category_id
       and gal_project.gal_project_id = :new.gal_project_id
	   and gal_budget.gal_budget_id = :new.gal_budget_id;

    if     v_task_type in('1', '2') then
	  begin
	    select gal_budget_category_id into v_BudCat_Id FROM gal_budget WHERE gal_budget_id = :new.gal_budget_id;
	  exception when no_data_found then
		v_BudCat_Id := null;
	  end;

      doc_record_functions.updaterecordproject(:new.gal_project_id
                                             , :new.gal_task_id
                                             , null
                                             , null
                                             , v_customer_id
                                             , v_type_tas
                                             , v_rco_status
                                             , v_rco_title
                                             , :new.tas_wording
                                             , v_short1
                                             , :new.tas_code
                                             , v_rco_long1
                                             , v_rco_long2
											 , v_BudCat_Id
                                              );

      gal_tas_aiu_doc_record.tas_index := gal_tas_aiu_doc_record.tas_index + 1;
	  gal_tas_aiu_doc_record.table_rowid_task(gal_tas_aiu_doc_record.tas_index).new_gal_task_id := :new.gal_task_id;
	  gal_tas_aiu_doc_record.table_rowid_task(gal_tas_aiu_doc_record.tas_index).new_gal_bud_cat_id := v_BudCat_Id;

    end if;
  exception
    when no_data_found then
      null;
  end;
end GAL_TAS_AIU_ROW_DOC_RECORD;

ALTER TRIGGER "C_ITX"."GAL_TAS_AIU_ROW_DOC_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_TAS_BD_DOC_RECORD"
  BEFORE DELETE
  ON GAL_TASK
  REFERENCING OLD AS OLD NEW AS NEW
  FOR EACH ROW
/**
* DESCRIPTION
*    SUPPRESSION DU LIEN ENTRE LE DOSSIER AFFAIRE ET LES DOSSIERS DE TYPE TâCHE D'APPROVISIONNEMENT, TâCHE DE
*    MAIN D'OEUVRE ET CODE BUDGET.
*
* @AUTHOR VJ
* @CREATED 17.05.2005
* @VERSION 2003
*/
begin
  -- Suppression du dossier tâche
  DOC_RECORD_FUNCTIONS.DeleteRecordProject(null, :old.GAL_TASK_ID, null,null);
end GAL_TAS_BD_DOC_RECORD;

ALTER TRIGGER "C_ITX"."GAL_TAS_BD_DOC_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GAL_TAS_BIU_DOC_RECORD"
   BEFORE INSERT OR UPDATE OF tas_code,
                              tas_wording,
                              c_tas_state,
                              tas_description,
                              gal_task_category_id,
							  gal_budget_id
   ON gal_task
DECLARE
BEGIN
   gal_tas_aiu_doc_record.tas_index := 0;
   gal_tas_aiu_doc_record.table_rowid_task.DELETE;
end gal_tas_biu_doc_record;

ALTER TRIGGER "C_ITX"."GAL_TAS_BIU_DOC_RECORD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_ATF_AIU_REPLICATE"
  after insert or update
  on GCO_ATTRIBUTE_FIELDS
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication d'une catégorie d'article.
 * @author spfister
 * @date 09.2007
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
  ln_category_id gco_good_category.gco_good_category_id%TYPE := null;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1 and
      :new.DIC_TABSHEET_ATTRIBUTE_ID is not null) then
    if (Nvl(:old.ATF_ACTIVE,0) <> Nvl(:new.ATF_ACTIVE,0)) or
       (Nvl(:old.ATF_ALIAS,' ') <> Nvl(:new.ATF_ALIAS,' ')) or
       (Nvl(:old.ATF_MANDATORY,0) <> Nvl(:new.ATF_MANDATORY,0)) or
       (Nvl(:old.ATF_SEQUENCE_NUMBER,0) <> Nvl(:new.ATF_SEQUENCE_NUMBER,0)) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_ID,' ')) or
       (Nvl(:old.PC_FLDSC_ID,0) <> Nvl(:new.PC_FLDSC_ID,0)) then
      begin
        -- rechercher l'id de la catégorie via la table gco_transfer_list
        select gco_good_category_id
        into ln_category_id
        from gco_good_category
        where rownum = 1 and c_replication_type = '1' and
          :new.DIC_TABSHEET_ATTRIBUTE_ID in (dic_tabsheet_attribute_1_id, dic_tabsheet_attribute_2_id,
            dic_tabsheet_attribute_3_id, dic_tabsheet_attribute_4_id, dic_tabsheet_attribute_5_id,
            dic_tabsheet_attribute_6_id, dic_tabsheet_attribute_7_id, dic_tabsheet_attribute_8_id,
            dic_tabsheet_attribute_9_id, dic_tabsheet_attribute_10_id, dic_tabsheet_attribute_11_id,
            dic_tabsheet_attribute_12_id, dic_tabsheet_attribute_13_id, dic_tabsheet_attribute_14_id,
            dic_tabsheet_attribute_15_id, dic_tabsheet_attribute_16_id, dic_tabsheet_attribute_17_id,
            dic_tabsheet_attribute_18_id, dic_tabsheet_attribute_19_id, dic_tabsheet_attribute_20_id);
      exception
        when NO_DATA_FOUND then
          null;
      end;

      if (ln_category_id is not null) then
        rep_functions.PublishGoodCategory(ln_category_id, ln_result);
      end if;
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_ATF_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_CAS_AIU_REPLICATE"
  after insert or update
  on GCO_COMPL_DATA_ASS
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author fperotto/pzuchetto
 * @author spfister
 * @date 11.2002
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result integer;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if    (nvl(:old.ASA_REP_TYPE_ID, 0) <> nvl(:new.ASA_REP_TYPE_ID, 0) )
       or (nvl(:old.CAS_DEFAULT_REPAIR, 0) <> nvl(:new.CAS_DEFAULT_REPAIR, 0) )
       or (nvl(:old.CAS_GUARANTEE_DELAY, 0) <> nvl(:new.CAS_GUARANTEE_DELAY, 0) )
       or (nvl(:old.CAS_WITH_GUARANTEE, 0) <> nvl(:new.CAS_WITH_GUARANTEE, 0) )
       or (nvl(:old.CDA_COMMENT, ' ') <> nvl(:new.CDA_COMMENT, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_EAN_CODE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_EAN_CODE, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_REFERENCE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_REFERENCE, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_UCC14_CODE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_UCC14_CODE, ' ') )
       or (nvl(:old.CDA_CONVERSION_FACTOR, 0) <> nvl(:new.CDA_CONVERSION_FACTOR, 0) )
       or (nvl(:old.CDA_FREE_ALPHA_1, ' ') <> nvl(:new.CDA_FREE_ALPHA_1, ' ') )
       or (nvl(:old.CDA_FREE_ALPHA_2, ' ') <> nvl(:new.CDA_FREE_ALPHA_2, ' ') )
       or (nvl(:old.CDA_FREE_DEC_1, 0) <> nvl(:new.CDA_FREE_DEC_1, 0) )
       or (nvl(:old.CDA_FREE_DEC_2, 0) <> nvl(:new.CDA_FREE_DEC_2, 0) )
       or (nvl(:old.CDA_FREE_DESCRIPTION, ' ') <> nvl(:new.CDA_FREE_DESCRIPTION, ' ') )
       or (nvl(:old.CDA_LONG_DESCRIPTION, ' ') <> nvl(:new.CDA_LONG_DESCRIPTION, ' ') )
       or (nvl(:old.CDA_NUMBER_OF_DECIMAL, 0) <> nvl(:new.CDA_NUMBER_OF_DECIMAL, 0) )
       or (nvl(:old.CDA_SECONDARY_REFERENCE, ' ') <> nvl(:new.CDA_SECONDARY_REFERENCE, ' ') )
       or (nvl(:old.CDA_SHORT_DESCRIPTION, ' ') <> nvl(:new.CDA_SHORT_DESCRIPTION, ' ') )
       or (nvl(:old.C_ASA_GUARANTY_UNIT, ' ') <> nvl(:new.C_ASA_GUARANTY_UNIT, ' ') )
       or (nvl(:old.DIC_COMPLEMENTARY_DATA_ID, ' ') <> nvl(:new.DIC_COMPLEMENTARY_DATA_ID, ' ') )
       or (nvl(:old.DIC_TARIFF_ID, ' ') <> nvl(:new.DIC_TARIFF_ID, ' ') )
       or (nvl(:old.DIC_UNIT_OF_MEASURE_ID, ' ') <> nvl(:new.DIC_UNIT_OF_MEASURE_ID, ' ') )
       or (nvl(:old.GCO_GOOD_ID, 0) <> nvl(:new.GCO_GOOD_ID, 0) )
       or (nvl(:old.GCO_QUALITY_PRINCIPLE_ID, 0) <> nvl(:new.GCO_QUALITY_PRINCIPLE_ID, 0) )
       or (nvl(:old.GCO_SUBSTITUTION_LIST_ID, 0) <> nvl(:new.GCO_SUBSTITUTION_LIST_ID, 0) )
       or (nvl(:old.STM_LOCATION_ID, 0) <> nvl(:new.STM_LOCATION_ID, 0) )
       or (nvl(:old.STM_STOCK_ID, 0) <> nvl(:new.STM_STOCK_ID, 0) ) then
      rep_functions.PublishArticle(:new.GCO_GOOD_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_CAS_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_CAT_AIU_REPLICATE"
  after insert or update
  on GCO_GOOD_CATEGORY
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication d'une catégorie d'article.
 * @author pzuchetto
 * @author spfister
 * @date 06.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1 and
      :new.C_REPLICATION_TYPE = '1') then
    if (Nvl(:old.CAT_AUTOM_NUMBERING,0) <> Nvl(:new.CAT_AUTOM_NUMBERING,0)) or
       (Nvl(:old.CAT_COMPL_ACHAT,0) <> Nvl(:new.CAT_COMPL_ACHAT,0)) or
       (Nvl(:old.CAT_COMPL_ATTRIBUTE,0) <> Nvl(:new.CAT_COMPL_ATTRIBUTE,0)) or
       (Nvl(:old.CAT_COMPL_DISTRIB,0) <> Nvl(:new.CAT_COMPL_DISTRIB,0)) or
       (Nvl(:old.CAT_COMPL_EXTERNAL_ASA,0) <> Nvl(:new.CAT_COMPL_EXTERNAL_ASA,0)) or
       (Nvl(:old.CAT_COMPL_FAB,0) <> Nvl(:new.CAT_COMPL_FAB,0)) or
       (Nvl(:old.CAT_COMPL_INV,0) <> Nvl(:new.CAT_COMPL_INV,0)) or
       (Nvl(:old.CAT_COMPL_SAV,0) <> Nvl(:new.CAT_COMPL_SAV,0)) or
       (Nvl(:old.CAT_COMPL_SERVICE,0) <> Nvl(:new.CAT_COMPL_SERVICE,0)) or
       (Nvl(:old.CAT_COMPL_STOCK,0) <> Nvl(:new.CAT_COMPL_STOCK,0)) or
       (Nvl(:old.CAT_COMPL_STRAIT,0) <> Nvl(:new.CAT_COMPL_STRAIT,0)) or
       (Nvl(:old.CAT_COMPL_TOOL,0) <> Nvl(:new.CAT_COMPL_TOOL,0)) or
       (Nvl(:old.CAT_COMPL_VENTE,0) <> Nvl(:new.CAT_COMPL_VENTE,0)) or
       (Nvl(:old.CAT_DUPL_CERTIFICATIONS,0) <> Nvl(:new.CAT_DUPL_CERTIFICATIONS,0)) or
       (Nvl(:old.CAT_DUPL_CHARGES,0) <> Nvl(:new.CAT_DUPL_CHARGES,0)) or
       (Nvl(:old.CAT_DUPL_COMPL_ACHAT,0) <> Nvl(:new.CAT_DUPL_COMPL_ACHAT,0)) or
       (Nvl(:old.CAT_DUPL_COMPL_ATTRIBUTE,0) <> Nvl(:new.CAT_DUPL_COMPL_ATTRIBUTE,0)) or
       (Nvl(:old.CAT_DUPL_COMPL_DISTRIB,0) <> Nvl(:new.CAT_DUPL_COMPL_DISTRIB,0)) or
       (Nvl(:old.CAT_DUPL_COMPL_EXTERNAL_ASA,0) <> Nvl(:new.CAT_DUPL_COMPL_EXTERNAL_ASA,0)) or
       (Nvl(:old.CAT_DUPL_COMPL_FAB,0) <> Nvl(:new.CAT_DUPL_COMPL_FAB,0)) or
       (Nvl(:old.CAT_DUPL_COMPL_INV,0) <> Nvl(:new.CAT_DUPL_COMPL_INV,0)) or
       (Nvl(:old.CAT_DUPL_COMPL_SAV,0) <> Nvl(:new.CAT_DUPL_COMPL_SAV,0)) or
       (Nvl(:old.CAT_DUPL_COMPL_SERVICE,0) <> Nvl(:new.CAT_DUPL_COMPL_SERVICE,0)) or
       (Nvl(:old.CAT_DUPL_COMPL_STOCK,0) <> Nvl(:new.CAT_DUPL_COMPL_STOCK,0)) or
       (Nvl(:old.CAT_DUPL_COMPL_STRAIT,0) <> Nvl(:new.CAT_DUPL_COMPL_STRAIT,0)) or
       (Nvl(:old.CAT_DUPL_COMPL_TOOL,0) <> Nvl(:new.CAT_DUPL_COMPL_TOOL,0)) or
       (Nvl(:old.CAT_DUPL_COMPL_VENTE,0) <> Nvl(:new.CAT_DUPL_COMPL_VENTE,0)) or
       (Nvl(:old.CAT_DUPL_CORRELATION,0) <> Nvl(:new.CAT_DUPL_CORRELATION,0)) or
       (Nvl(:old.CAT_DUPL_COUPLED_GOODS,0) <> Nvl(:new.CAT_DUPL_COUPLED_GOODS,0)) or
       (Nvl(:old.CAT_DUPL_DISCOUNT,0) <> Nvl(:new.CAT_DUPL_DISCOUNT,0)) or
       (Nvl(:old.CAT_DUPL_FREEDATA,0) <> Nvl(:new.CAT_DUPL_FREEDATA,0)) or
       (Nvl(:old.CAT_DUPL_NOMENCL,0) <> Nvl(:new.CAT_DUPL_NOMENCL,0)) or
       (Nvl(:old.CAT_DUPL_PRC,0) <> Nvl(:new.CAT_DUPL_PRC,0)) or
       (Nvl(:old.CAT_DUPL_PRECIOUS_MAT,0) <> Nvl(:new.CAT_DUPL_PRECIOUS_MAT,0)) or
       (Nvl(:old.CAT_DUPL_PRF,0) <> Nvl(:new.CAT_DUPL_PRF,0)) or
       (Nvl(:old.CAT_DUPL_TARIFF,0) <> Nvl(:new.CAT_DUPL_TARIFF,0)) or
       (Nvl(:old.CAT_DUPL_TOOLS,0) <> Nvl(:new.CAT_DUPL_TOOLS,0)) or
       (Nvl(:old.CAT_DUPL_VIRTUAL_FIELDS,0) <> Nvl(:new.CAT_DUPL_VIRTUAL_FIELDS,0)) or
       (Nvl(:old.CAT_EAN_ASA_UCC14,0) <> Nvl(:new.CAT_EAN_ASA_UCC14,0)) or
       (Nvl(:old.CAT_EAN_ASA_UPDATABLE,0) <> Nvl(:new.CAT_EAN_ASA_UPDATABLE,0)) or
       (Nvl(:old.CAT_EAN_CTRL_FUNCTION,' ') <> Nvl(:new.CAT_EAN_CTRL_FUNCTION,' ')) or
       (Nvl(:old.CAT_EAN_DIU_UCC14,0) <> Nvl(:new.CAT_EAN_DIU_UCC14,0)) or
       (Nvl(:old.CAT_EAN_DIU_UPDATABLE,0) <> Nvl(:new.CAT_EAN_DIU_UPDATABLE,0)) or
       (Nvl(:old.CAT_EAN_FAL_UCC14,0) <> Nvl(:new.CAT_EAN_FAL_UCC14,0)) or
       (Nvl(:old.CAT_EAN_FAL_UPDATABLE,0) <> Nvl(:new.CAT_EAN_FAL_UPDATABLE,0)) or
       (Nvl(:old.CAT_EAN_GEN_FUNCTION,' ') <> Nvl(:new.CAT_EAN_GEN_FUNCTION,' ')) or
       (Nvl(:old.CAT_EAN_GOO_UCC14,0) <> Nvl(:new.CAT_EAN_GOO_UCC14,0)) or
       (Nvl(:old.CAT_EAN_GOO_UPDATABLE,0) <> Nvl(:new.CAT_EAN_GOO_UPDATABLE,0)) or
       (Nvl(:old.CAT_EAN_INV_UCC14,0) <> Nvl(:new.CAT_EAN_INV_UCC14,0)) or
       (Nvl(:old.CAT_EAN_INV_UPDATABLE,0) <> Nvl(:new.CAT_EAN_INV_UPDATABLE,0)) or
       (Nvl(:old.CAT_EAN_PUR_UCC14,0) <> Nvl(:new.CAT_EAN_PUR_UCC14,0)) or
       (Nvl(:old.CAT_EAN_PUR_UPDATABLE,0) <> Nvl(:new.CAT_EAN_PUR_UPDATABLE,0)) or
       (Nvl(:old.CAT_EAN_SAL_UCC14,0) <> Nvl(:new.CAT_EAN_SAL_UCC14,0)) or
       (Nvl(:old.CAT_EAN_SAL_UPDATABLE,0) <> Nvl(:new.CAT_EAN_SAL_UPDATABLE,0)) or
       (Nvl(:old.CAT_EAN_STK_UCC14,0) <> Nvl(:new.CAT_EAN_STK_UCC14,0)) or
       (Nvl(:old.CAT_EAN_STK_UPDATABLE,0) <> Nvl(:new.CAT_EAN_STK_UPDATABLE,0)) or
       (Nvl(:old.CAT_EAN_SUB_UCC14,0) <> Nvl(:new.CAT_EAN_SUB_UCC14,0)) or
       (Nvl(:old.CAT_EAN_SUB_UPDATABLE,0) <> Nvl(:new.CAT_EAN_SUB_UPDATABLE,0)) or
       (Nvl(:old.CAT_FREE_NUMBER_1,0) <> Nvl(:new.CAT_FREE_NUMBER_1,0)) or
       (Nvl(:old.CAT_FREE_NUMBER_2,0) <> Nvl(:new.CAT_FREE_NUMBER_2,0)) or
       (Nvl(:old.CAT_FREE_NUMBER_3,0) <> Nvl(:new.CAT_FREE_NUMBER_3,0)) or
       (Nvl(:old.CAT_FREE_NUMBER_4,0) <> Nvl(:new.CAT_FREE_NUMBER_4,0)) or
       (Nvl(:old.CAT_FREE_NUMBER_5,0) <> Nvl(:new.CAT_FREE_NUMBER_5,0)) or
       (Nvl(:old.CAT_FREE_TEXT_1,' ') <> Nvl(:new.CAT_FREE_TEXT_1,' ')) or
       (Nvl(:old.CAT_FREE_TEXT_2,' ') <> Nvl(:new.CAT_FREE_TEXT_2,' ')) or
       (Nvl(:old.CAT_FREE_TEXT_3,' ') <> Nvl(:new.CAT_FREE_TEXT_3,' ')) or
       (Nvl(:old.CAT_FREE_TEXT_4,' ') <> Nvl(:new.CAT_FREE_TEXT_4,' ')) or
       (Nvl(:old.CAT_FREE_TEXT_5,' ') <> Nvl(:new.CAT_FREE_TEXT_5,' ')) or
       (Nvl(:old.CAT_GUID,' ') <> Nvl(:new.CAT_GUID,' ')) or
       (Nvl(:old.CAT_HIBC_AUTO_GEN,0) <> Nvl(:new.CAT_HIBC_AUTO_GEN,0)) or
       (Nvl(:old.CAT_HIBC_MANAGEMENT,0) <> Nvl(:new.CAT_HIBC_MANAGEMENT,0)) or
       (Nvl(:old.CAT_STK_POSSESSION_RATE,0) <> Nvl(:new.CAT_STK_POSSESSION_RATE,0)) or
       (Nvl(:old.CAT_XSLT_FLAG_IN,0) <> Nvl(:new.CAT_XSLT_FLAG_IN,0)) or
       (Nvl(:old.CAT_XSLT_FLAG_OUT,0) <> Nvl(:new.CAT_XSLT_FLAG_OUT,0)) or
--       (Nvl(:old.CAT_XSLT_IN,CLOB) <> Nvl(:new.CAT_XSLT_IN,CLOB)) or
--       (Nvl(:old.CAT_XSLT_OUT,CLOB) <> Nvl(:new.CAT_XSLT_OUT,CLOB)) or
       (Nvl(:old.C_EAN_TYPE,' ') <> Nvl(:new.C_EAN_TYPE,' ')) or
       (Nvl(:old.C_EAN_TYPE_ASA,' ') <> Nvl(:new.C_EAN_TYPE_ASA,' ')) or
       (Nvl(:old.C_EAN_TYPE_DIU,' ') <> Nvl(:new.C_EAN_TYPE_DIU,' ')) or
       (Nvl(:old.C_EAN_TYPE_FAL,' ') <> Nvl(:new.C_EAN_TYPE_FAL,' ')) or
       (Nvl(:old.C_EAN_TYPE_INV,' ') <> Nvl(:new.C_EAN_TYPE_INV,' ')) or
       (Nvl(:old.C_EAN_TYPE_PURCHASE,' ') <> Nvl(:new.C_EAN_TYPE_PURCHASE,' ')) or
       (Nvl(:old.C_EAN_TYPE_SALE,' ') <> Nvl(:new.C_EAN_TYPE_SALE,' ')) or
       (Nvl(:old.C_EAN_TYPE_STOCK,' ') <> Nvl(:new.C_EAN_TYPE_STOCK,' ')) or
       (Nvl(:old.C_EAN_TYPE_SUBCONTRACT,' ') <> Nvl(:new.C_EAN_TYPE_SUBCONTRACT,' ')) or
       (Nvl(:old.C_REPLICATION_TYPE,' ') <> Nvl(:new.C_REPLICATION_TYPE,' ')) or
       (Nvl(:old.DIC_CATEGORY_FREE_1_ID,' ') <> Nvl(:new.DIC_CATEGORY_FREE_1_ID,' ')) or
       (Nvl(:old.DIC_CATEGORY_FREE_2_ID,' ') <> Nvl(:new.DIC_CATEGORY_FREE_2_ID,' ')) or
       (Nvl(:old.DIC_GOOD_EAN_CTRL_ASA_ID,' ') <> Nvl(:new.DIC_GOOD_EAN_CTRL_ASA_ID,' ')) or
       (Nvl(:old.DIC_GOOD_EAN_CTRL_DIU_ID,' ') <> Nvl(:new.DIC_GOOD_EAN_CTRL_DIU_ID,' ')) or
       (Nvl(:old.DIC_GOOD_EAN_CTRL_FAL_ID,' ') <> Nvl(:new.DIC_GOOD_EAN_CTRL_FAL_ID,' ')) or
       (Nvl(:old.DIC_GOOD_EAN_CTRL_ID,' ') <> Nvl(:new.DIC_GOOD_EAN_CTRL_ID,' ')) or
       (Nvl(:old.DIC_GOOD_EAN_CTRL_INV_ID,' ') <> Nvl(:new.DIC_GOOD_EAN_CTRL_INV_ID,' ')) or
       (Nvl(:old.DIC_GOOD_EAN_CTRL_PUR_ID,' ') <> Nvl(:new.DIC_GOOD_EAN_CTRL_PUR_ID,' ')) or
       (Nvl(:old.DIC_GOOD_EAN_CTRL_SALE_ID,' ') <> Nvl(:new.DIC_GOOD_EAN_CTRL_SALE_ID,' ')) or
       (Nvl(:old.DIC_GOOD_EAN_CTRL_SCO_ID,' ') <> Nvl(:new.DIC_GOOD_EAN_CTRL_SCO_ID,' ')) or
       (Nvl(:old.DIC_GOOD_EAN_CTRL_STOCK_ID,' ') <> Nvl(:new.DIC_GOOD_EAN_CTRL_STOCK_ID,' ')) or
       (Nvl(:old.DIC_GOOD_EAN_GEN_ASA_ID,' ') <> Nvl(:new.DIC_GOOD_EAN_GEN_ASA_ID,' ')) or
       (Nvl(:old.DIC_GOOD_EAN_GEN_DIU_ID,' ') <> Nvl(:new.DIC_GOOD_EAN_GEN_DIU_ID,' ')) or
       (Nvl(:old.DIC_GOOD_EAN_GEN_FAL_ID,' ') <> Nvl(:new.DIC_GOOD_EAN_GEN_FAL_ID,' ')) or
       (Nvl(:old.DIC_GOOD_EAN_GEN_ID,' ') <> Nvl(:new.DIC_GOOD_EAN_GEN_ID,' ')) or
       (Nvl(:old.DIC_GOOD_EAN_GEN_INV_ID,' ') <> Nvl(:new.DIC_GOOD_EAN_GEN_INV_ID,' ')) or
       (Nvl(:old.DIC_GOOD_EAN_GEN_PUR_ID,' ') <> Nvl(:new.DIC_GOOD_EAN_GEN_PUR_ID,' ')) or
       (Nvl(:old.DIC_GOOD_EAN_GEN_SALE_ID,' ') <> Nvl(:new.DIC_GOOD_EAN_GEN_SALE_ID,' ')) or
       (Nvl(:old.DIC_GOOD_EAN_GEN_SCO_ID,' ') <> Nvl(:new.DIC_GOOD_EAN_GEN_SCO_ID,' ')) or
       (Nvl(:old.DIC_GOOD_EAN_GEN_STOCK_ID,' ') <> Nvl(:new.DIC_GOOD_EAN_GEN_STOCK_ID,' ')) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_10_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_10_ID,' ')) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_11_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_11_ID,' ')) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_12_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_12_ID,' ')) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_13_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_13_ID,' ')) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_14_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_14_ID,' ')) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_15_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_15_ID,' ')) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_16_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_16_ID,' ')) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_17_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_17_ID,' ')) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_18_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_18_ID,' ')) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_19_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_19_ID,' ')) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_1_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_1_ID,' ')) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_20_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_20_ID,' ')) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_2_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_2_ID,' ')) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_3_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_3_ID,' ')) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_4_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_4_ID,' ')) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_5_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_5_ID,' ')) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_6_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_6_ID,' ')) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_7_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_7_ID,' ')) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_8_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_8_ID,' ')) or
       (Nvl(:old.DIC_TABSHEET_ATTRIBUTE_9_ID,' ') <> Nvl(:new.DIC_TABSHEET_ATTRIBUTE_9_ID,' ')) or
       (Nvl(:old.GAL_COST_CENTER_ID,0) <> Nvl(:new.GAL_COST_CENTER_ID,0)) or
       (Nvl(:old.GCO_CATEGORY_CODE,0) <> Nvl(:new.GCO_CATEGORY_CODE,0)) or
       (Nvl(:old.GCO_GCO_GOOD_NUMBERING_ID,0) <> Nvl(:new.GCO_GCO_GOOD_NUMBERING_ID,0)) or
       (Nvl(:old.GCO_GOOD_CATEGORY_WORDING,' ') <> Nvl(:new.GCO_GOOD_CATEGORY_WORDING,' ')) or
       (Nvl(:old.GCO_GOOD_NUMBERING_ID,0) <> Nvl(:new.GCO_GOOD_NUMBERING_ID,0)) or
       (Nvl(:old.GCO_REFERENCE_TEMPLATE_ID,0) <> Nvl(:new.GCO_REFERENCE_TEMPLATE_ID,0)) then
      ln_result := rep_functions.PublishRecord(:new.GCO_GOOD_CATEGORY_ID, 'GCO_GOOD_CATEGORY');
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_CAT_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_CAT_DES_AIU_REPLICATE"
  after insert or update
  on GCO_GOOD_CATEGORY_DESCR
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication d'une catégorie d'article.
 * @author spfister
 * @date 09.2007
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1 and
      rep_lib_replicate.IsCategoryReplicable(:new.GCO_GOOD_CATEGORY_ID) = 1) then
    if (Nvl(:old.GCD_FREE_DESCRIPTION,' ') <> Nvl(:new.GCD_FREE_DESCRIPTION,' ')) or
       (Nvl(:old.GCD_WORDING,' ') <> Nvl(:new.GCD_WORDING,' ')) or
       (Nvl(:old.GCO_GOOD_CATEGORY_ID,0) <> Nvl(:new.GCO_GOOD_CATEGORY_ID,0)) or
       (Nvl(:old.PC_LANG_ID,0) <> Nvl(:new.PC_LANG_ID,0)) then
      rep_functions.PublishGoodCategory(:new.GCO_GOOD_CATEGORY_ID, ln_result);
    end if;
  end if;

  exception
    when EX.TABLE_MUTATING then
      null;
end;

ALTER TRIGGER "C_ITX"."GCO_CAT_DES_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_CDA_BD_INTEGRITY"
  before delete
  on GCO_COMPL_DATA_SALE
  referencing old as old new as new
  for each row
/**
* Description
*     remplace les contraintes avec effacement en cascade
* @author Fabrice Perotto
* @version 2003
*/
declare
  temp number(12);
begin
  -- controle si les données de vente sont utilisées dans GCO_PACKING_ELEMENT
  select max(GCO_PACKING_ELEMENT_ID)
    into temp
    from GCO_PACKING_ELEMENT
   where GCO_COMPL_DATA_SALE_ID = :old.GCO_COMPL_DATA_SALE_ID;

  if temp is not null then
    delete from GCO_PACKING_ELEMENT
          where GCO_COMPL_DATA_SALE_ID = :old.GCO_COMPL_DATA_SALE_ID;
  end if;
end GCO_CDA_BD_INTEGRITY;

ALTER TRIGGER "C_ITX"."GCO_CDA_BD_INTEGRITY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_CHA_AIU_REPLICATE"
  after insert or update
  on GCO_CHARACTERIZATION
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author fperotto/pzuchetto
 * @author spfister
 * @date 11.2002
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result integer;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if    (nvl(:old.CHA_AUTOMATIC_INCREMENTATION, 0) <> nvl(:new.CHA_AUTOMATIC_INCREMENTATION, 0) )
       or (nvl(:old.CHA_CHARACTERIZATION_DESIGN, ' ') <> nvl(:new.CHA_CHARACTERIZATION_DESIGN, ' ') )
       or (nvl(:old.CHA_COMMENT, ' ') <> nvl(:new.CHA_COMMENT, ' ') )
       or (nvl(:old.CHA_FREE_TEXT_1, ' ') <> nvl(:new.CHA_FREE_TEXT_1, ' ') )
       or (nvl(:old.CHA_FREE_TEXT_2, ' ') <> nvl(:new.CHA_FREE_TEXT_2, ' ') )
       or (nvl(:old.CHA_FREE_TEXT_3, ' ') <> nvl(:new.CHA_FREE_TEXT_3, ' ') )
       or (nvl(:old.CHA_FREE_TEXT_4, ' ') <> nvl(:new.CHA_FREE_TEXT_4, ' ') )
       or (nvl(:old.CHA_FREE_TEXT_5, ' ') <> nvl(:new.CHA_FREE_TEXT_5, ' ') )
       or (nvl(:old.CHA_INCREMENT_STE, 0) <> nvl(:new.CHA_INCREMENT_STE, 0) )
       or (nvl(:old.CHA_LAPSING_DELAY, 0) <> nvl(:new.CHA_LAPSING_DELAY, 0) )
       or (nvl(:old.CHA_LAPSING_MARGE, 0) <> nvl(:new.CHA_LAPSING_MARGE, 0) )
       or (nvl(:old.CHA_LAST_USED_INCREMENT, 0) <> nvl(:new.CHA_LAST_USED_INCREMENT, 0) )
       or (nvl(:old.CHA_MAXIMUM_VALUE, 0) <> nvl(:new.CHA_MAXIMUM_VALUE, 0) )
       or (nvl(:old.CHA_MINIMUM_VALUE, 0) <> nvl(:new.CHA_MINIMUM_VALUE, 0) )
       or (nvl(:old.CHA_PREFIXE, ' ') <> nvl(:new.CHA_PREFIXE, ' ') )
       or (nvl(:old.CHA_STOCK_MANAGEMENT, 0) <> nvl(:new.CHA_STOCK_MANAGEMENT, 0) )
       or (nvl(:old.CHA_SUFFIXE, ' ') <> nvl(:new.CHA_SUFFIXE, ' ') )
       or (nvl(:old.C_CHARACT_TYPE, ' ') <> nvl(:new.C_CHARACT_TYPE, ' ') )
       or (nvl(:old.C_CHRONOLOGY_TYPE, ' ') <> nvl(:new.C_CHRONOLOGY_TYPE, ' ') )
       or (nvl(:old.C_UNIT_OF_TIME, ' ') <> nvl(:new.C_UNIT_OF_TIME, ' ') )
       or (nvl(:old.GCO_CHAR_AUTONUM_FUNC_ID, 0) <> nvl(:new.GCO_CHAR_AUTONUM_FUNC_ID, 0) )
       or (nvl(:old.GCO_GOOD_ID, 0) <> nvl(:new.GCO_GOOD_ID, 0) )
       or (nvl(:old.GCO_REFERENCE_TEMPLATE_ID, 0) <> nvl(:new.GCO_REFERENCE_TEMPLATE_ID, 0) ) then
      rep_functions.PublishArticle(:new.GCO_GOOD_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_CHA_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_CHA_BIUD_DENORM"
  before delete or insert or update of "A_RECSTATUS", "C_CHARACT_TYPE"
  on GCO_CHARACTERIZATION
  referencing old as old new as new
  for each row
/**
* Description
*     Gestion de la dénormalisation des caractérisations dans GCO_GOOD
* @author FP 14.6.2005
* @version 2003
*/
declare
  vResult       number;
  vErrorMessage varchar2(4000);
begin
  -- dénormalisation lors de la suppression ou de la mise à jour de A_RECSTATUS à '9'
  if    deleting
     or (    updating
         and :new.A_RECSTATUS = 9) then
    declare
      strStdChar varchar2(65);
      strPiece   varchar2(38);
      strSet     varchar2(38);
      version1Id GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      StdChar1Id GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      StdChar2Id GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      StdChar3Id GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      StdChar4Id GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      StdChar5Id GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      piece1Id   GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      piece2Id   GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      piece3Id   GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      set1Id     GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      set2Id     GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      set3Id     GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      chrono1Id  GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
    begin
      select decode(GOO_VERSION1_ID, :old.GCO_CHARACTERIZATION_ID, null, GOO_VERSION1_ID)
           , ExtractLine(decode(GOO_STD_CHAR1_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR1_ID, GOO_STD_CHAR1_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR2_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR2_ID, GOO_STD_CHAR2_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR3_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR3_ID, GOO_STD_CHAR3_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR4_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR4_ID, GOO_STD_CHAR4_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR5_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR5_ID, GOO_STD_CHAR5_ID || ',', null)
                               )
                       , 1
                       , ','
                        )
           , ExtractLine(decode(GOO_STD_CHAR1_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR1_ID, GOO_STD_CHAR1_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR2_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR2_ID, GOO_STD_CHAR2_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR3_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR3_ID, GOO_STD_CHAR3_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR4_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR4_ID, GOO_STD_CHAR4_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR5_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR5_ID, GOO_STD_CHAR5_ID || ',', null)
                               )
                       , 2
                       , ','
                        )
           , ExtractLine(decode(GOO_STD_CHAR1_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR1_ID, GOO_STD_CHAR1_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR2_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR2_ID, GOO_STD_CHAR2_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR3_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR3_ID, GOO_STD_CHAR3_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR4_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR4_ID, GOO_STD_CHAR4_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR5_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR5_ID, GOO_STD_CHAR5_ID || ',', null)
                               )
                       , 3
                       , ','
                        )
           , ExtractLine(decode(GOO_STD_CHAR1_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR1_ID, GOO_STD_CHAR1_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR2_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR2_ID, GOO_STD_CHAR2_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR3_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR3_ID, GOO_STD_CHAR3_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR4_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR4_ID, GOO_STD_CHAR4_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR5_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR5_ID, GOO_STD_CHAR5_ID || ',', null)
                               )
                       , 4
                       , ','
                        )
           , ExtractLine(decode(GOO_STD_CHAR1_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR1_ID, GOO_STD_CHAR1_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR2_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR2_ID, GOO_STD_CHAR2_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR3_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR3_ID, GOO_STD_CHAR3_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR4_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR4_ID, GOO_STD_CHAR4_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR5_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR5_ID, GOO_STD_CHAR5_ID || ',', null)
                               )
                       , 5
                       , ','
                        )
           , ExtractLine(decode(GOO_PIECE1_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_PIECE1_ID, GOO_PIECE1_ID || ',', null)
                               ) ||
                         decode(GOO_PIECE2_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_PIECE2_ID, GOO_PIECE2_ID || ',', null)
                               ) ||
                         decode(GOO_PIECE3_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_PIECE3_ID, GOO_PIECE3_ID || ',', null)
                               )
                       , 1
                       , ','
                        )
           , ExtractLine(decode(GOO_PIECE1_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_PIECE1_ID, GOO_PIECE1_ID || ',', null)
                               ) ||
                         decode(GOO_PIECE2_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_PIECE2_ID, GOO_PIECE2_ID || ',', null)
                               ) ||
                         decode(GOO_PIECE3_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_PIECE3_ID, GOO_PIECE3_ID || ',', null)
                               )
                       , 2
                       , ','
                        )
           , ExtractLine(decode(GOO_PIECE1_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_PIECE1_ID, GOO_PIECE1_ID || ',', null)
                               ) ||
                         decode(GOO_PIECE2_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_PIECE2_ID, GOO_PIECE2_ID || ',', null)
                               ) ||
                         decode(GOO_PIECE3_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_PIECE3_ID, GOO_PIECE3_ID || ',', null)
                               )
                       , 3
                       , ','
                        )
           , ExtractLine(decode(GOO_SET1_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_SET1_ID, GOO_SET1_ID || ',', null)
                               ) ||
                         decode(GOO_SET2_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_SET2_ID, GOO_SET2_ID || ',', null)
                               ) ||
                         decode(GOO_SET3_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_SET3_ID, GOO_SET3_ID || ',', null)
                               )
                       , 1
                       , ','
                        )
           , ExtractLine(decode(GOO_SET1_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_SET1_ID, GOO_SET1_ID || ',', null)
                               ) ||
                         decode(GOO_SET2_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_SET2_ID, GOO_SET2_ID || ',', null)
                               ) ||
                         decode(GOO_SET3_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_SET3_ID, GOO_SET3_ID || ',', null)
                               )
                       , 2
                       , ','
                        )
           , ExtractLine(decode(GOO_SET1_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_SET1_ID, GOO_SET1_ID || ',', null)
                               ) ||
                         decode(GOO_SET2_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_SET2_ID, GOO_SET2_ID || ',', null)
                               ) ||
                         decode(GOO_SET3_ID
                              , :old.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_SET3_ID, GOO_SET3_ID || ',', null)
                               )
                       , 3
                       , ','
                        )
           , decode(GOO_CHRONO1_ID, :old.GCO_CHARACTERIZATION_ID, null, GOO_CHRONO1_ID)
        into version1Id
           , StdChar1Id
           , StdChar2Id
           , StdChar3Id
           , StdChar4Id
           , StdChar5Id
           , piece1Id
           , piece2Id
           , piece3Id
           , set1Id
           , set2Id
           , set3Id
           , chrono1Id
        from GCO_GOOD
       where GCO_GOOD_ID = :old.GCO_GOOD_ID;

      update GCO_GOOD
         set GOO_VERSION1_ID = version1Id
           , GOO_STD_CHAR1_ID = StdChar1Id
           , GOO_STD_CHAR2_ID = StdChar2Id
           , GOO_STD_CHAR3_ID = StdChar3Id
           , GOO_STD_CHAR4_ID = StdChar4Id
           , GOO_STD_CHAR5_ID = StdChar5Id
           , GOO_PIECE1_ID = piece1Id
           , GOO_PIECE2_ID = piece2Id
           , GOO_PIECE3_ID = piece3Id
           , GOO_SET1_ID = set1Id
           , GOO_SET2_ID = set2Id
           , GOO_SET3_ID = set3Id
           , GOO_CHRONO1_ID = chrono1Id
       where GCO_GOOD_ID = :old.GCO_GOOD_ID;
    end;
  end if;

  -- Dénormalisation lors de l'insertion ou la mise à jour de A_RECSTATUS à une valeur différente de '9'
  if    inserting
     or (    updating
         and :new.A_RECSTATUS <> 9) then
    declare
      strStdChar varchar2(65);
      strPiece   varchar2(38);
      strSet     varchar2(38);
      version1Id GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      StdChar1Id GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      StdChar2Id GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      StdChar3Id GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      StdChar4Id GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      StdChar5Id GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      piece1Id   GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      piece2Id   GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      piece3Id   GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      set1Id     GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      set2Id     GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      set3Id     GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
      chrono1Id  GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type;
    begin
      select decode(:new.C_CHARACT_TYPE, '1', :new.GCO_CHARACTERIZATION_ID)
           , ExtractLine(decode(GOO_STD_CHAR1_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR1_ID, GOO_STD_CHAR1_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR2_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR2_ID, GOO_STD_CHAR2_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR3_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR3_ID, GOO_STD_CHAR3_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR4_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR4_ID, GOO_STD_CHAR4_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR5_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR5_ID, GOO_STD_CHAR5_ID || ',', null)
                               ) ||
                         decode(:new.C_CHARACT_TYPE, '2', :new.GCO_CHARACTERIZATION_ID)
                       , 1
                       , ','
                        )
           , ExtractLine(decode(GOO_STD_CHAR1_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR1_ID, GOO_STD_CHAR1_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR2_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR2_ID, GOO_STD_CHAR2_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR3_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR3_ID, GOO_STD_CHAR3_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR4_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR4_ID, GOO_STD_CHAR4_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR5_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR5_ID, GOO_STD_CHAR5_ID || ',', null)
                               ) ||
                         decode(:new.C_CHARACT_TYPE, '2', :new.GCO_CHARACTERIZATION_ID)
                       , 2
                       , ','
                        )
           , ExtractLine(decode(GOO_STD_CHAR1_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR1_ID, GOO_STD_CHAR1_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR2_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR2_ID, GOO_STD_CHAR2_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR3_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR3_ID, GOO_STD_CHAR3_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR4_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR4_ID, GOO_STD_CHAR4_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR5_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR5_ID, GOO_STD_CHAR5_ID || ',', null)
                               ) ||
                         decode(:new.C_CHARACT_TYPE, '2', :new.GCO_CHARACTERIZATION_ID)
                       , 3
                       , ','
                        )
           , ExtractLine(decode(GOO_STD_CHAR1_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR1_ID, GOO_STD_CHAR1_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR2_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR2_ID, GOO_STD_CHAR2_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR3_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR3_ID, GOO_STD_CHAR3_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR4_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR4_ID, GOO_STD_CHAR4_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR5_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR5_ID, GOO_STD_CHAR5_ID || ',', null)
                               ) ||
                         decode(:new.C_CHARACT_TYPE, '2', :new.GCO_CHARACTERIZATION_ID)
                       , 4
                       , ','
                        )
           , ExtractLine(decode(GOO_STD_CHAR1_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR1_ID, GOO_STD_CHAR1_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR2_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR2_ID, GOO_STD_CHAR2_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR3_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR3_ID, GOO_STD_CHAR3_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR4_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR4_ID, GOO_STD_CHAR4_ID || ',', null)
                               ) ||
                         decode(GOO_STD_CHAR5_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_STD_CHAR5_ID, GOO_STD_CHAR5_ID || ',', null)
                               ) ||
                         decode(:new.C_CHARACT_TYPE, '2', :new.GCO_CHARACTERIZATION_ID)
                       , 5
                       , ','
                        )
           , ExtractLine(decode(GOO_PIECE1_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_PIECE1_ID, GOO_PIECE1_ID || ',', null)
                               ) ||
                         decode(GOO_PIECE2_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_PIECE2_ID, GOO_PIECE2_ID || ',', null)
                               ) ||
                         decode(GOO_PIECE3_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_PIECE3_ID, GOO_PIECE3_ID || ',', null)
                               ) ||
                         decode(:new.C_CHARACT_TYPE, '3', :new.GCO_CHARACTERIZATION_ID)
                       , 1
                       , ','
                        )
           , ExtractLine(decode(GOO_PIECE1_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_PIECE1_ID, GOO_PIECE1_ID || ',', null)
                               ) ||
                         decode(GOO_PIECE2_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_PIECE2_ID, GOO_PIECE2_ID || ',', null)
                               ) ||
                         decode(GOO_PIECE3_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_PIECE3_ID, GOO_PIECE3_ID || ',', null)
                               ) ||
                         decode(:new.C_CHARACT_TYPE, '3', :new.GCO_CHARACTERIZATION_ID)
                       , 2
                       , ','
                        )
           , ExtractLine(decode(GOO_PIECE1_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_PIECE1_ID, GOO_PIECE1_ID || ',', null)
                               ) ||
                         decode(GOO_PIECE2_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_PIECE2_ID, GOO_PIECE2_ID || ',', null)
                               ) ||
                         decode(GOO_PIECE3_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_PIECE3_ID, GOO_PIECE3_ID || ',', null)
                               ) ||
                         decode(:new.C_CHARACT_TYPE, '3', :new.GCO_CHARACTERIZATION_ID)
                       , 3
                       , ','
                        )
           , ExtractLine(decode(GOO_SET1_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_SET1_ID, GOO_SET1_ID || ',', null)
                               ) ||
                         decode(GOO_SET2_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_SET2_ID, GOO_SET2_ID || ',', null)
                               ) ||
                         decode(GOO_SET3_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_SET3_ID, GOO_SET3_ID || ',', null)
                               ) ||
                         decode(:new.C_CHARACT_TYPE, '4', :new.GCO_CHARACTERIZATION_ID)
                       , 1
                       , ','
                        )
           , ExtractLine(decode(GOO_SET1_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_SET1_ID, GOO_SET1_ID || ',', null)
                               ) ||
                         decode(GOO_SET2_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_SET2_ID, GOO_SET2_ID || ',', null)
                               ) ||
                         decode(GOO_SET3_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_SET3_ID, GOO_SET3_ID || ',', null)
                               ) ||
                         decode(:new.C_CHARACT_TYPE, '4', :new.GCO_CHARACTERIZATION_ID)
                       , 2
                       , ','
                        )
           , ExtractLine(decode(GOO_SET1_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_SET1_ID, GOO_SET1_ID || ',', null)
                               ) ||
                         decode(GOO_SET2_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_SET2_ID, GOO_SET2_ID || ',', null)
                               ) ||
                         decode(GOO_SET3_ID
                              , :new.GCO_CHARACTERIZATION_ID, null
                              , nvl2(GOO_SET3_ID, GOO_SET3_ID || ',', null)
                               ) ||
                         decode(:new.C_CHARACT_TYPE, '4', :new.GCO_CHARACTERIZATION_ID)
                       , 3
                       , ','
                        )
           , decode(:new.C_CHARACT_TYPE, '5', :new.GCO_CHARACTERIZATION_ID)
        into version1Id
           , StdChar1Id
           , StdChar2Id
           , StdChar3Id
           , StdChar4Id
           , StdChar5Id
           , piece1Id
           , piece2Id
           , piece3Id
           , set1Id
           , set2Id
           , set3Id
           , chrono1Id
        from GCO_GOOD
       where GCO_GOOD_ID = :new.GCO_GOOD_ID;

      update GCO_GOOD
         set GOO_VERSION1_ID = version1Id
           , GOO_STD_CHAR1_ID = StdChar1Id
           , GOO_STD_CHAR2_ID = StdChar2Id
           , GOO_STD_CHAR3_ID = StdChar3Id
           , GOO_STD_CHAR4_ID = StdChar4Id
           , GOO_STD_CHAR5_ID = StdChar5Id
           , GOO_PIECE1_ID = piece1Id
           , GOO_PIECE2_ID = piece2Id
           , GOO_PIECE3_ID = piece3Id
           , GOO_SET1_ID = set1Id
           , GOO_SET2_ID = set2Id
           , GOO_SET3_ID = set3Id
           , GOO_CHRONO1_ID = chrono1Id
       where GCO_GOOD_ID = :new.GCO_GOOD_ID;
    end;
  end if;
exception
  when ex.TABLE_MUTATING then
    -- dans le cas d'un effacement en cascade depuis GCO_GOOD, la table GCO_GOD n'est pas mise à jour
    -- vu qu'elle va être supprimée
    null;
end GCO_CHA_BIUD_DENORM;

ALTER TRIGGER "C_ITX"."GCO_CHA_BIUD_DENORM" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_CHA_BIUD_INTEGRITY"
  before delete or insert or update of "C_CHARACT_TYPE"
                                     , "C_CHRONOLOGY_TYPE"
                                     , "C_UNIT_OF_TIME"
                                     , "CHA_USE_DETAIL"
                                     , "CHA_WITH_RETEST"
                                     , "CHA_STOCK_MANAGEMENT"
                                     , "GCO_CHARACTERIZATION_ID"
                                     , "GCO_GOOD_ID"
  on GCO_CHARACTERIZATION
  referencing old as old new as new
  for each row
/**
* Description
*     Gestion de l'intégrité des caractérisations
* @author Stéphanie Matthey
* @version 2013
*/
declare
  vResult       number;
  vErrorMessage varchar2(4000);
begin
  -- si on est pas en mode maintenance, on vérifie que le bien incriminé ne soit pas déjà utilisé
  if GCO_CHARACTERIZATION_FUNCTIONS.gCharManagementMode = 0 then
    vResult  := gco_functions.IsCharactUpdatable(:old.GCO_GOOD_ID, :new.GCO_GOOD_ID, vErrorMessage);

    if vResult = 0 then
      raise_application_error(-20900, vErrorMessage);
    end if;
  end if;
end GCO_CHA_BIUD_INTEGRITY;

ALTER TRIGGER "C_ITX"."GCO_CHA_BIUD_INTEGRITY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_CHE_AIU_REPLICATE"
  after insert or update
  on GCO_CHARACTERISTIC_ELEMENT
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author jsomers
 * @author spfister
 * @date 12.2002
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result  integer;
  ln_good_id gco_good.gco_good_id%type   := null;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if    (nvl(:old.CHE_ALLOCATION, 0) <> nvl(:new.CHE_ALLOCATION, 0) )
       or (nvl(:old.CHE_EAN_CODE, ' ') <> nvl(:new.CHE_EAN_CODE, ' ') )
       or (nvl(:old.CHE_VALUE, ' ') <> nvl(:new.CHE_VALUE, ' ') )
       or (nvl(:old.GCO_CHARACTERIZATION_ID, 0) <> nvl(:new.GCO_CHARACTERIZATION_ID, 0) ) then
      begin
        select gco_good_id
          into ln_good_id
          from gco_characterization
         where gco_characterization_id = :new.gco_characterization_id;
      exception
        when no_data_found then
          null;
      end;

      if (ln_good_id is not null) then
        rep_functions.PublishArticle(ln_good_id, ln_result);
      end if;
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_CHE_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_CIN_AIU_REPLICATE"
  after insert or update
  on GCO_COMPL_DATA_INVENTORY
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author fperotto/pzuchetto
 * @author spfister
 * @date 11.2002
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result integer;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if    (nvl(:old.CDA_COMMENT, ' ') <> nvl(:new.CDA_COMMENT, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_EAN_CODE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_EAN_CODE, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_REFERENCE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_REFERENCE, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_UCC14_CODE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_UCC14_CODE, ' ') )
       or (nvl(:old.CDA_CONVERSION_FACTOR, 0) <> nvl(:new.CDA_CONVERSION_FACTOR, 0) )
       or (nvl(:old.CDA_FREE_ALPHA_1, ' ') <> nvl(:new.CDA_FREE_ALPHA_1, ' ') )
       or (nvl(:old.CDA_FREE_ALPHA_2, ' ') <> nvl(:new.CDA_FREE_ALPHA_2, ' ') )
       or (nvl(:old.CDA_FREE_DEC_1, 0) <> nvl(:new.CDA_FREE_DEC_1, 0) )
       or (nvl(:old.CDA_FREE_DEC_2, 0) <> nvl(:new.CDA_FREE_DEC_2, 0) )
       or (nvl(:old.CDA_FREE_DESCRIPTION, ' ') <> nvl(:new.CDA_FREE_DESCRIPTION, ' ') )
       or (nvl(:old.CDA_LONG_DESCRIPTION, ' ') <> nvl(:new.CDA_LONG_DESCRIPTION, ' ') )
       or (nvl(:old.CDA_NUMBER_OF_DECIMAL, 0) <> nvl(:new.CDA_NUMBER_OF_DECIMAL, 0) )
       or (nvl(:old.CDA_SECONDARY_REFERENCE, ' ') <> nvl(:new.CDA_SECONDARY_REFERENCE, ' ') )
       or (nvl(:old.CDA_SHORT_DESCRIPTION, ' ') <> nvl(:new.CDA_SHORT_DESCRIPTION, ' ') )
       or (nvl(:old.CIN_FIXED_STOCK_POSITION, 0) <> nvl(:new.CIN_FIXED_STOCK_POSITION, 0) )
       or
--       (Nvl(:old.CIN_LAST_INVENTORY_DATE,to_date('01011900', 'DDMMYYYY')) <> Nvl(:new.CIN_LAST_INVENTORY_DATE,to_date('01011900', 'DDMMYYYY'))) or
--       (Nvl(:old.CIN_NEXT_INVENTORY_DATE,to_date('01011900', 'DDMMYYYY')) <> Nvl(:new.CIN_NEXT_INVENTORY_DATE,to_date('01011900', 'DDMMYYYY'))) or
          (nvl(:old.CIN_TURNING_INVENTORY, 0) <> nvl(:new.CIN_TURNING_INVENTORY, 0) )
       or (nvl(:old.CIN_TURNING_INVENTORY_DELAY, 0) <> nvl(:new.CIN_TURNING_INVENTORY_DELAY, 0) )
       or (nvl(:old.DIC_COMPLEMENTARY_DATA_ID, ' ') <> nvl(:new.DIC_COMPLEMENTARY_DATA_ID, ' ') )
       or (nvl(:old.DIC_UNIT_OF_MEASURE_ID, ' ') <> nvl(:new.DIC_UNIT_OF_MEASURE_ID, ' ') )
       or (nvl(:old.GCO_GOOD_ID, 0) <> nvl(:new.GCO_GOOD_ID, 0) )
       or (nvl(:old.GCO_QUALITY_PRINCIPLE_ID, 0) <> nvl(:new.GCO_QUALITY_PRINCIPLE_ID, 0) )
       or (nvl(:old.GCO_SUBSTITUTION_LIST_ID, 0) <> nvl(:new.GCO_SUBSTITUTION_LIST_ID, 0) )
       or (nvl(:old.STM_LOCATION_ID, 0) <> nvl(:new.STM_LOCATION_ID, 0) )
       or (nvl(:old.STM_STOCK_ID, 0) <> nvl(:new.STM_STOCK_ID, 0) ) then
      rep_functions.PublishArticle(:new.GCO_GOOD_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_CIN_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_CMA_AIU_REPLICATE"
  after insert or update
  on GCO_COMPL_DATA_MANUFACTURE
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author fperotto/pzuchetto
 * @author spfister
 * @date 11.2002
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result integer;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if    (nvl(:old.CDA_COMMENT, ' ') <> nvl(:new.CDA_COMMENT, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_EAN_CODE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_EAN_CODE, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_REFERENCE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_REFERENCE, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_UCC14_CODE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_UCC14_CODE, ' ') )
       or (nvl(:old.CDA_CONVERSION_FACTOR, 0) <> nvl(:new.CDA_CONVERSION_FACTOR, 0) )
       or (nvl(:old.CDA_FREE_ALPHA_1, ' ') <> nvl(:new.CDA_FREE_ALPHA_1, ' ') )
       or (nvl(:old.CDA_FREE_ALPHA_2, ' ') <> nvl(:new.CDA_FREE_ALPHA_2, ' ') )
       or (nvl(:old.CDA_FREE_DEC_1, 0) <> nvl(:new.CDA_FREE_DEC_1, 0) )
       or (nvl(:old.CDA_FREE_DEC_2, 0) <> nvl(:new.CDA_FREE_DEC_2, 0) )
       or (nvl(:old.CDA_FREE_DESCRIPTION, ' ') <> nvl(:new.CDA_FREE_DESCRIPTION, ' ') )
       or (nvl(:old.CDA_LONG_DESCRIPTION, ' ') <> nvl(:new.CDA_LONG_DESCRIPTION, ' ') )
       or (nvl(:old.CDA_NUMBER_OF_DECIMAL, 0) <> nvl(:new.CDA_NUMBER_OF_DECIMAL, 0) )
       or (nvl(:old.CDA_SECONDARY_REFERENCE, ' ') <> nvl(:new.CDA_SECONDARY_REFERENCE, ' ') )
       or (nvl(:old.CDA_SHORT_DESCRIPTION, ' ') <> nvl(:new.CDA_SHORT_DESCRIPTION, ' ') )
       or (nvl(:old.CMA_AUTOMATIC_GENERATING_PROP, 0) <> nvl(:new.CMA_AUTOMATIC_GENERATING_PROP, 0) )
       or (nvl(:old.CMA_AUTO_RECEPT, 0) <> nvl(:new.CMA_AUTO_RECEPT, 0) )
       or (nvl(:old.CMA_DEFAULT, 0) <> nvl(:new.CMA_DEFAULT, 0) )
       or (nvl(:old.CMA_ECONOMICAL_QUANTITY, 0) <> nvl(:new.CMA_ECONOMICAL_QUANTITY, 0) )
       or (nvl(:old.CMA_FIXED_DELAY, 0) <> nvl(:new.CMA_FIXED_DELAY, 0) )
       or (nvl(:old.CMA_FIXED_QUANTITY_TRASH, 0) <> nvl(:new.CMA_FIXED_QUANTITY_TRASH, 0) )
       or (nvl(:old.CMA_FIXED_QUANTITY_WASTE, 0) <> nvl(:new.CMA_FIXED_QUANTITY_WASTE, 0) )
       or (nvl(:old.CMA_FIX_DELAY, 0) <> nvl(:new.CMA_FIX_DELAY, 0) )
       or (nvl(:old.CMA_LOT_QUANTITY, 0) <> nvl(:new.CMA_LOT_QUANTITY, 0) )
       or (nvl(:old.CMA_MANUFACTURING_DELAY, 0) <> nvl(:new.CMA_MANUFACTURING_DELAY, 0) )
       or (nvl(:old.CMA_MODULO_QUANTITY, 0) <> nvl(:new.CMA_MODULO_QUANTITY, 0) )
       or (nvl(:old.CMA_MULTIMEDIA_PLAN, ' ') <> nvl(:new.CMA_MULTIMEDIA_PLAN, ' ') )
       or (nvl(:old.CMA_PERCENT_TRASH, 0) <> nvl(:new.CMA_PERCENT_TRASH, 0) )
       or (nvl(:old.CMA_PERCENT_WASTE, 0) <> nvl(:new.CMA_PERCENT_WASTE, 0) )
       or (nvl(:old.CMA_PLAN_NUMBER, ' ') <> nvl(:new.CMA_PLAN_NUMBER, ' ') )
       or (nvl(:old.CMA_PLAN_VERSION, ' ') <> nvl(:new.CMA_PLAN_VERSION, ' ') )
       or (nvl(:old.CMA_QTY_REFERENCE_LOSS, 0) <> nvl(:new.CMA_QTY_REFERENCE_LOSS, 0) )
       or (nvl(:old.CMA_SCHEDULE_TYPE, 0) <> nvl(:new.CMA_SCHEDULE_TYPE, 0) )
       or (nvl(:old.CMA_SHIFT, 0) <> nvl(:new.CMA_SHIFT, 0) )
       or (nvl(:old.C_ECONOMIC_CODE, ' ') <> nvl(:new.C_ECONOMIC_CODE, ' ') )
       or (nvl(:old.C_QTY_SUPPLY_RULE, ' ') <> nvl(:new.C_QTY_SUPPLY_RULE, ' ') )
       or (nvl(:old.C_TIME_SUPPLY_RULE, ' ') <> nvl(:new.C_TIME_SUPPLY_RULE, ' ') )
       or (nvl(:old.DIC_COMPLEMENTARY_DATA_ID, ' ') <> nvl(:new.DIC_COMPLEMENTARY_DATA_ID, ' ') )
       or (nvl(:old.DIC_FAB_CONDITION_ID, ' ') <> nvl(:new.DIC_FAB_CONDITION_ID, ' ') )
       or (nvl(:old.DIC_UNIT_OF_MEASURE_ID, ' ') <> nvl(:new.DIC_UNIT_OF_MEASURE_ID, ' ') )
       or (nvl(:old.FAL_SCHEDULE_PLAN_ID, 0) <> nvl(:new.FAL_SCHEDULE_PLAN_ID, 0) )
       or (nvl(:old.GCO_GOOD_ID, 0) <> nvl(:new.GCO_GOOD_ID, 0) )
       or (nvl(:old.GCO_QUALITY_PRINCIPLE_ID, 0) <> nvl(:new.GCO_QUALITY_PRINCIPLE_ID, 0) )
       or (nvl(:old.GCO_SUBSTITUTION_LIST_ID, 0) <> nvl(:new.GCO_SUBSTITUTION_LIST_ID, 0) )
       or (nvl(:old.PPS_NOMENCLATURE_ID, 0) <> nvl(:new.PPS_NOMENCLATURE_ID, 0) )
       or (nvl(:old.PPS_OPERATION_PROCEDURE_ID, 0) <> nvl(:new.PPS_OPERATION_PROCEDURE_ID, 0) )
       or (nvl(:old.PPS_RANGE_ID, 0) <> nvl(:new.PPS_RANGE_ID, 0) )
       or (nvl(:old.STM_LOCATION_ID, 0) <> nvl(:new.STM_LOCATION_ID, 0) )
       or (nvl(:old.STM_STOCK_ID, 0) <> nvl(:new.STM_STOCK_ID, 0) ) then
      rep_functions.PublishArticle(:new.GCO_GOOD_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_CMA_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_CMA_BD_CASCADE"
  before delete
  on GCO_COMPL_DATA_MANUFACTURE
  referencing old as old new as new
  for each row
/**
* Description
*     remplace les contraintes avec effacement en cascade
* @author David Saadé
* @version 2003
*/
declare
  temp number(12);
begin
  -- controle si la donnée complémentaire est utilisée dans COM_IMAGE_FILES
  select max(IMF_REC_ID)
    into temp
    from COM_IMAGE_FILES
   where IMF_TABLE = 'GCO_COMPL_DATA_MANUFACTURE'
     and IMF_REC_ID = :old.GCO_COMPL_DATA_MANUFACTURE_ID;

  if temp is not null then
    delete from COM_IMAGE_FILES
          where IMF_TABLE = 'GCO_COMPL_DATA_MANUFACTURE'
            and IMF_REC_ID = :old.GCO_COMPL_DATA_MANUFACTURE_ID;
  end if;
end GCO_CMA_BD_CASCADE;

ALTER TRIGGER "C_ITX"."GCO_CMA_BD_CASCADE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_CON_AIU_REPLICATE"
  after insert or update
  on GCO_CONNECTED_GOOD
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author fperotto/pzuchetto
 * @author spfister
 * @date 11.2002
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result integer;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if    (nvl(:old.CON_DEFAULT_SELECTION, 0) <> nvl(:new.CON_DEFAULT_SELECTION, 0) )
       or (nvl(:old.CON_REM, ' ') <> nvl(:new.CON_REM, ' ') )
       or (nvl(:old.CON_UTIL_COEFF, 0) <> nvl(:new.CON_UTIL_COEFF, 0) )
       or (nvl(:old.DIC_CONNECTED_TYPE_ID, ' ') <> nvl(:new.DIC_CONNECTED_TYPE_ID, ' ') )
       or (nvl(:old.GCO_GCO_GOOD_ID, 0) <> nvl(:new.GCO_GCO_GOOD_ID, 0) )
       or (nvl(:old.GCO_GOOD_ID, 0) <> nvl(:new.GCO_GOOD_ID, 0) ) then
      rep_functions.PublishArticle(:new.GCO_GOOD_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_CON_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_CPU_AIU_REPLICATE"
  after insert or update
  on GCO_COMPL_DATA_PURCHASE
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author fperotto/pzuchetto
 * @author spfister
 * @date 11.2002
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result integer;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if    (nvl(:old.CDA_COMMENT, ' ') <> nvl(:new.CDA_COMMENT, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_EAN_CODE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_EAN_CODE, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_REFERENCE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_REFERENCE, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_UCC14_CODE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_UCC14_CODE, ' ') )
       or (nvl(:old.CDA_CONVERSION_FACTOR, 0) <> nvl(:new.CDA_CONVERSION_FACTOR, 0) )
       or (nvl(:old.CDA_FREE_ALPHA_1, ' ') <> nvl(:new.CDA_FREE_ALPHA_1, ' ') )
       or (nvl(:old.CDA_FREE_ALPHA_2, ' ') <> nvl(:new.CDA_FREE_ALPHA_2, ' ') )
       or (nvl(:old.CDA_FREE_DEC_1, 0) <> nvl(:new.CDA_FREE_DEC_1, 0) )
       or (nvl(:old.CDA_FREE_DEC_2, 0) <> nvl(:new.CDA_FREE_DEC_2, 0) )
       or (nvl(:old.CDA_FREE_DESCRIPTION, ' ') <> nvl(:new.CDA_FREE_DESCRIPTION, ' ') )
       or (nvl(:old.CDA_LONG_DESCRIPTION, ' ') <> nvl(:new.CDA_LONG_DESCRIPTION, ' ') )
       or (nvl(:old.CDA_NUMBER_OF_DECIMAL, 0) <> nvl(:new.CDA_NUMBER_OF_DECIMAL, 0) )
       or (nvl(:old.CDA_SECONDARY_REFERENCE, ' ') <> nvl(:new.CDA_SECONDARY_REFERENCE, ' ') )
       or (nvl(:old.CDA_SHORT_DESCRIPTION, ' ') <> nvl(:new.CDA_SHORT_DESCRIPTION, ' ') )
       or (nvl(:old.CPU_AUTOMATIC_GENERATING_PROP, 0) <> nvl(:new.CPU_AUTOMATIC_GENERATING_PROP, 0) )
       or (nvl(:old.CPU_CONTROL_DELAY, 0) <> nvl(:new.CPU_CONTROL_DELAY, 0) )
       or (nvl(:old.CPU_DEFAULT_SUPPLIER, 0) <> nvl(:new.CPU_DEFAULT_SUPPLIER, 0) )
       or (nvl(:old.CPU_ECONOMICAL_QUANTITY, 0) <> nvl(:new.CPU_ECONOMICAL_QUANTITY, 0) )
       or (nvl(:old.CPU_FIXED_DELAY, 0) <> nvl(:new.CPU_FIXED_DELAY, 0) )
       or (nvl(:old.CPU_FIXED_QUANTITY_TRASH, 0) <> nvl(:new.CPU_FIXED_QUANTITY_TRASH, 0) )
       or (nvl(:old.CPU_GAUGE_TYPE_POS_MANDATORY, 0) <> nvl(:new.CPU_GAUGE_TYPE_POS_MANDATORY, 0) )
       or (nvl(:old.CPU_GUARANTY_PC_APPLTXT_ID, 0) <> nvl(:new.CPU_GUARANTY_PC_APPLTXT_ID, 0) )
       or (nvl(:old.CPU_HIBC_CODE, ' ') <> nvl(:new.CPU_HIBC_CODE, ' ') )
       or (nvl(:old.CPU_MODULO_QUANTITY, 0) <> nvl(:new.CPU_MODULO_QUANTITY, 0) )
       or (nvl(:old.CPU_OFFICIAL_SUPPLIER, 0) <> nvl(:new.CPU_OFFICIAL_SUPPLIER, 0) )
       or (nvl(:old.CPU_PERCENT_SOURCING, 0) <> nvl(:new.CPU_PERCENT_SOURCING, 0) )
       or (nvl(:old.CPU_PERCENT_TRASH, 0) <> nvl(:new.CPU_PERCENT_TRASH, 0) )
       or (nvl(:old.CPU_PRECIOUS_MAT_VALUE, 0) <> nvl(:new.CPU_PRECIOUS_MAT_VALUE, 0) )
       or (nvl(:old.CPU_QTY_REFERENCE_TRASH, 0) <> nvl(:new.CPU_QTY_REFERENCE_TRASH, 0) )
       or (nvl(:old.CPU_SECURITY_DELAY, 0) <> nvl(:new.CPU_SECURITY_DELAY, 0) )
       or (nvl(:old.CPU_SHIFT, 0) <> nvl(:new.CPU_SHIFT, 0) )
       or (nvl(:old.CPU_SUPPLY_CAPACITY, 0) <> nvl(:new.CPU_SUPPLY_CAPACITY, 0) )
       or (nvl(:old.CPU_SUPPLY_DELAY, 0) <> nvl(:new.CPU_SUPPLY_DELAY, 0) )
       or (nvl(:old.CPU_WARRANTY_PERIOD, 0) <> nvl(:new.CPU_WARRANTY_PERIOD, 0) )
       or (nvl(:old.C_ASA_GUARANTY_UNIT, ' ') <> nvl(:new.C_ASA_GUARANTY_UNIT, ' ') )
       or (nvl(:old.C_ECONOMIC_CODE, ' ') <> nvl(:new.C_ECONOMIC_CODE, ' ') )
       or (nvl(:old.C_GAUGE_TYPE_POS, ' ') <> nvl(:new.C_GAUGE_TYPE_POS, ' ') )
       or (nvl(:old.C_QTY_SUPPLY_RULE, ' ') <> nvl(:new.C_QTY_SUPPLY_RULE, ' ') )
       or (nvl(:old.C_TIME_SUPPLY_RULE, ' ') <> nvl(:new.C_TIME_SUPPLY_RULE, ' ') )
       or (nvl(:old.DIC_COMPLEMENTARY_DATA_ID, ' ') <> nvl(:new.DIC_COMPLEMENTARY_DATA_ID, ' ') )
       or (nvl(:old.DIC_UNIT_OF_MEASURE_ID, ' ') <> nvl(:new.DIC_UNIT_OF_MEASURE_ID, ' ') )
       or (nvl(:old.GCO_GCO_GOOD_ID, 0) <> nvl(:new.GCO_GCO_GOOD_ID, 0) )
       or (nvl(:old.GCO_GOOD_ID, 0) <> nvl(:new.GCO_GOOD_ID, 0) )
       or (nvl(:old.GCO_QUALITY_PRINCIPLE_ID, 0) <> nvl(:new.GCO_QUALITY_PRINCIPLE_ID, 0) )
       or (nvl(:old.GCO_SUBSTITUTION_LIST_ID, 0) <> nvl(:new.GCO_SUBSTITUTION_LIST_ID, 0) )
       or (nvl(:old.PAC_PAC_SUPPLIER_PARTNER_ID, 0) <> nvl(:new.PAC_PAC_SUPPLIER_PARTNER_ID, 0) )
       or (nvl(:old.PAC_SUPPLIER_PARTNER_ID, 0) <> nvl(:new.PAC_SUPPLIER_PARTNER_ID, 0) )
       or (nvl(:old.STM_LOCATION_ID, 0) <> nvl(:new.STM_LOCATION_ID, 0) )
       or (nvl(:old.STM_STOCK_ID, 0) <> nvl(:new.STM_STOCK_ID, 0) ) then
      rep_functions.PublishArticle(:new.GCO_GOOD_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_CPU_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_CSA_AIU_REPLICATE"
  after insert or update
  on GCO_COMPL_DATA_SALE
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author fperotto/pzuchetto
 * @author spfister
 * @date 11.2002
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result integer;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if    (nvl(:old.CDA_COMMENT, ' ') <> nvl(:new.CDA_COMMENT, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_EAN_CODE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_EAN_CODE, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_REFERENCE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_REFERENCE, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_UCC14_CODE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_UCC14_CODE, ' ') )
       or (nvl(:old.CDA_CONVERSION_FACTOR, 0) <> nvl(:new.CDA_CONVERSION_FACTOR, 0) )
       or (nvl(:old.CDA_FREE_ALPHA_1, ' ') <> nvl(:new.CDA_FREE_ALPHA_1, ' ') )
       or (nvl(:old.CDA_FREE_ALPHA_2, ' ') <> nvl(:new.CDA_FREE_ALPHA_2, ' ') )
       or (nvl(:old.CDA_FREE_DEC_1, 0) <> nvl(:new.CDA_FREE_DEC_1, 0) )
       or (nvl(:old.CDA_FREE_DEC_2, 0) <> nvl(:new.CDA_FREE_DEC_2, 0) )
       or (nvl(:old.CDA_FREE_DESCRIPTION, ' ') <> nvl(:new.CDA_FREE_DESCRIPTION, ' ') )
       or (nvl(:old.CDA_LONG_DESCRIPTION, ' ') <> nvl(:new.CDA_LONG_DESCRIPTION, ' ') )
       or (nvl(:old.CDA_NUMBER_OF_DECIMAL, 0) <> nvl(:new.CDA_NUMBER_OF_DECIMAL, 0) )
       or (nvl(:old.CDA_SECONDARY_REFERENCE, ' ') <> nvl(:new.CDA_SECONDARY_REFERENCE, ' ') )
       or (nvl(:old.CDA_SHORT_DESCRIPTION, ' ') <> nvl(:new.CDA_SHORT_DESCRIPTION, ' ') )
       or (nvl(:old.CSA_DELIVERY_DELAY, 0) <> nvl(:new.CSA_DELIVERY_DELAY, 0) )
       or (nvl(:old.CSA_DISPATCHING_DELAY, 0) <> nvl(:new.CSA_DISPATCHING_DELAY, 0) )
       or (nvl(:old.CSA_GAUGE_TYPE_POS_MANDATORY, 0) <> nvl(:new.CSA_GAUGE_TYPE_POS_MANDATORY, 0) )
       or (nvl(:old.CSA_GOOD_PACKED, 0) <> nvl(:new.CSA_GOOD_PACKED, 0) )
       or (nvl(:old.CSA_HIBC_CODE, ' ') <> nvl(:new.CSA_HIBC_CODE, ' ') )
       or (nvl(:old.CSA_LAPSING_MARGE, 0) <> nvl(:new.CSA_LAPSING_MARGE, 0) )
       or (nvl(:old.CSA_QTY_CONDITIONING, 0) <> nvl(:new.CSA_QTY_CONDITIONING, 0) )
       or (nvl(:old.CSA_SCALE_LINK, 0) <> nvl(:new.CSA_SCALE_LINK, 0) )
       or (nvl(:old.CSA_SHIPPING_CAUTION, ' ') <> nvl(:new.CSA_SHIPPING_CAUTION, ' ') )
       or (nvl(:old.CSA_STACKABLE, 0) <> nvl(:new.CSA_STACKABLE, 0) )
       or (nvl(:old.CSA_TH_SUPPLY_DELAY, 0) <> nvl(:new.CSA_TH_SUPPLY_DELAY, 0) )
       or (nvl(:old.C_GAUGE_TYPE_POS, ' ') <> nvl(:new.C_GAUGE_TYPE_POS, ' ') )
       or (nvl(:old.DIC_COMPLEMENTARY_DATA_ID, ' ') <> nvl(:new.DIC_COMPLEMENTARY_DATA_ID, ' ') )
       or (nvl(:old.DIC_PACKING_TYPE_ID, ' ') <> nvl(:new.DIC_PACKING_TYPE_ID, ' ') )
       or (nvl(:old.DIC_UNIT_OF_MEASURE_ID, ' ') <> nvl(:new.DIC_UNIT_OF_MEASURE_ID, ' ') )
       or (nvl(:old.GCO_GOOD_ID, 0) <> nvl(:new.GCO_GOOD_ID, 0) )
       or (nvl(:old.GCO_QUALITY_PRINCIPLE_ID, 0) <> nvl(:new.GCO_QUALITY_PRINCIPLE_ID, 0) )
       or (nvl(:old.GCO_SUBSTITUTION_LIST_ID, 0) <> nvl(:new.GCO_SUBSTITUTION_LIST_ID, 0) )
       or (nvl(:old.PAC_CUSTOM_PARTNER_ID, 0) <> nvl(:new.PAC_CUSTOM_PARTNER_ID, 0) )
       or (nvl(:old.STM_LOCATION_ID, 0) <> nvl(:new.STM_LOCATION_ID, 0) )
       or (nvl(:old.STM_STOCK_ID, 0) <> nvl(:new.STM_STOCK_ID, 0) ) then
      rep_functions.PublishArticle(:new.GCO_GOOD_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_CSA_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_CST_AIU_REPLICATE"
  after insert or update
  on GCO_COMPL_DATA_STOCK
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author fperotto/pzuchetto
 * @author spfister
 * @date 11.2002
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result integer;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if    (nvl(:old.CDA_COMMENT, ' ') <> nvl(:new.CDA_COMMENT, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_EAN_CODE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_EAN_CODE, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_REFERENCE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_REFERENCE, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_UCC14_CODE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_UCC14_CODE, ' ') )
       or (nvl(:old.CDA_CONVERSION_FACTOR, 0) <> nvl(:new.CDA_CONVERSION_FACTOR, 0) )
       or (nvl(:old.CDA_FREE_ALPHA_1, ' ') <> nvl(:new.CDA_FREE_ALPHA_1, ' ') )
       or (nvl(:old.CDA_FREE_ALPHA_2, ' ') <> nvl(:new.CDA_FREE_ALPHA_2, ' ') )
       or (nvl(:old.CDA_FREE_DEC_1, 0) <> nvl(:new.CDA_FREE_DEC_1, 0) )
       or (nvl(:old.CDA_FREE_DEC_2, 0) <> nvl(:new.CDA_FREE_DEC_2, 0) )
       or (nvl(:old.CDA_FREE_DESCRIPTION, ' ') <> nvl(:new.CDA_FREE_DESCRIPTION, ' ') )
       or (nvl(:old.CDA_LONG_DESCRIPTION, ' ') <> nvl(:new.CDA_LONG_DESCRIPTION, ' ') )
       or (nvl(:old.CDA_NUMBER_OF_DECIMAL, 0) <> nvl(:new.CDA_NUMBER_OF_DECIMAL, 0) )
       or (nvl(:old.CDA_SECONDARY_REFERENCE, ' ') <> nvl(:new.CDA_SECONDARY_REFERENCE, ' ') )
       or (nvl(:old.CDA_SHORT_DESCRIPTION, ' ') <> nvl(:new.CDA_SHORT_DESCRIPTION, ' ') )
       or (nvl(:old.CST_NUMBER_PERIOD, 0) <> nvl(:new.CST_NUMBER_PERIOD, 0) )
       or (nvl(:old.CST_OBTAINING_MULTIPLE, 0) <> nvl(:new.CST_OBTAINING_MULTIPLE, 0) )
       or (nvl(:old.CST_PERIOD_VALUE, 0) <> nvl(:new.CST_PERIOD_VALUE, 0) )
       or (nvl(:old.CST_PROPRIETOR_STOCK, 0) <> nvl(:new.CST_PROPRIETOR_STOCK, 0) )
       or (nvl(:old.CST_QUANTITY_MAX, 0) <> nvl(:new.CST_QUANTITY_MAX, 0) )
       or (nvl(:old.CST_QUANTITY_MIN, 0) <> nvl(:new.CST_QUANTITY_MIN, 0) )
       or (nvl(:old.CST_QUANTITY_OBTAINING_STOCK, 0) <> nvl(:new.CST_QUANTITY_OBTAINING_STOCK, 0) )
       or (nvl(:old.CST_STORING_CAUTION, ' ') <> nvl(:new.CST_STORING_CAUTION, ' ') )
       or (nvl(:old.CST_TRANSFERT_DELAY, 0) <> nvl(:new.CST_TRANSFERT_DELAY, 0) )
       or (nvl(:old.CST_TRIGGER_POINT, 0) <> nvl(:new.CST_TRIGGER_POINT, 0) )
       or (nvl(:old.DIC_COMPLEMENTARY_DATA_ID, ' ') <> nvl(:new.DIC_COMPLEMENTARY_DATA_ID, ' ') )
       or (nvl(:old.DIC_UNIT_OF_MEASURE_ID, ' ') <> nvl(:new.DIC_UNIT_OF_MEASURE_ID, ' ') )
       or (nvl(:old.GCO_GOOD_ID, 0) <> nvl(:new.GCO_GOOD_ID, 0) )
       or (nvl(:old.GCO_QUALITY_PRINCIPLE_ID, 0) <> nvl(:new.GCO_QUALITY_PRINCIPLE_ID, 0) )
       or (nvl(:old.GCO_SUBSTITUTION_LIST_ID, 0) <> nvl(:new.GCO_SUBSTITUTION_LIST_ID, 0) )
       or (nvl(:old.STM_LOCATION_ID, 0) <> nvl(:new.STM_LOCATION_ID, 0) )
       or (nvl(:old.STM_STOCK_ID, 0) <> nvl(:new.STM_STOCK_ID, 0) ) then
      rep_functions.PublishArticle(:new.GCO_GOOD_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_CST_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_CUS_AIU_REPLICATE"
  after insert or update
  on GCO_CUSTOMS_ELEMENT
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author pzuchetto
 * @author spfister
 * @date 03.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result integer;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if    (nvl(:old.CUS_CHARGE_RATE, 0) <> nvl(:new.CUS_CHARGE_RATE, 0) )
       or (nvl(:old.CUS_COMMISSION_RATE, 0) <> nvl(:new.CUS_COMMISSION_RATE, 0) )
       or (nvl(:old.CUS_CONVERSION_FACTOR, 0) <> nvl(:new.CUS_CONVERSION_FACTOR, 0) )
       or (nvl(:old.CUS_CUSTONS_POSITION, ' ') <> nvl(:new.CUS_CUSTONS_POSITION, ' ') )
       or (nvl(:old.CUS_EXCISE_RATE, 0) <> nvl(:new.CUS_EXCISE_RATE, 0) )
       or (nvl(:old.CUS_KEY_TARIFF, 0) <> nvl(:new.CUS_KEY_TARIFF, 0) )
       or (nvl(:old.CUS_LICENCE_NUMBER, 0) <> nvl(:new.CUS_LICENCE_NUMBER, 0) )
       or (nvl(:old.CUS_RATE_FOR_VALUE, 0) <> nvl(:new.CUS_RATE_FOR_VALUE, 0) )
       or (nvl(:old.CUS_TRANSPORT_INFORMATION, ' ') <> nvl(:new.CUS_TRANSPORT_INFORMATION, ' ') )
       or (nvl(:old.C_CUSTOMS_ELEMENT_TYPE, ' ') <> nvl(:new.C_CUSTOMS_ELEMENT_TYPE, ' ') )
       or (nvl(:old.DIC_REPAYMENT_CODE_ID, ' ') <> nvl(:new.DIC_REPAYMENT_CODE_ID, ' ') )
       or (nvl(:old.DIC_SUBJUGATED_LICENCE_ID, ' ') <> nvl(:new.DIC_SUBJUGATED_LICENCE_ID, ' ') )
       or (nvl(:old.DIC_UNIT_OF_MEASURE_ID, ' ') <> nvl(:new.DIC_UNIT_OF_MEASURE_ID, ' ') )
       or (nvl(:old.GCO_GOOD_ID, 0) <> nvl(:new.GCO_GOOD_ID, 0) )
       or (nvl(:old.PC_CNTRY_ID, 0) <> nvl(:new.PC_CNTRY_ID, 0) )
       or (nvl(:old.PC_ORIGIN_PC_CNTRY_ID, 0) <> nvl(:new.PC_ORIGIN_PC_CNTRY_ID, 0) ) then
      rep_functions.PublishArticle(:new.GCO_GOOD_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_CUS_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_DATA_AIU_REPLICATE"
  after insert or update
  on GCO_FREE_DATA
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author fperotto/pzuchetto
 * @author spfister
 * @date 11.2002
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result integer;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if    (nvl(:old.DATA_ALPHA_COURT_1, ' ') <> nvl(:new.DATA_ALPHA_COURT_1, ' ') )
       or (nvl(:old.DATA_ALPHA_COURT_2, ' ') <> nvl(:new.DATA_ALPHA_COURT_2, ' ') )
       or (nvl(:old.DATA_ALPHA_COURT_3, ' ') <> nvl(:new.DATA_ALPHA_COURT_3, ' ') )
       or (nvl(:old.DATA_ALPHA_COURT_4, ' ') <> nvl(:new.DATA_ALPHA_COURT_4, ' ') )
       or (nvl(:old.DATA_ALPHA_COURT_5, ' ') <> nvl(:new.DATA_ALPHA_COURT_5, ' ') )
       or (nvl(:old.DATA_ALPHA_LONG_1, ' ') <> nvl(:new.DATA_ALPHA_LONG_1, ' ') )
       or (nvl(:old.DATA_ALPHA_LONG_2, ' ') <> nvl(:new.DATA_ALPHA_LONG_2, ' ') )
       or (nvl(:old.DATA_ALPHA_LONG_3, ' ') <> nvl(:new.DATA_ALPHA_LONG_3, ' ') )
       or (nvl(:old.DATA_ALPHA_LONG_4, ' ') <> nvl(:new.DATA_ALPHA_LONG_4, ' ') )
       or (nvl(:old.DATA_ALPHA_LONG_5, ' ') <> nvl(:new.DATA_ALPHA_LONG_5, ' ') )
       or (nvl(:old.DATA_BOOLEAN_1, 0) <> nvl(:new.DATA_BOOLEAN_1, 0) )
       or (nvl(:old.DATA_BOOLEAN_2, 0) <> nvl(:new.DATA_BOOLEAN_2, 0) )
       or (nvl(:old.DATA_BOOLEAN_3, 0) <> nvl(:new.DATA_BOOLEAN_3, 0) )
       or (nvl(:old.DATA_BOOLEAN_4, 0) <> nvl(:new.DATA_BOOLEAN_4, 0) )
       or (nvl(:old.DATA_BOOLEAN_5, 0) <> nvl(:new.DATA_BOOLEAN_5, 0) )
       or (nvl(:old.DATA_DEC_1, 0) <> nvl(:new.DATA_DEC_1, 0) )
       or (nvl(:old.DATA_DEC_2, 0) <> nvl(:new.DATA_DEC_2, 0) )
       or (nvl(:old.DATA_DEC_3, 0) <> nvl(:new.DATA_DEC_3, 0) )
       or (nvl(:old.DATA_DEC_4, 0) <> nvl(:new.DATA_DEC_4, 0) )
       or (nvl(:old.DATA_DEC_5, 0) <> nvl(:new.DATA_DEC_5, 0) )
       or (nvl(:old.DATA_INTEGER_1, 0) <> nvl(:new.DATA_INTEGER_1, 0) )
       or (nvl(:old.DATA_INTEGER_2, 0) <> nvl(:new.DATA_INTEGER_2, 0) )
       or (nvl(:old.DATA_INTEGER_3, 0) <> nvl(:new.DATA_INTEGER_3, 0) )
       or (nvl(:old.DATA_INTEGER_4, 0) <> nvl(:new.DATA_INTEGER_4, 0) )
       or (nvl(:old.DATA_INTEGER_5, 0) <> nvl(:new.DATA_INTEGER_5, 0) )
       or (nvl(:old.DATA_UNIT_PRICE_SALE, 0) <> nvl(:new.DATA_UNIT_PRICE_SALE, 0) )
       or (nvl(:old.DIC_FREE_TABLE_1_ID, ' ') <> nvl(:new.DIC_FREE_TABLE_1_ID, ' ') )
       or (nvl(:old.DIC_FREE_TABLE_2_ID, ' ') <> nvl(:new.DIC_FREE_TABLE_2_ID, ' ') )
       or (nvl(:old.DIC_FREE_TABLE_3_ID, ' ') <> nvl(:new.DIC_FREE_TABLE_3_ID, ' ') )
       or (nvl(:old.DIC_FREE_TABLE_4_ID, ' ') <> nvl(:new.DIC_FREE_TABLE_4_ID, ' ') )
       or (nvl(:old.DIC_FREE_TABLE_5_ID, ' ') <> nvl(:new.DIC_FREE_TABLE_5_ID, ' ') )
       or (nvl(:old.GCO_GOOD_ID, 0) <> nvl(:new.GCO_GOOD_ID, 0) ) then
      rep_functions.PublishArticle(:new.GCO_GOOD_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_DATA_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_DES_AIUD_SHP_GCO_PUBLISH"
  after insert or update or delete
  on GCO_DESCRIPTION
  referencing old as old new as new
  for each row
/**
* Description
*    Ajout de l' ID de l'élément concerné dans la table SHP_TO_PUBLISH pour republication
*    Selon le type de description touchée.
* @created PYV 22.12.2011
* @lastUpdate AGE 07.06.2012
*/
declare
  lnResult integer;
begin
  if PCS.PC_CONFIG.GetConfig(aConfigName => 'SHP_SHOP_VERSION', aCompanyID => PCS.PC_I_LIB_SESSION.GetCompanyId, aConliID => null) =
                                                                                                                  SHP_I_LIB_TYPES.gcvExternalShopConnectorValue then
    if     deleting
       and :old.C_DESCRIPTION_TYPE in('09', '10') then
      lnResult  :=
        SHP_PRC_PUBLISH.publishRecord(inStpRecID        => :old.GCO_GOOD_ID
                                    , ivStpContext      => 'PRODUCT'
                                    , ivGooWebStatus    => '1'
                                    , ivShopDocStatus   => null
                                    , ivShopDocNumber   => null
                                     );
    elsif :new.C_DESCRIPTION_TYPE in('01', '09', '10') then
      lnResult  :=
        SHP_PRC_PUBLISH.publishRecord(inStpRecID        => :new.GCO_GOOD_ID
                                    , ivStpContext      => 'PRODUCT'
                                    , ivGooWebStatus    => '1'
                                    , ivShopDocStatus   => null
                                    , ivShopDocNumber   => null
                                     );
    end if;
  end if;
end GCO_DES_AIUD_SHP_GCO_PUBLISH;

ALTER TRIGGER "C_ITX"."GCO_DES_AIUD_SHP_GCO_PUBLISH" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_DES_AIU_REPLICATE"
  after insert or update
  on GCO_DESCRIPTION
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author fperotto/pzuchetto
 * @author spfister
 * @date 11.2002
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result integer;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if    (nvl(:old.C_DESCRIPTION_TYPE, ' ') <> nvl(:new.C_DESCRIPTION_TYPE, ' ') )
       or (nvl(:old.DES_FREE_DESCRIPTION, ' ') <> nvl(:new.DES_FREE_DESCRIPTION, ' ') )
       or (nvl(:old.DES_LONG_DESCRIPTION, ' ') <> nvl(:new.DES_LONG_DESCRIPTION, ' ') )
       or (nvl(:old.DES_SHORT_DESCRIPTION, ' ') <> nvl(:new.DES_SHORT_DESCRIPTION, ' ') )
       or (nvl(:old.GCO_GOOD_ID, 0) <> nvl(:new.GCO_GOOD_ID, 0) )
       or (nvl(:old.GCO_MULTIMEDIA_ELEMENT_ID, 0) <> nvl(:new.GCO_MULTIMEDIA_ELEMENT_ID, 0) )
       or (nvl(:old.PC_LANG_ID, 0) <> nvl(:new.PC_LANG_ID, 0) ) then
      rep_functions.PublishArticle(:new.GCO_GOOD_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_DES_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_DIU_AIU_REPLICATE"
  after insert or update
  on GCO_COMPL_DATA_DISTRIB
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author fperotto/pzuchetto
 * @author spfister
 * @date 07.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result integer;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if    (nvl(:old.CDA_COMMENT, ' ') <> nvl(:new.CDA_COMMENT, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_EAN_CODE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_EAN_CODE, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_REFERENCE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_REFERENCE, ' ') )
       or (nvl(:old.CDA_COMPLEMENTARY_UCC14_CODE, ' ') <> nvl(:new.CDA_COMPLEMENTARY_UCC14_CODE, ' ') )
       or (nvl(:old.CDA_CONVERSION_FACTOR, 0) <> nvl(:new.CDA_CONVERSION_FACTOR, 0) )
       or (nvl(:old.CDA_FREE_ALPHA_1, ' ') <> nvl(:new.CDA_FREE_ALPHA_1, ' ') )
       or (nvl(:old.CDA_FREE_ALPHA_2, ' ') <> nvl(:new.CDA_FREE_ALPHA_2, ' ') )
       or (nvl(:old.CDA_FREE_DEC_1, 0) <> nvl(:new.CDA_FREE_DEC_1, 0) )
       or (nvl(:old.CDA_FREE_DEC_2, 0) <> nvl(:new.CDA_FREE_DEC_2, 0) )
       or (nvl(:old.CDA_FREE_DESCRIPTION, ' ') <> nvl(:new.CDA_FREE_DESCRIPTION, ' ') )
       or (nvl(:old.CDA_LONG_DESCRIPTION, ' ') <> nvl(:new.CDA_LONG_DESCRIPTION, ' ') )
       or (nvl(:old.CDA_NUMBER_OF_DECIMAL, 0) <> nvl(:new.CDA_NUMBER_OF_DECIMAL, 0) )
       or (nvl(:old.CDA_SECONDARY_REFERENCE, ' ') <> nvl(:new.CDA_SECONDARY_REFERENCE, ' ') )
       or (nvl(:old.CDA_SHORT_DESCRIPTION, ' ') <> nvl(:new.CDA_SHORT_DESCRIPTION, ' ') )
       or (nvl(:old.CDI_BLOCKED_FROM, to_date('01011900', 'DDMMYYYY') ) <> nvl(:new.CDI_BLOCKED_FROM, to_date('01011900', 'DDMMYYYY') ) )
       or (nvl(:old.CDI_BLOCKED_TO, to_date('01011900', 'DDMMYYYY') ) <> nvl(:new.CDI_BLOCKED_TO, to_date('01011900', 'DDMMYYYY') ) )
       or (nvl(:old.CDI_COVER_PERCENT, 0) <> nvl(:new.CDI_COVER_PERCENT, 0) )
       or (nvl(:old.CDI_ECONOMICAL_QUANTITY, 0) <> nvl(:new.CDI_ECONOMICAL_QUANTITY, 0) )
       or (nvl(:old.CDI_PRIORITY_CODE, 0) <> nvl(:new.CDI_PRIORITY_CODE, 0) )
       or (nvl(:old.CDI_STOCK_MAX, 0) <> nvl(:new.CDI_STOCK_MAX, 0) )
       or (nvl(:old.CDI_STOCK_MIN, 0) <> nvl(:new.CDI_STOCK_MIN, 0) )
       or (nvl(:old.C_DRP_DOC_MODE, ' ') <> nvl(:new.C_DRP_DOC_MODE, ' ') )
       or (nvl(:old.C_DRP_QTY_RULE, ' ') <> nvl(:new.C_DRP_QTY_RULE, ' ') )
       or (nvl(:old.C_DRP_RELIQUAT, ' ') <> nvl(:new.C_DRP_RELIQUAT, ' ') )
       or (nvl(:old.C_DRP_USE_COVER_PERCENT, ' ') <> nvl(:new.C_DRP_USE_COVER_PERCENT, ' ') )
       or (nvl(:old.DIC_COMPLEMENTARY_DATA_ID, ' ') <> nvl(:new.DIC_COMPLEMENTARY_DATA_ID, ' ') )
       or (nvl(:old.DIC_DISTRIB_COMPL_DATA_ID, ' ') <> nvl(:new.DIC_DISTRIB_COMPL_DATA_ID, ' ') )
       or (nvl(:old.DIC_UNIT_OF_MEASURE_ID, ' ') <> nvl(:new.DIC_UNIT_OF_MEASURE_ID, ' ') )
       or (nvl(:old.GCO_GOOD_ID, 0) <> nvl(:new.GCO_GOOD_ID, 0) )
       or (nvl(:old.GCO_PRODUCT_GROUP_ID, 0) <> nvl(:new.GCO_PRODUCT_GROUP_ID, 0) )
       or (nvl(:old.GCO_QUALITY_PRINCIPLE_ID, 0) <> nvl(:new.GCO_QUALITY_PRINCIPLE_ID, 0) )
       or (nvl(:old.GCO_SUBSTITUTION_LIST_ID, 0) <> nvl(:new.GCO_SUBSTITUTION_LIST_ID, 0) )
       or (nvl(:old.STM_DISTRIBUTION_UNIT_ID, 0) <> nvl(:new.STM_DISTRIBUTION_UNIT_ID, 0) )
       or (nvl(:old.STM_LOCATION_ID, 0) <> nvl(:new.STM_LOCATION_ID, 0) )
       or (nvl(:old.STM_STOCK_ID, 0) <> nvl(:new.STM_STOCK_ID, 0) ) then
      rep_functions.PublishArticle(:new.GCO_GOOD_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_DIU_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_DLA_AIU_REPLICATE"
  after insert or update
  on GCO_DESC_LANGUAGE
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author jsomers
 * @author spfister
 * @date 12.2002
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result  integer;
  ln_good_id gco_good.gco_good_id%type   := null;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if    (nvl(:old.C_TYPE_DESC_LANG, ' ') <> nvl(:new.C_TYPE_DESC_LANG, ' ') )
       or (nvl(:old.DLA_DESCRIPTION, ' ') <> nvl(:new.DLA_DESCRIPTION, ' ') )
       or
--       (Nvl(:old.GCO_BASE_CHARACTERIZATION_ID,0) <> Nvl(:new.GCO_BASE_CHARACTERIZATION_ID,0)) or
--       (Nvl(:old.GCO_BASE_ELEMENT_CHARAC_ID,0) <> Nvl(:new.GCO_BASE_ELEMENT_CHARAC_ID,0)) or
          (nvl(:old.GCO_CHARACTERISTIC_ELEMENT_ID, 0) <> nvl(:new.GCO_CHARACTERISTIC_ELEMENT_ID, 0) )
       or (nvl(:old.GCO_CHARACTERIZATION_ID, 0) <> nvl(:new.GCO_CHARACTERIZATION_ID, 0) )
       or (nvl(:old.PC_LANG_ID, 0) <> nvl(:new.PC_LANG_ID, 0) ) then
      begin
        if (:new.GCO_CHARACTERIZATION_ID is not null) then
          begin
            select gco_good_id
              into ln_good_id
              from gco_characterization
             where gco_characterization_id = :new.gco_characterization_id;
          exception
            when no_data_found then
              null;
          end;
        elsif(:new.GCO_CHARACTERISTIC_ELEMENT_ID is not null) then
          begin
            select gco_good_id
              into ln_good_id
              from gco_characterization
             where gco_characterization_id = (select gco_characterization_id
                                                from gco_characteristic_element
                                               where gco_characteristic_element_id = :new.gco_characteristic_element_id);
          exception
            when no_data_found then
              null;
          end;
        end if;

        if (ln_good_id is not null) then
          rep_functions.PublishArticle(ln_good_id, ln_result);
        end if;
      end;
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_DLA_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_FCO_AIU_REPLICATE"
  after insert or update
  on GCO_FREE_CODE
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author fperotto/pzuchetto
 * @author spfister
 * @date 11.2002
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result integer;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if    (nvl(:old.DIC_GCO_BOOLEAN_CODE_TYPE_ID, ' ') <> nvl(:new.DIC_GCO_BOOLEAN_CODE_TYPE_ID, ' ') )
       or (nvl(:old.DIC_GCO_CHAR_CODE_TYPE_ID, ' ') <> nvl(:new.DIC_GCO_CHAR_CODE_TYPE_ID, ' ') )
       or (nvl(:old.DIC_GCO_DATE_CODE_TYPE_ID, ' ') <> nvl(:new.DIC_GCO_DATE_CODE_TYPE_ID, ' ') )
       or (nvl(:old.DIC_GCO_MEMO_CODE_TYPE_ID, ' ') <> nvl(:new.DIC_GCO_MEMO_CODE_TYPE_ID, ' ') )
       or (nvl(:old.DIC_GCO_NUMBER_CODE_TYPE_ID, ' ') <> nvl(:new.DIC_GCO_NUMBER_CODE_TYPE_ID, ' ') )
       or (nvl(:old.FCO_BOO_CODE, 0) <> nvl(:new.FCO_BOO_CODE, 0) )
       or (nvl(:old.FCO_CHA_CODE, ' ') <> nvl(:new.FCO_CHA_CODE, ' ') )
       or (nvl(:old.FCO_DAT_CODE, to_date('01011900', 'DDMMYYYY') ) <> nvl(:new.FCO_DAT_CODE, to_date('01011900', 'DDMMYYYY') ) )
       or (nvl(:old.FCO_MEM_CODE, ' ') <> nvl(:new.FCO_MEM_CODE, ' ') )
       or (nvl(:old.FCO_NUM_CODE, 0) <> nvl(:new.FCO_NUM_CODE, 0) )
       or (nvl(:old.GCO_GOOD_ID, 0) <> nvl(:new.GCO_GOOD_ID, 0) ) then
      rep_functions.PublishArticle(:new.GCO_GOOD_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_FCO_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_GAT_AIU_REPLICATE"
  after insert or update
  on GCO_GOOD_ATTRIBUTE
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author fperotto/pzuchetto
 * @author spfister
 * @date 11.2002
 * Modifications:
 * spfister 10.08.2012::
 *   - SolvaQueuing
 * spfister 03.10.2008:
 *   - Suppression des tests entre les valeurs de :OLD et :NEW
 */
declare
  ln_result integer;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    rep_functions.PublishArticle(:new.GCO_GOOD_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_GAT_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_GFN_AIU_REPLICATE"
  after insert or update
  on GCO_FREE_NUMBER
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication d'une catégorie d'article.
 * @author pzuchetto
 * @author spfister
 * @date 06.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1 and
      rep_lib_replicate.IsCategoryReplicable(:new.GCO_GOOD_CATEGORY_ID) = 1) then
    if (Nvl(:old.C_CALC_FORMULA,' ') <> Nvl(:new.C_CALC_FORMULA,' ')) or
       (Nvl(:old.C_NUMBERING_TYPE,' ') <> Nvl(:new.C_NUMBERING_TYPE,' ')) or
       (Nvl(:old.GCO_GOOD_CATEGORY_ID,0) <> Nvl(:new.GCO_GOOD_CATEGORY_ID,0)) or
       (Nvl(:old.GFN_GOOD_NUMBERING_ID,0) <> Nvl(:new.GFN_GOOD_NUMBERING_ID,0)) or
       (Nvl(:old.GFN_NUMBER,' ') <> Nvl(:new.GFN_NUMBER,' ')) or
       (Nvl(:old.GFN_RESERVED,0) <> Nvl(:new.GFN_RESERVED,0)) then
      rep_functions.PublishGoodCategory(:new.GCO_GOOD_CATEGORY_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_GFN_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_GOO_AD_REPLICATE"
  after delete
  on GCO_GOOD
  referencing old as old new as new
  for each row
/**
 *
 * Traitment lié au déclenchement des triggers liés à la réplication d'un bien.
 *   voir trigger GCO_GOO_BD_REPLICATE
 * @author ngomes
 * @date 04.05.2015
 */
begin
  -- Indiquer que le bien n'est plus en train d'être effacé
  GCO_PRC_GOOD.SetGoodDeleting(iGoodID => :old.GCO_GOOD_ID, iDeleting => False);
end GCO_GOO_AD_REPLICATE;

ALTER TRIGGER "C_ITX"."GCO_GOO_AD_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_GOO_AI_CALC_DATA"
  after insert
  on GCO_GOOD
  referencing new as new
  for each row
/**
* Description
*   Création automatique d'un enregistrement dans GCO_GOOD_CALC_DATA
*   lors de l'insertion d'un bien
* @created fp 06.05.2003
* @updated fp 04.02.2014 - DEVERP-20145 FDA - VE - Revoir la gestion du statut 4 (En inventaire)
*/
begin
  -- insertion d'un record dans GCO_GOOD_CALC_DATA avec les valeurs par défaut
  insert into GCO_GOOD_CALC_DATA
              (GCO_GOOD_ID
             , GOO_BASE_COST_PRICE
             , GOO_ADDED_QTY_COST_PRICE
             , GOO_ADDED_VALUE_COST_PRICE
             , GOO_LAST_INVENTORY_DATE
             , GOO_INV_POS_COUNTER
             , GOO_IN_INVENTORY
             , A_DATECRE
             , A_IDCRE
              )
       values (:new.GCO_GOOD_ID
             , 0
             , 0
             , 0
             , null
             , 0
             , 0
             , sysdate
             , :new.A_IDCRE
              );
end GCO_GOO_AI_CALC_DATA;

ALTER TRIGGER "C_ITX"."GCO_GOO_AI_CALC_DATA" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_GOO_AIUD_SHP_GCO_PUBLISH"
  after insert or update or delete
of GOO_WEB_PUBLISHED, GOO_WEB_VISUAL_LEVEL, GOO_WEB_ORDERABILITY_LEVEL, GOO_WEB_CAN_BE_ORDERED
on GCO_GOOD
  referencing old as old new as new
  for each row
/**
* Description
*    Ajout de l'ID du bien dans la table SHP_TO_PUBLISH pour (re)publication un suppression si la valeur des champs suivants est modifiée :
*    - GOO_WEB_PUBLISHED ("Produit publiable")
*    - GOO_WEB_VISUAL_LEVEL ("Niveau de visibilité")
*    - GOO_WEB_ORDERABILITY_LEVEL ("Niveau de commande")
*    - GOO_WEB_CAN_BE_ORDERED ("Commandable")
* @created PYV 22.12.2011
* @lastUpdate age 11.02.2013
*/
declare
  lnResult integer;
  lContext varchar2(10) := 'PRODUCT';
begin
  if PCS.PC_CONFIG.GetConfig(aConfigName => 'SHP_SHOP_VERSION', aCompanyID => PCS.PC_I_LIB_SESSION.GetCompanyId, aConliID => null) =
                                                                                                                  SHP_I_LIB_TYPES.gcvExternalShopConnectorValue then
    if updating then
      if     :old.GOO_WEB_PUBLISHED = 1
         and :new.GOO_WEB_PUBLISHED = 1
         /* Niveau de visualisation a changé sur un produit publiable --> Republication du bien */
         and (   nvl(:new.GOO_WEB_VISUAL_LEVEL, 0) <> nvl(:old.GOO_WEB_VISUAL_LEVEL, 0)
              or
                 /* Niveau de commande a changé sur un produit publiable --> Republication du bien */
                 nvl(:new.GOO_WEB_ORDERABILITY_LEVEL, 0) <> nvl(:old.GOO_WEB_ORDERABILITY_LEVEL, 0)
              or
                 /* Commandable a changé sur un produit publiable --> Republication du bien */
                 :new.GOO_WEB_CAN_BE_ORDERED <> :old.GOO_WEB_CAN_BE_ORDERED
             ) then
        lnResult  := SHP_PRC_PUBLISH.publishRecord(inStpRecID => :new.GCO_GOOD_ID, ivStpContext => lContext, ivGooWebStatus => '1');  --2
      /* Le bien devient publiable --> Publication du bien */
      elsif     :old.GOO_WEB_PUBLISHED = 0
            and :new.GOO_WEB_PUBLISHED = 1 then
        lnResult  := SHP_PRC_PUBLISH.publishRecord(inStpRecID => :new.GCO_GOOD_ID, ivStpContext => lContext, ivGooWebStatus => '1');
      /* Le bien n'est plus publiable --> Supression de la publication du bien */
      elsif     :old.GOO_WEB_PUBLISHED = 1
            and :new.GOO_WEB_PUBLISHED = 0 then
        lnResult  := SHP_PRC_PUBLISH.publishRecord(inStpRecID => :new.GCO_GOOD_ID, ivStpContext => lContext, ivGooWebStatus => '3');
      end if;
    elsif inserting then
      /* Nouveau bien publiable --> Publication du bien */
      if :new.GOO_WEB_PUBLISHED = 1 then
        lnResult  := SHP_PRC_PUBLISH.publishRecord(inStpRecID => :new.GCO_GOOD_ID, ivStpContext => lContext, ivGooWebStatus => '1');
      end if;
    elsif deleting then
      /* Supression d'un bien publiable --> Suppression de la publication du bien */
      if :old.GOO_WEB_PUBLISHED = 1 then
        lnResult  := SHP_PRC_PUBLISH.publishRecord(inStpRecID => :old.GCO_GOOD_ID, ivStpContext => lContext, ivGooWebStatus => '3');
      end if;
    end if;
  end if;
end GCO_GOO_AIUD_SHP_GCO_PUBLISH;

ALTER TRIGGER "C_ITX"."GCO_GOO_AIUD_SHP_GCO_PUBLISH" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_GOO_AIU_REPLICATE"
  after insert or update
  on GCO_GOOD
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author fperotto/pzuchetto
 * @author spfister
 * @date 02.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result integer;
begin
  if rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1 then
    if    (nvl(:old.C_GOOD_STATUS, ' ') <> nvl(:new.C_GOOD_STATUS, ' ') )
       or (nvl(:old.C_GOO_WEB_STATUS, ' ') <> nvl(:new.C_GOO_WEB_STATUS, ' ') )
       or (nvl(:old.C_MANAGEMENT_MODE, ' ') <> nvl(:new.C_MANAGEMENT_MODE, ' ') )
       or (nvl(:old.C_SERVICE_GOOD_LINK, ' ') <> nvl(:new.C_SERVICE_GOOD_LINK, ' ') )
       or (nvl(:old.C_SERVICE_KIND, ' ') <> nvl(:new.C_SERVICE_KIND, ' ') )
       or (nvl(:old.C_SERVICE_RENEWAL, ' ') <> nvl(:new.C_SERVICE_RENEWAL, ' ') )
       or (nvl(:old.DIC_ACCOUNTABLE_GROUP_ID, ' ') <> nvl(:new.DIC_ACCOUNTABLE_GROUP_ID, ' ') )
       or (nvl(:old.DIC_COMMISSIONING_ID, ' ') <> nvl(:new.DIC_COMMISSIONING_ID, ' ') )
       or (nvl(:old.DIC_GCO_STATISTIC_10_ID, ' ') <> nvl(:new.DIC_GCO_STATISTIC_10_ID, ' ') )
       or (nvl(:old.DIC_GCO_STATISTIC_1_ID, ' ') <> nvl(:new.DIC_GCO_STATISTIC_1_ID, ' ') )
       or (nvl(:old.DIC_GCO_STATISTIC_2_ID, ' ') <> nvl(:new.DIC_GCO_STATISTIC_2_ID, ' ') )
       or (nvl(:old.DIC_GCO_STATISTIC_3_ID, ' ') <> nvl(:new.DIC_GCO_STATISTIC_3_ID, ' ') )
       or (nvl(:old.DIC_GCO_STATISTIC_4_ID, ' ') <> nvl(:new.DIC_GCO_STATISTIC_4_ID, ' ') )
       or (nvl(:old.DIC_GCO_STATISTIC_5_ID, ' ') <> nvl(:new.DIC_GCO_STATISTIC_5_ID, ' ') )
       or (nvl(:old.DIC_GCO_STATISTIC_6_ID, ' ') <> nvl(:new.DIC_GCO_STATISTIC_6_ID, ' ') )
       or (nvl(:old.DIC_GCO_STATISTIC_7_ID, ' ') <> nvl(:new.DIC_GCO_STATISTIC_7_ID, ' ') )
       or (nvl(:old.DIC_GCO_STATISTIC_8_ID, ' ') <> nvl(:new.DIC_GCO_STATISTIC_8_ID, ' ') )
       or (nvl(:old.DIC_GCO_STATISTIC_9_ID, ' ') <> nvl(:new.DIC_GCO_STATISTIC_9_ID, ' ') )
       or (nvl(:old.DIC_GOOD_FAMILY_ID, ' ') <> nvl(:new.DIC_GOOD_FAMILY_ID, ' ') )
       or (nvl(:old.DIC_GOOD_GROUP_ID, ' ') <> nvl(:new.DIC_GOOD_GROUP_ID, ' ') )
       or (nvl(:old.DIC_GOOD_LINE_ID, ' ') <> nvl(:new.DIC_GOOD_LINE_ID, ' ') )
       or (nvl(:old.DIC_GOOD_MODEL_ID, ' ') <> nvl(:new.DIC_GOOD_MODEL_ID, ' ') )
       or (nvl(:old.DIC_GOO_WEB_CATEG1_ID, ' ') <> nvl(:new.DIC_GOO_WEB_CATEG1_ID, ' ') )
       or (nvl(:old.DIC_GOO_WEB_CATEG2_ID, ' ') <> nvl(:new.DIC_GOO_WEB_CATEG2_ID, ' ') )
       or (nvl(:old.DIC_GOO_WEB_CATEG3_ID, ' ') <> nvl(:new.DIC_GOO_WEB_CATEG3_ID, ' ') )
       or (nvl(:old.DIC_GOO_WEB_CATEG4_ID, ' ') <> nvl(:new.DIC_GOO_WEB_CATEG4_ID, ' ') )
       or (nvl(:old.DIC_PTC_GOOD_GROUP_ID, ' ') <> nvl(:new.DIC_PTC_GOOD_GROUP_ID, ' ') )
       or (nvl(:old.DIC_PUR_TARIFF_STRUCT_ID, ' ') <> nvl(:new.DIC_PUR_TARIFF_STRUCT_ID, ' ') )
       or (nvl(:old.DIC_SALE_TARIFF_STRUCT_ID, ' ') <> nvl(:new.DIC_SALE_TARIFF_STRUCT_ID, ' ') )
       or (nvl(:old.DIC_SET_TYPE_ID, ' ') <> nvl(:new.DIC_SET_TYPE_ID, ' ') )
       or (nvl(:old.DIC_TARIFF_ID, ' ') <> nvl(:new.DIC_TARIFF_ID, ' ') )
       or (nvl(:old.DIC_TARIFF_SET_PURCHASE_ID, ' ') <> nvl(:new.DIC_TARIFF_SET_PURCHASE_ID, ' ') )
       or (nvl(:old.DIC_TARIFF_SET_SALE_ID, ' ') <> nvl(:new.DIC_TARIFF_SET_SALE_ID, ' ') )
       or (nvl(:old.DIC_UNIT_OF_MEASURE_ID, ' ') <> nvl(:new.DIC_UNIT_OF_MEASURE_ID, ' ') )
       or
--       (Nvl(:old.GCO_DATA_INVENTORY,0) <> Nvl(:new.GCO_DATA_INVENTORY,0)) or
--       (Nvl(:old.GCO_DATA_MANUFACTURE,0) <> Nvl(:new.GCO_DATA_MANUFACTURE,0)) or
--       (Nvl(:old.GCO_DATA_PURCHASE,0) <> Nvl(:new.GCO_DATA_PURCHASE,0)) or
--       (Nvl(:old.GCO_DATA_SALE,0) <> Nvl(:new.GCO_DATA_SALE,0)) or
--       (Nvl(:old.GCO_DATA_SAV,0) <> Nvl(:new.GCO_DATA_SAV,0)) or
--       (Nvl(:old.GCO_DATA_STOCK,0) <> Nvl(:new.GCO_DATA_STOCK,0)) or
--       (Nvl(:old.GCO_DATA_SUBCONTRACT,0) <> Nvl(:new.GCO_DATA_SUBCONTRACT,0)) or
          (nvl(:old.GCO_GOOD_CATEGORY_ID, 0) <> nvl(:new.GCO_GOOD_CATEGORY_ID, 0) )
       or (nvl(:old.GCO_GOOD_OLE_OBJECT, ' ') <> nvl(:new.GCO_GOOD_OLE_OBJECT, ' ') )
       or (nvl(:old.GCO_MULTIMEDIA_ELEMENT_ID, 0) <> nvl(:new.GCO_MULTIMEDIA_ELEMENT_ID, 0) )
       or (nvl(:old.GCO_PRODUCT_GROUP_ID, 0) <> nvl(:new.GCO_PRODUCT_GROUP_ID, 0) )
       or (nvl(:old.GCO_SUBSTITUTION_LIST_ID, 0) <> nvl(:new.GCO_SUBSTITUTION_LIST_ID, 0) )
       or (nvl(:old.GOO_CCP_MANAGEMENT, 0) <> nvl(:new.GOO_CCP_MANAGEMENT, 0) )
       or
--       (Nvl(:old.GOO_CHRONO1_ID,0) <> Nvl(:new.GOO_CHRONO1_ID,0)) or
--       (Nvl(:old.GOO_CONTRACT_CONDITION,CLOB) <> Nvl(:new.GOO_CONTRACT_CONDITION,CLOB)) or
          (nvl(:old.GOO_EAN_CODE, ' ') <> nvl(:new.GOO_EAN_CODE, ' ') )
       or (nvl(:old.GOO_EAN_CODE_AUTO_GEN, 0) <> nvl(:new.GOO_EAN_CODE_AUTO_GEN, 0) )
       or (nvl(:old.GOO_EAN_UCC14_CODE, ' ') <> nvl(:new.GOO_EAN_UCC14_CODE, ' ') )
       or (nvl(:old.GOO_HIBC_PRIMARY_CODE, ' ') <> nvl(:new.GOO_HIBC_PRIMARY_CODE, ' ') )
       or (nvl(:old.GOO_HIBC_REFERENCE, ' ') <> nvl(:new.GOO_HIBC_REFERENCE, ' ') )
       or (nvl(:old.GOO_INNOVATION_FROM, to_date('01011900', 'DDMMYYYY') ) <> nvl(:new.GOO_INNOVATION_FROM, to_date('01011900', 'DDMMYYYY') ) )
       or (nvl(:old.GOO_INNOVATION_TO, to_date('01011900', 'DDMMYYYY') ) <> nvl(:new.GOO_INNOVATION_TO, to_date('01011900', 'DDMMYYYY') ) )
       or (nvl(:old.GOO_MAJOR_REFERENCE, ' ') <> nvl(:new.GOO_MAJOR_REFERENCE, ' ') )
       or (nvl(:old.GOO_NUMBER_OF_DECIMAL, 0) <> nvl(:new.GOO_NUMBER_OF_DECIMAL, 0) )
       or (nvl(:old.GOO_OBSOLETE, 0) <> nvl(:new.GOO_OBSOLETE, 0) )
       or
--       (Nvl(:old.GOO_PIECE1_ID,0) <> Nvl(:new.GOO_PIECE1_ID,0)) or
--       (Nvl(:old.GOO_PIECE2_ID,0) <> Nvl(:new.GOO_PIECE2_ID,0)) or
--       (Nvl(:old.GOO_PIECE3_ID,0) <> Nvl(:new.GOO_PIECE3_ID,0)) or
          (nvl(:old.GOO_PRECIOUS_MAT, 0) <> nvl(:new.GOO_PRECIOUS_MAT, 0) )
       or (nvl(:old.GOO_SECONDARY_REFERENCE, ' ') <> nvl(:new.GOO_SECONDARY_REFERENCE, ' ') )
       or
--       (Nvl(:old.GOO_SET1_ID,0) <> Nvl(:new.GOO_SET1_ID,0)) or
--       (Nvl(:old.GOO_SET2_ID,0) <> Nvl(:new.GOO_SET2_ID,0)) or
--       (Nvl(:old.GOO_SET3_ID,0) <> Nvl(:new.GOO_SET3_ID,0)) or
--       (Nvl(:old.GOO_STD_CHAR1_ID,0) <> Nvl(:new.GOO_STD_CHAR1_ID,0)) or
--       (Nvl(:old.GOO_STD_CHAR2_ID,0) <> Nvl(:new.GOO_STD_CHAR2_ID,0)) or
--       (Nvl(:old.GOO_STD_CHAR3_ID,0) <> Nvl(:new.GOO_STD_CHAR3_ID,0)) or
  --     (Nvl(:old.GOO_STD_CHAR4_ID,0) <> Nvl(:new.GOO_STD_CHAR4_ID,0)) or
--       (Nvl(:old.GOO_STD_CHAR5_ID,0) <> Nvl(:new.GOO_STD_CHAR5_ID,0)) or
          (nvl(:old.GOO_STD_FIXED_QUANTITY_WASTE, 0) <> nvl(:new.GOO_STD_FIXED_QUANTITY_WASTE, 0) )
       or (nvl(:old.GOO_STD_PERCENT_WASTE, 0) <> nvl(:new.GOO_STD_PERCENT_WASTE, 0) )
       or (nvl(:old.GOO_STD_QTY_REFERENCE_LOSS, 0) <> nvl(:new.GOO_STD_QTY_REFERENCE_LOSS, 0) )
       or
--       (Nvl(:old.GOO_TO_PUBLISH,0) <> Nvl(:new.GOO_TO_PUBLISH,0)) or
          (nvl(:old.GOO_UNSPSC, ' ') <> nvl(:new.GOO_UNSPSC, ' ') )
       or (nvl(:old.GOO_VERSION1_ID, 0) <> nvl(:new.GOO_VERSION1_ID, 0) )
       or (nvl(:old.GOO_WEB_ALIAS, ' ') <> nvl(:new.GOO_WEB_ALIAS, ' ') )
       or (nvl(:old.GOO_WEB_ATTACHEMENT_URL, ' ') <> nvl(:new.GOO_WEB_ATTACHEMENT_URL, ' ') )
       or (nvl(:old.GOO_WEB_PICTURE_URL, ' ') <> nvl(:new.GOO_WEB_PICTURE_URL, ' ') )
       or (nvl(:old.GOO_WEB_PUBLISHED, 0) <> nvl(:new.GOO_WEB_PUBLISHED, 0) ) then
      if (rep_lib_replicate.IsCategoryReplicable(:new.GCO_GOOD_CATEGORY_ID) = 1) then
        ln_result  := rep_functions.PublishRecord(:new.GCO_GOOD_ID, 'GCO_PRODUCT');
      end if;
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_GOO_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_GOO_BD_CASCADE"
  before delete
  on GCO_GOOD
  referencing old as old new as new
  for each row
/**
* Description
*    remplace les contraintes avec effacement en cascade
* @author Fabrice Perotto
* @lastUpdate age 04.12.2012
*/
declare
  temp number(12);
begin
  -- controle si le bien est utilisé dans GCO_CHARACTERIZATION
  select max(GCO_CHARACTERIZATION_ID)
    into temp
    from GCO_CHARACTERIZATION
   where GCO_GOOD_ID = :old.GCO_GOOD_ID;

  if temp is not null then
    delete from GCO_CHARACTERIZATION
          where GCO_GOOD_ID = :old.GCO_GOOD_ID;
  end if;

  -- controle si le bien a été utilisé dans l'assistant de caractérisations GCO_CHAR_WIZARD_LOG
  select max(GCO_CHAR_WIZARD_LOG_ID)
    into temp
    from GCO_CHAR_WIZARD_LOG
   where GCO_GOOD_ID = :old.GCO_GOOD_ID;

  if temp is not null then
    delete from GCO_CHAR_WIZARD_LOG
          where GCO_GOOD_ID = :old.GCO_GOOD_ID;
  end if;

  -- controle si le bien est utilisé dans STM_ELEMENT_NUMBER
  select max(STM_ELEMENT_NUMBER_ID)
    into temp
    from STM_ELEMENT_NUMBER
   where GCO_GOOD_ID = :old.GCO_GOOD_ID;

  if temp is not null then
    STM_PRC_ELEMENT_NUMBER.DeleteDetail(iGoodID => :old.GCO_GOOD_ID);
  end if;

  -- controle si le bien est utilisé dans PAC_REP_STRUCTURE
  select max(PAC_REP_STRUCTURE_ID)
    into temp
    from PAC_REP_STRUCTURE
   where GCO_GOOD_ID = :old.GCO_GOOD_ID;

  if temp is not null then
    delete from PAC_REP_STRUCTURE
          where GCO_GOOD_ID = :old.GCO_GOOD_ID;
  end if;

  -- controle si le bien est utilisé dans GCO_PACKING_ELEMENT
  select max(GCO_PACKING_ELEMENT_ID)
    into temp
    from GCO_PACKING_ELEMENT
   where GCO_GOOD_ID = :old.GCO_GOOD_ID;

  if temp is not null then
    delete from GCO_PACKING_ELEMENT
          where GCO_GOOD_ID = :old.GCO_GOOD_ID;
  end if;

  -- controle si le bien est utilisé dans GCO_GOOD_CALC_DATA
  select max(GCO_GOOD_ID)
    into temp
    from GCO_GOOD_CALC_DATA
   where GCO_GOOD_ID = :old.GCO_GOOD_ID;

  if temp is not null then
    delete from GCO_GOOD_CALC_DATA
          where GCO_GOOD_ID = :old.GCO_GOOD_ID;
  end if;

  -- controle si le bien est utilisé dans COM_IMAGE_FILES
  select max(IMF_REC_ID)
    into temp
    from COM_IMAGE_FILES
   where IMF_TABLE = 'GCO_GOOD'
     and IMF_REC_ID = :old.GCO_GOOD_ID;

  if temp is not null then
    delete from COM_IMAGE_FILES
          where IMF_TABLE = 'GCO_GOOD'
            and IMF_REC_ID = :old.GCO_GOOD_ID;
  end if;

  -- controle si le bien est utilisé dans COM_BITMAP
  select max(BIT_TABLE_ID)
    into temp
    from COM_BITMAP
   where BIT_TABLE = 'GCO_PRODUCT'
     and BIT_TABLE_ID = :old.GCO_GOOD_ID;

  if temp is not null then
    delete from COM_BITMAP
          where BIT_TABLE = 'GCO_PRODUCT'
            and BIT_TABLE_ID = :old.GCO_GOOD_ID;
  end if;

  -- controle si le bien est utilisé dans les "biens associés" (WEB_GOOD)
  select max(GCO_GOOD_ID)
    into temp
    from WEB_GOOD
   where GCO_GOOD_ID = :old.GCO_GOOD_ID;

  if temp is not null then
    delete from WEB_GOOD
          where GCO_GOOD_ID = :old.GCO_GOOD_ID;
  end if;

  select max(GCO_GOOD_ID)
    into temp
    from FAL_PROD_LEVEL
   where GCO_GOOD_ID = :old.GCO_GOOD_ID;

  if temp is not null then
    delete from FAL_PROD_LEVEL
          where GCO_GOOD_ID = :old.GCO_GOOD_ID;
  end if;
end GCO_GOO_BD_CASCADE;

ALTER TRIGGER "C_ITX"."GCO_GOO_BD_CASCADE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_GOO_BD_REPLICATE"
  before delete
  on GCO_GOOD
  referencing old as old new as new
  for each row
/**
 * Empecher le déclenchement des triggers liés à la réplication d'un bien.
 *   en indicant que le bien est en train d'être effacé
 * @author ngomes
 * @date 04.05.2015
 */
begin
  -- Indiquer que le bien est en train d'être effacé
  GCO_PRC_GOOD.SetGoodDeleting(iGoodID => :old.GCO_GOOD_ID, iDeleting => True);
end GCO_GOO_BD_REPLICATE;

ALTER TRIGGER "C_ITX"."GCO_GOO_BD_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_GOO_BD_RESTRICT"
  before delete
  on GCO_GOOD
  referencing old as old new as new
  for each row
/**
* Description
*     Remplace les contraintes restrict sur GCO_GOOD
* @author Fabrice Perotto
* @version 2003
*/
declare
  -- exception dans le cas ou l'on obtient le message table is mutating, trigger cannot see it
  table_mutating exception;
  pragma exception_init(table_mutating, -4091);

  lv_Message   varchar2(4000);
begin
  if (:old.GOO_WEB_PUBLISHED = 1) or
     (:old.C_GOO_WEB_STATUS = '1') or
     (:old.C_GOO_WEB_STATUS = '2') then
    raise_application_error(-20100, PCS.PC_FUNCTIONS.TranslateWord('Ce produit est publié (WEB).'));
  end if;
end GCO_GOO_BD_RESTRICT;

ALTER TRIGGER "C_ITX"."GCO_GOO_BD_RESTRICT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_GOO_BU_CTRL_HIBC"
  before update of GOO_HIBC_PRIMARY_CODE
  on GCO_GOOD
  referencing new as new old as old
  for each row
/**
* Description
*   Gestion du caractère espace en dernière position du code HIBC primaire
* @created dsa 29.12.2004
* @version 2003
* @lastUpdate
*/
declare
  vLength number(2);
begin
  if nvl(:new.GOO_HIBC_PRIMARY_CODE, 'null') <> nvl(:old.GOO_HIBC_PRIMARY_CODE, 'null') then
    -- test sur la longueur du code HIBC
    vLength  := length(:new.GOO_HIBC_REFERENCE) + length(Gco_Barcode_Functions.GetHIBC_LIC) + 3;

    if length(:new.GOO_HIBC_PRIMARY_CODE) = vLength - 1 then
      if Gco_Barcode_Functions.ControlHIBC(:new.GOO_HIBC_PRIMARY_CODE || ' ') is null then
        :new.GOO_HIBC_PRIMARY_CODE  := :new.GOO_HIBC_PRIMARY_CODE || ' ';
      else
        :new.GOO_HIBC_PRIMARY_CODE  := '';
      end if;
    end if;
  end if;
end GCO_GOO_BU_CTRL_HIBC;


ALTER TRIGGER "C_ITX"."GCO_GOO_BU_CTRL_HIBC" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_GPM_BI_INIT_FIELDS"
  before insert
  on GCO_PRECIOUS_MAT
  referencing old as old new as new
  for each row
/**
* Description
*    Initialisation des données systèmes
* @author VJ
* @created 17.03.2004
* @version 2003
*/
declare
begin
  if :new.GCO_PRECIOUS_MAT_ID is null then
    select INIT_ID_SEQ.nextval
      into :new.GCO_PRECIOUS_MAT_ID
      from dual;
  end if;
end GCO_GPM_BI_INIT_FIELDS;


ALTER TRIGGER "C_ITX"."GCO_GPM_BI_INIT_FIELDS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_MAT_AIU_REPLICATE"
  after insert or update
  on GCO_MATERIAL
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author pzuchetto
 * @author spfister
 * @date 03.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result integer;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if    (nvl(:old.DIC_MATERIAL_KIND_ID, ' ') <> nvl(:new.DIC_MATERIAL_KIND_ID, ' ') )
       or (nvl(:old.DIC_UNIT_OF_MEASURE_ID, ' ') <> nvl(:new.DIC_UNIT_OF_MEASURE_ID, ' ') )
       or (nvl(:old.GCO_GOOD_ID, 0) <> nvl(:new.GCO_GOOD_ID, 0) )
       or (nvl(:old.MAT_COMMENT, ' ') <> nvl(:new.MAT_COMMENT, ' ') )
       or (nvl(:old.MAT_GEM_NUMBER, 0) <> nvl(:new.MAT_GEM_NUMBER, 0) )
       or (nvl(:old.MAT_MATERIAL_WEIGHT, 0) <> nvl(:new.MAT_MATERIAL_WEIGHT, 0) ) then
      rep_functions.PublishArticle(:new.GCO_GOOD_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_MAT_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_MEA_AIU_REPLICATE"
  after insert or update
  on GCO_MEASUREMENT_WEIGHT
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author pzuchetto
 * @author spfister
 * @date 03.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result integer;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if    (nvl(:old.DIC_SHAPE_TYPE_ID, ' ') <> nvl(:new.DIC_SHAPE_TYPE_ID, ' ') )
       or (nvl(:old.GCO_GOOD_ID, 0) <> nvl(:new.GCO_GOOD_ID, 0) )
       or (nvl(:old.MEA_GROSS_DEPTH, 0) <> nvl(:new.MEA_GROSS_DEPTH, 0) )
       or (nvl(:old.MEA_GROSS_HEIGHT, 0) <> nvl(:new.MEA_GROSS_HEIGHT, 0) )
       or (nvl(:old.MEA_GROSS_LENGTH, 0) <> nvl(:new.MEA_GROSS_LENGTH, 0) )
       or (nvl(:old.MEA_GROSS_SURFACE, 0) <> nvl(:new.MEA_GROSS_SURFACE, 0) )
       or (nvl(:old.MEA_GROSS_VOLUME, 0) <> nvl(:new.MEA_GROSS_VOLUME, 0) )
       or (nvl(:old.MEA_GROSS_WEIGHT, 0) <> nvl(:new.MEA_GROSS_WEIGHT, 0) )
       or (nvl(:old.MEA_NET_DEPTH, 0) <> nvl(:new.MEA_NET_DEPTH, 0) )
       or (nvl(:old.MEA_NET_HEIGHT, 0) <> nvl(:new.MEA_NET_HEIGHT, 0) )
       or (nvl(:old.MEA_NET_LENGTH, 0) <> nvl(:new.MEA_NET_LENGTH, 0) )
       or (nvl(:old.MEA_NET_MANAGEMENT, 0) <> nvl(:new.MEA_NET_MANAGEMENT, 0) )
       or (nvl(:old.MEA_NET_SURFACE, 0) <> nvl(:new.MEA_NET_SURFACE, 0) )
       or (nvl(:old.MEA_NET_VOLUME, 0) <> nvl(:new.MEA_NET_VOLUME, 0) )
       or (nvl(:old.MEA_NET_WEIGHT, 0) <> nvl(:new.MEA_NET_WEIGHT, 0) ) then
      rep_functions.PublishArticle(:new.GCO_GOOD_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_MEA_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_PDT_AIU_REPLICATE"
  after insert or update
  on GCO_PRODUCT
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author fperotto/pzuchetto
 * @author spfister
 * @date 11.2002
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result integer;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if    (nvl(:old.C_PRODUCT_DELIVERY_TYP, ' ') <> nvl(:new.C_PRODUCT_DELIVERY_TYP, ' ') )
       or (nvl(:old.C_PRODUCT_TYPE, ' ') <> nvl(:new.C_PRODUCT_TYPE, ' ') )
       or (nvl(:old.C_SUPPLY_MODE, ' ') <> nvl(:new.C_SUPPLY_MODE, ' ') )
       or (nvl(:old.C_SUPPLY_TYPE, ' ') <> nvl(:new.C_SUPPLY_TYPE, ' ') )
       or (nvl(:old.DIC_DEL_TYP_EXPLAIN_ID, ' ') <> nvl(:new.DIC_DEL_TYP_EXPLAIN_ID, ' ') )
       or (nvl(:old.DIC_UNIT_OF_MEASURE1_ID, ' ') <> nvl(:new.DIC_UNIT_OF_MEASURE1_ID, ' ') )
       or (nvl(:old.DIC_UNIT_OF_MEASURE2_ID, ' ') <> nvl(:new.DIC_UNIT_OF_MEASURE2_ID, ' ') )
       or (nvl(:old.DIC_UNIT_OF_MEASURE_ID, ' ') <> nvl(:new.DIC_UNIT_OF_MEASURE_ID, ' ') )
       or (nvl(:old.GCO2_GCO_GOOD_ID, 0) <> nvl(:new.GCO2_GCO_GOOD_ID, 0) )
       or (nvl(:old.GCO_DANGEROUS_TRANSP_ADR_ID, 0) <> nvl(:new.GCO_DANGEROUS_TRANSP_ADR_ID, 0) )
       or (nvl(:old.GCO_DANGEROUS_TRANSP_IATA_ID, 0) <> nvl(:new.GCO_DANGEROUS_TRANSP_IATA_ID, 0) )
       or (nvl(:old.GCO_DANGEROUS_TRANSP_IMDG_ID, 0) <> nvl(:new.GCO_DANGEROUS_TRANSP_IMDG_ID, 0) )
       or (nvl(:old.GCO_GCO_SERVICE_ID, 0) <> nvl(:new.GCO_GCO_SERVICE_ID, 0) )
       or (nvl(:old.GCO_GOOD_ID, 0) <> nvl(:new.GCO_GOOD_ID, 0) )
       or (nvl(:old.PAC_SUPPLIER_PARTNER_ID, 0) <> nvl(:new.PAC_SUPPLIER_PARTNER_ID, 0) )
       or (nvl(:old.PDT_ALTERNATIVE_QUANTITY_1, 0) <> nvl(:new.PDT_ALTERNATIVE_QUANTITY_1, 0) )
       or (nvl(:old.PDT_ALTERNATIVE_QUANTITY_2, 0) <> nvl(:new.PDT_ALTERNATIVE_QUANTITY_2, 0) )
       or (nvl(:old.PDT_ALTERNATIVE_QUANTITY_3, 0) <> nvl(:new.PDT_ALTERNATIVE_QUANTITY_3, 0) )
       or (nvl(:old.PDT_BLOCK_EQUI, 0) <> nvl(:new.PDT_BLOCK_EQUI, 0) )
       or (nvl(:old.PDT_CALC_REQUIREMENT_MNGMENT, 0) <> nvl(:new.PDT_CALC_REQUIREMENT_MNGMENT, 0) )
       or (nvl(:old.PDT_CONTINUOUS_INVENTAR, 0) <> nvl(:new.PDT_CONTINUOUS_INVENTAR, 0) )
       or (nvl(:old.PDT_CONVERSION_FACTOR_1, 0) <> nvl(:new.PDT_CONVERSION_FACTOR_1, 0) )
       or (nvl(:old.PDT_CONVERSION_FACTOR_2, 0) <> nvl(:new.PDT_CONVERSION_FACTOR_2, 0) )
       or (nvl(:old.PDT_CONVERSION_FACTOR_3, 0) <> nvl(:new.PDT_CONVERSION_FACTOR_3, 0) )
       or (nvl(:old.PDT_END_LIFE, 0) <> nvl(:new.PDT_END_LIFE, 0) )
       or (nvl(:old.PDT_FACT_STOCK, 0) <> nvl(:new.PDT_FACT_STOCK, 0) )
       or (nvl(:old.PDT_FULL_TRACABILITY, 0) <> nvl(:new.PDT_FULL_TRACABILITY, 0) )
       or (nvl(:old.PDT_FULL_TRACABILITY_COEF, 0) <> nvl(:new.PDT_FULL_TRACABILITY_COEF, 0) )
       or (nvl(:old.PDT_FULL_TRACABILITY_RULE, 0) <> nvl(:new.PDT_FULL_TRACABILITY_RULE, 0) )
       or (nvl(:old.PDT_FULL_TRACABILITY_SUPPLY, 0) <> nvl(:new.PDT_FULL_TRACABILITY_SUPPLY, 0) )
       or (nvl(:old.PDT_GUARANTY_USE, 0) <> nvl(:new.PDT_GUARANTY_USE, 0) )
       or (nvl(:old.PDT_MARK_NOMENCLATURE, 0) <> nvl(:new.PDT_MARK_NOMENCLATURE, 0) )
       or (nvl(:old.PDT_MARK_USED, 0) <> nvl(:new.PDT_MARK_USED, 0) )
       or (nvl(:old.PDT_MULTI_SOURCING, 0) <> nvl(:new.PDT_MULTI_SOURCING, 0) )
       or (nvl(:old.PDT_PIC, 0) <> nvl(:new.PDT_PIC, 0) )
       or (nvl(:old.PDT_SCALE_LINK, 0) <> nvl(:new.PDT_SCALE_LINK, 0) )
       or (nvl(:old.PDT_STOCK_ALLOC_BATCH, 0) <> nvl(:new.PDT_STOCK_ALLOC_BATCH, 0) )
       or (nvl(:old.PDT_STOCK_MANAGEMENT, 0) <> nvl(:new.PDT_STOCK_MANAGEMENT, 0) )
       or (nvl(:old.PDT_STOCK_OBTAIN_MANAGEMENT, 0) <> nvl(:new.PDT_STOCK_OBTAIN_MANAGEMENT, 0) )
       or (nvl(:old.PDT_THRESHOLD_MANAGEMENT, 0) <> nvl(:new.PDT_THRESHOLD_MANAGEMENT, 0) )
       or (nvl(:old.STM_LOCATION_ID, 0) <> nvl(:new.STM_LOCATION_ID, 0) )
       or (nvl(:old.STM_STOCK_ID, 0) <> nvl(:new.STM_STOCK_ID, 0) ) then
      rep_functions.PublishArticle(:new.GCO_GOOD_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_PDT_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_PDT_AU_MOD_FIELDS"
  after update of C_SUPPLY_MODE
                , STM_STOCK_ID
                , STM_LOCATION_ID
                , PDT_CONTINUOUS_INVENTAR
                , PDT_STOCK_MANAGEMENT
                , PDT_FULL_TRACABILITY
                , PDT_PIC
                , PDT_CALC_REQUIREMENT_MNGMENT
                , PDT_BLOCK_EQUI
                , PDT_GUARANTY_USE
                , PDT_STOCK_OBTAIN_MANAGEMENT
  on GCO_PRODUCT
  referencing old as old new as new
  for each row
/**
* Description
*     Ce Trigger permet de mettre à jour les champs A_DATEMOD et A_IDMOD  de la
*     table GCO_GOOD à partir d'une modification d'un champ de la table GCO_PRODUCT
* @version 2003
*/
begin
  update GCO_GOOD
     set A_DATEMOD = sysdate
       , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
   where GCO_GOOD_ID = :new.GCO_GOOD_ID;
end GCO_PDT_AU_MOD_FIELDS;

ALTER TRIGGER "C_ITX"."GCO_PDT_AU_MOD_FIELDS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_PDT_BU_STK_MANAGEMENT"
  before update of "PDT_STOCK_MANAGEMENT"
  on GCO_PRODUCT
  referencing old as old new as new
  for each row
/**
* Description
*     Ce trigger interdit de modifier le flag " Gestion stock" pour les
*     articles déjà référencés dans d'autres tables que GCO_PRODUCT
* @version 2003
*/
declare
  lLangID number(12);   --Réceptionne la langue du user ou 'Anglais'
begin
  -- Gestion de stock
  --   0 : Sans gestion de stock
  --   1 : Avec gestion de stock
  --   2 : Inventaire uniquement

  -- Ne permet pas de modifier le flag " Gestion stock" pour les articles déjà référencés dans d'autres tables
  --   Si on passe de 0 à (1 ou 2) ou l'inverse
  if     (:old.PDT_STOCK_MANAGEMENT <> :new.PDT_STOCK_MANAGEMENT)
     and (    (:old.PDT_STOCK_MANAGEMENT = 0)
          or (:new.PDT_STOCK_MANAGEMENT = 0) ) then
    --Recherche si produit est utilisé dans les tables
    --Le produit est référencé dans les tables
    if GCO_LIB_FUNCTIONS.IsProductInUse(iGoodId                    => :new.GCO_GOOD_ID
                                      , iSearchInStocks            => 0
                                      , iSearchInDocuments         => 0
                                      , iSearchInBatches           => 0
                                      , iSearchInBatchComponents   => 0
                                      , iSearchInBillOfMaterials   => 0
                                      , iSearchInStockMovements    => 1
                                      , iSearchInDocPosition       => 1
                                      , iSearchInWorshopInput      => 1
                                      , iSearchInNeed              => 1
                                      , iSearchInSupply            => 1
                                      , iSearchInBatchProp         => 1
                                      , iSearchInDocProp           => 1
                                      , iSearchInBatchDetail       => 1
                                      , iSearchInSubstitute        => 1
                                       ) = 1 then
      --Recherche de la langue du user ou Anglais par défaut
      select nvl(PCS.PC_I_LIB_SESSION.GetUserLangId, LAN.PC_LANG_ID)
        into lLangID
        from PCS.PC_LANG LAN
       where LAN.LANID = 'EN';

      RAISE_APPLICATION_ERROR(-20101, PCS.PC_FUNCTIONS.TranslateWord2('GCO_PDT_BU_STK_MANAGEMENT', lLangID) );
    else   -- Produit n'est pas référencé
      if :new.PDT_STOCK_MANAGEMENT = 0 then   -- Pas de gestion de stock
        --Suppression du lien sur les substitutions
        update GCO_GOOD
           set GCO_SUBSTITUTION_LIST_ID = null
             , A_DATEMOD = sysdate
             , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
         where GCO_GOOD_ID = :new.GCO_GOOD_ID;

        --Les caractérisations sont forcées à 'Sans gestion de stock'
        update GCO_CHARACTERIZATION
           set CHA_STOCK_MANAGEMENT = 0
             , A_DATEMOD = sysdate
             , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
         where GCO_GOOD_ID = :new.GCO_GOOD_ID;

        -- Suppression des données complémentaires de stock et d'inventaire
        delete from GCO_COMPL_DATA_STOCK
              where GCO_GOOD_ID = :new.GCO_GOOD_ID;

        delete from GCO_COMPL_DATA_INVENTORY
              where GCO_GOOD_ID = :new.GCO_GOOD_ID;

        --Suppression des liens du stock et emplacement des autres données
        --complémentaires
        update GCO_COMPL_DATA_PURCHASE
           set STM_STOCK_ID = null
             , STM_LOCATION_ID = null
             , A_DATEMOD = sysdate
             , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
         where GCO_GOOD_ID = :new.GCO_GOOD_ID;

        update GCO_COMPL_DATA_SALE
           set STM_STOCK_ID = null
             , STM_LOCATION_ID = null
             , A_DATEMOD = sysdate
             , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
         where GCO_GOOD_ID = :new.GCO_GOOD_ID;

        update GCO_COMPL_DATA_ASS
           set STM_STOCK_ID = null
             , STM_LOCATION_ID = null
             , A_DATEMOD = sysdate
             , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
         where GCO_GOOD_ID = :new.GCO_GOOD_ID;

        update GCO_COMPL_DATA_MANUFACTURE
           set STM_STOCK_ID = null
             , STM_LOCATION_ID = null
             , A_DATEMOD = sysdate
             , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
         where GCO_GOOD_ID = :new.GCO_GOOD_ID;

        update GCO_COMPL_DATA_SUBCONTRACT
           set STM_STOCK_ID = null
             , STM_LOCATION_ID = null
             , A_DATEMOD = sysdate
             , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
         where GCO_GOOD_ID = :new.GCO_GOOD_ID;
      end if;
    end if;
  end if;
end GCO_PDT_BU_STK_MANAGEMENT;

ALTER TRIGGER "C_ITX"."GCO_PDT_BU_STK_MANAGEMENT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_PMA_AIU_REPLICATE"
  after insert or update
  on GCO_PRECIOUS_MAT
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author spfister
 * @date 11.2008
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result integer;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if    (nvl(:old.GCO_ALLOY_ID, 0) <> nvl(:new.GCO_ALLOY_ID, 0) )
       or (nvl(:old.GCO_GOOD_ID, 0) <> nvl(:new.GCO_GOOD_ID, 0) )
       or (nvl(:old.GPM_THEORICAL_WEIGHT, 0) <> nvl(:new.GPM_THEORICAL_WEIGHT, 0) )
       or (nvl(:old.GPM_WEIGHT_DELIVER, 0) <> nvl(:new.GPM_WEIGHT_DELIVER, 0) )
       or (nvl(:old.GPM_WEIGHT_DELIVER_VALUE, 0) <> nvl(:new.GPM_WEIGHT_DELIVER_VALUE, 0) )
       or (nvl(:old.GPM_WEIGHT_DELIVER_AUTO, 0) <> nvl(:new.GPM_WEIGHT_DELIVER_AUTO, 0) )
       or (nvl(:old.GPM_LOSS_UNIT, 0) <> nvl(:new.GPM_LOSS_UNIT, 0) )
       or (nvl(:old.GPM_LOSS_PERCENT, 0) <> nvl(:new.GPM_LOSS_PERCENT, 0) )
       or (nvl(:old.GPM_WEIGHT_INVEST, 0) <> nvl(:new.GPM_WEIGHT_INVEST, 0) )
       or (nvl(:old.GPM_WEIGHT_INVEST_VALUE, 0) <> nvl(:new.GPM_WEIGHT_INVEST_VALUE, 0) )
       or (nvl(:old.GPM_WEIGHT_CHIP, 0) <> nvl(:new.GPM_WEIGHT_CHIP, 0) )
       or (nvl(:old.GPM_WEIGHT_INVEST_TOTAL, 0) <> nvl(:new.GPM_WEIGHT_INVEST_TOTAL, 0) )
       or (nvl(:old.GPM_FREE_NUMBER5, 0) <> nvl(:new.GPM_FREE_NUMBER5, 0) )
       or (nvl(:old.GPM_WEIGHT_CHIP_TOTAL, 0) <> nvl(:new.GPM_WEIGHT_CHIP_TOTAL, 0) )
       or (nvl(:old.GPM_LOSS_TOTAL, 0) <> nvl(:new.GPM_LOSS_TOTAL, 0) )
       or (nvl(:old.GPM_COMMENT, ' ') <> nvl(:new.GPM_COMMENT, ' ') )
       or (nvl(:old.DIC_FREE_PMAT1_ID, ' ') <> nvl(:new.DIC_FREE_PMAT1_ID, ' ') )
       or (nvl(:old.DIC_FREE_PMAT2_ID, ' ') <> nvl(:new.DIC_FREE_PMAT2_ID, ' ') )
       or (nvl(:old.DIC_FREE_PMAT3_ID, ' ') <> nvl(:new.DIC_FREE_PMAT3_ID, ' ') )
       or (nvl(:old.DIC_FREE_PMAT4_ID, ' ') <> nvl(:new.DIC_FREE_PMAT4_ID, ' ') )
       or (nvl(:old.DIC_FREE_PMAT5_ID, ' ') <> nvl(:new.DIC_FREE_PMAT5_ID, ' ') )
       or (nvl(:old.GPM_COMMENT2, ' ') <> nvl(:new.GPM_COMMENT2, ' ') )
       or (nvl(:old.GPM_STONE_NUMBER, 0) <> nvl(:new.GPM_STONE_NUMBER, 0) )
       or (nvl(:old.GPM_FREE_NUMBER1, 0) <> nvl(:new.GPM_FREE_NUMBER1, 0) )
       or (nvl(:old.GPM_FREE_NUMBER2, 0) <> nvl(:new.GPM_FREE_NUMBER2, 0) )
       or (nvl(:old.GPM_FREE_NUMBER3, 0) <> nvl(:new.GPM_FREE_NUMBER3, 0) )
       or (nvl(:old.GPM_FREE_NUMBER4, 0) <> nvl(:new.GPM_FREE_NUMBER4, 0) )
       or (nvl(:old.GPM_REAL_WEIGHT, 0) <> nvl(:new.GPM_REAL_WEIGHT, 0) )
       or (nvl(:old.GPM_WEIGHT, 0) <> nvl(:new.GPM_WEIGHT, 0) )
       or (nvl(:old.GPM_WEIGHT_INVEST_TOTAL_VALUE, 0) <> nvl(:new.GPM_WEIGHT_INVEST_TOTAL_VALUE, 0) ) then
      rep_functions.PublishArticle(:new.GCO_GOOD_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_PMA_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_SER_BD_CASCADE"
before delete
on GCO_SERVICE
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*    Effacements en cascade lors de la suppression d'un service
* @author Fabrice Perotto
* @version DEVELOP
*/


declare
  temp number(12);
begin

  -- controle si le service est utilisé dans GCO_CONTRACT_DATA
  select max(GCO_CONTRACT_DATA_ID) into temp
    from GCO_CONTRACT_DATA
    where GCO_GOOD_ID = :OLD.GCO_GOOD_ID;

  if temp is not null then
    delete from GCO_CONTRACT_DATA where GCO_GOOD_ID = :OLD.GCO_GOOD_ID;
  end if;

end GCO_SER_BD_CASCADE;


ALTER TRIGGER "C_ITX"."GCO_SER_BD_CASCADE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_SER_BD_RESTRICT"
before delete
on GCO_SERVICE
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*     Contraintes restrictives lors de l'effacement d'un service
* @author Fabrice Perotto
* @version DEVELOP
*/


declare
  temp number(12);
begin

  -- controle si le service est utilisé dans GCO_PRODUCT
  select max(GCO_GOOD_ID) into temp
    from GCO_PRODUCT
    where GCO_GCO_SERVICE_ID = :OLD.GCO_GOOD_ID;

  if temp is not null then
    raise_application_error(-20100,'PCS - This service is used in GCO_PRODUCT');
  end if;

end GCO_SER_BD_RESTRICT;


ALTER TRIGGER "C_ITX"."GCO_SER_BD_RESTRICT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_SER_PLAN_BD_CASCADE"
  before delete
  on GCO_SERVICE_PLAN
  referencing old as old new as new
  for each row
/**
* Description
*     remplace les contraintes avec effacement en cascade
* @author David Saadé
* @version 2003
*/
declare
  temp number(12);
begin
  -- controle si la donnée complémentaire est utilisée dans COM_IMAGE_FILES
  select max(IMF_REC_ID)
    into temp
    from COM_IMAGE_FILES
   where IMF_TABLE = 'GCO_SERVICE_PLAN'
     and IMF_REC_ID = :old.GCO_SERVICE_PLAN_ID;

  if temp is not null then
    delete from COM_IMAGE_FILES
          where IMF_TABLE = 'GCO_SERVICE_PLAN'
            and IMF_REC_ID = :old.GCO_SERVICE_PLAN_ID;
  end if;
end GCO_SER_PLAN_BD_CASCADE;

ALTER TRIGGER "C_ITX"."GCO_SER_PLAN_BD_CASCADE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_SHI_AIU_REPLICATE"
  after insert or update
  on GCO_PACKING_ELEMENT
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author pzuchetto
 * @author spfister
 * @date 03.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result  integer;
  ln_good_id gco_good.gco_good_id%type   := null;
begin
  if (    rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1
      and :new.GCO_COMPL_DATA_SALE_ID is not null) then
    if    (nvl(:old.GCO_COMPL_DATA_SALE_ID, 0) <> nvl(:new.GCO_COMPL_DATA_SALE_ID, 0) )
       or (nvl(:old.GCO_GOOD_ID, 0) <> nvl(:new.GCO_GOOD_ID, 0) )
       or (nvl(:old.SHI_COMMENT, ' ') <> nvl(:new.SHI_COMMENT, ' ') )
       or (nvl(:old.SHI_SEQ, 0) <> nvl(:new.SHI_SEQ, 0) )
       or (nvl(:old.SHI_QUOTA, 0) <> nvl(:new.SHI_QUOTA, 0) )
       or (nvl(:old.STM_LOCATION_ID, 0) <> nvl(:new.STM_LOCATION_ID, 0) )
       or (nvl(:old.STM_STOCK_ID, 0) <> nvl(:new.STM_STOCK_ID, 0) ) then
      begin
        select gco_good_id
          into ln_good_id
          from gco_compl_data_sale
         where gco_compl_data_sale_id = :new.gco_compl_data_sale_id;
      exception
        when no_data_found then
          null;
      end;

      if (ln_good_id is not null) then
        rep_functions.PublishArticle(ln_good_id, ln_result);
      end if;
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_SHI_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_TXA_AIU_REPLICATE"
  after insert or update
  on GCO_TEXT_ASSIGNEMENT
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication d'une catégorie d'article.
 * @author pzuchetto
 * @author spfister
 * @date 06.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1 and
      rep_lib_replicate.IsCategoryReplicable(:new.GCO_GOOD_CATEGORY_ID) = 1) then
    if (Nvl(:old.C_DESCRIPTION_TYPE,' ') <> Nvl(:new.C_DESCRIPTION_TYPE,' ')) or
       (Nvl(:old.C_SELECTED_TEXT_FIELD,' ') <> Nvl(:new.C_SELECTED_TEXT_FIELD,' ')) or
       (Nvl(:old.GCO_GOOD_CATEGORY_ID,0) <> Nvl(:new.GCO_GOOD_CATEGORY_ID,0)) or
       (Nvl(:old.TXA_CHARS_NOT_ALLOWED,' ') <> Nvl(:new.TXA_CHARS_NOT_ALLOWED,' ')) or
       (Nvl(:old.TXF_FORMULA_NUMBER,0) <> Nvl(:new.TXF_FORMULA_NUMBER,0)) then
      rep_functions.PublishGoodCategory(:new.GCO_GOOD_CATEGORY_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_TXA_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_VAG_AIU_REPLICATE"
  after insert or update
  on GCO_VAT_GOOD
  referencing old as old new as new
  for each row
/**
 * Replication d'un article.
 * @author fperotto/pzuchetto
 * @author spfister
 * @date 11.2002
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result integer;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if    (nvl(:old.ACS_VAT_DET_ACCOUNT_ID, 0) <> nvl(:new.ACS_VAT_DET_ACCOUNT_ID, 0) )
       or (nvl(:old.DIC_TYPE_VAT_GOOD_ID, ' ') <> nvl(:new.DIC_TYPE_VAT_GOOD_ID, ' ') )
       or (nvl(:old.GCO_GOOD_ID, 0) <> nvl(:new.GCO_GOOD_ID, 0) ) then
      rep_functions.PublishArticle(:new.GCO_GOOD_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_VAG_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_XLI_AIU_REPLICATE"
  after insert or update
  on GCO_TRANSFER_LIST
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication d'une catégorie d'article.
 * @author pzuchetto
 * @author spfister
 * @date 06.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1 and
      rep_lib_replicate.IsCategoryReplicable(:new.GCO_GOOD_CATEGORY_ID) = 1) then
    if (Nvl(:old.C_DEFAULT_REPL,' ') <> Nvl(:new.C_DEFAULT_REPL,' ')) or
       (Nvl(:old.C_TRANSFER_TYPE,' ') <> Nvl(:new.C_TRANSFER_TYPE,' ')) or
       (Nvl(:old.GCO_GOOD_CATEGORY_ID,0) <> Nvl(:new.GCO_GOOD_CATEGORY_ID,0)) or
       (Nvl(:old.PC_FLDSC_ID,0) <> Nvl(:new.PC_FLDSC_ID,0)) or
       (Nvl(:old.PC_TABLE_ID,0) <> Nvl(:new.PC_TABLE_ID,0)) or
       (Nvl(:old.XLI_FIELD_CONTENTS,' ') <> Nvl(:new.XLI_FIELD_CONTENTS,' ')) or
       (Nvl(:old.XLI_FIELD_LENGTH,0) <> Nvl(:new.XLI_FIELD_LENGTH,0)) or
       (Nvl(:old.XLI_FIELD_NAME,' ') <> Nvl(:new.XLI_FIELD_NAME,' ')) or
       (Nvl(:old.XLI_FIELD_TYPE,' ') <> Nvl(:new.XLI_FIELD_TYPE,' ')) or
       (Nvl(:old.XLI_NUMBER_OF_DECIMALS,0) <> Nvl(:new.XLI_NUMBER_OF_DECIMALS,0)) or
       (Nvl(:old.XLI_REQUIRED,0) <> Nvl(:new.XLI_REQUIRED,0)) or
       (Nvl(:old.XLI_SUBSTITUTION,0) <> Nvl(:new.XLI_SUBSTITUTION,0)) or
       (Nvl(:old.XLI_TABLE_NAME,' ') <> Nvl(:new.XLI_TABLE_NAME,' ')) then
      rep_functions.PublishGoodCategory(:new.GCO_GOOD_CATEGORY_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_XLI_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."GCO_XSU_AIU_REPLICATE"
  after insert or update
  on GCO_TRANSFER_SUBST
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication d'une catégorie d'article.
 * @author pzuchetto
 * @author spfister
 * @date 06.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
  ln_category_id gco_good_category.gco_good_category_id%TYPE := null;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    begin
      -- rechercher l'id de la catégorie via la table gco_transfer_list
      select gco_good_category_id
      into ln_category_id
      from gco_transfer_list
      where gco_transfer_list_id = :new.gco_transfer_list_id;
    exception
      when NO_DATA_FOUND then
        null;
    end;

    if (ln_category_id is not null) and (rep_lib_replicate.IsCategoryReplicable(ln_category_id) = 1) then
      if (Nvl(:old.GCO_TRANSFER_LIST_ID,0) <> Nvl(:new.GCO_TRANSFER_LIST_ID,0)) or
         (Nvl(:old.XSU_BOOLEAN_IN,0) <> Nvl(:new.XSU_BOOLEAN_IN,0)) or
         (Nvl(:old.XSU_BOOLEAN_OUT,0) <> Nvl(:new.XSU_BOOLEAN_OUT,0)) or
         (Nvl(:old.XSU_DATE_IN,to_date('01011900', 'DDMMYYYY')) <> Nvl(:new.XSU_DATE_IN,to_date('01011900', 'DDMMYYYY'))) or
         (Nvl(:old.XSU_DATE_OUT,to_date('01011900', 'DDMMYYYY')) <> Nvl(:new.XSU_DATE_OUT,to_date('01011900', 'DDMMYYYY'))) or
         (Nvl(:old.XSU_FLOAT_IN,0) <> Nvl(:new.XSU_FLOAT_IN,0)) or
         (Nvl(:old.XSU_FLOAT_OUT,0) <> Nvl(:new.XSU_FLOAT_OUT,0)) or
         (Nvl(:old.XSU_INTEGER_IN,0) <> Nvl(:new.XSU_INTEGER_IN,0)) or
         (Nvl(:old.XSU_INTEGER_OUT,0) <> Nvl(:new.XSU_INTEGER_OUT,0)) or
         (Nvl(:old.XSU_IS_DEFAULT_VALUE,0) <> Nvl(:new.XSU_IS_DEFAULT_VALUE,0)) or
         (Nvl(:old.XSU_ORIGINAL,' ') <> Nvl(:new.XSU_ORIGINAL,' ')) or
         (Nvl(:old.XSU_OTHER_IN,' ') <> Nvl(:new.XSU_OTHER_IN,' ')) or
         (Nvl(:old.XSU_OTHER_OUT,' ') <> Nvl(:new.XSU_OTHER_OUT,' ')) or
         (Nvl(:old.XSU_REPLACEMENT,' ') <> Nvl(:new.XSU_REPLACEMENT,' ')) or
         (Nvl(:old.XSU_STRING_IN,' ') <> Nvl(:new.XSU_STRING_IN,' ')) or
         (Nvl(:old.XSU_STRING_OUT,' ') <> Nvl(:new.XSU_STRING_OUT,' ')) then
        rep_functions.PublishGoodCategory(ln_category_id, ln_result);
      end if;
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."GCO_XSU_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."HRM_ELM_TRANSMISSION_BU"
before update on hrm_elm_transmission for each row
declare lx_xml xmltype;
-- 26.01.2017 RGU: nouvelle variable
vf_record_exists number;

begin
    IF DBMS_LOB.GETLENGTH(:new.elm_receipt_xml) > 0 then
        begin
            select extract(xmltype(:new.elm_receipt_xml),'//soap:Body/soap:Fault//FaultState//Description/text()','xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:ns3="http://www.swissdec.ch/schema/sd/20130514/SalaryDeclarationServiceTypes" xmlns="http://www.swissdec.ch/schema/sd/20130514/SalaryDeclarationContainer" xmlns:ns2="http://www.swissdec.ch/schema/sd/20130514/SalaryDeclaration"')
            into lx_xml from dual;
            /* Empêche d'avoir le message d'erreur et donc une réinitialisation automatique */
            if :new.c_elm_transmission_type = '4' and instr(lower(:new.elm_receipt_xml),'soap:fault')>0 then
                :new.elm_comment := --case when :new.elm_comment is not null then substr(:new.elm_comment||chr(10)||lx_xml.getclobval(),255) else substr(lx_xml.getclobval(),255) end;
                -- 26.01.2017 RGU: champ commentaire limité à 255 caractères trop court pour recevoir le commentaire -> subsrt
                --lx_xml.getclobval();
                substr(lx_xml.getclobval(),1,255);

                -- 26.01.2017 RGU: insertion du commentaire complet dans un champ virtuel
                if length(lx_xml.getclobval())>255
                   then -- recherche si un record de champ virtuel existe déjà
                          select count(*) into vf_record_exists
                          from com_vfields_record
                          where vfi_tabname='HRM_ELM_TRANSMISSION'
                          and vfi_rec_id=:new.hrm_elm_transmission_id;

                        -- si le record existe -> udpdate, sinon insert
                        if vf_record_exists > 0
                        then update com_vfields_record
                             set vfi_memo_01 = substr(to_char(sysdate,'DD.MM.YYYY HH24:MI:SS') ||chr(10)|| lx_xml.getclobval(),1,4000)
                             where vfi_tabname='HRM_ELM_TRANSMISSION'
                             and vfi_rec_id=:new.hrm_elm_transmission_id;
                        else insert into com_vfields_record (COM_VFIELDS_RECORD_ID,VFI_TABNAME,VFI_REC_ID,VFI_MEMO_01,A_DATECRE,A_IDCRE)
                             values (init_id_seq.nextval,'HRM_ELM_TRANSMISSION',:new.hrm_elm_transmission_id,substr(to_char(sysdate,'DD.MM.YYYY HH24:MI:SS') ||chr(10)|| lx_xml.getclobval(),1,4000),sysdate,nvl(pcs.pc_init_session.GetUserIni,'SDEC'));
                        end if;
                end if;



                -- Remise à l'état non-envoyé de la déclaration
                :new.c_hrm_elm_status := 0;
                --, ELM_ORIGINAL_RECEIPT_XML := EMPTY_CLOB();
                :new.ELM_RECEIPT_XML := EMPTY_CLOB();
            end if;
            exception when no_data_found then null;
        end;
    end if;
end;
ALTER TRIGGER "C_ITX"."HRM_ELM_TRANSMISSION_BU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."HRM_EMPLOYEE_CONST_ADU"
after update or delete
on HRM_EMPLOYEE_CONST
--END OPTION
--OPTION+ ENCRYPTION
--on "HrmEmployeeConst_ECP"
--END OPTION
for each row
begin
  insert into HRM_EMPL_CONST_HISTORY (
--END OPTION
--OPTION+ ENCRYPTION
--  insert into "HrmEmplConstHistory_ECP" (
--END OPTION
    HRM_EMPL_CONST_HISTORY_ID,
    HRM_EMPLOYEE_ID,
    HRM_CODE_TABLE_ID,
    HRM_CONSTANTS_ID,
    EMC_BASE_AMOUNT,
    EMC_RATE,
    EMC_PER_RATE,
    EMC_VALUE,
    EMC_NUM_VALUE,
    EMC_FOREIGN_VALUE,
    EMC_REF_VALUE,
--OPTION+ ENCRYPTION
--    "EmcBaseAmount_ECP", "EmcBaseAmount_S",
--    "EmcRate_ECP", "EmcRate_S",
--    "EmcPerRate_ECP", "EmcPerRate_S",
--    "EmcValue_ECP", "EmcValue_S",
--    "EmcNumValue_ECP", "EmcNumValue_S",
--    "EmcForeignValue_ECP", "EmcForeignValue_S",
--    "EmcRefValue_ECP", "EmcRefValue_S",
--END OPTION
    EMC_ZL,
    EMC_VALUE_FROM,
    EMC_VALUE_TO,
    EMC_ACTIVE,
    EMC_TEXT,
    A_DATECRE,
    A_IDCRE
  ) values (
    hrm_empl_history_seq.nextval,
    :old.HRM_EMPLOYEE_ID,
    :old.HRM_CODE_TABLE_ID,
    :old.HRM_CONSTANTS_ID,
    :old.EMC_BASE_AMOUNT,
    :old.EMC_RATE,
    :old.EMC_PER_RATE,
    :old.EMC_VALUE,
    :old.EMC_NUM_VALUE,
    :old.EMC_FOREIGN_VALUE,
    :old.EMC_REF_VALUE,
--OPTION+ ENCRYPTION
--    :old."EmcBaseAmount_ECP", :old."EmcBaseAmount_S",
--    :old."EmcRate_ECP", :old."EmcRate_S",
--    :old."EmcPerRate_ECP", :old."EmcPerRate_S",
--    :old."EmcValue_ECP", :old."EmcValue_S",
--    :old."EmcNumValue_ECP", :old."EmcNumValue_S",
--    :old."EmcForeignValue_ECP", :old."EmcForeignValue_S",
--    :old."EmcRefValue_ECP", :old."EmcRefValue_S",
--END OPTION
    :old.EMC_ZL,
    :old.EMC_VALUE_FROM,
    :old.EMC_VALUE_TO,
    :old.EMC_ACTIVE,
    :old.EMC_TEXT,
    Sysdate,
    pcs.PC_I_LIB_SESSION.GetUserIni
  );
exception
  when ex.TABLE_MUTATING then
    null;
end;

ALTER TRIGGER "C_ITX"."HRM_EMPLOYEE_CONST_ADU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."HRM_EMPLOYEE_ELEMENTS_ADU"
after update or delete
on HRM_EMPLOYEE_ELEMENTS
--END OPTION
--OPTION+ ENCRYPTION
--on "HrmEmployeeElements_ECP"
--END OPTION
for each row
begin
  insert into HRM_EMPL_ELEM_HISTORY (
--END OPTION
--OPTION+ ENCRYPTION
--  insert into "HrmEmplElemHistory_ECP" (
--END OPTION
    HRM_EMPL_ELEM_HISTORY_ID,
    HRM_EMPLOYEE_ID,
    HRM_ELEMENTS_ID,
    EMP_BASE_AMOUNT,
    EMP_RATE,
    EMP_PER_RATE,
    EMP_VALUE,
    EMP_NUM_VALUE,
    EMP_FOREIGN_VALUE,
    EMP_REF_VALUE,
--OPTION+ ENCRYPTION
--    "EmpBaseAmount_ECP", "EmpBaseAmount_S",
--    "EmpForeignValue_ECP", "EmpForeignValue_S",
--    "EmpNumValue_ECP", "EmpNumValue_S",
--    "EmpPerRate_ECP", "EmpPerRate_S",
--    "EmpRate_ECP", "EmpRate_S",
--    "EmpRefValue_ECP", "EmpRefValue_S",
--    "EmpValue_ECP", "EmpValue_S",
--END OPTION
    EMP_ZL,
    EMP_VALUE_FROM,
    EMP_VALUE_TO,
    EMP_ACTIVE,
    EMP_TEXT,
    A_DATECRE,
    A_IDCRE
  ) values (
    hrm_empl_history_seq.nextval,
    :old.HRM_EMPLOYEE_ID,
    :old.HRM_ELEMENTS_ID,
    :old.EMP_BASE_AMOUNT,
    :old.EMP_RATE,
    :old.EMP_PER_RATE,
    :old.EMP_VALUE,
    :old.EMP_NUM_VALUE,
    :old.EMP_FOREIGN_VALUE,
    :old.EMP_REF_VALUE,
--OPTION+ ENCRYPTION
--    :old."EmpBaseAmount_ECP", :old."EmpBaseAmount_S",
--    :old."EmpForeignValue_ECP", :old."EmpForeignValue_S",
--    :old."EmpNumValue_ECP", :old."EmpNumValue_S",
--    :old."EmpPerRate_ECP", :old."EmpPerRate_S",
--    :old."EmpRate_ECP", :old."EmpRate_S",
--    :old."EmpRefValue_ECP", :old."EmpRefValue_S",
--    :old."EmpValue_ECP", :old."EmpValue_S",
--END OPTION
    :old.EMP_ZL,
    :old.EMP_VALUE_FROM,
    :old.EMP_VALUE_TO,
    :old.EMP_ACTIVE,
    :old.EMP_TEXT,
    Sysdate,
    pcs.PC_I_LIB_SESSION.GetUserIni
  );
exception
  when ex.TABLE_MUTATING then
    null;
end;

ALTER TRIGGER "C_ITX"."HRM_EMPLOYEE_ELEMENTS_ADU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."HRM_PERSON_BIU_NAME"
  before insert or update of PER_LAST_NAME, PER_FIRST_NAME on hrm_person
  referencing old as old new as new
  for each row
/**
 * @version 1.0
 * @date 01/2006
 * @author ireber
 *
 * Copyright 1997-2006 Pro-Concept SA. Tous droits réservés.
 *
 * Remplissage automatique du champ PER_SEARCH_NAME
 */
begin
  :new.PER_SEARCH_NAME := HRM_UTILS.CONVERTTOSEARCHTEXT(:new.PER_LAST_NAME||' '||:new.PER_FIRST_NAME);
end HRM_PERSON_BIU_NAME;

ALTER TRIGGER "C_ITX"."HRM_PERSON_BIU_NAME" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."IND_TRG_ACI_SWAP_DC_BI"
  before insert on aci_document_status
  referencing old as old new as new
  for each row
/**
* Description
*   Inversion débit/crédit pour les document de type NC lorsque le montant est négatif
* @author RGU
* @version 2009.08
* @lastUpdate 2009.11.16 séparation de l'update TVA
*			 ajout test des champs IMF_AMOUNT_EUR_C/IMF_AMOUNT_EUR_D
*			 ajout test des champs TAX_VAT_AMOUNT_VC/TAX_TOT_VAT_AMOUNT_VC
*/
declare
  vGaugeTitle doc_gauge_structured.c_gauge_title%type;
begin

  -- recherche type de document logistique
  select max(gau.c_gauge_title) into vGaugeTitle
  from aci_document aci, doc_document doc, doc_gauge_structured gau
  where aci.doc_document_id=doc.doc_document_id
  and doc.doc_gauge_id=gau.doc_gauge_id
  and aci.aci_document_id=:new.aci_document_id;

  -- Si type document = NC or FC (c_gauge_title=9 / 8)
  if nvl(vGaugeTitle,'xxx')='9' or nvl(vGaugeTitle,'xxx')='8'
  then
      -- Débit négatif
      update aci_financial_imputation
      set IMF_AMOUNT_LC_C=abs(IMF_AMOUNT_LC_D),
          IMF_AMOUNT_LC_D=0,
          IMF_AMOUNT_FC_C=abs(IMF_AMOUNT_FC_D),
          IMF_AMOUNT_FC_D=0,
          IMF_AMOUNT_EUR_C=abs(IMF_AMOUNT_EUR_D),
          IMF_AMOUNT_EUR_D=0
      where nvl(IMF_AMOUNT_LC_D,0)<0
            or nvl(IMF_AMOUNT_FC_D,0)<0
            or nvl(IMF_AMOUNT_EUR_D,0)<0;

      -- Crédit négatif
      update aci_financial_imputation
      set IMF_AMOUNT_LC_D=abs(IMF_AMOUNT_LC_C),
          IMF_AMOUNT_LC_C=0,
          IMF_AMOUNT_FC_D=abs(IMF_AMOUNT_FC_C),
          IMF_AMOUNT_FC_C=0,
          IMF_AMOUNT_EUR_D=abs(IMF_AMOUNT_EUR_C),
          IMF_AMOUNT_EUR_C=0
      where nvl(IMF_AMOUNT_LC_C,0)<0
            or nvl(IMF_AMOUNT_FC_C,0)<0
            or nvl(IMF_AMOUNT_EUR_C,0)<0;

       -- TVA
       update aci_financial_imputation
      set TAX_TOT_VAT_AMOUNT_LC=abs(TAX_TOT_VAT_AMOUNT_LC),
          TAX_TOT_VAT_AMOUNT_FC=abs(TAX_TOT_VAT_AMOUNT_FC),
          TAX_VAT_AMOUNT_LC=abs(TAX_VAT_AMOUNT_LC),
          TAX_VAT_AMOUNT_FC=abs(TAX_VAT_AMOUNT_FC),
          TAX_VAT_AMOUNT_EUR=abs(TAX_VAT_AMOUNT_EUR),
          TAX_VAT_AMOUNT_VC=abs(TAX_VAT_AMOUNT_VC),
          TAX_TOT_VAT_AMOUNT_VC=abs(TAX_TOT_VAT_AMOUNT_VC)
      where nvl(TAX_TOT_VAT_AMOUNT_LC,0)<0
            or nvl(TAX_TOT_VAT_AMOUNT_FC,0)<0
            or nvl(TAX_VAT_AMOUNT_LC,0)<0
            or nvl(TAX_VAT_AMOUNT_FC,0)<0
            or nvl(TAX_VAT_AMOUNT_EUR,0)<0
            or nvl(TAX_TOT_VAT_AMOUNT_VC,0)<0;

  end if;

end IND_TRG_ACI_SWAP_DC_BI;


ALTER TRIGGER "C_ITX"."IND_TRG_ACI_SWAP_DC_BI" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."IND_TRG_BILL_ENTRY_SEQ_BI"
  before insert on IND_DOC_BILL_ENTRY
  referencing old as old new as new
  for each row
/**
* Description
*   Initialisation de la séquence
* @author RGU
* @version 2008.09
* @lastUpdate
*/
declare
  new_seq IND_DOC_BILL_ENTRY.IND_DOC_BILL_ENTRY_id%type;
begin
  select init_id_seq.nextval into new_seq
  from dual;

  :new.IND_DOC_BILL_ENTRY_ID:=new_seq;

end IND_TRG_BILL_ENTRY_SEQ_BI;


ALTER TRIGGER "C_ITX"."IND_TRG_BILL_ENTRY_SEQ_BI" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."IND_TRG_BI_PERS_TAX"
/******************************************************************************
      NAME:       IND_TRG_BI_PERS_TAX
      PURPOSE:

      REVISIONS:
      Ver        Date        Author           Description
      ---------  ----------  ---------------  ------------------------------------
      1.0        26/10/2015      DDO       1. Created this trigger.
   ******************************************************************************/
   AFTER INSERT --OR UPDATE
   ON HRM_PERSON
   REFERENCING NEW AS NEW OLD AS OLD
   FOR EACH ROW
BEGIN
   IF PCS.PC_CONFIG.GETCONFIG ('HRM_LOCALISATION',
                               PCS.PC_INIT_SESSION.GETCOMPANYID) = 'FR'
   THEN
      INSERT INTO HRM_PERSON_TAX (C_HRM_TAX_CERTIF_TYPE,
                                  EMP_TAX_FULLFILLED,
                                  EMP_TAX_EXPAT_EXPENSES,
                                  EMP_TAX_THIRD_SHARE,
                                  EMP_TAX_CHILD_ALLOW_PERAVS,
                                  EMP_TAX_CAR_CHECK,
                                  A_DATECRE,
                                  A_IDCRE,
                                  EMP_TAX_IS_EXPATRIATE,
                                  HRM_PERSON_ID,
                                  EMP_TAX_YEAR)
         SELECT '01',
                0,
                0,
                0,
                0,
                0,
                SYSDATE,
                PCS.PC_INIT_SESSION.GETUSERINI,
                0,
                :NEW.HRM_PERSON_ID,
                TO_CHAR (HRM_DATE.ACTIVEPERIOD, 'yyyy')
           FROM DUAL
          WHERE NOT EXISTS
                       (SELECT 1
                          FROM hrm_person_tax pt
                         WHERE     HRM_PERSON_ID = :NEW.HRM_PERSON_ID
                               AND EMP_TAX_YEAR =
                                      TO_CHAR (HRM_DATE.ACTIVEPERIOD, 'yyyy'));
   END IF;
EXCEPTION
   WHEN OTHERS
   THEN
      -- Consider logging the error and then re-raise
      RAISE;
END IND_TRG_BI_PERS_TAX;

ALTER TRIGGER "C_ITX"."IND_TRG_BI_PERS_TAX" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."IND_TRG_BREAK_DEVISE"
  before insert or update of SAB_AMOUNT on HRM_SALARY_BREAKDOWN
  referencing old as old new as new
  for each row
/**
* Description
*   Alimentation de la monnaie et montant en devise dans la monnaie du décompte de l'employé
*   Champs complémentaires créés sur la table
* @author RGU
* @version 2007.09
* @lastUpdate
*/
declare
 CompteMonnaie varchar2(10);
 CompteTransfert varchar2(10);
 Curr varchar2(10);
 FinCurId number;
 vRate number;
 vAmount number;
begin
 -- recherche s'il s'agit d'un compte de paiement en monnaie (421210, 421215, ...)
 -- ou du compte de transfert (421299)
 select
 max(b.DIC_FIN_ACC_CODE_1_ID),max(b.DIC_FIN_ACC_CODE_2_ID)
  into CompteMonnaie, CompteTransfert
 from
 acs_account a,
 ACS_FINANCIAL_ACCOUNT b
 where
 a.acs_account_id=b.acs_financial_account_id
 and a.acc_number=:new.SAB_ACCOUNT_NAME
 and :new.DIC_ACCOUNT_TYPE_ID='CG';

 -- Détermination de la monnaie à utiliser
 if CompteMonnaie is not null
 -- *** Si compte de paiement en monnaie (421210, 421215, ...)
 then
	 Curr:=CompteMonnaie;

 else if CompteTransfert is not null
  -- *** Si compte de transfert (421299)
     then
	      select nvl(
                        nvl(
                        max(b.dic_group3_id),
                        hrm_itx.GET_PERS_CURR(:new.hrm_employee_id,:new.sab_pay_date)
                        ),
                        acs_function.GetLocalCurrencyName) into Curr
	      from hrm_history_detail a, hrm_elements_root b
		  where a.hrm_elements_id=b.hrm_elements_id
		  and a.hrm_history_detail_id=:new.hrm_history_detail_id;

     -- *** Sinon pas compte spécial -> utilisation de la monnaie du décompte
     else
         select
         nvl(
            hrm_itx.GET_PERS_CURR(:new.hrm_employee_id,:new.sab_pay_date),
            acs_function.GetLocalCurrencyName
            ) into Curr
         from dual;
     end if;
 end if;

 -- recherche de l'id de la monnaie
 select
 max(acs_financial_currency_id) into FinCurId
 from acs_financial_currency a, pcs.pc_curr b
 where a.pc_curr_id=b.pc_curr_id
 and b.currency=Curr;

 -- recherche du taux de change
 --  recherche dans l'historique car le cours n'est pas tjs conservé
 --  cela suppose que le GS existe bien... si rien n'est trouvé -> 1
 select
 nvl(max(his_pay_sum_val),1) into vRate
 from
 hrm_history_detail a, hrm_elements b
 where a.hrm_elements_id=b.hrm_elements_id
 and ele_code='Div'||Curr||'Taux'
 and a.hrm_employee_id=:new.hrm_employee_id
 and a.his_pay_period=:new.sab_pay_date;

 -- détermination du montant en devise
 select
 round(:new.sab_amount/vRate,2) into vAmount
 from dual;


  -- Affectation des valaurs
  :new.currency2:=Curr;

  :new.acs_financial_currency_id2:=FinCurId;

  :new.rate2:=vRate;

  :new.sab_amount2:=vAmount;

end IND_TRG_BREAK_DEVISE;


ALTER TRIGGER "C_ITX"."IND_TRG_BREAK_DEVISE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."IND_TRG_DEPART_DICFREE1_AIU"
  after insert or update of dic_department_id, div_descr on HRM_DIVISION
  referencing old as old new as new
  for each row
/**
* Description
*  Création d'un d'un code libre 1 (imputaton financière) lors de la création d'un département
* @author RGU
* @version 2010.02
* @lastUpdate
*/
DECLARE
 TradExists integer;
begin

if inserting then
 -- Création du code
 insert into DIC_IMP_FREE1 (DIC_IMP_FREE1_ID,DIC_DESCRIPTION,A_DATECRE,A_IDCRE)
 values ( :new.dic_department_id,:new.div_descr,sysdate,'TRG');

 -- création des traductions
 SELECT COUNT(*) into TradExists
 from DICO_DESCRIPTION
 WHERE DIT_TABLE='DIC_IMP_FREE1'
                  AND DIT_CODE=:NEW.DIC_DEPARTMENT_ID
                  and PC_LANG_ID=1;

 IF TRADEXISTS = 0
 then
   INSERT INTO DICO_DESCRIPTION (DIT_TABLE,DIT_CODE,PC_LANG_ID,DIT_DESCR,A_DATECRE,A_IDCRE)
   VALUES ('DIC_IMP_FREE1',:NEW.DIC_DEPARTMENT_ID,1,:NEW.DIV_DESCR,SYSDATE,'TRG');
  end if;
end if;

if updating then

 -- modification du code -> suppression traduction / update code / insert traduction
 if :new.dic_department_id<>:old.dic_department_id then
  delete from DICO_DESCRIPTION
  where DIT_TABLE='DIC_IMP_FREE1'
  and DIT_CODE=:old.dic_department_id;

  update DIC_IMP_FREE1
  set DIC_IMP_FREE1_ID=:new.dic_department_id
  where DIC_IMP_FREE1_ID=:old.dic_department_id;

  SELECT COUNT(*) INTO TRADEXISTS
  FROM DICO_DESCRIPTION
  WHERE DIT_TABLE='DIC_IMP_FREE1'
                  AND DIT_CODE=:NEW.DIC_DEPARTMENT_ID
                  and PC_LANG_ID=1;

  IF TRADEXISTS = 0
  then
    insert into DICO_DESCRIPTION (DIT_TABLE,DIT_CODE,PC_LANG_ID,DIT_DESCR,A_DATECRE,A_IDCRE)
    VALUES ('DIC_IMP_FREE1',:NEW.DIC_DEPARTMENT_ID,1,:NEW.DIV_DESCR,SYSDATE,'TRG');
  END IF;
 end if;

 -- modification de la description (uniquement)
 if :new.div_descr<>:old.div_descr and :new.dic_department_id=:old.dic_department_id then
  update DIC_IMP_FREE1
  set DIC_DESCRIPTION=:new.div_descr
  where DIC_IMP_FREE1_ID=:new.dic_department_id;

  update DICO_DESCRIPTION
  set DIT_DESCR=:new.div_descr
  where DIT_TABLE='DIC_IMP_FREE1'
  and DIT_CODE=:new.dic_department_id;
 end if;

end if;

end IND_TRG_DEPART_DICFREE1_AIU;


ALTER TRIGGER "C_ITX"."IND_TRG_DEPART_DICFREE1_AIU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."IND_TRG_DEPART_DICFREE1_BD"
  before delete on HRM_DIVISION
  referencing old as old new as new
  for each row
/**
* Description
*  Suppression du code libre 1 (imputaton financière) lors de la suppression d'un département
* @author RGU
* @version 2010.09
* @lastUpdate
*/
DECLARE
 vCount INTEGER;

begin
 -- recherche si le code a été utilisé dans des imputations comptables
 select count(*) into vCount
 FROM ACT_FINANCIAL_IMPUTATION
 WHERE trim(DIC_IMP_FREE1_ID) = trim(:OLD.DIC_DEPARTMENT_ID);

 IF VCOUNT > 0
 THEN RAISE_APPLICATION_ERROR(-20001,'Suppression du code '||:OLD.DIC_DEPARTMENT_ID||
                                     ' impossible - il existe des mouvements comptables');
 ELSE -- SUPPRESSION DU CODE
      DELETE FROM DIC_IMP_FREE1
      WHERE DIC_IMP_FREE1_ID = :OLD.DIC_DEPARTMENT_ID;

      DELETE FROM DIC_DEPARTMENT
      WHERE DIC_DEPARTMENT_ID = :OLD.DIC_DEPARTMENT_ID;

      DELETE FROM DICO_DESCRIPTION
      WHERE DIT_TABLE IN ('DIC_DEPARTMENT','DIC_IMP_FREE1')
      AND DIT_CODE=:OLD.DIC_DEPARTMENT_ID;
 END IF;

end IND_TRG_DEPART_DICFREE1_BD;


ALTER TRIGGER "C_ITX"."IND_TRG_DEPART_DICFREE1_BD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."IND_TRG_EMP_DIVISION_AIU"
  after insert or update of EMP_NUMBER, PER_LAST_NAME, PER_FIRST_NAME on HRM_PERSON
  referencing old as old new as new
  for each row
/**
* Description
*  Création d'une division lorsqu'un employé est créé.
*  Si le matricule ou le nom est modifié, le no de compte division est adapté
*  L'id de l'employé est l'id de la division
* @author RGU
* @version 2007.10
* @lastUpdate
*/

begin

 if inserting then
 -- Compte
 insert into acs_account (
 ACS_ACCOUNT_ID,
 ACS_SUB_SET_ID,
 C_VALID,
 ACC_NUMBER,
 ACC_DETAIL_PRINTING,
 ACC_BLOCKED,
 ACC_INTEREST,
 A_DATECRE,
 A_IDCRE)
 select
 :new.hrm_person_id,
 (select min(acs_sub_set_id) from acs_sub_set where c_sub_set='DTO'),
 'VAL',
 :new.emp_number,
 1,
 0,
 0 ,
 sysdate,
 'TRG'
 from dual;

 -- Compte division
 insert into acs_division_account (
 ACS_DIVISION_ACCOUNT_ID,
 A_DATECRE,
 A_IDCRE)
 values (
 :new.hrm_person_id,
 sysdate,
 'TRG');

 -- Description compte
 insert into acs_description (
 ACS_DESCRIPTION_ID,
 ACS_ACCOUNT_ID,
 PC_LANG_ID,
 DES_DESCRIPTION_SUMMARY,
 A_DATECRE,
 A_IDCRE)
 select
 init_id_seq.nextval,
 :new.hrm_person_id,
 1,
 :new.per_search_name,
 sysdate,
 'TRG'
 from dual;
end if;

if updating then
 update acs_account
 set acc_number=:new.emp_number
 where
 acs_account_id=:new.hrm_person_id;

 update acs_description
 set des_description_summary=:new.per_search_name
 where
 acs_account_id=:new.hrm_person_id;
end if;

end IND_TRG_EMP_DIVISION_AIU;


ALTER TRIGGER "C_ITX"."IND_TRG_EMP_DIVISION_AIU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."IND_TRG_EMP_NUM_DIVISION_BD"
   /**
   * Description
   *  Impossible de supprimer un employé si la division correspondante a été créée
   * @author RGU
   * @mod DDO
   * @version 2007.10
   * @lastUpdate  2016.01
   */
   BEFORE DELETE
   ON HRM_PERSON
   REFERENCING OLD AS old NEW AS new
   FOR EACH ROW
DECLARE
   DivExists   INTEGER;
BEGIN
   SELECT COUNT (*)
     INTO DivExists
     FROM acs_account
    WHERE /*acs_account_id=:old.hrm_person_id; --> suite à la mise en place des salaires sur ITX, il n'y a actuellement pas de correspondance entre les id des
    comptes et les id des employés */
         acc_number = :old.emp_number;

   IF DivExists > 0
   THEN
      raise_application_error (
         -20001,
            'Suppression impossible : une division comptable est rattachée à cet employé. Veuillez d''abord supprimer la division'
         || CHR (10)
         || CHR (10)
         || 'Message généré par trigger : IND_TRG_EMP_NUM_DIVISION_BD');
   END IF;
END IND_TRG_EMP_NUM_DIVISION_BD;
ALTER TRIGGER "C_ITX"."IND_TRG_EMP_NUM_DIVISION_BD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."IND_TRG_HRM_LIST_BDU"
  before delete or update of col_name on HRM_CONTROL_LIST
  referencing old as old new as new
  for each row
/**
* Description
*   Impossible de supprimer la liste car utilisée par rapport Crystal
*   Se base sur le A_IDCRE
* @author RGU
* @version 2006.06
* @lastUpdate
*
*/

begin

if :old.a_idcre='NODEL'
then

 raise_application_error(-20001,'Impossible de modifier cette liste (liste utilisée dans un rapport)');

end if;

end IND_TRG_HRM_LIST_BDU;


ALTER TRIGGER "C_ITX"."IND_TRG_HRM_LIST_BDU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."IND_TRG_HRM_NDF_BIU"
  before insert or update of emp_foreign_value,PC_CURR_ID,EMP_VALUE_FROM,EMP_VALU_TO on IND_HRM_NDF
  referencing old as old new as new
  for each row
/**
* Description
*   Calcul du montant en CHF dans la Saisie des notes de frais
* @author RGU
* @version septembre 2005
* @lastUpdate 26.09.2005 RGU: ajout de la monaie du décompte et transformation du montant
*             			      CHF en devise du décompte
*			  20.02.2008 RGU: Ajout vDateDebut pour pouvoir gérer une date automatique si non renseignée.
*			  			 	  Le Champ EMP_VALUE_FROM n'est plus obligatoire (Gestion des champs)
*       09.12.2008 RGU: Le taux de conversion est celui du mois en cours (au lieu de celui de la date de début
*                       -> pose pb en cas de modification d'une NDF récurrente)
*
*/
declare
  vCurrency varchar2(5);
  vDate date;
  vDateRate date;
  vRate number;
  vForeignAmount number;
  vCHFAmount number;
  vDateDebut date;
  vDateFin date;
  vCurrDéc varchar2(5);
  vAmountDéc number;
  vRateDéc number;


begin

  -- recherche de la monnaie
  select max(currency) into vCurrency
  from pcs.pc_curr
  where pc_curr_id=:new.pc_curr_id;

  -- recherche de la date de début
  if :new.emp_value_from is null
  then vDateDebut:=hrm_date.activeperiod;
  else vDateDebut:=:new.emp_value_from;
  end if;

  -- recherche de la date référence
  if :new.emp_value_from is not null
   then vDate:=:new.emp_value_from+1;
   else vDate:=nvl(:old.emp_value_from,vDateDebut+1);
  end if;

  -- recherche du taux de change
  select hrm_itx.exchangeRateDate(vCurrency,4,hrm_date.activeperiod+1) into vRate  -- 09.12.2008: remplacé vDate par hrm_date.activeperiod+1
  from dual;

  -- recherche de la date du cours dans la Gestion des cours pour contrôle
  select
    max(c.pcu_start_validity) into vDateRate
    from
      acs_price_currency c,
      (SELECT max(pcu_start_validity) pcu_start_validity,
              acs_between_curr_id, acs_and_curr_id
       FROM acs_price_currency c,
            acs_financial_currency a,
            pcs.pc_curr b
       WHERE
         b.currency = vCurrency and
         a.pc_curr_id = b.pc_curr_id and
         c.acs_between_curr_id = a.acs_financial_currency_id and
         c.acs_and_curr_id = acs_function.getlocalcurrencyid and
         c.pcu_start_validity <= vDate
       GROUP BY acs_and_curr_id, acs_between_curr_id) v
    where
      c.acs_and_curr_id = v.acs_and_curr_id and
      c.acs_between_curr_id = v.acs_between_curr_id and
      c.pcu_start_validity = v.pcu_start_validity;

  if acs_function.GetLocalCurrencyName <> vCurrency and
     (trunc(vDate,'MM') <> nvl(trunc(vDateRate,'MM'),to_date('31.12.2022','DD.MM.YYYY')) or vRate=1)
  then raise_application_error(-20001,'Aucun cours pour '||vCurrency||' dans la période. Contrôler la Gestion des cours');
  end if;

  -- recherche du montant en devise
  if :new.EMP_FOREIGN_VALUE is not null
   then vForeignAmount:=:new.EMP_FOREIGN_VALUE;
   else vForeignAmount:=:old.EMP_FOREIGN_VALUE;
  end if;

  -- recherche du montant en CHF
  select nvl(round(vForeignAmount*vRate,2),0) into vCHFAmount
  from dual;

  -- recherche de la monnaie du décompte de l'employé
  select hrm_itx.get_pers_curr_code(:new.hrm_person_id,vDate) into vCurrDéc
  from dual;

  -- recherche du taux de change CHF -> monnaie du décompte
  select hrm_itx.exchangeRateDate(vCurrDéc,4,vDate) into vRateDéc
  from dual;

  -- recherche du montant en monnaie du décompte
  select nvl(round(vCHFAmount/vRateDéc,2),0) into vAmountDéc
  from dual;

  -- Mise à jour du taux de change dans la table
  :new.EMP_EX_RATE:=vRate;

  -- Mise à jour du montant en CHF dans la table
  :new.EMP_NUM_VALUE:=vCHFAmount;

  -- Insertion automatique de la date de fin de validité
  select last_day(vDateDebut) into vDateFin
  from dual;

  if :new.emp_valu_to is null
   then :new.emp_valu_to:=vDateFin;
  end if;

  if :new.emp_value_from is null
   then :new.emp_value_from:=vDateDebut;
  end if;

  -- Mise à jour de la monnaie du décompte dans la table
  :new.MONNAIE_DEC:=vCurrDéc;

  -- Mise à jour du montant en monnaie du décompte dans la table
  :new.VALUE_DEC:=vAmountDéc;

  end IND_TRG_HRM_NDF_BIU;


ALTER TRIGGER "C_ITX"."IND_TRG_HRM_NDF_BIU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."IND_TRG_HRM_NDF_SEQ_BI"
  before insert on IND_HRM_NDF
  referencing old as old new as new
  for each row
/**
* Description
*   initialisation de l'id de la table
* @author RGU
* @version 2007.07
* @lastUpdate
*
*/
declare
 Seq number;
begin

 select init_id_seq.nextval into Seq
 from dual;

 :new.ndf_id:=Seq;

end IND_TRG_HRM_NDF_SEQ_BI;


ALTER TRIGGER "C_ITX"."IND_TRG_HRM_NDF_SEQ_BI" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."IND_TRG_PERIOD_AC_AI"
  after insert on HRM_PERIOD
  referencing old as old new as new
  for each row
/**
* Description
*   Lors du passage à une nouvelle année, stockage des jours AC et plafond AC dans les champs virtuels de l'employé
* @author RGU
* @version 2008.03
* @lastUpdate
*
*/
declare
 Cursor CurEmp is
  select
  c.hrm_employee_id,
  com_vfields_record_id,
  sum(decode(b.coe_box,'MAX',c.his_pay_sum_val,0)) plafond,
  sum(decode(b.coe_box,'JOURS',c.his_pay_sum_val,0)) jours
  from
  hrm_control_list a,
  hrm_control_elements b,
  hrm_history_detail c,
  com_vfields_record vfi
  where
  a.hrm_control_list_id= b.hrm_control_list_id
  and b.hrm_control_elements_id=c.hrm_elements_id
  and c.hrm_employee_id=vfi.vfi_rec_id(+)
  and (vfi.vfi_tabname='HRM_PERSON'
      or vfi.vfi_tabname is null)
  and col_name='Plafond AC - mise à jour données employé'
  and c.his_pay_period<=:NEW.PER_BEGIN-1
  and c.his_pay_period>=add_months(:NEW.PER_BEGIN,-12)
  group by c.hrm_employee_id,
  com_vfields_record_id;
begin

 if to_char(:new.per_begin,'MM') = '01'
 then
  for RowEmp in CurEmp
  loop
   if RowEmp.com_vfields_record_id is not null
   then -- La ligne de champ virtuel existe déjà -> update
        update com_vfields_record
        set VFI_FLOAT_01=RowEmp.plafond,
            VFI_INTEGER_01=RowEmp.jours
        where com_vfields_record_id=RowEmp.com_vfields_record_id;

   else -- La ligne de champ virtuel n'existe pas -> insert
        insert into com_vfields_record (
        com_vfields_record_id,
        VFI_TABNAME,
        VFI_REC_ID,
        VFI_FLOAT_01,
        VFI_INTEGER_01,
        A_DATECRE,
        A_IDCRE)
        values (
        init_id_seq.nextval,
        'HRM_PERSON',
        RowEmp.hrm_employee_id,
        RowEmp.plafond,
        RowEmp.jours,
        sysdate,
        'TRG');
    end if;

  end loop;
 end if;

end IND_TRG_PERIOD_NDF_AI;


ALTER TRIGGER "C_ITX"."IND_TRG_PERIOD_AC_AI" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."IND_TRG_PERIOD_NDF_AI"
  after insert on HRM_PERIOD
  referencing old as old new as new
  for each row
/**
* Description
*   Lors du passage à une nouvelle période, réactivation des lignes de saisie des
*   Notes de frais valides selon dates de validité
* @author RGU
* @version 2007.07
* @lastUpdate
*
*/
begin

 update ind_hrm_ndf
 set to_transfer=1
 where
 emp_valu_to>=:new.per_begin
 and to_transfer=0;

end IND_TRG_PERIOD_NDF_AI;


ALTER TRIGGER "C_ITX"."IND_TRG_PERIOD_NDF_AI" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."IND_TRG_UPDATE_RATE"
  after insert or update ON ACS_PRICE_CURRENCY   referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour des taux de change et valeurs en CHF dans Employés avec GS lors d'une modification dans la Gestion des cours
*   Seul le cours du jours est utilisé
* @author RGU
* @version 06.01.2006
* @lastUpdate 28.07.2010 - set emp_value
*			 - round(EMC_FOREIGN_VALUE * round(:new.PCU_DAYLY_PRICE / :new.PCU_BASE_PRICE,6),2)  *** ajouté le round sur 6 ***
*/
declare
 msg varchar2(200);
begin

 -- *** MONTANTS FIXES ***
 -- Mise à jour du taux de change
 update hrm_employee_const a
 set emc_ex_rate = round(:new.PCU_DAYLY_PRICE / :new.PCU_BASE_PRICE,6)
 where
 trunc(emc_value_to)>=trunc(:new.PCU_START_VALIDITY)
 and exists (select 1
 		   from hrm_constants b
 		   where a.hrm_constants_id=b.hrm_constants_id
 		   and b.ACS_FINANCIAL_CURRENCY_ID=:new.ACS_BETWEEN_CURR_ID);

 -- Mise à jour du montant CHF
 update hrm_employee_const a
 set emc_num_value = round(EMC_FOREIGN_VALUE * round(:new.PCU_DAYLY_PRICE / :new.PCU_BASE_PRICE,6),2)
 where
 trunc(emc_value_to)>=trunc(:new.PCU_START_VALIDITY)
 and exists (select 1
 		   from hrm_constants b
 		   where a.hrm_constants_id=b.hrm_constants_id
 		   and b.ACS_FINANCIAL_CURRENCY_ID=:new.ACS_BETWEEN_CURR_ID);

 -- *** VARIABLES ***
 -- Mise à jour du taux de change
 update hrm_employee_elements a
 set emp_ex_rate = round(:new.PCU_DAYLY_PRICE / :new.PCU_BASE_PRICE,6)
 where
 trunc(emp_value_to)>=trunc(:new.PCU_START_VALIDITY)
 and exists (select 1
 		   from hrm_elements b
 		   where a.hrm_elements_id=b.hrm_elements_id
 		   and b.ACS_FINANCIAL_CURRENCY_ID=:new.ACS_BETWEEN_CURR_ID);

 -- Mise à jour du montant CHF
 update hrm_employee_elements a
 set emp_num_value = round(EMP_FOREIGN_VALUE * round(:new.PCU_DAYLY_PRICE / :new.PCU_BASE_PRICE,6),2),
     emp_value = round(EMP_FOREIGN_VALUE * round(:new.PCU_DAYLY_PRICE / :new.PCU_BASE_PRICE,6),2)
 where
 trunc(emp_value_to)>=trunc(:new.PCU_START_VALIDITY)
 and exists (select 1
 		   from hrm_elements b
 		   where a.hrm_elements_id=b.hrm_elements_id
 		   and b.ACS_FINANCIAL_CURRENCY_ID=:new.ACS_BETWEEN_CURR_ID);

-- *** NOTES DE FRAIS ***
 -- Mise à jour du taux de change
 update ind_hrm_ndf a
 set emp_ex_rate = round(:new.PCU_DAYLY_PRICE / :new.PCU_BASE_PRICE,6)
 where
 trunc(emp_valu_to)>=trunc(:new.PCU_START_VALIDITY)
 and is_transfered is null
 and exists (select 1
 		   from ACS_FINANCIAL_CURRENCY b
 		   where a.pc_curr_id=b.pc_curr_id
 		   and b.ACS_FINANCIAL_CURRENCY_ID=:new.ACS_BETWEEN_CURR_ID);

 -- Mise à jour du montant CHF
 update ind_hrm_ndf a
 set emp_num_value = round(EMp_FOREIGN_VALUE * :new.PCU_DAYLY_PRICE / :new.PCU_BASE_PRICE,2)
 where
 trunc(emp_valu_to)>=trunc(:new.PCU_START_VALIDITY)
 and is_transfered is null
 and exists (select 1
 		   from ACS_FINANCIAL_CURRENCY b
 		   where a.pc_curr_id=b.pc_curr_id
 		   and b.ACS_FINANCIAL_CURRENCY_ID=:new.ACS_BETWEEN_CURR_ID);


end IND_TRG_UPDATE_RATE;


ALTER TRIGGER "C_ITX"."IND_TRG_UPDATE_RATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."LPM_ADD_IOI"
   INSTEAD OF INSERT
   ON lpm_address
   FOR EACH ROW
BEGIN
   INSERT INTO pac_person (PAC_PERSON_ID,
                           DIC_PERSON_POLITNESS_ID,
                           PER_NAME,
                           PER_FORENAME,
                           PER_ACTIVITY,
                           PER_COMMENT,
                           PER_KEY1,
                           PER_KEY2,
                           DIC_FREE_CODE1_ID,
                           DIC_FREE_CODE2_ID,
                           DIC_FREE_CODE3_ID,
                           DIC_FREE_CODE4_ID,
                           DIC_FREE_CODE5_ID,
                           DIC_FREE_CODE6_ID,
                           DIC_FREE_CODE7_ID,
                           DIC_FREE_CODE8_ID,
                           DIC_FREE_CODE9_ID,
                           DIC_FREE_CODE10_ID,
                           PER_SHORT_NAME,
                           PER_CONTACT,
                           C_PARTNER_STATUS,
                           a_datecre,
                           a_idcre)
        VALUES (:new.PAC_PERSON_ID,
                :new.DIC_PERSON_POLITNESS_ID,
                :new.PER_NAME,
                :new.PER_FORENAME,
                :new.PER_ACTIVITY,
                :new.PER_COMMENT,
                :new.PER_KEY1,
                :new.PER_KEY2,
                :new.DIC_FREE_CODE1_ID,
                :new.DIC_FREE_CODE2_ID,
                :new.DIC_FREE_CODE3_ID,
                :new.DIC_FREE_CODE4_ID,
                :new.DIC_FREE_CODE5_ID,
                :new.DIC_FREE_CODE6_ID,
                :new.DIC_FREE_CODE7_ID,
                :new.DIC_FREE_CODE8_ID,
                :new.DIC_FREE_CODE9_ID,
                :new.DIC_FREE_CODE10_ID,
                :new.PER_SHORT_NAME,
                :new.PER_CONTACT,
                NVL(:new.C_PARTNER_STATUS,'1'),
                SYSDATE,
                'LPM');

   INSERT INTO pac_address (PAC_ADDRESS_ID,
                            PAC_PERSON_ID,
                            PC_CNTRY_ID,
                            PC_LANG_ID,
                            DIC_ADDRESS_TYPE_ID,
                            A_DATECRE,
                            A_IDCRE,
                            C_PARTNER_STATUS,
                            ADD_ADDRESS1,
                            ADD_ZIPCODE,
                            ADD_CITY,
                            ADD_STATE,
                            ADD_COMMENT,
                            ADD_FORMAT,
                            ADD_PRINCIPAL,
                            ADD_PRIORITY,
                            ADD_CARE_OF,
                            ADD_PO_BOX,
                            ADD_PO_BOX_NBR,
                            ADD_COUNTY)
      SELECT init_id_seq.NEXTVAL,
             :new.PAC_PERSON_ID,
             :new.PC_CNTRY_ID,
             :new.PC_LANG_ID,
             DIC_ADDRESS_TYPE_ID,
             SYSDATE,
             'LPM',
             NVL(:new.add_STATUS,'1'),
             :new.ADD_ADDRESS1,
             :new.ADD_ZIPCODE,
             :new.ADD_CITY,
             :new.ADD_STATE,
             :new.ADD_COMMENT,
             :new.ADD_FORMAT,
             1,
             :new.ADD_PRIORITY,
             :new.ADD_CARE_OF,
             :new.ADD_PO_BOX,
             :new.ADD_PO_BOX_NBR,
             :new.ADD_COUNTY
        FROM dic_address_type
       WHERE dad_default = 1 AND :new.add_city IS NOT NULL;

   INSERT INTO pac_address (PAC_ADDRESS_ID,
                            PAC_PERSON_ID,
                            PC_CNTRY_ID,
                            PC_LANG_ID,
                            DIC_ADDRESS_TYPE_ID,
                            A_DATECRE,
                            A_IDCRE,
                            C_PARTNER_STATUS,
                            ADD_ADDRESS1,
                            ADD_ZIPCODE,
                            ADD_CITY,
                            ADD_STATE,
                            ADD_COMMENT,
                            ADD_FORMAT,
                            ADD_PRINCIPAL,
                            ADD_PRIORITY,
                            ADD_CARE_OF,
                            ADD_PO_BOX,
                            ADD_PO_BOX_NBR,
                            ADD_COUNTY)
      SELECT init_id_seq.NEXTVAL,
             :new.PAC_PERSON_ID,
             :new.PC_CNTRY_ID2,
             :new.PC_LANG_ID2,
             'LPM2',
             SYSDATE,
             'LPM',
             NVL(:new.add_status2,'1'),
             :new.ADD_ADDRESS2,
             :new.ADD_ZIPCODE2,
             :new.ADD_CITY2,
             :new.ADD_STATE2,
             :new.ADD_COMMENT2,
             :new.ADD_FORMAT2,
             1,
             :new.ADD_PRIORITY2,
             :new.ADD_CARE_OF2,
             :new.ADD_PO_BOX2,
             :new.ADD_PO_BOX_NBR2,
             :new.ADD_COUNTY2
        FROM dic_address_type
       WHERE dic_address_type_id = 'LPM2' AND :new.add_city2 IS NOT NULL;

   INSERT INTO pac_communication (PAC_COMMUNICATION_ID,
                                  PAC_PERSON_ID,
                                  DIC_COMMUNICATION_TYPE_ID,
                                  A_DATECRE,
                                  A_IDCRE,
                                  COM_EXT_NUMBER)
      SELECT init_id_seq.NEXTVAL,
             :new.pac_person_id,
             dic_communication_type_id,
             SYSDATE,
             'LPM',
             :new.dco_phone
        FROM dic_communication_type
       WHERE dco_phone = 1 AND :new.dco_phone IS NOT NULL;

   INSERT INTO pac_communication (PAC_COMMUNICATION_ID,
                                  PAC_PERSON_ID,
                                  DIC_COMMUNICATION_TYPE_ID,
                                  A_DATECRE,
                                  A_IDCRE,
                                  COM_EXT_NUMBER)
      SELECT init_id_seq.NEXTVAL,
             :new.pac_person_id,
             dic_communication_type_id,
             SYSDATE,
             'LPM',
             :new.dco_mobilephone
        FROM dic_communication_type
       WHERE dco_mobilephone = 1 AND :new.dco_mobilephone IS NOT NULL;

   INSERT INTO pac_communication (PAC_COMMUNICATION_ID,
                                  PAC_PERSON_ID,
                                  DIC_COMMUNICATION_TYPE_ID,
                                  A_DATECRE,
                                  A_IDCRE,
                                  COM_EXT_NUMBER)
      SELECT init_id_seq.NEXTVAL,
             :new.pac_person_id,
             dic_communication_type_id,
             SYSDATE,
             'LPM',
             :new.dco_email
        FROM dic_communication_type
       WHERE dco_email = 1 AND :new.dco_email IS NOT NULL;
END LPM_ADD_IOU;

ALTER TRIGGER "C_ITX"."LPM_ADD_IOI" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."LPM_ADD_IOU"
   INSTEAD OF UPDATE
   ON lpm_address
   FOR EACH ROW
DECLARE
   l_add_exist      PLS_INTEGER := 0;
   l_exist_email    PLS_INTEGER := 0;
   l_exist_phone    PLS_INTEGER := 0;
   l_exist_mobile   PLS_INTEGER := 0;
BEGIN
   UPDATE pac_person
      SET DIC_PERSON_POLITNESS_ID = :new.DIC_PERSON_POLITNESS_ID,
          per_name = :new.PER_NAME,
          per_forename = :new.PER_FORENAME,
          PER_ACTIVITY = :new.PER_ACTIVITY,
          PER_COMMENT = :new.PER_COMMENT,
          PER_KEY1 = :new.PER_KEY1,
          PER_KEY2 = :new.PER_KEY2,
          DIC_FREE_CODE1_ID = :new.DIC_FREE_CODE1_ID,
          DIC_FREE_CODE2_ID = :new.DIC_FREE_CODE2_ID,
          DIC_FREE_CODE3_ID = :new.DIC_FREE_CODE3_ID,
          DIC_FREE_CODE4_ID = :new.DIC_FREE_CODE4_ID,
          DIC_FREE_CODE5_ID = :new.DIC_FREE_CODE5_ID,
          DIC_FREE_CODE6_ID = :new.DIC_FREE_CODE6_ID,
          DIC_FREE_CODE7_ID = :new.DIC_FREE_CODE7_ID,
          DIC_FREE_CODE8_ID = :new.DIC_FREE_CODE8_ID,
          DIC_FREE_CODE9_ID = :new.DIC_FREE_CODE9_ID,
          DIC_FREE_CODE10_ID = :new.DIC_FREE_CODE10_ID,
          PER_SHORT_NAME = :new.PER_SHORT_NAME,
          PER_CONTACT = :new.PER_CONTACT,
          C_PARTNER_STATUS = :new.C_PARTNER_STATUS,
          a_datemod = SYSDATE,
          a_idmod = 'LPM'
    WHERE pac_person_id = :new.pac_person_id;
   SELECT COUNT (*)
     INTO l_add_exist
     FROM pac_address
    WHERE pac_person_id = :new.pac_person_id AND add_principal = 1;
   IF l_add_exist = 0
   THEN
      INSERT INTO pac_address (PAC_ADDRESS_ID,
                               PAC_PERSON_ID,
                               PC_CNTRY_ID,
                               PC_LANG_ID,
                               DIC_ADDRESS_TYPE_ID,
                               A_DATECRE,
                               A_IDCRE,
                               C_PARTNER_STATUS,
                               ADD_ADDRESS1,
                               ADD_ZIPCODE,
                               ADD_CITY,
                               ADD_STATE,
                               ADD_COMMENT,
                               ADD_FORMAT,
                               ADD_PRINCIPAL,
                               ADD_PRIORITY,
                               ADD_CARE_OF,
                               ADD_PO_BOX,
                               ADD_PO_BOX_NBR,
                               ADD_COUNTY)
         SELECT init_id_seq.NEXTVAL,
                :new.PAC_PERSON_ID,
                :new.PC_CNTRY_ID,
                :new.PC_LANG_ID,
                DIC_ADDRESS_TYPE_ID,
                SYSDATE,
                'LPM',
                :new.add_STATUS,
                :new.ADD_ADDRESS1,
                :new.ADD_ZIPCODE,
                :new.ADD_CITY,
                :new.ADD_STATE,
                :new.ADD_COMMENT,
                :new.ADD_FORMAT,
                1,
                :new.ADD_PRIORITY,
                :new.ADD_CARE_OF,
                :new.ADD_PO_BOX,
                :new.ADD_PO_BOX_NBR,
                :new.ADD_COUNTY
           FROM dic_address_type
          WHERE dad_default = 1 AND :new.add_city IS NOT NULL;
   ELSIF l_add_exist != 0
   THEN
      UPDATE pac_address
         SET pc_cntry_id = :new.PC_CNTRY_ID,
             pc_lang_id = :new.PC_LANG_ID,
             dic_address_type_id =
                (SELECT DIC_ADDRESS_TYPE_ID
                   FROM dic_address_type
                  WHERE dad_default = 1),
             a_datemod = SYSDATE,
             a_idmod = 'LPM',
             c_partner_status = :new.add_STATUS,
             add_address1 = :new.ADD_ADDRESS1,
             add_zipcode = :new.ADD_ZIPCODE,
             add_city = :new.ADD_CITY,
             add_state = :new.ADD_STATE,
             add_comment = :new.ADD_COMMENT,
             add_format = :new.ADD_FORMAT,
             add_principal = 1,
             add_priority = :new.ADD_PRIORITY,
             add_care_of = :new.ADD_CARE_OF,
             add_po_box = :new.ADD_PO_BOX,
            add_po_box_nbr = :new.ADD_PO_BOX_NBR,
             add_county = :new.ADD_COUNTY
       WHERE     add_principal = 1
             AND pac_person_id = :new.pac_person_id
             AND :new.add_city IS NOT NULL;
   END IF;
   SELECT COUNT (*)
     INTO l_add_exist
     FROM pac_address
    WHERE     pac_person_id = :new.pac_person_id
          AND add_principal = 0
          AND dic_address_type_id = 'LPM2';

   IF l_add_exist = 0
   THEN
      INSERT INTO pac_address (PAC_ADDRESS_ID,
                               PAC_PERSON_ID,
                               PC_CNTRY_ID,
                               PC_LANG_ID,
                               DIC_ADDRESS_TYPE_ID,
                               A_DATECRE,
                               A_IDCRE,
                               C_PARTNER_STATUS,
                               ADD_ADDRESS1,
                               ADD_ZIPCODE,
                               ADD_CITY,
                               ADD_STATE,
                               ADD_COMMENT,
                               ADD_FORMAT,
                               ADD_PRINCIPAL,
                               ADD_PRIORITY,
                               ADD_CARE_OF,
                               ADD_PO_BOX,
                               ADD_PO_BOX_NBR,
                               ADD_COUNTY)
         SELECT init_id_seq.NEXTVAL,
                :new.PAC_PERSON_ID,
                :new.PC_CNTRY_ID2,
                :new.PC_LANG_ID2,
                'LPM2',
                SYSDATE,
                'LPM',
                :new.add_status2,
                :new.ADD_ADDRESS2,
                :new.ADD_ZIPCODE2,
                :new.ADD_CITY2,
                :new.ADD_STATE2,
                :new.ADD_COMMENT2,
                :new.ADD_FORMAT2,
                1,
                :new.ADD_PRIORITY2,
                :new.ADD_CARE_OF2,
                :new.ADD_PO_BOX2,
                :new.ADD_PO_BOX_NBR2,
                :new.ADD_COUNTY2
           FROM dic_address_type
          WHERE dic_address_type_id = 'LPM2' AND :new.add_city2 IS NOT NULL;
   ELSIF l_add_exist != 0
   THEN
      UPDATE pac_address
         SET pc_cntry_id = :new.PC_CNTRY_ID,
             pc_lang_id = :new.PC_LANG_ID,
             dic_address_type_id =
                (SELECT DIC_ADDRESS_TYPE_ID
                   FROM dic_address_type
                  WHERE dad_default = 1),
             a_datemod = SYSDATE,
             a_idmod = 'LPM',
             c_partner_status = :new.add_STATUS,
             add_address1 = :new.ADD_ADDRESS1,
             add_zipcode = :new.ADD_ZIPCODE,
             add_city = :new.ADD_CITY,
             add_state = :new.ADD_STATE,
             add_comment = :new.ADD_COMMENT,
             add_format = :new.ADD_FORMAT,
             add_principal = 1,
             add_priority = :new.ADD_PRIORITY,
             add_care_of = :new.ADD_CARE_OF,
             add_po_box = :new.ADD_PO_BOX,
             add_po_box_nbr = :new.ADD_PO_BOX_NBR,
             add_county = :new.ADD_COUNTY
       WHERE     add_principal = 0
             AND pac_person_id = :new.pac_person_id
             AND :new.add_city IS NOT NULL
             AND dic_address_type_id = 'LPM2';
   END IF;
   SELECT COUNT (*)
     INTO l_exist_phone
     FROM pac_communication c, dic_communication_type t
    WHERE     pac_person_id = :new.pac_person_id
          AND c.dic_communication_type_id = t.dic_communication_type_id
          AND dco_phone = 1;

   IF l_exist_phone = 0
   THEN
      INSERT INTO pac_communication (PAC_COMMUNICATION_ID,
                                     PAC_PERSON_ID,
                                     DIC_COMMUNICATION_TYPE_ID,
                                     A_DATECRE,
                                     A_IDCRE,
                                     COM_EXT_NUMBER)
         SELECT init_id_seq.NEXTVAL,
                :new.pac_person_id,
                dic_communication_type_id,
                SYSDATE,
                'LPM',
                :new.dco_phone
           FROM dic_communication_type
          WHERE dco_phone = 1 AND :new.dco_phone IS NOT NULL;
   ELSIF l_exist_phone != 0
   THEN
      UPDATE pac_communication
         SET com_ext_number = :new.dco_phone
       WHERE pac_person_id = :new.pac_person_id
             AND dic_communication_type_id =
                    (SELECT MIN (dic_communication_type_id)
                       FROM dic_communication_type
                      WHERE dco_phone = 1);
   END IF;
   SELECT COUNT (*)
     INTO l_exist_mobile
     FROM pac_communication c, dic_communication_type t
    WHERE     pac_person_id = :new.pac_person_id
          AND c.dic_communication_type_id = t.dic_communication_type_id
          AND dco_mobilephone = 1;
   IF l_exist_mobile = 0
   THEN
      INSERT INTO pac_communication (PAC_COMMUNICATION_ID,
                                     PAC_PERSON_ID,
                                     DIC_COMMUNICATION_TYPE_ID,
                                     A_DATECRE,
                                     A_IDCRE,
                                     COM_EXT_NUMBER)
         SELECT init_id_seq.NEXTVAL,
                :new.pac_person_id,
                dic_communication_type_id,
                SYSDATE,
                'LPM',
                :new.dco_mobilephone
           FROM dic_communication_type
          WHERE dco_mobilephone = 1 AND :new.dco_mobilephone IS NOT NULL;
   ELSIF l_exist_mobile != 0
   THEN
      UPDATE pac_communication
         SET com_ext_number = :new.dco_mobilephone
       WHERE pac_person_id = :new.pac_person_id
             AND dic_communication_type_id =
                    (SELECT MIN (dic_communication_type_id)
                       FROM dic_communication_type
                      WHERE dco_mobilephone = 1);
   END IF;
   SELECT COUNT (*)
     INTO l_exist_email
     FROM pac_communication c, dic_communication_type t
    WHERE     pac_person_id = :new.pac_person_id
          AND c.dic_communication_type_id = t.dic_communication_type_id
          AND dco_email = 1;
   IF l_exist_email = 0
   THEN
      INSERT INTO pac_communication (PAC_COMMUNICATION_ID,
                                     PAC_PERSON_ID,
                                     DIC_COMMUNICATION_TYPE_ID,
                                     A_DATECRE,
                                     A_IDCRE,
                                     COM_EXT_NUMBER)
         SELECT init_id_seq.NEXTVAL,
                :new.pac_person_id,
                dic_communication_type_id,
                SYSDATE,
                'LPM',
                :new.dco_email
           FROM dic_communication_type
          WHERE dco_email = 1 AND :new.dco_email IS NOT NULL;
   ELSIF l_exist_email != 0
   THEN
      UPDATE pac_communication
         SET com_ext_number = :new.dco_email
       WHERE pac_person_id = :new.pac_person_id
             AND dic_communication_type_id =
                    (SELECT MIN (dic_communication_type_id)
                       FROM dic_communication_type
                      WHERE dco_email = 1);
   END IF;
END LPM_ADD_IOU;

ALTER TRIGGER "C_ITX"."LPM_ADD_IOU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."MOB_ADD_IOIU_FWK"
  instead of insert or update
  on MOB_ADDRESS
  for each row
declare
  ltpl MOB_LIB_VIEW_PAC.T_address;
begin
  ltpl.PAC_ADDRESS_ID       := :new.PAC_ADDRESS_ID;
  ltpl.PAC_PERSON_ID        := :new.PAC_PERSON_ID;
  ltpl.CNTID                := :new.CNTID;
  ltpl.ADD_ADDRESS1         := :new.ADD_ADDRESS1;
  ltpl.ADD_ZIPCODE          := :new.ADD_ZIPCODE;
  ltpl.ADD_CITY             := :new.ADD_CITY;
  ltpl.ADD_STATE            := :new.ADD_STATE;
  ltpl.LANID                := :new.LANID;
  ltpl.DIC_ADDRESS_TYPE_ID  := :new.DIC_ADDRESS_TYPE_ID;
  ltpl.A_DELETED            := :new.A_DELETED;
  ltpl.A_DATEMOD            := :new.A_DATEMOD;
  ltpl.A_IDMOD              := :new.A_IDMOD;

  if (inserting) then
    mob_prc_view_pac.crud_address(ltpl, 'INSERT');
  else
    mob_prc_view_pac.crud_address(ltpl, 'UPDATE');
  end if;
end MOB_ADD_IOIU_FWK;

ALTER TRIGGER "C_ITX"."MOB_ADD_IOIU_FWK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."MOB_COM_IOIU_FWK"
  instead of insert or update
  on MOB_COMMUNICATION
  for each row
declare
  ltpl MOB_LIB_VIEW_PAC.T_COMMUNICATION;
begin
  ltpl.PAC_COMMUNICATION_ID       := :new.PAC_COMMUNICATION_ID;
  ltpl.PAC_PERSON_ID              := :new.PAC_PERSON_ID;
  ltpl.DIC_COMMUNICATION_TYPE_ID  := :new.DIC_COMMUNICATION_TYPE_ID;
  ltpl.COM_EXT_NUMBER             := :new.COM_EXT_NUMBER;
  ltpl.A_DELETED                  := :new.A_DELETED;
  ltpl.A_DATEMOD                  := :new.A_DATEMOD;
  ltpl.A_IDMOD                    := :new.A_IDMOD;

  if (inserting) then
    mob_prc_view_pac.CRUD_COMMUNICATION(ltpl, 'INSERT');
  else
    mob_prc_view_pac.CRUD_COMMUNICATION(ltpl, 'UPDATE');
  end if;
end MOB_COM_IOIU_FWK;

ALTER TRIGGER "C_ITX"."MOB_COM_IOIU_FWK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."MOB_CTC_IOIU_FWK"
  instead of insert or update
  on MOB_CONTACT
  for each row
declare
  ltpl MOB_LIB_VIEW_PAC.t_association;
begin
  ltpl.PAC_PERSON_ASSOCIATION_ID  := :new.PAC_PERSON_ASSOCIATION_ID;
  ltpl.PAC_COMPANY_ID             := :new.PAC_PERSON_ID;
  ltpl.PAS_MAIN_CONTACT           := :new.PAS_MAIN_CONTACT;
  ltpl.PAC_PERSON_ID              := :new.PAC_PAC_PERSON_ID;
  ltpl.PAS_FUNCTION               := :new.PAS_FUNCTION;
  ltpl.DIC_ASSOCIATION_TYPE_ID    := :new.DIC_ASSOCIATION_TYPE_ID;
  ltpl.DIC_PERSON_POLITNESS_ID    := :new.DIC_PERSON_POLITNESS_ID;
  ltpl.PER_NAME                   := :new.PER_NAME;
  ltpl.PER_FORENAME               := :new.PER_FORENAME;
  ltpl.PER_COMMENT                := :new.PER_COMMENT;
  ltpl.PER_KEY1                   := :new.PER_KEY1;
  ltpl.PER_KEY2                   := :new.PER_KEY2;
  ltpl.DIC_FREE_CODE1_ID          := :new.DIC_FREE_CODE1_ID;
  ltpl.DIC_FREE_CODE2_ID          := :new.DIC_FREE_CODE2_ID;
  ltpl.DIC_FREE_CODE3_ID          := :new.DIC_FREE_CODE3_ID;
  ltpl.DIC_FREE_CODE4_ID          := :new.DIC_FREE_CODE4_ID;
  ltpl.DIC_FREE_CODE5_ID          := :new.DIC_FREE_CODE5_ID;
  ltpl.DIC_FREE_CODE6_ID          := :new.DIC_FREE_CODE6_ID;
  ltpl.DIC_FREE_CODE7_ID          := :new.DIC_FREE_CODE7_ID;
  ltpl.DIC_FREE_CODE8_ID          := :new.DIC_FREE_CODE8_ID;
  ltpl.DIC_FREE_CODE9_ID          := :new.DIC_FREE_CODE9_ID;
  ltpl.DIC_FREE_CODE10_ID         := :new.DIC_FREE_CODE10_ID;
  ltpl.PER_SHORT_NAME             := :new.PER_SHORT_NAME;
  ltpl.PER_CONTACT                := :new.PER_CONTACT;
  ltpl.C_PARTNER_STATUS           := :new.C_PARTNER_STATUS;
  ltpl.A_DELETED                  := :new.A_DELETED;
  ltpl.A_DATEMOD                  := :new.A_DATEMOD;
  ltpl.A_IDMOD                    := :new.A_IDMOD;

  if (inserting) then
    if (:new.PER_SHORT_NAME IS NULL or :new.PER_SHORT_NAME = '') then
      ltpl.PER_SHORT_NAME := :new.PER_NAME || ' ' || :new.PER_FORENAME;
    end if;
    select PAC_PARTNER_MANAGEMENT.ExtractKey(ltpl.PER_SHORT_NAME, 'KEY1')
          ,PAC_PARTNER_MANAGEMENT.ExtractKey(ltpl.PER_SHORT_NAME, 'KEY2')
    into ltpl.PER_KEY1
        ,ltpl.PER_KEY2
    from dual;
    mob_prc_view_pac.CRUD_association(ltpl, 'INSERT');
  else
    mob_prc_view_pac.CRUD_association(ltpl, 'UPDATE');
  end if;
end MOB_CTC_IOIU_FWK;

ALTER TRIGGER "C_ITX"."MOB_CTC_IOIU_FWK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."MOB_EVE_IOIU_FWK"
  instead of insert or update
  on MOB_EVENTS
  for each row
declare
  ltpl MOB_LIB_VIEW_PAC.T_event;
begin
  ltpl.PAC_EVENT_ID       := :new.PAC_EVENT_ID;
  ltpl.PAC_COMPANY_ID     := :new.PAC_PERSON_ID;
  ltpl.PAC_LEAD_ID        := :new.PAC_LEAD_ID;
  ltpl.PAC_EVENT_TYPE_ID  := :new.PAC_EVENT_TYPE_ID;
  ltpl.EVE_SUBJECT        := :new.EVE_SUBJECT;
  ltpl.EVE_TEXT           := :new.EVE_TEXT;
  ltpl.EVE_DATE           := :new.EVE_DATE;
  ltpl.EVE_ENDDATE        := :new.EVE_ENDDATE;
  ltpl.PAC_PERSON_ID      := :new.PAC_PAC_PERSON_ID;
  ltpl.eve_user_id        := :new.eve_user_id;
  ltpl.eve_ended          := :new.eve_ended;
  ltpl.eve_date_completed := :new.eve_date_completed;
  ltpl.A_DELETED          := :new.A_DELETED;
  ltpl.A_DATEMOD          := :new.A_DATEMOD;
  ltpl.A_IDMOD            := :new.A_IDMOD;

  if (inserting) then
    if :new.eve_ended = 1 then
      ltpl.eve_date_completed := SYSDATE;
    end if;

    mob_prc_view_pac.CRUD_event(ltpl, 'INSERT');
  else
    if (:old.eve_ended = 0 or :old.eve_ended IS NULL) and :new.eve_ended = 1 then
      ltpl.eve_date_completed := SYSDATE;
    elsif :old.eve_ended = 1 and :new.eve_ended = 0 then
      ltpl.eve_date_completed := NULL;
    end if;

    mob_prc_view_pac.CRUD_event(ltpl, 'UPDATE');
  end if;
end MOB_EVE_IOIU_FWK;

ALTER TRIGGER "C_ITX"."MOB_EVE_IOIU_FWK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."MOB_LEA_IOIU_FWK"
  instead of insert or update
  on MOB_LEAD
  for each row
declare
  ltpl MOB_LIB_VIEW_PAC.T_lead;
begin
  ltpl.PAC_LEAD_ID                := :new.PAC_LEAD_ID;
  ltpl.PAC_PERSON_ID              := :new.PAC_PERSON_ID;
  ltpl.C_LEAD_STATUS              := :new.C_LEAD_STATUS;
  ltpl.LEA_LABEL                  := :new.LEA_LABEL;
  ltpl.LEA_COMMENT                := :new.LEA_COMMENT;
  ltpl.DIC_LEA_SOURCE_ID          := :new.DIC_LEA_SOURCE_ID;
  ltpl.LEA_SOURCE_COMMENT         := :new.LEA_SOURCE_COMMENT;
  ltpl.LEA_SOURCE_NR              := :new.LEA_SOURCE_NR;
  ltpl.DIC_LEA_CLASSIFICATION_ID  := :new.DIC_LEA_CLASSIFICATION_ID;
  ltpl.PAC_REPRESENTATIVE_ID      := :new.PAC_REPRESENTATIVE_ID;
  ltpl.LEA_USER_ID                := :new.LEA_USER_ID;
  ltpl.C_OPPORTUNITY_STATUS       := :new.C_OPPORTUNITY_STATUS;
  ltpl.LEA_RESULT_COMMENT         := :new.LEA_RESULT_COMMENT;
  ltpl.DIC_LEA_NEXT_STEP_ID       := :new.DIC_LEA_NEXT_STEP_ID;
  ltpl.DIC_LEA_RATING_ID          := :new.DIC_LEA_RATING_ID;
  ltpl.CURRENCY                   := :new.CURRENCY;
  ltpl.LEA_BUDGET_AMOUNT          := :new.LEA_BUDGET_AMOUNT;
  ltpl.LEA_OFFER_DEADLINE         := :new.LEA_OFFER_DEADLINE;
  ltpl.LEA_PROJECT_BEGIN_DATE     := :new.LEA_PROJECT_BEGIN_DATE;
  ltpl.LEA_PROJECT_END_DATE       := :new.LEA_PROJECT_END_DATE;
  ltpl.LEA_DATE                   := :new.LEA_DATE;
  ltpl.LEA_CONTACT_PERSON_ID      := :new.LEA_CONTACT_PERSON_ID;
  ltpl.LEA_NEXT_STEP_DEADLINE     := :new.LEA_NEXT_STEP_DEADLINE;
  ltpl.LEA_COMPANY_NAME           := :new.LEA_COMPANY_NAME;
  ltpl.LEA_COMP_ADDRESS           := :new.LEA_COMP_ADDRESS;
  ltpl.LEA_COMP_ZIPCODE           := :new.LEA_COMP_ZIPCODE;
  ltpl.LEA_COMP_CITY              := :new.LEA_COMP_CITY;
  ltpl.CNTID                      := :new.CNTID;
  ltpl.LANID                      := :new.LANID;
  ltpl.DIC_PERSON_POLITNESS_ID    := :new.DIC_PERSON_POLITNESS_ID;
  ltpl.LEA_CONTACT_NAME           := :new.LEA_CONTACT_NAME;
  ltpl.LEA_CONTACT_FORENAME       := :new.LEA_CONTACT_FORENAME;
  ltpl.LEA_CONTACT_LANG_ID        := :new.LEA_CONTACT_LANG_ID;
  ltpl.LEA_CONTACT_FUNCTION       := :new.LEA_CONTACT_FUNCTION;
  ltpl.DIC_ASSOCIATION_TYPE_ID    := :new.DIC_ASSOCIATION_TYPE_ID;
  ltpl.LEA_CONTACT_PHONE          := :new.LEA_CONTACT_PHONE;
  ltpl.LEA_CONTACT_FAX            := :new.LEA_CONTACT_FAX;
  ltpl.LEA_CONTACT_MOBILE         := :new.LEA_CONTACT_MOBILE;
  ltpl.LEA_CONTACT_EMAIL          := :new.LEA_CONTACT_EMAIL;
  ltpl.LEA_NUMBER                 := :new.LEA_NUMBER;
  ltpl.DIC_LEA_PROJ_STEP_ID       := :new.DIC_LEA_PROJ_STEP_ID;
  ltpl.DIC_LEA_REASON_ID          := :new.DIC_LEA_REASON_ID;
  ltpl.DIC_LEA_REASON_2_ID        := :new.DIC_LEA_REASON_2_ID;
  ltpl.LEA_REASON_COMMENT         := :new.LEA_REASON_COMMENT;
  ltpl.DIC_LEA_REASON_CUST_ID     := :new.DIC_LEA_REASON_CUST_ID;
  ltpl.DIC_LEA_REASON_CUST_2_ID   := :new.DIC_LEA_REASON_CUST_2_ID;
  ltpl.LEA_REASON_COMMENT_CUST    := :new.LEA_REASON_COMMENT_CUST;
  ltpl.DIC_LEA_CATEGORY_ID        := :new.DIC_LEA_CATEGORY_ID;
  ltpl.DIC_LEA_SUBCATEGORY_ID     := :new.DIC_LEA_SUBCATEGORY_ID;
  ltpl.A_DELETED                  := :new.A_DELETED;
  ltpl.A_DATEMOD                  := :new.A_DATEMOD;
  ltpl.A_IDMOD                    := :new.A_IDMOD;

  if (inserting) then
    mob_prc_view_pac.CRUD_lead(ltpl, 'INSERT');
  else
    mob_prc_view_pac.CRUD_lead(ltpl, 'UPDATE');
  end if;
end MOB_LEA_IOIU_FWK;

ALTER TRIGGER "C_ITX"."MOB_LEA_IOIU_FWK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."MOB_LEA_OFFER_GOOD_IOIU_FWK"
  instead of insert or update
  on MOB_LEAD_OFFER_GOOD
  for each row
declare
  ltpl MOB_LIB_VIEW_PAC.T_lead_offer_good;
begin
  ltpl.PAC_LEAD_OFFER_GOOD_ID  := :new.PAC_LEAD_OFFER_GOOD_ID;
  ltpl.PAC_LEAD_OFFER_ID       := :new.PAC_LEAD_OFFER_ID;
  ltpl.GCO_GOOD_ID             := :new.GCO_GOOD_ID;
  ltpl.LEO_GOOD_DESCR          := :new.LEO_GOOD_DESCR;
  ltpl.LEO_GOOD_COMMENT        := :new.LEO_GOOD_COMMENT;
  ltpl.LEO_GOOD_PRICE          := :new.LEO_GOOD_PRICE;
  ltpl.DOC_POSITION_ID         := :new.DOC_POSITION_ID;
  ltpl.LEO_GOOD_QTY            := :new.LEO_GOOD_QTY;
  ltpl.LEO_GOOD_UNIT_PRICE     := :new.LEO_GOOD_UNIT_PRICE;
  ltpl.A_DELETED               := :new.A_DELETED;
  ltpl.A_DATEMOD               := :new.A_DATEMOD;
  ltpl.A_IDMOD                 := :new.A_IDMOD;

  if (inserting) then
    mob_prc_view_pac.CRUD_lead_offer_good(ltpl, 'INSERT');
  else
    mob_prc_view_pac.CRUD_lead_offer_good(ltpl, 'UPDATE');
  end if;
end MOB_LEA_OFFER_GOOD_IOIU_FWK;

ALTER TRIGGER "C_ITX"."MOB_LEA_OFFER_GOOD_IOIU_FWK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."MOB_LEA_OFFER_IOIU_FWK"
  instead of insert or update
  on MOB_LEAD_OFFER
  for each row
declare
  ltpl MOB_LIB_VIEW_PAC.T_lead_offer;
begin
  ltpl.PAC_LEAD_OFFER_ID             := :new.PAC_LEAD_OFFER_ID;
  ltpl.LEO_NUMBER                    := :new.LEO_NUMBER;
  ltpl.PAC_LEAD_ID                   := :new.PAC_LEAD_ID;
  ltpl.LEO_DATE                      := :new.LEO_DATE;
  ltpl.LEO_COMMENT                   := :new.LEO_COMMENT;
  ltpl.LEO_PRICE                     := :new.LEO_PRICE;
  ltpl.CURRENCY                      := :new.CURRENCY;
  ltpl.DOC_DOCUMENT_ID               := :new.DOC_DOCUMENT_ID;
  ltpl.C_LEO_STATUS                  := :new.C_LEO_STATUS;
  ltpl.DIC_LEO_QUALIF_ID             := :new.DIC_LEO_QUALIF_ID;
  ltpl.DIC_PAC_LEAD_OFFER_FREE01_ID  := :new.DIC_PAC_LEAD_OFFER_FREE01_ID;
  ltpl.DIC_PAC_LEAD_OFFER_FREE02_ID  := :new.DIC_PAC_LEAD_OFFER_FREE02_ID;
  ltpl.DIC_PAC_LEAD_OFFER_FREE03_ID  := :new.DIC_PAC_LEAD_OFFER_FREE03_ID;
  ltpl.DIC_PAC_LEAD_OFFER_FREE04_ID  := :new.DIC_PAC_LEAD_OFFER_FREE04_ID;
  ltpl.DIC_PAC_LEAD_OFFER_FREE05_ID  := :new.DIC_PAC_LEAD_OFFER_FREE05_ID;
  ltpl.DIC_PAC_LEAD_OFFER_FREE06_ID  := :new.DIC_PAC_LEAD_OFFER_FREE06_ID;
  ltpl.DIC_PAC_LEAD_OFFER_FREE07_ID  := :new.DIC_PAC_LEAD_OFFER_FREE07_ID;
  ltpl.DIC_PAC_LEAD_OFFER_FREE08_ID  := :new.DIC_PAC_LEAD_OFFER_FREE08_ID;
  ltpl.DIC_PAC_LEAD_OFFER_FREE09_ID  := :new.DIC_PAC_LEAD_OFFER_FREE09_ID;
  ltpl.DIC_PAC_LEAD_OFFER_FREE10_ID  := :new.DIC_PAC_LEAD_OFFER_FREE10_ID;
  ltpl.DIC_QUOTE_TYPE_ID             := :new.DIC_QUOTE_TYPE_ID;
  ltpl.A_DELETED                     := :new.A_DELETED;
  ltpl.A_DATEMOD                     := :new.A_DATEMOD;
  ltpl.A_IDMOD                       := :new.A_IDMOD;

  if (inserting) then
    mob_prc_view_pac.CRUD_lead_offer(ltpl, 'INSERT');
  else
    mob_prc_view_pac.CRUD_lead_offer(ltpl, 'UPDATE');
  end if;
end MOB_LEA_OFFER_IOIU_FWK;

ALTER TRIGGER "C_ITX"."MOB_LEA_OFFER_IOIU_FWK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."MOB_PER_IOIU_FWK"
  instead of insert or update
  on MOB_PERSON
  for each row
declare
  ltpl MOB_LIB_VIEW_PAC.T_PERSON;
begin
  ltpl.PAC_PERSON_ID            := :new.PAC_PERSON_ID;
  ltpl.DIC_PERSON_POLITNESS_ID  := :new.DIC_PERSON_POLITNESS_ID;
  ltpl.PER_NAME                 := :new.PER_NAME;
  ltpl.PER_FORENAME             := :new.PER_FORENAME;
  ltpl.PER_ACTIVITY             := :new.PER_ACTIVITY;
  ltpl.PER_COMMENT              := :new.PER_COMMENT;
  ltpl.PER_KEY1                 := :new.PER_KEY1;
  ltpl.PER_KEY2                 := :new.PER_KEY2;
  ltpl.DIC_FREE_CODE1_ID        := :new.DIC_FREE_CODE1_ID;
  ltpl.DIC_FREE_CODE2_ID        := :new.DIC_FREE_CODE2_ID;
  ltpl.DIC_FREE_CODE3_ID        := :new.DIC_FREE_CODE3_ID;
  ltpl.DIC_FREE_CODE4_ID        := :new.DIC_FREE_CODE4_ID;
  ltpl.DIC_FREE_CODE5_ID        := :new.DIC_FREE_CODE5_ID;
  ltpl.DIC_FREE_CODE6_ID        := :new.DIC_FREE_CODE6_ID;
  ltpl.DIC_FREE_CODE7_ID        := :new.DIC_FREE_CODE7_ID;
  ltpl.DIC_FREE_CODE8_ID        := :new.DIC_FREE_CODE8_ID;
  ltpl.DIC_FREE_CODE9_ID        := :new.DIC_FREE_CODE9_ID;
  ltpl.DIC_FREE_CODE10_ID       := :new.DIC_FREE_CODE10_ID;
  ltpl.PER_SHORT_NAME           := :new.PER_SHORT_NAME;
  ltpl.PER_CONTACT              := :new.PER_CONTACT;
  ltpl.C_PARTNER_STATUS         := :new.C_PARTNER_STATUS;
  ltpl.PCO_DESCR                := :new.PCO_DESCR;
  ltpl.REP_DESCR                := :new.REP_DESCR;
  ltpl.DIC_TARIFF_ID            := :new.DIC_TARIFF_ID;
  ltpl.A_DELETED                := :new.a_deleted;

  if (inserting) then
    if (:new.PER_SHORT_NAME IS NULL or :new.PER_SHORT_NAME = '') then
      ltpl.PER_SHORT_NAME := :new.PER_NAME || ' ' || :new.PER_FORENAME;
    end if;
    select PAC_PARTNER_MANAGEMENT.ExtractKey(ltpl.PER_SHORT_NAME, 'KEY1')
          ,PAC_PARTNER_MANAGEMENT.ExtractKey(ltpl.PER_SHORT_NAME, 'KEY2')
    into ltpl.PER_KEY1
        ,ltpl.PER_KEY2
    from dual;
    mob_prc_view_pac.crud_person(ltpl, 'INSERT');
  else
    mob_prc_view_pac.crud_person(ltpl, 'UPDATE');
  end if;
end;

ALTER TRIGGER "C_ITX"."MOB_PER_IOIU_FWK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_ADD_AIU_REPLICATE"
  after insert or update
  on PAC_ADDRESS
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des partenaires.
 * @author skalayci
 * @author spfister
 * @date 06.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_PAC_TRIGGERS') = 1) then
    rep_functions.PublishPerson(:NEW.PAC_PERSON_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."PAC_ADD_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_ADD_AU_ZIPCITY"
after update of
  ADD_ZIPCODE, ADD_CITY, ADD_PRINCIPAL
on PAC_ADDRESS
referencing OLD as OLD NEW as NEW
for each row
declare
  vPersonId       PAC_ADDRESS.PAC_PERSON_ID%type;
  vZipCode        PAC_ADDRESS.ADD_ZIPCODE%type;
  vCity           PAC_ADDRESS.ADD_CITY%type;
begin
  /**
  * Seules les informations de l'adresse principale
  * entrent en considération
  **/
  if :NEW.ADD_PRINCIPAL = 1 then
    ACS_FUNCTION.UpdateAddPersonAccountDescr(:NEW.PAC_PERSON_ID,:NEW.ADD_ZIPCODE, :NEW.ADD_CITY);
  end if;

end PAC_ADD_AU_ZIPCITY;

ALTER TRIGGER "C_ITX"."PAC_ADD_AU_ZIPCITY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_ADD_BI_FORMAT_ADDRESS"
before insert
on PAC_ADDRESS
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*
* @author BL
* @version 2003
* @lastUpdate
*/
begin
  :NEW.ADD_FORMAT := PAC_PARTNER_MANAGEMENT.FormatingAddress(:NEW.ADD_ZIPCODE,
                                                             :NEW.ADD_CITY,
                                                             :NEW.ADD_STATE,
                                                             :NEW.ADD_COUNTY,
                                                             :NEW.PC_CNTRY_ID);
end PAC_ADD_BI_FORMAT_ADDRESS;

ALTER TRIGGER "C_ITX"."PAC_ADD_BI_FORMAT_ADDRESS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_ADD_BU_FORMAT_ADDRESS"
before update
of
  ADD_ZIPCODE,
  ADD_CITY,
  ADD_STATE,
  ADD_COUNTY,
  PC_CNTRY_ID
on PAC_ADDRESS
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*
* @author BL
* @version 2003
* @lastUpdate
*/
begin
  :NEW.ADD_FORMAT := PAC_PARTNER_MANAGEMENT.FormatingAddress(:NEW.ADD_ZIPCODE,
                                                             :NEW.ADD_CITY,
                                                             :NEW.ADD_STATE,
                                                             :NEW.ADD_COUNTY,
                                                             :NEW.PC_CNTRY_ID);
end PAC_ADD_BU_FORMAT_ADDRESS;

ALTER TRIGGER "C_ITX"."PAC_ADD_BU_FORMAT_ADDRESS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_BOO_COD_AIU_REPLICATE"
  after insert or update
  on PAC_BOOLEAN_CODE
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des partenaires.
 * @author skalayci
 * @author spfister
 * @date 06.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_PAC_TRIGGERS') = 1) then
    rep_functions.PublishPerson(:NEW.PAC_PERSON_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."PAC_BOO_COD_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_CHAR_COD_AIU_REPLICATE"
  after insert or update
  on PAC_CHAR_CODE
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des partenaires.
 * @author skalayci
 * @author spfister
 * @date 06.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_PAC_TRIGGERS') = 1) then
    rep_functions.PublishPerson(:NEW.PAC_PERSON_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."PAC_CHAR_COD_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_COM_AIU_REPLICATE"
  after insert or update
  on PAC_COMMUNICATION
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des partenaires.
 * @author skalayci
 * @author spfister
 * @date 06.20103
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_PAC_TRIGGERS') = 1) then
    rep_functions.PublishPerson(:NEW.PAC_PERSON_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."PAC_COM_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_COM_BIU_CTI_NUMBER"
before insert or update of COM_AREA_CODE,
                           COM_EXT_NUMBER,
                           PAC_ADDRESS_ID,
                           DIC_COMMUNICATION_TYPE_ID
on PAC_COMMUNICATION
referencing OLD as OLD NEW as NEW
for each row
declare
  cursor CountryCodesCursor
  is
    select nvl(CNT.CNT_IDD,''),nvl(CNT.CNT_CC,'')
    from PCS.PC_CNTRY CNT,
         PAC_PERSON_ASSOCIATION ASS,
         PAC_ADDRESS  ADR
    where ASS.PAC_PAC_PERSON_ID = :NEW.PAC_PERSON_ID
      and ADR.PAC_PERSON_ID     = ASS.PAC_PERSON_ID
      and CNT.PC_CNTRY_ID       = ADR.PC_CNTRY_ID
    order by CNTID ASC, ADR.ADD_PRINCIPAL DESC;

  vPhoneNumber       varchar(100);
  vIntNumLength      varchar2(5);
  vCntryCC           PCS.PC_CNTRY.CNT_CC%type;
  vCntryIDD          PCS.PC_CNTRY.CNT_IDD%type;
  vIntNumber         DIC_COMMUNICATION_TYPE.DCO_INT_NUMBER%type;
begin
  /**
  * Réception du flag indiquant la gestion n° international
  **/
  select nvl(max(DCO_INT_NUMBER),0)
  into vIntNumber
  from DIC_COMMUNICATION_TYPE
  where DIC_COMMUNICATION_TYPE_id = :NEW.DIC_COMMUNICATION_TYPE_ID;

  /**
  * Le traitement ne se fait que pour les types de communication marqués comme n° international
  * et si l'identifiant de PAC_ADDRESS_ID n'est pas nul
  **/
  if vIntNumber = 1 and :NEW.PAC_ADDRESS_ID is not null then
    /**
    *  Réception du code pays et code sortie selon le pays de l'adresse attachée
    *  à l'enregistrement courant
    **/
    select nvl(max(CNT.CNT_IDD),''),nvl(max(CNT.CNT_CC),'')
    into vCntryIDD, vCntryCC
    from PCS.PC_CNTRY CNT,
         PAC_ADDRESS  ADR
    where ADR.PAC_ADDRESS_ID = :NEW.PAC_ADDRESS_ID
      and CNT.PC_CNTRY_ID    = ADR.PC_CNTRY_ID;

    /**
    *  Si pas d'adresse rattaché à la communication,
    *  on prend l'adresse principale de la personne
    **/
    if vCntryIDD is null or vCntryCC is null then
      select nvl(max(CNT.CNT_IDD),''),nvl(max(CNT.CNT_CC),'')
      into vCntryIDD, vCntryCC
      from PCS.PC_CNTRY CNT,
           PAC_ADDRESS  ADR
      where ADR.PAC_PERSON_ID  = :NEW.PAC_PERSON_ID
        and ADR.ADD_PRINCIPAL  = 1
        and CNT.PC_CNTRY_ID    = ADR.PC_CNTRY_ID;
    end if;

    /**
    *  Step 3...Si pas d'adresse principale au niveau de la personne,
    *  codes du pays de l'adresse par défaut de la société
    *  Cette partie est inopérante lors de l'ajout du contact ;
    *  La création de l'association n'a pas encore eu lieu dans la base lors du passage
    *  dans ce trigger et donc impossible de rechercher la société liée .
    **/
    if vCntryIDD is null or vCntryCC is null then
      open CountryCodesCursor;
      fetch CountryCodesCursor into vCntryIDD, vCntryCC;
      close CountryCodesCursor;
    end if;

    /**
    * Step 4...Si pas d'adresse principale au niveau de la personne,
    *  codes du pays du mandat.
    **/
    if vCntryIDD is null or vCntryCC is null then
      select nvl(CNT.CNT_IDD,''),nvl(CNT.CNT_CC,'')
      into vCntryIDD, vCntryCC
      from PCS.PC_CNTRY CNT,
           PCS.PC_COMP CPY
      where CPY.PC_COMP_ID   = PCS.PC_I_LIB_SESSION.GetCompanyId
        and CNT.PC_CNTRY_ID  = CPY.PC_CNTRY_ID;
    end if;

    if (not vCntryIDD is null) and (not vCntryCC is null) then
      /**
      *  Réception de la longueur des numéros internes définis pour le User en particulier
      *  ou au schéma en général et formatage numéro complet : indicatif + numéro
      *  si les codes pays existent
      **/
      vIntNumLength                 := PAC_FUNCTIONS.GetConfigPropertyVal('50', PCS.PC_I_LIB_SESSION.GetUserId,'InternalPhoneNumberLength');
      vPhoneNumber                  := trim(:NEW.COM_AREA_CODE || :NEW.COM_EXT_NUMBER);
      :NEW.COM_INTERNATIONAL_NUMBER :=  PAC_FUNCTIONS.FormatInternationalPhoneNumber(vPhoneNumber,vCntryCC,vCntryIDD,'',vIntNumLength);
    end if;
  end if;

end PAC_COM_BIU_CTI_NUMBER;

ALTER TRIGGER "C_ITX"."PAC_COM_BIU_CTI_NUMBER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_CRE_LIM_AIU_REPLICATE"
  after insert or update
  on PAC_CREDIT_LIMIT
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des partenaires.
 * @author skalayci
 * @author spfister
 * @date 06.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_PAC_TRIGGERS') = 1) then
    if (:NEW.PAC_CUSTOM_PARTNER_ID is not null) then
      rep_functions.PublishPerson(:NEW.PAC_CUSTOM_PARTNER_ID, ln_result);
    else
      rep_functions.PublishPerson(:NEW.PAC_SUPPLIER_PARTNER_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."PAC_CRE_LIM_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_CUS_AIU_REPLICATE"
  after insert or update on
  PAC_CUSTOM_PARTNER
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des partenaires.
 * @author skalayci
 * @author spfister
 * @date 06.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_PAC_TRIGGERS') = 1) then
    rep_functions.PublishPerson(:NEW.PAC_CUSTOM_PARTNER_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."PAC_CUS_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_DAT_COD_AIU_REPLICATE"
  after insert or update
  on PAC_DATE_CODE
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des partenaires.
 * @author skalayci
 * @author spfister
 * @date 06.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_PAC_TRIGGERS') = 1) then
    rep_functions.PublishPerson(:NEW.PAC_PERSON_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."PAC_DAT_COD_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_EBP_BIU"
  before insert or update
  on PAC_EBPP_REFERENCE
  referencing old as old new as new
  for each row
/**
* Description
*   Mise à jour du descode C_EBPP_BSP en fonction du numéro d'adhérent e-facture saisi
* @author PYV
* @version 2012
* @lastUpdate
*/
begin
  :new.c_ebpp_bsp  := case substr(:new.ebp_account, 1, 4)
                       when '4101' then '01'   -- Paynet
                       when '4110' then '00'   -- YellowBill
                     end;
end PAC_EBP_BIU;

ALTER TRIGGER "C_ITX"."PAC_EBP_BIU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_EVE_AD_FREE_NUMBER"
after delete
on PAC_EVENT
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*
* @author BL
* @version 2003
* @lastUpdate
*/
begin

  PAC_PARTNER_MANAGEMENT.AddFreeNumber(:OLD.PAC_EVENT_TYPE_ID,
                                       :OLD.EVE_DATE,
                                       :OLD.EVE_NUMBER);

end PAC_EVE_AD_FREE_NUMBER;

ALTER TRIGGER "C_ITX"."PAC_EVE_AD_FREE_NUMBER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_EVENT_ENDED"
after update of
 EVE_ENDED
on PAC_EVENT
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*
* @author PVO
* @version 2003
* @lastUpdate
*/
declare
  vDOC_RECORD_ID DOC_RECORD.DOC_RECORD_ID%type;
  vEndCampaign   PAC_CAMPAIGN_QUALIF.CAQ_END_CAMPAIGN%type;
begin
  if (:NEW.PAC_CAMPAIGN_EVENT_ID > 0) and (:NEW.EVE_ENDED = 1) then
    select nvl(max(CAE.DOC_RECORD_ID),0) into vDOC_RECORD_ID
  	from PAC_CAMPAIGN_EVENT CAE
	  where CAE.PAC_CAMPAIGN_EVENT_ID = :NEW.PAC_CAMPAIGN_EVENT_ID;
	  select nvl(max(CAQ_END_CAMPAIGN), 0) into vEndCampaign
	  from PAC_CAMPAIGN_QUALIF
	  where PAC_EVENT_ID = :NEW.PAC_EVENT_ID;
  	if (vDOC_RECORD_ID > 0) and (vEndCampaign < 1) then
      PAC_CAMPAIGN.CreatePersonEvent(:NEW.PAC_CAMPAIGN_EVENT_ID, :NEW.PAC_PERSON_ID, :NEW.EVE_DATE_COMPLETED, :NEW.PAC_EVENT_ID, :NEW.PAC_ASSOCIATION_ID);
	  end if;
  end if;
end PAC_EVENT_ENDED;

ALTER TRIGGER "C_ITX"."PAC_EVENT_ENDED" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_FIN_REF_AIU_REPLICATE"
  after insert or update
  on PAC_FINANCIAL_REFERENCE
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des partenaires.
 * @author skalayci
 * @author spfister
 * @date 06.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_PAC_TRIGGERS') = 1) then
    if (:NEW.PAC_CUSTOM_PARTNER_ID is not null) then
      rep_functions.PublishPerson(:NEW.PAC_CUSTOM_PARTNER_ID, ln_result);
    else
      rep_functions.PublishPerson(:NEW.PAC_SUPPLIER_PARTNER_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."PAC_FIN_REF_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_NUM_COD_AIU_REPLICATE"
  after insert or update
  on PAC_NUMBER_CODE
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des partenaires.
 * @author skalayci
 * @author spfister
 * @date 06.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_PAC_TRIGGERS') = 1) then
    rep_functions.PublishPerson(:NEW.PAC_PERSON_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."PAC_NUM_COD_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_PER_AIU_REPLICATE"
  after insert or update
  on PAC_PERSON
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des partenaires.
 * @author skalayci
 * @author spfister
 * @date 06.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_PAC_TRIGGERS') = 1) then
    rep_functions.PublishPerson(:NEW.PAC_PERSON_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."PAC_PER_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_PER_ASS_AIU_REPLICATE"
  after insert or update
  on PAC_PERSON_ASSOCIATION
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des associations.
 * @author skalayci
 * @author spfister
 * @date 06.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_PAC_TRIGGERS') = 1) then
    rep_functions.PublishAssociation(:NEW.PAC_PERSON_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."PAC_PER_ASS_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_PER_AU_ACCOUNT_DESCR"
after update of
 PAC_PERSON_ID,
 PER_FORENAME,
 PER_NAME
on PAC_PERSON
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*
* @author BL
* @version 2003
* @lastUpdate
*/
begin
  PAC_PARTNER_MANAGEMENT.UPDATE_ACCOUNT_DESCR(
    :NEW.PAC_PERSON_ID,
    :NEW.PER_NAME,
    :NEW.PER_FORENAME);
end PAC_PER_AU_ACCOUNT_DESCR;

ALTER TRIGGER "C_ITX"."PAC_PER_AU_ACCOUNT_DESCR" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_SCP_BIU_CALC_TIME"
  before insert or update of SCP_NONWORKING_DAY, SCP_OPEN_TIME, SCP_CLOSE_TIME, SCP_WORKING_TIME
  on PAC_SCHEDULE_PERIOD
  referencing old as old new as new
  for each row
/**
* Description
*   Màj le champ de la durée de la période
* @author NGV
* @version 2003
*/
declare
begin
  -- Si jour non-ouvré, vider les heures et la durée de la période
  if :new.SCP_NONWORKING_DAY = 1 then
    :new.SCP_OPEN_TIME     := null;
    :new.SCP_CLOSE_TIME    := null;
    :new.SCP_WORKING_TIME  := null;
  else
    -- Calculer la durée de la période ouvrée
    :new.SCP_WORKING_TIME  := round( (:new.SCP_CLOSE_TIME - :new.SCP_OPEN_TIME) * 24, 2);
  end if;
end PAC_SCP_BIU_CALC_TIME;

ALTER TRIGGER "C_ITX"."PAC_SCP_BIU_CALC_TIME" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_SUP_AIU_REPLICATE"
  after insert or update
  on PAC_SUPPLIER_PARTNER
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des partenaires.
 * @author skalayci
 * @author spfister
 * @date 06.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_PAC_TRIGGERS') = 1) then
    rep_functions.PublishPerson(:NEW.PAC_SUPPLIER_PARTNER_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."PAC_SUP_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_THA_BI_METAL_ACCOUNT"
  before insert
  on PAC_THIRD_ALLOY
  referencing old as old new as new
  for each row
/**
* Description
*     Initialisation du numéro de la matière/alliage du tiers en fonction de la séquence PAC_THIRD_ALLOY_SEQ. Valable
*     uniquement si la configuration des comptes poids dans les documents (DOC_METAL_ACCOUNT) est active.
* @author Vincent Jeanfavre
* @version 2003
*/
declare
begin
  if     (PCS.PC_CONFIG.GetConfig('DOC_METAL_ACCOUNT') = '1')
     and :new.THA_NUMBER is null then
    select PAC_THIRD_ALLOY_SEQ.nextval
      into :new.THA_NUMBER
      from dual;
  end if;
end PAC_THA_BI_METAL_ACCOUNT;


ALTER TRIGGER "C_ITX"."PAC_THA_BI_METAL_ACCOUNT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PAC_THI_AIU_REPLICATE"
  after insert or update
  on PAC_THIRD
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication des partenaires.
 * @author skalayci
 * @author spfister
 * @date 06.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_PAC_TRIGGERS') = 1) then
    rep_functions.PublishPerson(:NEW.PAC_THIRD_ID, ln_result);
  end if;
end;

ALTER TRIGGER "C_ITX"."PAC_THI_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PPS_COM_AD_HIST"
after delete
on PPS_NOM_BOND
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*    mise à jour de l'historique
* @version 2003
* @lastUpdate
*/
declare
  aNew PPS_NOM_BOND%rowtype;
  aOld PPS_NOM_BOND%rowtype;

  begin

  -- transfert de :OLD dans aOld pour passage en paramètre
  aOld.A_DATECRE                      := :OLD.A_DATECRE;
  aOld.A_DATEMOD                      := :OLD.A_DATEMOD;
  aOld.A_IDCRE                        := :OLD.A_IDCRE;
  aOld.A_IDMOD                        := :OLD.A_IDMOD;
  aOld.A_RECLEVEL                     := :OLD.A_RECLEVEL;
  aOld.A_RECSTATUS                    := :OLD.A_RECSTATUS;
  aOld.COM_BEG_VALID                  := :OLD.COM_BEG_VALID;
  aOld.COM_END_VALID                  := :OLD.COM_END_VALID;
  aOld.COM_INTERVAL                   := :OLD.COM_INTERVAL;
  aOld.COM_PDIR_COEFF                 := :OLD.COM_PDIR_COEFF;
  aOld.COM_POS                        := :OLD.COM_POS;
  aOld.COM_REC_PCENT                  := :OLD.COM_REC_PCENT;
  aOld.COM_REMPLACEMENT               := :OLD.COM_REMPLACEMENT;
  aOld.COM_RES_NUM                    := :OLD.COM_RES_NUM;
  aOld.COM_RES_TEXT                   := :OLD.COM_RES_TEXT;
  aOld.COM_SEQ                        := :OLD.COM_SEQ;
  aOld.COM_SUBSTITUT                  := :OLD.COM_SUBSTITUT;
  aOld.COM_TEXT                       := :OLD.COM_TEXT;
  aOld.COM_UTIL_COEFF                 := :OLD.COM_UTIL_COEFF;
  aOld.COM_VAL                        := :OLD.COM_VAL;
  aOld.C_DISCHARGE_COM                := :OLD.C_DISCHARGE_COM;
  aOld.C_KIND_COM                     := :OLD.C_KIND_COM;
  aOld.C_REMPLACEMENT_NOM             := :OLD.C_REMPLACEMENT_NOM;
  aOld.C_TYPE_COM                     := :OLD.C_TYPE_COM;
  aOld.FAL_SCHEDULE_STEP_ID           := :OLD.FAL_SCHEDULE_STEP_ID;
  aOld.GCO_GOOD_ID                    := :OLD.GCO_GOOD_ID;
  aOld.PPS_NOMENCLATURE_ID            := :OLD.PPS_NOMENCLATURE_ID;
  aOld.PPS_NOM_BOND_ID                := :OLD.PPS_NOM_BOND_ID;
  aOld.PPS_PPS_NOMENCLATURE_ID        := :OLD.PPS_PPS_NOMENCLATURE_ID;
  aOld.PPS_RANGE_OPERATION_ID         := :OLD.PPS_RANGE_OPERATION_ID;
  aOld.STM_LOCATION_ID                := :OLD.STM_LOCATION_ID;
  aOld.STM_STOCK_ID                   := :OLD.STM_STOCK_ID;

  -- mise à jour de l'historique
  PPS_NOM_HIST.UPDATEHISTORY_BOND_AD (aOld);
end PPS_COM_AD_HIST;

ALTER TRIGGER "C_ITX"."PPS_COM_AD_HIST" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PPS_COM_AD_INTERRO"
after Delete
on PPS_NOM_BOND
referencing OLD as OLD NEW as NEW
for each row
begin
  DELETE FROM  PPS_NOM_INTER
  WHERE PPS_NOM_BOND_ID = :OLD.PPS_NOM_BOND_ID;
end PPS_COM_AD_INTERRO;

ALTER TRIGGER "C_ITX"."PPS_COM_AD_INTERRO" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PPS_COM_AI_HIST"
after insert
on PPS_NOM_BOND
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*    mise à jour de l'historique
* @version 2003
* @lastUpdate
*/
declare
  aNew PPS_NOM_BOND%rowtype;
  aOld PPS_NOM_BOND%rowtype;
  begin

  -- transfert de :NEW dans aNew pour passage en paramètre
  aNew.A_DATECRE                      := :NEW.A_DATECRE;
  aNew.A_DATEMOD                      := :NEW.A_DATEMOD;
  aNew.A_IDCRE                        := :NEW.A_IDCRE;
  aNew.A_IDMOD                        := :NEW.A_IDMOD;
  aNew.A_RECLEVEL                     := :NEW.A_RECLEVEL;
  aNew.A_RECSTATUS                    := :NEW.A_RECSTATUS;
  aNew.COM_BEG_VALID                  := :NEW.COM_BEG_VALID;
  aNew.COM_END_VALID                  := :NEW.COM_END_VALID;
  aNew.COM_INTERVAL                   := :NEW.COM_INTERVAL;
  aNew.COM_PDIR_COEFF                 := :NEW.COM_PDIR_COEFF;
  aNew.COM_POS                        := :NEW.COM_POS;
  aNew.COM_REC_PCENT                  := :NEW.COM_REC_PCENT;
  aNew.COM_REMPLACEMENT               := :NEW.COM_REMPLACEMENT;
  aNew.COM_RES_NUM                    := :NEW.COM_RES_NUM;
  aNew.COM_RES_TEXT                   := :NEW.COM_RES_TEXT;
  aNew.COM_SEQ                        := :NEW.COM_SEQ;
  aNew.COM_SUBSTITUT                  := :NEW.COM_SUBSTITUT;
  aNew.COM_TEXT                       := :NEW.COM_TEXT;
  aNew.COM_UTIL_COEFF                 := :NEW.COM_UTIL_COEFF;
  aNew.COM_VAL                        := :NEW.COM_VAL;
  aNew.C_DISCHARGE_COM                := :NEW.C_DISCHARGE_COM;
  aNew.C_KIND_COM                     := :NEW.C_KIND_COM;
  aNew.C_REMPLACEMENT_NOM             := :NEW.C_REMPLACEMENT_NOM;
  aNew.C_TYPE_COM                     := :NEW.C_TYPE_COM;
  aNew.FAL_SCHEDULE_STEP_ID           := :NEW.FAL_SCHEDULE_STEP_ID;
  aNew.GCO_GOOD_ID                    := :NEW.GCO_GOOD_ID;
  aNew.PPS_NOMENCLATURE_ID            := :NEW.PPS_NOMENCLATURE_ID;
  aNew.PPS_NOM_BOND_ID                := :NEW.PPS_NOM_BOND_ID;
  aNew.PPS_PPS_NOMENCLATURE_ID        := :NEW.PPS_PPS_NOMENCLATURE_ID;
  aNew.PPS_RANGE_OPERATION_ID         := :NEW.PPS_RANGE_OPERATION_ID;
  aNew.STM_LOCATION_ID                := :NEW.STM_LOCATION_ID;
  aNew.STM_STOCK_ID                   := :NEW.STM_STOCK_ID;

  -- mise à jour de l'historique
  PPS_NOM_HIST.UPDATEHISTORY_BOND_AI (aNew);
end PPS_COM_AI_HIST;

ALTER TRIGGER "C_ITX"."PPS_COM_AI_HIST" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PPS_COM_AI_INTERRO"
after Insert
on PPS_NOM_BOND
referencing OLD as OLD NEW as NEW
for each row
begin
  INSERT INTO PPS_NOM_INTER (PPS_NOMENCLATURE_ID, PPS_PRODUCT, C_TYPE_NOM, PPS_NOM_BOND_ID,
         PPS_COMPONENT)
  SELECT ENT.PPS_NOMENCLATURE_ID, ENT.GCO_GOOD_ID PPS_PRODUCT,  ENT.C_TYPE_NOM,
         :NEW.PPS_NOM_BOND_ID, :NEW.GCO_GOOD_ID PPS_COMPONENT
  FROM   PPS_NOMENCLATURE ENT
  WHERE ENT.PPS_NOMENCLATURE_ID = :NEW.PPS_NOMENCLATURE_ID;
end PPS_COM_AI_INTERRO;

ALTER TRIGGER "C_ITX"."PPS_COM_AI_INTERRO" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PPS_COM_AIUD_SHP_GCO_PUBLISH"
  after insert or update or delete
  of GCO_GOOD_ID, COM_POS, COM_SEQ, COM_RES_NUM
on PPS_NOM_BOND
  referencing old as old new as new
  for each row
/**
* Description
*    Ajout de l' ID du bien concerné dans la table SHP_TO_PUBLISH pour republication si un des champs suivant d'un composant
*    de la nomenclature a changé.
*    - GCO_GOOD_ID,
*    - COM_POS
*    - COM_SEQ
*    - COM_RES_NUM
* @created AGE 13.02.2012
* @lastUpdate age 06.09.2013
*/
declare
  lCompanyId      number  := PCS.PC_I_LIB_SESSION.GetCompanyId;
  lConliId        number  := PCS.PC_I_LIB_SESSION.GetConliId;
  lPublisableGood number;
  lGoodId         number;
  lResult         integer;
  lNomenclatureId number;
  lTypeNom        number;
  lDefault        number;
begin
  -- Si la version active du Shop = 3 et si l'option nomenclature est activée.
  if     pcs.PC_CONFIG.GetConfig('SHP_SHOP_VERSION', lCompanyId, lConliId) = SHP_I_LIB_TYPES.gcvExternalShopConnectorValue
     and pcs.PC_CONFIG.GetBooleanConfig('SHP_USE_OPTION_BOM', lCompanyId, lConliID) then
    -- Récupération de l'Id de la nomenclature du composant
    if deleting then
      lNomenclatureId  := :old.PPS_NOMENCLATURE_ID;
    else
      lNomenclatureId  := :new.PPS_NOMENCLATURE_ID;
    end if;

    -- Récupération de l'id du produit de la nomenclature,de sa propriété publiable du type de nomenclature et du flag par défaut.
    select nvl(goo.GOO_WEB_PUBLISHED, 0)
         , goo.GCO_GOOD_ID
         , nom.C_TYPE_NOM
         , nom.NOM_DEFAULT
      into lPublisableGood
         , lGoodId
         , lTypeNom
         , lDefault
      from GCO_GOOD goo
         , PPS_NOMENCLATURE NOM
     where goo.GCO_GOOD_ID = nom.GCO_GOOD_ID
       and nom.PPS_NOMENCLATURE_ID = lNomenclatureId;

    -- Si le produit est publiable, on l'insère dans la table SHP_TO_PUBLISH. Ne sont concernés
    -- que les composants d'une nomenclature par défaut de type Production ou SAV.
    if lPublisableGood = 1 and  lTypeNom in ('2', '8') and lDefault = 1 then
      lResult  := SHP_PRC_PUBLISH.publishRecord(lGoodId, 'PRODUCT', '1');   -- à (re)publier
    end if;
  end if;
exception
  -- dans ce cas, c'est l'effacement en cascade des composants suite à la suppression de la nomenclature.
  -- le trigger sur la nomenclature aura au besoin inséré le produit dans la table SHP_TO_PUBLISH.
  when ex.TABLE_MUTATING then
    null;
end PPS_COM_AIUD_SHP_GCO_PUBLISH;

ALTER TRIGGER "C_ITX"."PPS_COM_AIUD_SHP_GCO_PUBLISH" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PPS_COM_AU_HIST"
  after update
  on PPS_NOM_BOND
  referencing old as old new as new
  for each row
/**
* Description
*    mise à jour de l'historique
* @version 2003
* @lastUpdate
*/
declare
  aNew PPS_NOM_BOND%rowtype;
  aOld PPS_NOM_BOND%rowtype;
begin
  -- transfert de :NEW dans aNew pour passage en paramètre
  aNew.A_DATECRE                 := :new.A_DATECRE;
  aNew.A_DATEMOD                 := :new.A_DATEMOD;
  aNew.A_IDCRE                   := :new.A_IDCRE;
  aNew.A_IDMOD                   := :new.A_IDMOD;
  aNew.A_RECLEVEL                := :new.A_RECLEVEL;
  aNew.A_RECSTATUS               := :new.A_RECSTATUS;
  aNew.COM_BEG_VALID             := :new.COM_BEG_VALID;
  aNew.COM_END_VALID             := :new.COM_END_VALID;
  aNew.COM_INTERVAL              := :new.COM_INTERVAL;
  aNew.COM_PDIR_COEFF            := :new.COM_PDIR_COEFF;
  aNew.COM_POS                   := :new.COM_POS;
  aNew.COM_REC_PCENT             := :new.COM_REC_PCENT;
  aNew.COM_REMPLACEMENT          := :new.COM_REMPLACEMENT;
  aNew.COM_RES_NUM               := :new.COM_RES_NUM;
  aNew.COM_RES_TEXT              := :new.COM_RES_TEXT;
  aNew.COM_SEQ                   := :new.COM_SEQ;
  aNew.COM_SUBSTITUT             := :new.COM_SUBSTITUT;
  aNew.COM_TEXT                  := :new.COM_TEXT;
  aNew.COM_UTIL_COEFF            := :new.COM_UTIL_COEFF;
  aNew.COM_VAL                   := :new.COM_VAL;
  aNew.COM_PERCENT_WASTE         := :new.COM_PERCENT_WASTE;
  aNew.COM_FIXED_QUANTITY_WASTE  := :new.COM_FIXED_QUANTITY_WASTE;
  aNew.COM_QTY_REFERENCE_LOSS    := :new.COM_QTY_REFERENCE_LOSS;
  aNew.C_DISCHARGE_COM           := :new.C_DISCHARGE_COM;
  aNew.C_KIND_COM                := :new.C_KIND_COM;
  aNew.C_REMPLACEMENT_NOM        := :new.C_REMPLACEMENT_NOM;
  aNew.C_TYPE_COM                := :new.C_TYPE_COM;
  aNew.FAL_SCHEDULE_STEP_ID      := :new.FAL_SCHEDULE_STEP_ID;
  aNew.GCO_GOOD_ID               := :new.GCO_GOOD_ID;
  aNew.PPS_NOMENCLATURE_ID       := :new.PPS_NOMENCLATURE_ID;
  aNew.PPS_NOM_BOND_ID           := :new.PPS_NOM_BOND_ID;
  aNew.PPS_PPS_NOMENCLATURE_ID   := :new.PPS_PPS_NOMENCLATURE_ID;
  aNew.PPS_RANGE_OPERATION_ID    := :new.PPS_RANGE_OPERATION_ID;
  aNew.STM_LOCATION_ID           := :new.STM_LOCATION_ID;
  aNew.STM_STOCK_ID              := :new.STM_STOCK_ID;
  -- transfert de :OLD dans aOld pour passage en paramètre
  aOld.A_DATECRE                 := :old.A_DATECRE;
  aOld.A_DATEMOD                 := :old.A_DATEMOD;
  aOld.A_IDCRE                   := :old.A_IDCRE;
  aOld.A_IDMOD                   := :old.A_IDMOD;
  aOld.A_RECLEVEL                := :old.A_RECLEVEL;
  aOld.A_RECSTATUS               := :old.A_RECSTATUS;
  aOld.COM_BEG_VALID             := :old.COM_BEG_VALID;
  aOld.COM_END_VALID             := :old.COM_END_VALID;
  aOld.COM_INTERVAL              := :old.COM_INTERVAL;
  aOld.COM_PDIR_COEFF            := :old.COM_PDIR_COEFF;
  aOld.COM_POS                   := :old.COM_POS;
  aOld.COM_REC_PCENT             := :old.COM_REC_PCENT;
  aOld.COM_REMPLACEMENT          := :old.COM_REMPLACEMENT;
  aOld.COM_RES_NUM               := :old.COM_RES_NUM;
  aOld.COM_RES_TEXT              := :old.COM_RES_TEXT;
  aOld.COM_SEQ                   := :old.COM_SEQ;
  aOld.COM_SUBSTITUT             := :old.COM_SUBSTITUT;
  aOld.COM_TEXT                  := :old.COM_TEXT;
  aOld.COM_UTIL_COEFF            := :old.COM_UTIL_COEFF;
  aOld.COM_VAL                   := :old.COM_VAL;
  aOld.COM_PERCENT_WASTE         := :old.COM_PERCENT_WASTE;
  aOld.COM_FIXED_QUANTITY_WASTE  := :old.COM_FIXED_QUANTITY_WASTE;
  aOld.COM_QTY_REFERENCE_LOSS    := :old.COM_QTY_REFERENCE_LOSS;
  aOld.C_DISCHARGE_COM           := :old.C_DISCHARGE_COM;
  aOld.C_KIND_COM                := :old.C_KIND_COM;
  aOld.C_REMPLACEMENT_NOM        := :old.C_REMPLACEMENT_NOM;
  aOld.C_TYPE_COM                := :old.C_TYPE_COM;
  aOld.FAL_SCHEDULE_STEP_ID      := :old.FAL_SCHEDULE_STEP_ID;
  aOld.GCO_GOOD_ID               := :old.GCO_GOOD_ID;
  aOld.PPS_NOMENCLATURE_ID       := :old.PPS_NOMENCLATURE_ID;
  aOld.PPS_NOM_BOND_ID           := :old.PPS_NOM_BOND_ID;
  aOld.PPS_PPS_NOMENCLATURE_ID   := :old.PPS_PPS_NOMENCLATURE_ID;
  aOld.PPS_RANGE_OPERATION_ID    := :old.PPS_RANGE_OPERATION_ID;
  aOld.STM_LOCATION_ID           := :old.STM_LOCATION_ID;
  aOld.STM_STOCK_ID              := :old.STM_STOCK_ID;
  -- mise à jour de l'historique
  PPS_NOM_HIST.UPDATEHISTORY_BOND_AU(aOld, aNew);
end PPS_COM_AU_HIST;

ALTER TRIGGER "C_ITX"."PPS_COM_AU_HIST" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PPS_COM_AU_INTERRO"
  after update of GCO_GOOD_ID, PPS_NOM_BOND_ID, PPS_NOMENCLATURE_ID
  on PPS_NOM_BOND
  referencing old as old new as new
  for each row
begin
  update PPS_NOM_INTER
     set PPS_COMPONENT = :new.GCO_GOOD_ID
       , PPS_NOM_BOND_ID = :new.PPS_NOM_BOND_ID
       , PPS_NOMENCLATURE_ID = :new.PPS_NOMENCLATURE_ID
       , PPS_PRODUCT = (select GCO_GOOD_ID
                          from PPS_NOMENCLATURE
                         where PPS_NOMENCLATURE_ID = :new.PPS_NOMENCLATURE_ID)
   where PPS_NOM_BOND_ID = :old.PPS_NOM_BOND_ID;
end PPS_COM_AU_INTERRO;

ALTER TRIGGER "C_ITX"."PPS_COM_AU_INTERRO" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PPS_COM_BI_HIST"
before insert
on PPS_NOM_BOND
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*    mise à jour de l'historique
* @version DEVELOP
* @lastUpdate
*/

begin
select nom.nom_version, nom.nom_ref_qty
 into :new.com_nom_version, :new.com_ref_qty
from pps_nomenclature nom
where pps_nomenclature_id = :new.pps_nomenclature_id;

end PPS_COM_BI_HIST;

ALTER TRIGGER "C_ITX"."PPS_COM_BI_HIST" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PPS_COM_BI_INTEGRITY"
  before insert
  on PPS_NOM_BOND
  referencing old as old new as new
  for each row
/**
* Description
*    Intégration de règles de gestion
*
*    Règle 1 : forcer la valeur du coefficient plan directeur sur la base du
*              coefficient d'utilisation
*
* @version DEVELOP
* @lastUpdate
*/
begin
/* Règle 1 */
  if pcs.pc_config.GetConfigUpper('PPS_FORCE_COM_PDIR_COEFF') = '1' then
    :new.com_pdir_coeff  := :new.com_util_coeff;
  end if;
end PPS_COM_BI_INTEGRITY;

ALTER TRIGGER "C_ITX"."PPS_COM_BI_INTEGRITY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PPS_COM_BU_INTEGRITY"
  before update
  on PPS_NOM_BOND
  referencing old as old new as new
  for each row
/**
* Description
*    Intégration de règles de gestion
*
*    Règle 1 : forcer la valeur du coefficient plan directeur sur la base du
*              coefficient d'utilisation
*
* @version DEVELOP
* @lastUpdate
*/
begin
/* Règle 1 */
  if pcs.pc_config.GetConfigUpper('PPS_FORCE_COM_PDIR_COEFF') = '1' then
    :new.com_pdir_coeff  := :new.com_util_coeff;
  end if;
end PPS_COM_BU_INTEGRITY;

ALTER TRIGGER "C_ITX"."PPS_COM_BU_INTEGRITY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PPS_NBO_AD_REPLICATE"
  after delete
  on PPS_NOM_BOND
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication de la nomenclature
 * @author pzuchetto
 * @author spfister
 * @date 02.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    ln_result := rep_functions.PublishRecord(:OLD.PPS_NOMENCLATURE_ID, 'PPS_NOMENCLATURE');
  end if;
end;

ALTER TRIGGER "C_ITX"."PPS_NBO_AD_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PPS_NBO_AIU_REPLICATE"
  after insert or update
  on PPS_NOM_BOND
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication de la nomenclature.
 * @author pzuchetto
 * @author spfister
 * @date 01.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if (nvl(:OLD.GCO_GOOD_ID,0) <> nvl(:NEW.GCO_GOOD_ID,0)) or
       (nvl(:OLD.C_REMPLACEMENT_NOM,' ') <> nvl(:NEW.C_REMPLACEMENT_NOM,' ')) or
       (nvl(:OLD.C_TYPE_COM,' ') <> nvl(:NEW.C_TYPE_COM,' ')) or
       (nvl(:OLD.C_DISCHARGE_COM,' ') <> nvl(:NEW.C_DISCHARGE_COM,' ')) or
       (nvl(:OLD.C_KIND_COM,' ') <> nvl(:NEW.C_KIND_COM,' ')) or
       (nvl(:OLD.COM_SEQ,0) <> nvl(:NEW.COM_SEQ,0)) or
       (nvl(:OLD.COM_TEXT,' ') <> nvl(:NEW.COM_TEXT,' ')) or
       (nvl(:OLD.COM_RES_TEXT,' ') <> nvl(:NEW.COM_RES_TEXT,' ')) or
       (nvl(:OLD.COM_RES_NUM,0) <> nvl(:NEW.COM_RES_NUM,0)) or
       (nvl(:OLD.COM_VAL,0) <> nvl(:NEW.COM_VAL,0)) or
       (nvl(:OLD.COM_SUBSTITUT,0) <> nvl(:NEW.COM_SUBSTITUT,0)) or
       (nvl(:OLD.COM_POS,' ') <> nvl(:NEW.COM_POS,' ')) or
       (nvl(:OLD.COM_UTIL_COEFF,0) <> nvl(:NEW.COM_UTIL_COEFF,0)) or
       (nvl(:OLD.COM_PDIR_COEFF,0) <> nvl(:NEW.COM_PDIR_COEFF,0)) or
       (nvl(:OLD.COM_REC_PCENT,0) <> nvl(:NEW.COM_REC_PCENT,0)) or
       (nvl(:OLD.COM_INTERVAL,0) <> nvl(:NEW.COM_INTERVAL,0)) or
       (nvl(:OLD.COM_BEG_VALID,to_date('01011900','DDMMYYYY')) <> nvl(:NEW.COM_BEG_VALID,to_date('01011900','DDMMYYYY'))) or
       (nvl(:OLD.COM_END_VALID,to_date('01011900','DDMMYYYY')) <> nvl(:NEW.COM_END_VALID,to_date('01011900','DDMMYYYY'))) or
       (nvl(:OLD.COM_REMPLACEMENT,0) <> nvl(:NEW.COM_REMPLACEMENT,0)) or
       (nvl(:OLD.PPS_PPS_NOMENCLATURE_ID,0) <> nvl(:NEW.PPS_PPS_NOMENCLATURE_ID,0)) or
       (nvl(:OLD.COM_REF_QTY,0) <> nvl(:NEW.COM_REF_QTY,0)) or
       (nvl(:OLD.COM_PERCENT_WASTE,0) <> nvl(:NEW.COM_PERCENT_WASTE,0)) or
       (nvl(:OLD.COM_FIXED_QUANTITY_WASTE,0) <> nvl(:NEW.COM_FIXED_QUANTITY_WASTE,0)) or
       (nvl(:OLD.COM_QTY_REFERENCE_LOSS,0) <> nvl(:NEW.COM_QTY_REFERENCE_LOSS,0)) then
      rep_functions.PublishBOM(:NEW.PPS_NOMENCLATURE_ID, :NEW.GCO_GOOD_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."PPS_NBO_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PPS_NOM_AD_CONSTRAINTS"
  after delete
  on PPS_NOMENCLATURE
  referencing old as old new as new
  for each row
/**
* Description
*    remplace la contrainte cascade delete avec pps_nom_history
* @version 2003
* @lastUpdate
*/
declare
begin
  -- But : remplacer la contrainte cascade delete avec pps_nom_history
  delete from pps_nom_history
        where pps_nomenclature_id = :old.pps_nomenclature_id;
end PPS_NOM_AD_CONSTRAINTS;

ALTER TRIGGER "C_ITX"."PPS_NOM_AD_CONSTRAINTS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PPS_NOM_AI_HIST"
  after insert
  on PPS_NOMENCLATURE
  referencing old as old new as new
  for each row
/**
* Description
*    mise à jour de l'historique
* @version 2003
* @lastUpdate
*/
declare
  aNew PPS_NOMENCLATURE%rowtype;
begin
  aNew.A_DATECRE             := :new.A_DATECRE;
  aNew.A_DATEMOD             := :new.A_DATEMOD;
  aNew.A_IDCRE               := :new.A_IDCRE;
  aNew.A_IDMOD               := :new.A_IDMOD;
  aNew.A_RECLEVEL            := :new.A_RECLEVEL;
  aNew.A_RECSTATUS           := :new.A_RECSTATUS;
  aNew.C_REMPLACEMENT_NOM    := :new.C_REMPLACEMENT_NOM;
  aNew.C_TYPE_NOM            := :new.C_TYPE_NOM;
  aNew.FAL_SCHEDULE_PLAN_ID  := :new.FAL_SCHEDULE_PLAN_ID;
  aNew.GCO_GOOD_ID           := :new.GCO_GOOD_ID;
  aNew.NOM_BEG_VALID         := :new.NOM_BEG_VALID;
  aNew.NOM_DEFAULT           := :new.NOM_DEFAULT;
  aNew.NOM_REF_QTY           := :new.NOM_REF_QTY;
  aNew.NOM_TEXT              := :new.NOM_TEXT;
  aNew.NOM_VERSION           := :new.NOM_VERSION;
  aNew.PPS_NOMENCLATURE_ID   := :new.PPS_NOMENCLATURE_ID;
  aNew.PPS_RANGE_ID          := :new.PPS_RANGE_ID;
  PPS_NOM_HIST.UpdateHistory_NOM_AI(aNew);
end PPS_NOM_AI_HIST;

ALTER TRIGGER "C_ITX"."PPS_NOM_AI_HIST" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PPS_NOM_AIUD_SHP_GCO_PUBLISH"
  after insert or update or delete
  of C_TYPE_NOM, NOM_DEFAULT, GCO_GOOD_ID
on PPS_NOMENCLATURE
  referencing old as old new as new
  for each row
/**
* Description
*    Ajout de l' ID du bien concerné dans la table SHP_TO_PUBLISH pour republication si un des champs suivant
*    de la nomenclature a changé.
*    - C_TYPE_NOM
*    - NOM_DEFAULT
*    - GCO_GOOD_ID
* @created age 06.09.2013
* @lastUpdate
*/
declare
  lResult         integer;
  lCompanyId      number  := PCS.PC_I_LIB_SESSION.GetCompanyId;
  lConliId        number  := PCS.PC_I_LIB_SESSION.GetConliId;
  lPublisableGood number;
  lGoodId         number;
  lTypeNom        number;
  lDefault        number;
begin
  -- Si la version active du Shop = 3 et si l'option nomenclature est activée.
  if     pcs.PC_CONFIG.GetConfig('SHP_SHOP_VERSION', lCompanyId, lConliID) = SHP_I_LIB_TYPES.gcvExternalShopConnectorValue
     and pcs.PC_CONFIG.GetBooleanConfig('SHP_USE_OPTION_BOM', lCompanyId, lConliID) then
    if deleting then
      lTypeNom := :old.C_TYPE_NOM;
      lGoodId  := :old.GCO_GOOD_ID;
      lDefault := :old.NOM_DEFAULT;
    else
      lTypeNom := :new.C_TYPE_NOM;
      lGoodId  := :new.GCO_GOOD_ID;
      lDefault := :new.NOM_DEFAULT;
    end if;
    -- Seules les nomenclature par défaut de type production ou SAV sont concernées.
    if lTypeNom in ('2', '8') and lDefault = 1 then
      -- Récupération de la propriété publiable du produit de la nomenclature
      select nvl(GOO_WEB_PUBLISHED, 0)
        into lPublisableGood
        from GCO_GOOD
       where GCO_GOOD_ID = lGoodId;

      -- Si le produit est publiable, on l'insère dans la table SHP_TO_PUBLISH.
      if lPublisableGood = 1 then
        lResult  := SHP_PRC_PUBLISH.publishRecord(lGoodId, 'PRODUCT', '1');   -- à (re)publier
      end if;
    end if;
  end if;
end PPS_NOM_AIUD_SHP_GCO_PUBLISH;

ALTER TRIGGER "C_ITX"."PPS_NOM_AIUD_SHP_GCO_PUBLISH" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PPS_NOM_AIU_REPLICATE"
  after insert or update
  on PPS_NOMENCLATURE
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication de la nomenclature.
 * @author pzuchetto
 * @author spfister
 * @date 03.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 * pzuchetto 16.06.2003:
 *   - Suppression de l'appel de rep_functions.IsBOMReplicable
 *     qui est redondant avec l'appel de IsGoodReplicable.
 * pzuchetto 30.04.2003:
 *   - 2ème paramètre de IsBOMReplicable = 0, pour ne pas effectuer de
 *     test pour savoir si la nomenclature a été effacée entre temps.
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if (nvl(:OLD.C_REMPLACEMENT_NOM,' ') <> nvl(:NEW.C_REMPLACEMENT_NOM,' ')) or
       (nvl(:OLD.C_TYPE_NOM,' ') <> nvl(:NEW.C_TYPE_NOM,' ')) or
       (nvl(:OLD.FAL_SCHEDULE_PLAN_ID,0) <> nvl(:NEW.FAL_SCHEDULE_PLAN_ID,0)) or
       (nvl(:OLD.GCO_GOOD_ID,0) <> nvl(:NEW.GCO_GOOD_ID,0)) or
       (nvl(:OLD.NOM_BEG_VALID,to_date('01011900','DDMMYYYY')) <> nvl(:NEW.NOM_BEG_VALID,to_date('01011900','DDMMYYYY'))) or
       (nvl(:OLD.NOM_DEFAULT,0) <> nvl(:NEW.NOM_DEFAULT,0)) or
       (nvl(:OLD.NOM_REF_QTY,0) <> nvl(:NEW.NOM_REF_QTY,0)) or
       (nvl(:OLD.NOM_TEXT,' ') <> nvl(:NEW.NOM_TEXT,' ')) or
       (nvl(:OLD.NOM_VERSION,' ') <> nvl(:NEW.NOM_VERSION,' ')) or
       (nvl(:OLD.PPS_RANGE_ID,0) <> nvl(:NEW.PPS_RANGE_ID,0)) then
      if (rep_lib_replicate.IsGoodReplicable(:NEW.GCO_GOOD_ID) = 1) then
        ln_result := rep_functions.PublishRecord(:NEW.PPS_NOMENCLATURE_ID, 'PPS_NOMENCLATURE');
      end if;
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."PPS_NOM_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PPS_NOM_AU_HIST"
  after update
  on PPS_NOMENCLATURE
  referencing old as old new as new
  for each row
/**
* Description
*    mise à jour de l'historique
* @version 2003
* @lastUpdate
*/
declare
  aNew PPS_NOMENCLATURE%rowtype;
  aOld PPS_NOMENCLATURE%rowtype;
begin
  aNew.A_DATECRE             := :new.A_DATECRE;
  aNew.A_DATEMOD             := :new.A_DATEMOD;
  aNew.A_IDCRE               := :new.A_IDCRE;
  aNew.A_IDMOD               := :new.A_IDMOD;
  aNew.A_RECLEVEL            := :new.A_RECLEVEL;
  aNew.A_RECSTATUS           := :new.A_RECSTATUS;
  aNew.C_REMPLACEMENT_NOM    := :new.C_REMPLACEMENT_NOM;
  aNew.C_TYPE_NOM            := :new.C_TYPE_NOM;
  aNew.FAL_SCHEDULE_PLAN_ID  := :new.FAL_SCHEDULE_PLAN_ID;
  aNew.GCO_GOOD_ID           := :new.GCO_GOOD_ID;
  aNew.NOM_BEG_VALID         := :new.NOM_BEG_VALID;
  aNew.NOM_DEFAULT           := :new.NOM_DEFAULT;
  aNew.NOM_REF_QTY           := :new.NOM_REF_QTY;
  aNew.NOM_TEXT              := :new.NOM_TEXT;
  aNew.NOM_VERSION           := :new.NOM_VERSION;
  aNew.PPS_NOMENCLATURE_ID   := :new.PPS_NOMENCLATURE_ID;
  aNew.PPS_RANGE_ID          := :new.PPS_RANGE_ID;
  aOld.A_DATECRE             := :old.A_DATECRE;
  aOld.A_DATEMOD             := :old.A_DATEMOD;
  aOld.A_IDCRE               := :old.A_IDCRE;
  aOld.A_IDMOD               := :old.A_IDMOD;
  aOld.A_RECLEVEL            := :old.A_RECLEVEL;
  aOld.A_RECSTATUS           := :old.A_RECSTATUS;
  aOld.C_REMPLACEMENT_NOM    := :old.C_REMPLACEMENT_NOM;
  aOld.C_TYPE_NOM            := :old.C_TYPE_NOM;
  aOld.FAL_SCHEDULE_PLAN_ID  := :old.FAL_SCHEDULE_PLAN_ID;
  aOld.GCO_GOOD_ID           := :old.GCO_GOOD_ID;
  aOld.NOM_BEG_VALID         := :old.NOM_BEG_VALID;
  aOld.NOM_DEFAULT           := :old.NOM_DEFAULT;
  aOld.NOM_REF_QTY           := :old.NOM_REF_QTY;
  aOld.NOM_TEXT              := :old.NOM_TEXT;
  aOld.NOM_VERSION           := :old.NOM_VERSION;
  aOld.PPS_NOMENCLATURE_ID   := :old.PPS_NOMENCLATURE_ID;
  aOld.PPS_RANGE_ID          := :old.PPS_RANGE_ID;
  PPS_NOM_HIST.UpdateHistory_NOM_AU(aOld, aNew);
end PPS_NOM_AU_HIST;

ALTER TRIGGER "C_ITX"."PPS_NOM_AU_HIST" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PPS_NOM_AU_INTERRO"
  after update of GCO_GOOD_ID, C_TYPE_NOM
  on PPS_NOMENCLATURE
  referencing old as old new as new
  for each row
begin
  update PPS_NOM_INTER
     set PPS_PRODUCT = :new.GCO_GOOD_ID
       , C_TYPE_NOM = :new.C_TYPE_NOM
   where PPS_NOMENCLATURE_ID = :old.PPS_NOMENCLATURE_ID;
end PPS_NOM_AU_INTERRO;

ALTER TRIGGER "C_ITX"."PPS_NOM_AU_INTERRO" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PPS_NOM_AU_NOMENCLATURE"
  after update of nom_ref_qty, nom_version
  on PPS_NOMENCLATURE
  referencing old as old new as new
  for each row
/**
* Description
*    mise à jour de l'historique
* @version 2003
* @lastUpdate
*/
declare
  aNew PPS_NOMENCLATURE%rowtype;
  aOld PPS_NOMENCLATURE%rowtype;
begin
  update pps_nom_bond com
     set COM_REF_QTY = :new.nom_ref_qty
       , COM_NOM_VERSION = :new.nom_version
       , A_DATEMOD = sysdate
       , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
   where pps_nomenclature_id = :new.pps_nomenclature_id;
end PPS_NOM_AU_NOMENCLATURE;

ALTER TRIGGER "C_ITX"."PPS_NOM_AU_NOMENCLATURE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PTC_FCP_AU_UPDATE_COSTPRICE"
after update of "CPR_PRICE"
on PTC_FIXED_COSTPRICE
referencing old as old new as new
for each row
/**
* Description
*    Création d'un mouvement de correction lors de la modification du PRF par défaut
*    d'un bien géré avec inventaire permanent
* @author FP
* @version DEVELOP
* @lastUpdate
*/


begin
  if :NEW.CPR_DEFAULT = 1 and :NEW.C_COSTPRICE_STATUS = 'ACT' then
    PTC_COSTPRICE.GenPRFCorrectionMove(:NEW.GCO_GOOD_ID,:NEW.CPR_PRICE - :OLD.CPR_PRICE);
  end if;
end PTC_FCP_AU_UPDATE_COSTPRICE;


ALTER TRIGGER "C_ITX"."PTC_FCP_AU_UPDATE_COSTPRICE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PTC_FCP_BIU_PK2_HIST"
  before insert or update of "C_COSTPRICE_STATUS"
  on PTC_FIXED_COSTPRICE
  referencing old as old new as new
  for each row
/**
* Description
*    Permet de ne pas activer la PK2 sur les prix non actifs (HIS ou INA)
* @created FP 29.05.2008
* @lastUpdate age 04.03.2014
*/
begin
  if :new.C_COSTPRICE_STATUS = 'ACT' then
    :new.CPR_HISTORY_ID  := null;
  elsif :new.CPR_HISTORY_ID is null then
    :new.CPR_HISTORY_ID  := :new.PTC_FIXED_COSTPRICE_ID;
  end if;
end PTC_FCP_BIU_PK2_HIST;

ALTER TRIGGER "C_ITX"."PTC_FCP_BIU_PK2_HIST" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PTC_PRC_AD_REPLICATE"
  after delete
  on PTC_TARIFF
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication d'un article après suppression d'un tarif.
 * @author dsaade
 * @author spfister
 * @date 07.2011
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    -- vérifier si l'article correspondant est réplicable
    -- permet aussi de vérifier qu'il existe encore.
    if (rep_lib_replicate.IsGoodReplicable(:old.GCO_GOOD_ID) = 1) then
      rep_functions.PublishArticle(:old.GCO_GOOD_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."PTC_PRC_AD_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PTC_PRC_AIU_REPLICATE"
  after insert or update
  on PTC_TARIFF
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication d'un article.
 * @author pzuchetto
 * @author spfister
 * @date 03.2003
 * Modifications:
 * agentet 01.05.2015
 *   - Autoriser les structures de tarifs utilisées par des biens suspendus.
 * spfister 10.08.2012:
 *   - SolvaQueuing
 * spfister 15.09.2010:
 *   - Correction pour la prise en charge des tarifs par structure, envoi du
 *     premier article trouvé qui utilise la structure dont la catégorie est
 *     réplicable.
 */
declare
  ln_result INTEGER;
  ln_good_id gco_good.gco_good_id%TYPE;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if (Nvl(:old.ACS_FINANCIAL_CURRENCY_ID,0) <> Nvl(:new.ACS_FINANCIAL_CURRENCY_ID,0)) or
       (Nvl(:old.C_ROUND_TYPE,' ') <> Nvl(:new.C_ROUND_TYPE,' ')) or
       (Nvl(:old.C_TARIFFICATION_MODE,' ') <> Nvl(:new.C_TARIFFICATION_MODE,' ')) or
       (Nvl(:old.C_TARIFF_TYPE,' ') <> Nvl(:new.C_TARIFF_TYPE,' ')) or
       (Nvl(:old.DIC_PUR_TARIFF_STRUCT_ID,' ') <> Nvl(:new.DIC_PUR_TARIFF_STRUCT_ID,' ')) or
       (Nvl(:old.DIC_SALE_TARIFF_STRUCT_ID,' ') <> Nvl(:new.DIC_SALE_TARIFF_STRUCT_ID,' ')) or
       (Nvl(:old.DIC_TARIFF_ID,' ') <> Nvl(:new.DIC_TARIFF_ID,' ')) or
       (Nvl(:old.PAC_THIRD_ID,0) <> Nvl(:new.PAC_THIRD_ID,0)) or
       (Nvl(:old.PTC_TARIFF_ID,0) <> Nvl(:new.PTC_TARIFF_ID,0)) or
       (Nvl(:old.TRF_DESCR,' ') <> Nvl(:new.TRF_DESCR,' ')) or
       (Nvl(:old.TRF_ENDING_DATE,to_date('01011900','DDMMYYYY')) <> Nvl(:new.TRF_ENDING_DATE,to_date('01011900','DDMMYYYY'))) or
       (Nvl(:old.TRF_NET_TARIFF,0) <> Nvl(:new.TRF_NET_TARIFF,0)) or
       (Nvl(:old.TRF_ROUND_AMOUNT,0) <> Nvl(:new.TRF_ROUND_AMOUNT,0)) or
       (Nvl(:old.TRF_SPECIAL_TARIFF,0) <> Nvl(:new.TRF_SPECIAL_TARIFF,0)) or
       (Nvl(:old.TRF_SQL_CONDITIONAL,' ') <> Nvl(:new.TRF_SQL_CONDITIONAL,' ')) or
       (Nvl(:old.TRF_STARTING_DATE,to_date('01011900','DDMMYYYY')) <> Nvl(:new.TRF_STARTING_DATE,to_date('01011900','DDMMYYYY'))) or
       (Nvl(:old.TRF_UNIT,0) <> Nvl(:new.TRF_UNIT,0)) then
      -- Si GCO_GOOD_ID est null, alors il est très probable que c'est une structure
      -- de tarif, donc il faut rechercher le premier article qui l'utilise et qui
      -- est lié à une catégorie réplicable
      ln_good_id := :new.GCO_GOOD_ID;
      if (ln_good_id is null) then
        select Max(G.GCO_GOOD_ID)
        into ln_good_id
        from GCO_GOOD_CATEGORY C, GCO_GOOD G
        where G.C_GOOD_STATUS in (GCO_I_LIB_CONSTANT.gcGoodStatusActive, GCO_I_LIB_CONSTANT.gcGoodStatusSuspended) and
          (G.DIC_SALE_TARIFF_STRUCT_ID = :new.DIC_SALE_TARIFF_STRUCT_ID or
           G.DIC_PUR_TARIFF_STRUCT_ID = :new.DIC_PUR_TARIFF_STRUCT_ID) and
          C.GCO_GOOD_CATEGORY_ID = G.GCO_GOOD_CATEGORY_ID and
          C.C_REPLICATION_TYPE = '1';
      end if;
      rep_functions.PublishArticle(ln_good_id, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."PTC_PRC_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PTC_TRF_BIU_CONSTRAINT"
  before insert or update of "GCO_GOOD_ID", "DIC_PUR_TARIFF_STRUCT_ID", "DIC_SALE_TARIFF_STRUCT_ID"
  on PTC_TARIFF
  referencing old as old new as new
  for each row
/**
* Description
*    Contrainte vérifiant qu'au moins un bien ou une structure tariffaire soit liée au tarif
* @author FP 24.11.2004
* @version 2003
* @lastUpdate
*/
begin
  if    (    :new.GCO_GOOD_ID is null
         and :new.DIC_PUR_TARIFF_STRUCT_ID is null
         and :new.DIC_SALE_TARIFF_STRUCT_ID is null)
     or sign(:new.GCO_GOOD_ID) +
        sign(length(:new.DIC_PUR_TARIFF_STRUCT_ID) ) +
        sign(length(:new.DIC_SALE_TARIFF_STRUCT_ID) ) > 1 then
    raise_application_error
      (-20000
     , 'PCS - One and only one of these fields must be assigned: GCO_GOOD_ID, DIC_PUR_TARIFF_STRUCT_ID, DIC_SALE_TARIFF_STRUCT_ID!'
      );
  end if;
end PTC_TRF_BIU_CONSTRAINT;


ALTER TRIGGER "C_ITX"."PTC_TRF_BIU_CONSTRAINT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."PTC_TTA_AIU_REPLICATE"
  after insert or update
  on PTC_TARIFF_TABLE
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication d'un article.
 * @author pzuchetto
 * @author spfister
 * @date 03.2003
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
  ln_good_id gco_good.gco_good_id%TYPE;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if (Nvl(:old.PTC_TARIFF_ID,0) <> Nvl(:new.PTC_TARIFF_ID,0)) or
       (Nvl(:old.TTA_FROM_QUANTITY,0) <> Nvl(:new.TTA_FROM_QUANTITY,0)) or
       (Nvl(:old.TTA_PRICE,0) <> Nvl(:new.TTA_PRICE,0)) or
       (Nvl(:old.TTA_TO_QUANTITY,0) <> Nvl(:new.TTA_TO_QUANTITY,0)) then
      ln_good_id := rep_lib_replicate.GetGoodOfPTCTariff(:new.PTC_TARIFF_ID);
      if (ln_good_id is not null and ln_good_id != 0.0) then
        rep_functions.PublishArticle(ln_good_id, ln_result);
      end if;
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."PTC_TTA_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SCH_BILL_POS_BD_ENTERED_OUTLAY"
  before delete
  on SCH_BILL_POSITION
  referencing old as old new as new
  for each row
  /**
  * Description
  *   Réactivation des débours saisis correspondants à la position supprimée
  * @created ECA 23.09.08
  * @version 2003
  * @lastUpdate
  */
begin
  if :old.SCH_ENTERED_OUTLAY_ID is not null then
    update SCH_ENTERED_OUTLAY
       set EOU_STATUS = 1
     where SCH_ENTERED_OUTLAY_ID = :old.SCH_ENTERED_OUTLAY_ID
       and EOU_STATUS = 2;
  end if;
end SCH_BILL_POS_BD_ENTERED_OUTLAY;

ALTER TRIGGER "C_ITX"."SCH_BILL_POS_BD_ENTERED_OUTLAY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SCH_DISCOUNT_BIUD_GCO_SERVICE"
  before insert or delete or update
  on SCH_DISCOUNT
  referencing old as old new as new
  for each row
  /**
  * Description
  *   Synchronisation des Remises <-> Services
  * @created ECA 23.09.08
  * @version 2003
  * @lastUpdate
  */
declare
  aGCO_GOOD_ID number;
begin

  -- Insertion
  if Inserting
    or (updating and NVL(:old.GCO_GOOD_ID, 0) = 0) then
    -- Génération du service
    SCH_GOOD_INTERFACE.InsertService('2'
                                    , :new.DIS_MAJOR_REFERENCE
                                    , :new.DIS_SECONDARY_REFERENCE
                                    , :new.DIS_SHORT_DESCR
                                    , :new.DIS_LONG_DESCR
                                    , ''
                                    , aGCO_GOOD_ID
                                    );
    -- On le relie à la catégorie d'écolage
    :new.GCO_GOOD_ID := aGCO_GOOD_ID;

  -- Modification
  elsif updating then

    -- Modification du service, insertion s'il n'existe pas
    SCH_GOOD_INTERFACE.UpdateService(:old.GCO_GOOD_ID
                , :new.DIS_MAJOR_REFERENCE
                , :new.DIS_SECONDARY_REFERENCE
                , :new.DIS_SHORT_DESCR
                , :new.DIS_LONG_DESCR
                , ''
                , '2'
                , :new.SCH_DISCOUNT_ID
                );

  -- Suppression
  elsif deleting then
    -- Suppression du service
    SCH_GOOD_INTERFACE.DeleteService(:old.GCO_GOOD_ID);
  end if;

end SCH_DISCOUNT_BIUD_GCO_SERVICE;

ALTER TRIGGER "C_ITX"."SCH_DISCOUNT_BIUD_GCO_SERVICE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SCH_ECO_CAT_AI_FREE_DATA"
  after insert
  on SCH_ECOLAGE_CATEGORY
  referencing old as old new as new
  for each row
  /**
  * Description
  *   Copie des données libres de écolages à catégorie
  * @created ECA 23.09.08
  * @version 2003
  * @lastUpdate
  */
begin
  SCH_ECOLAGE_FUNCTIONS.CopyFreeDataFromEcolage(:new.SCH_ECOLAGE_ID
                                              , :new.SCH_ECOLAGE_CATEGORY_ID);
end SCH_ECO_CAT_AI_FREE_DATA;

ALTER TRIGGER "C_ITX"."SCH_ECO_CAT_AI_FREE_DATA" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SCH_ECO_CAT_BIUD_GCO_SERVICE"
  before insert or delete or update
  on SCH_ECOLAGE_CATEGORY
  referencing old as old new as new
  for each row
  /**
  * Description
  *   Synchronisation des  Ecolages <-> Services
  * @created ECA 23.09.08
  * @version 2003
  * @lastUpdate
  */
declare
  aGCO_GOOD_ID number;
begin

  -- Insertion
  if Inserting
    or (updating and NVL(:old.GCO_GOOD_ID, 0) = 0) then
    -- Génération du service
    SCH_GOOD_INTERFACE.InsertService('1'
                                    , :new.CAT_MAJOR_REFERENCE
                                    , :new.CAT_SECONDARY_REFERENCE
                                    , :new.CAT_SHORT_DESCR
                                    , :new.CAT_LONG_DESCR
                                    , :new.CAT_FREE_DESCR
                                    , aGCO_GOOD_ID
                                    );

    -- On le relie à la catégorie d'écolage
    :new.GCO_GOOD_ID := aGCO_GOOD_ID;

  -- Modification
  elsif updating then

    -- Modification du service, insertion s'il n'existe pas
    SCH_GOOD_INTERFACE.UpdateService(:old.GCO_GOOD_ID
                , :new.CAT_MAJOR_REFERENCE
                , :new.CAT_SECONDARY_REFERENCE
                , :new.CAT_SHORT_DESCR
                , :new.CAT_LONG_DESCR
                , :new.CAT_FREE_DESCR
                , '1'
                , :new.SCH_ECOLAGE_CATEGORY_ID
                );

  -- Suppression
  elsif deleting then
    -- Suppression du service
    SCH_GOOD_INTERFACE.DeleteService(:old.GCO_GOOD_ID);
  end if;

end SCH_ECO_CAT_BIUD_GCO_SERVICE;

ALTER TRIGGER "C_ITX"."SCH_ECO_CAT_BIUD_GCO_SERVICE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SCH_OUT_CAT_AI_FREE_DATA"
  after insert
  on SCH_OUTLAY_CATEGORY
  referencing old as old new as new
  for each row
  /**
  * Description
  *   Copie des données libres de débours à catégorie
  * @created ECA 23.09.08
  * @version 2003
  * @lastUpdate
  */
begin
  SCH_OUTLAY_FUNCTIONS.CopyFreeDataFromOutlay(:new.SCH_OUTLAY_ID
                                            , :new.SCH_OUTLAY_CATEGORY_ID);
end SCH_OUT_CAT_AI_FREE_DATA;

ALTER TRIGGER "C_ITX"."SCH_OUT_CAT_AI_FREE_DATA" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SCH_OUT_CAT_BIUD_GCO_SERVICE"
  before insert or delete or update
  on SCH_OUTLAY_CATEGORY
  referencing old as old new as new
  for each row
  /**
  * Description
  *   Synchronisation des  Débours <-> Services
  * @created ECA 23.09.08
  * @version 2003
  * @lastUpdate
  */
declare
  aGCO_GOOD_ID number;
begin
  -- Insertion
  if Inserting
    or (updating and NVL(:old.GCO_GOOD_ID, 0) = 0) then
    -- Génération du service
    SCH_GOOD_INTERFACE.InsertService('3'
                                    , :new.COU_MAJOR_REFERENCE
                                    , :new.COU_SECONDARY_REFERENCE
                                    , :new.COU_SHORT_DESCR
                                    , :new.COU_LONG_DESCR
                                    , :new.COU_FREE_DESCR
                                    , aGCO_GOOD_ID
                                    );
    -- on le relie à la catégorie d'écolage
    :new.GCO_GOOD_ID := aGCO_GOOD_ID;

  -- Modification
  elsif updating then
    -- Modification du service, insertion s'il n'existe pas
    SCH_GOOD_INTERFACE.UpdateService(:old.GCO_GOOD_ID
                , :new.COU_MAJOR_REFERENCE
                , :new.COU_SECONDARY_REFERENCE
                , :new.COU_SHORT_DESCR
                , :new.COU_LONG_DESCR
                , :new.COU_FREE_DESCR
                , '3'
                , :new.SCH_OUTLAY_CATEGORY_ID
                );
  -- Suppression
  elsif deleting then
    -- Suppression du service
    SCH_GOOD_INTERFACE.DeleteService(:old.GCO_GOOD_ID);
  end if;
end SCH_OUT_CAT_BIUD_GCO_SERVICE;

ALTER TRIGGER "C_ITX"."SCH_OUT_CAT_BIUD_GCO_SERVICE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SCH_STU_AI_SCH_STUDENT"
  after insert
  on SCH_STUDENT
  referencing old as old new as new
  for each row
/*--------------------------------------------------------
 Createur : Cassis Emmanuel .
 Date     : 23/06/2003 ;
 Objet    : Ajout automatique de la caractéristique libre
            Préfect = Faux à l'insertion d'un élève
----------------------------------------------------------*/
declare
  cursor CUR_SCH_FREE_CHARACT
  is
    select SCH_FREE_CHARACT_TYPE_ID
      from SCH_FREE_CHARACT_TYPE
     where CHT_SHORT_DESCR = 'Prefect';

  CurSchFreeCharact CUR_SCH_FREE_CHARACT%rowtype;
begin
  -- Recherche de la caractéristique à insérer
  open CUR_SCH_FREE_CHARACT;

  fetch CUR_SCH_FREE_CHARACT
   into CurSchFreeCharact;

  if CUR_SCH_FREE_CHARACT%found then
    -- Insertion de la caractéristique libre à faux
    insert into SCH_FREE_CHARACTERISTIC
                (SCH_FREE_CHARACTERISTIC_ID
               , SCH_STUDENT_ID
               , FRC_BOOLEAN_VAL
               , A_DATECRE
               , A_IDCRE
               , SCH_FREE_CHARACT_TYPE_ID
                )
         values (GetNewId
               , :new.SCH_STUDENT_ID
               , 0
               , sysdate
               , PCS.PC_I_LIB_SESSION.GETUSERINI
               , CurSchFreeCharact.SCH_FREE_CHARACT_TYPE_ID
                );
  end if;

  close CUR_SCH_FREE_CHARACT;
end SCH_STU_AI_SCH_STUDENT;

ALTER TRIGGER "C_ITX"."SCH_STU_AI_SCH_STUDENT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SCH_STU_AU_EXIT_DATE"
  after update of "STU_EXIT_DATE"
  on SCH_STUDENT
  referencing old as old new as new
  for each row
/**
* Description
*    gestion des date de fin d'appartenance en fonction de la date
* @author JFR
* @version 30.12.2013
* @lastUpdate
*/
declare
  ExitDate date;
begin
  if :new.STU_EXIT_DATE is not null then
    ExitDate  := trunc(:new.STU_EXIT_DATE);

    if PCS.PC_CONFIG.GetConfig('LPM_CLOSE_BELONGINGS') = 1 then
      update LPM_REFERENTS
         set LRE_END_DATE = ExitDate
       where SCH_STUDENT_ID = :new.SCH_STUDENT_ID
         and LRE_END_DATE is null;
    end if;

    if PCS.PC_CONFIG.GetConfig('LPM_CLOSE_BELONGINGS') = 2 then
      if to_char(ExitDate, 'D') <> '1' then
        update LPM_REFERENTS
           set LRE_END_DATE = next_day(ExitDate, 1)
         where SCH_STUDENT_ID = :new.SCH_STUDENT_ID
           and LRE_END_DATE is null;
      else
        update LPM_REFERENTS
           set LRE_END_DATE = ExitDate
         where SCH_STUDENT_ID = :new.SCH_STUDENT_ID
           and LRE_END_DATE is null;
      end if;
    end if;

    if PCS.PC_CONFIG.GetConfig('LPM_CLOSE_BELONGINGS') = 3 then
      update LPM_REFERENTS
         set LRE_END_DATE = last_day(ExitDate)
       where SCH_STUDENT_ID = :new.SCH_STUDENT_ID
         and LRE_END_DATE is null;
    end if;
  end if;
end SCH_STU_AU_EXIT_DATE;

ALTER TRIGGER "C_ITX"."SCH_STU_AU_EXIT_DATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SCH_STUDENT_BU_DATES"
AFTER UPDATE OF STU_ENTRY_DATE, STU_EXIT_DATE
ON SCH_STUDENT
REFERENCING OLD as OLD NEW as NEW
FOR EACH ROW
/*--------------------------------------------------------
 Createur : Cassis Emmanuel .
 Date     : 23/03/2012 ;
 Objet    : Historisation des dates entrées et sorties
----------------------------------------------------------*/
begin


  if trunc(NVL(:New.STU_ENTRY_DATE, to_date('01.01.1800','dd.mm.yyyy'))) <> trunc(NVL(:old.STU_ENTRY_DATE, to_date('01.01.1800','dd.mm.yyyy')))
    or trunc(NVL(:New.STU_EXIT_DATE, to_date('01.01.1800','dd.mm.yyyy'))) <> trunc(NVL(:old.STU_EXIT_DATE, to_date('01.01.1800','dd.mm.yyyy'))) then
    SCH_STUDENT_MANAGEMENT.InsertPresenceHistory(:old.SCH_STUDENT_ID
      , :New.STU_ENTRY_DATE
      , :Old.STU_ENTRY_DATE
      , :New.STU_EXIT_DATE
      , :Old.STU_EXIT_DATE);
  end if;
end SCH_STUDENT_BU_DATES;

ALTER TRIGGER "C_ITX"."SCH_STUDENT_BU_DATES" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SCH_VAT_BIUD_GCO_VAT_GOOD"
  before insert or delete or update
  on SCH_VAT
  referencing old as old new as new
  for each row
  /**
  * Description
  *   Synchronisation des  TVA Débours, écolages <-> TVA Services
  * @created ECA 23.09.08
  * @version 2003
  * @lastUpdate
  */
begin
  -- Insertion
  if Inserting then
    -- Génération de la TVA du service
    :new.GCO_VAT_GOOD_ID := SCH_GOOD_INTERFACE.InsertVatGood(NVL(:new.SCH_OUTLAY_CATEGORY_ID, :new.SCH_ECOLAGE_CATEGORY_ID)
                                                           , :new.ACS_VAT_DET_ACCOUNT_ID
                                                           , :new.DIC_TYPE_VAT_GOOD_ID);
  -- Modification
  elsif updating then
    -- Modification de la TVA du service, insertion si elle n'existe pas
    SCH_GOOD_INTERFACE.UpdateVatGood(:new.GCO_VAT_GOOD_ID
                                   , :new.ACS_VAT_DET_ACCOUNT_ID
                                   , :new.DIC_TYPE_VAT_GOOD_ID);
  -- Suppression
  elsif deleting then
    -- Suppression de la TVA du service
    SCH_GOOD_INTERFACE.DeleteVatGood(:old.GCO_VAT_GOOD_ID);
  end if;
end SCH_VAT_BIUD_GCO_VAT_GOOD;

ALTER TRIGGER "C_ITX"."SCH_VAT_BIUD_GCO_VAT_GOOD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SQM_ANC_AI_FREE_NUMBER"
after insert
on SQM_ANC
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*    Suppression du numéro de document dans la table doc_free_number
* @author ECA
* @lastUpdate
* @version
*/
declare
  gau_number         DOC_GAUGE.GAU_NUMBERING%TYPE;
  gauge_numbering_id DOC_GAUGE.DOC_GAUGE_NUMBERING_ID%TYPE;
  free_number        DOC_GAUGE_NUMBERING.GAN_FREE_NUMBER%TYPE;
  gauge_id           DOC_GAUGE.DOC_GAUGE_ID%TYPE;
begin
  -- Récupération du gabarit pour le type d'ANC
  gauge_id := SQM_ANC_FUNCTIONS.GetDocGaugeID(:NEW.C_ANC_TYPE);

  if gauge_id = 0 then
    if :NEW.C_ANC_TYPE = '1' then
      raise_application_error(-20010,PCS.PC_PUBLIC.TranslateWord('PCS - Gabarit de numérotation ANC interne non trouvé! Configuration : SQM_ANC_INTERN_GAUGE.',PCS.PC_PUBLIC.GetUserLangId));
    elsif :NEW.C_ANC_TYPE = '2' then
      raise_application_error(-20010,PCS.PC_PUBLIC.TranslateWord('PCS - Gabarit de numérotation ANC fournisseur non trouvé! Configuration : SQM_ANC_SUPPLIER_GAUGE.',PCS.PC_PUBLIC.GetUserLangId));
    elsif :NEW.C_ANC_TYPE = '3' then
      raise_application_error(-20010,PCS.PC_PUBLIC.TranslateWord('PCS - Gabarit de numérotation ANC fournisseur non trouvé! Configuration : SQM_ANC_CUSTOM_GAUGE.',PCS.PC_PUBLIC.GetUserLangId));
    else
      raise_application_error(-20010,PCS.PC_PUBLIC.TranslateWord('PCS - Type de l''ANC inconnu.',PCS.PC_PUBLIC.GetUserLangId));
    end if;
  end if;

  -- Recherche du type de numérotation
  begin
	  select GAU.GAU_NUMBERING,
	         GAU.DOC_GAUGE_NUMBERING_ID,
			 GAN.GAN_FREE_NUMBER
	    into gau_number,
		     gauge_numbering_id,
			 free_number
	    from DOC_GAUGE GAU,
		     DOC_GAUGE_NUMBERING GAN
	   where GAU.DOC_GAUGE_ID = gauge_id
	     and GAN.DOC_GAUGE_NUMBERING_ID (+) = GAU.DOC_GAUGE_NUMBERING_ID
         and gau.doc_gauge_id not in (select DOC_GAUGE_ID
   		                               from DOC_GAUGE_STRUCTURED);
  exception
    when no_data_found then
      raise_application_error(-20010,PCS.PC_PUBLIC.TranslateWord('PCS - Gabarit non trouvé!',PCS.PC_PUBLIC.GetUserLangId));
  end;

  -- si on gère la numérotation sur ce type de document
  if (gau_number = 1) and (free_number = 1) then

    DELETE FROM DOC_FREE_NUMBER
      WHERE DOF_NUMBER = :NEW.ANC_NUMBER;

  end if;

end SQM_ANC_AI_FREE_NUMBER;

ALTER TRIGGER "C_ITX"."SQM_ANC_AI_FREE_NUMBER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SQM_ANC_BD_FREE_NUMBER"
before delete
on SQM_ANC
referencing OLD as OLD NEW as NEW
for each row
/**
* Description
*     Gestion des numéros libres avant effacement
*     Récupération du numéro de document dans la table doc_free_number
* @author
* @lastUpdate ECA
* @version
*/
declare
  gau_number                   DOC_GAUGE.GAU_NUMBERING%TYPE;
  gauge_numbering_id           DOC_GAUGE.DOC_GAUGE_NUMBERING_ID%TYPE;
  free_number                  DOC_GAUGE_NUMBERING.GAN_FREE_NUMBER%TYPE;
  temp_number                  DOC_FREE_NUMBER.DOF_NUMBER%TYPE;
  gauge_id                     DOC_GAUGE.DOC_GAUGE_ID%TYPE;
begin
  -- Récupération du gabarit pour le type d'ANC
  gauge_id := SQM_ANC_FUNCTIONS.GetDocGaugeID(:OLD.C_ANC_TYPE);

  if gauge_id = 0 then
    if :NEW.C_ANC_TYPE = '1' then
      raise_application_error(-20010,PCS.PC_PUBLIC.TranslateWord('PCS - Gabarit de numérotation ANC interne non trouvé! Configuration : SQM_ANC_INTERN_GAUGE.',PCS.PC_PUBLIC.GetUserLangId));
    elsif :NEW.C_ANC_TYPE = '2' then
      raise_application_error(-20010,PCS.PC_PUBLIC.TranslateWord('PCS - Gabarit de numérotation ANC fournisseur non trouvé! Configuration : SQM_ANC_SUPPLIER_GAUGE.',PCS.PC_PUBLIC.GetUserLangId));
    elsif :NEW.C_ANC_TYPE = '3' then
      raise_application_error(-20010,PCS.PC_PUBLIC.TranslateWord('PCS - Gabarit de numérotation ANC client non trouvé! Configuration : SQM_ANC_CUSTOM_GAUGE.',PCS.PC_PUBLIC.GetUserLangId));
    else
      raise_application_error(-20010,PCS.PC_PUBLIC.TranslateWord('PCS - Type de l''ANC inconnu.',PCS.PC_PUBLIC.GetUserLangId));
    end if;
  end if;

  begin
	  select  GAU_NUMBERING,
	          GAU.DOC_GAUGE_NUMBERING_ID,
			  GAN_FREE_NUMBER
	     into gau_number,
		      gauge_numbering_id,
			  free_number
	     from DOC_GAUGE GAU,
		      DOC_GAUGE_NUMBERING GAN
	    where DOC_GAUGE_ID = gauge_id
	      and GAN.DOC_GAUGE_NUMBERING_ID (+) = GAU.DOC_GAUGE_NUMBERING_ID
		   and gau.doc_gauge_id not in (select DOC_GAUGE_ID
   		                                  from DOC_GAUGE_STRUCTURED);
  exception
    when no_data_found then
      raise_application_error(-20010,PCS.PC_PUBLIC.TranslateWord('PCS - Gabarit non trouvé!',PCS.PC_PUBLIC.GetUserLangId));
  end;

  -- si on gère la numérotation sur ce type de document
  if (gau_number = 1) and (free_number = 1) then
    begin
      INSERT INTO DOC_FREE_NUMBER (DOC_FREE_NUMBER_ID,
	                               DOC_GAUGE_NUMBERING_ID,
								   DOF_NUMBER,
								   DOF_CREATING)
                           VALUES (init_id_seq.nextval,
						           gauge_numbering_id,
								   :OLD.ANC_NUMBER,
								   0);
    exception
      when DUP_VAL_ON_INDEX then
        null;  -- en cas de doublons, on continue sans erreur
    end;
  end if;

end SQM_ANC_BD_FREE_NUMBER;

ALTER TRIGGER "C_ITX"."SQM_ANC_BD_FREE_NUMBER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SQM_ANC_BID_MISSING_NUMBERS"
  after insert or delete or update of "ANC_NUMBER"
  on SQM_ANC
  referencing old as old new as new
  for each row
/**
* Description
*    Gestion des numéros manquants
* @created ECA
* @version
* @lastUpdate
*/
declare
  ganIncrement DOC_GAUGE_NUMBERING.GAN_INCREMENT%type;
  gauge_id     DOC_GAUGE.DOC_GAUGE_ID%type;
begin
  -- suppression du numéro manquant
  if    inserting
     or updating then
    delete from DOC_MISSING_NUMBER
          where DMN_NUMBER = :new.ANC_NUMBER;
  end if;

  -- insertion du numéro dans la liste des numéros manquants
  if    updating
     or deleting then
    -- Récupération du gabarit pour le type d'ANC
    gauge_id  := SQM_ANC_FUNCTIONS.GetDocGaugeID(:old.C_ANC_TYPE);

    if gauge_id = 0 then
      if :new.C_ANC_TYPE = '1' then
        raise_application_error(-20010
                              , PCS.PC_PUBLIC.TranslateWord('PCS - Gabarit de numérotation ANC interne non trouvé! Configuration : SQM_ANC_INTERN_GAUGE.'
                                                          , PCS.PC_PUBLIC.GetUserLangId
                                                           )
                               );
      elsif :new.C_ANC_TYPE = '2' then
        raise_application_error
                            (-20010
                           , PCS.PC_PUBLIC.TranslateWord('PCS - Gabarit de numérotation ANC fournisseur non trouvé! Configuration : SQM_ANC_SUPPLIER_GAUGE.'
                                                       , PCS.PC_PUBLIC.GetUserLangId
                                                        )
                            );
      elsif :new.C_ANC_TYPE = '3' then
        raise_application_error(-20010
                              , PCS.PC_PUBLIC.TranslateWord('PCS - Gabarit de numérotation ANC client non trouvé! Configuration : SQM_ANC_CUSTOM_GAUGE.'
                                                          , PCS.PC_PUBLIC.GetUserLangId
                                                           )
                               );
      else
        raise_application_error(-20010, PCS.PC_PUBLIC.TranslateWord('PCS - Type de l''ANC inconnu.', PCS.PC_PUBLIC.GetUserLangId) );
      end if;
    end if;

    begin
      select gan.gan_increment
        into ganIncrement
        from doc_gauge gau
           , doc_gauge_numbering gan
       where gau.doc_gauge_id = gauge_id
         and gau.doc_gauge_numbering_id = gan.doc_gauge_numbering_id(+)
         and gau.doc_gauge_id not in(select DOC_GAUGE_ID
                                       from DOC_GAUGE_STRUCTURED);
    exception
      when no_data_found then
        raise_application_error(-20010, PCS.PC_PUBLIC.TranslateWord('PCS - Gabarit non trouvé!', PCS.PC_PUBLIC.GetUserLangId) );
    end;

    if ganIncrement = 1 then
      begin
        insert into DOC_MISSING_NUMBER
                    (DOC_MISSING_NUMBER_ID
                   , DOC_GAUGE_NUMBERING_ID
                   , STM_EXERCISE_ID
                   , DOC_GAUGE_ID
                   , DMN_NUMBER
                   , DMN_CREATING
                   , A_DATECRE
                   , A_IDCRE
                    )
          select init_id_seq.nextval
               , DOC_GAUGE_NUMBERING_ID
               , STM_FUNCTIONS.GetPeriodExerciseId(STM_FUNCTIONS.GetPeriodId(:old.ANC_DATE) )
               , gauge_id
               , :old.ANC_NUMBER
               , 0
               , sysdate
               , PCS.PC_I_LIB_SESSION.GetUserIni
            from DOC_GAUGE
           where DOC_GAUGE_ID = gauge_id;
      exception
        when dup_val_on_index then   -- ne pas déclencher d'exception si insertion de doublon
          null;
      end;
    end if;
  end if;
end SQM_ANC_BID_MISSING_NUMBERS;

ALTER TRIGGER "C_ITX"."SQM_ANC_BID_MISSING_NUMBERS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SQM_AUD_AIU_MODEL"
  after insert or update of SQM_AUDIT_MODEL_ID
  on SQM_AUDIT
  referencing old as old new as new
  for each row
/**
* Description
*     Génération de la structure de l'audit sur la base du modèle d'audit associé
* @author DSA
* @version 2003
* @lastUpdate
*/
declare
begin
  -- Au changement de modèle et si l'audit est au statut "saisi"
  if (:new.C_SQM_AUDIT_STATUS = '1') then
    if     updating
       and (:new.SQM_AUDIT_MODEL_ID <> :old.SQM_AUDIT_MODEL_ID) then
      -- Suppression du détail de l'audit
      delete from SQM_AUDIT_DETAIL
            where SQM_AUDIT_ID = :new.SQM_AUDIT_ID;
    end if;

    -- Insertion d'un détail d'audit pour chaque chapitre du modèle
    insert into SQM_AUDIT_DETAIL
                (SQM_AUDIT_DETAIL_ID
               , SQM_AUDIT_ID
               , SQM_AUDIT_CHAPTER_ID
               , A_DATECRE
               , A_IDCRE
                )
      select INIT_ID_SEQ.nextval
           , :new.SQM_AUDIT_ID
           , ACH.SQM_AUDIT_CHAPTER_ID
           , sysdate
           , PCS.PC_I_LIB_SESSION.GetUserIni
        from SQM_AUDIT_CHAPTER ACH
           , SQM_AUDIT_CHAP_S_MODEL CSM
       where ACH.SQM_AUDIT_CHAPTER_ID = CSM.SQM_AUDIT_CHAPTER_ID
         and CSM.SQM_AUDIT_MODEL_ID = :new.SQM_AUDIT_MODEL_ID;

    -- Insertion d'un détail d'audit pour chaque question à réponse unique
    -- (axe numérique, booléen et alphanumérique à choix unique)
    insert into SQM_AUDIT_DETAIL
                (SQM_AUDIT_DETAIL_ID
               , SQM_AUDIT_ID
               , SQM_AUDIT_CHAPTER_ID
               , SQM_AUDIT_QUESTION_ID
               , ADE_MCQ_SELECTED
               , A_DATECRE
               , A_IDCRE
                )
      select INIT_ID_SEQ.nextval
           , :new.SQM_AUDIT_ID
           , ACH.SQM_AUDIT_CHAPTER_ID
           , AQU.SQM_AUDIT_QUESTION_ID
           , 1
           , sysdate
           , PCS.PC_I_LIB_SESSION.GetUserIni
        from SQM_AUDIT_CHAPTER ACH
           , SQM_AUDIT_CHAP_S_MODEL CSM
           , SQM_AUDIT_QUESTION AQU
           , SQM_AXIS SAX
       where AQU.SQM_AUDIT_CHAPTER_ID = ACH.SQM_AUDIT_CHAPTER_ID
         and ACH.SQM_AUDIT_CHAPTER_ID = CSM.SQM_AUDIT_CHAPTER_ID
         and CSM.SQM_AUDIT_MODEL_ID = :new.SQM_AUDIT_MODEL_ID
         and SAX.SQM_AXIS_ID(+) = AQU.SQM_AXIS_ID
         and (   C_AXIS_TYPE is null
              or C_AXIS_TYPE = '1'
              or C_AXIS_TYPE = '2'
              or (    C_AXIS_TYPE = '3'
                  and AQU_MULTIPLE_ANSWER = 0) );

    -- Pour chaque question à choix multiple, insertion d'un détail d'audit par choix possible
    insert into SQM_AUDIT_DETAIL
                (SQM_AUDIT_DETAIL_ID
               , SQM_AUDIT_ID
               , SQM_AUDIT_CHAPTER_ID
               , SQM_AUDIT_QUESTION_ID
               , SQM_AXIS_VALUE_ID
               , ADE_MCQ_SELECTED
               , ADE_POINTS
               , A_DATECRE
               , A_IDCRE
                )
      select INIT_ID_SEQ.nextval
           , :new.SQM_AUDIT_ID
           , ACH.SQM_AUDIT_CHAPTER_ID
           , AQU.SQM_AUDIT_QUESTION_ID
           , AXV.SQM_AXIS_VALUE_ID
           , 0
           , STA.STA_PENALTY
           , sysdate
           , PCS.PC_I_LIB_SESSION.GetUserIni
        from SQM_AUDIT_CHAPTER ACH
           , SQM_AUDIT_CHAP_S_MODEL CSM
           , SQM_AUDIT_QUESTION AQU
           , SQM_AXIS SAX
           , SQM_AXIS_VALUE AXV
           , SQM_SCALE_TABLE STA
       where AQU.SQM_AUDIT_CHAPTER_ID = ACH.SQM_AUDIT_CHAPTER_ID
         and ACH.SQM_AUDIT_CHAPTER_ID = CSM.SQM_AUDIT_CHAPTER_ID
         and CSM.SQM_AUDIT_MODEL_ID = :new.SQM_AUDIT_MODEL_ID
         and SAX.SQM_AXIS_ID(+) = AQU.SQM_AXIS_ID
         and AXV.SQM_AXIS_ID(+) = SAX.SQM_AXIS_ID
         and AXV.SQM_AXIS_VALUE_ID = STA.SQM_AXIS_VALUE_ID
         and C_AXIS_TYPE = '3'
         and AQU_MULTIPLE_ANSWER = 1;
  end if;
end SQM_AUD_AIU_MODEL;

ALTER TRIGGER "C_ITX"."SQM_AUD_AIU_MODEL" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SQM_AUD_BD_PENALTY"
  before delete
  on SQM_AUDIT
  referencing old as old new as new
  for each row
/**
* Description
*     Suppression du détail et des notes attachées
* @author DSA
* @version 2003
* @lastUpdate
*/
declare
begin
  if :old.C_SQM_AUDIT_STATUS <> '3' then
    -- Suppression des notes
    delete from SQM_PENALTY
          where SQM_AUDIT_ID = :old.SQM_AUDIT_ID;

    -- Suppression du détail de l'audit
    delete from SQM_AUDIT_DETAIL
          where SQM_AUDIT_ID = :old.SQM_AUDIT_ID;
  end if;
end SQM_AUD_BD_PENALTY;


ALTER TRIGGER "C_ITX"."SQM_AUD_BD_PENALTY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SQM_AXI_AI_VALUES"
  after insert
  on SQM_AXIS
  referencing old as old new as new
  for each row
/**
* Description
*    Modifie la liste des valeurs selon le type d'axe qualité
* @author DSA
* @version DEVELOP
*/
begin
  -- Insertion des valeurs true et false pour un axe de type booléen
  if :new.C_AXIS_TYPE = '1' then
    insert into SQM_AXIS_VALUE
                (SQM_AXIS_ID
               , SQM_AXIS_VALUE_ID
               , AXV_VALUE
               , A_DATECRE
               , A_IDCRE
                )
      select :new.SQM_AXIS_ID
           , init_id_seq.nextval
           , 'TRUE'
           , sysdate
           , pcs.PC_I_LIB_SESSION.getuserini
        from dual;

    insert into SQM_AXIS_VALUE
                (SQM_AXIS_ID
               , SQM_AXIS_VALUE_ID
               , AXV_VALUE
               , A_DATECRE
               , A_IDCRE
                )
      select :new.SQM_AXIS_ID
           , init_id_seq.nextval
           , 'FALSE'
           , sysdate
           , pcs.PC_I_LIB_SESSION.getuserini
        from dual;
  end if;
end SQM_AXI_AI_VALUES;

ALTER TRIGGER "C_ITX"."SQM_AXI_AI_VALUES" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SQM_AXI_AU_VALUES"
  after update of "C_AXIS_TYPE"
  on SQM_AXIS
  referencing old as old new as new
  for each row
/**
* Description
*    Modifie la liste des valeurs selon le type d'axe qualité
* @author DSA
* @version DEVELOP
*/
begin
  delete from SQM_SCALE_TABLE
        where SQM_SCALE_ID in(select SQM_SCALE_ID
                                from SQM_SCALE
                               where SQM_AXIS_ID = :new.SQM_AXIS_ID);

  -- Suppression des anciennes valeurs associées
  delete from SQM_AXIS_VALUE
        where SQM_AXIS_ID = :new.SQM_AXIS_ID;

  -- Insertion des valeurs true et false pour un axe de type booléen
  if :new.C_AXIS_TYPE = '1' then
    insert into SQM_AXIS_VALUE
                (SQM_AXIS_ID
               , SQM_AXIS_VALUE_ID
               , AXV_VALUE
               , A_DATECRE
               , A_IDCRE
                )
      select :new.SQM_AXIS_ID
           , init_id_seq.nextval
           , 'TRUE'
           , sysdate
           , pcs.PC_I_LIB_SESSION.getuserini
        from dual;

    insert into SQM_AXIS_VALUE
                (SQM_AXIS_ID
               , SQM_AXIS_VALUE_ID
               , AXV_VALUE
               , A_DATECRE
               , A_IDCRE
                )
      select :new.SQM_AXIS_ID
           , init_id_seq.nextval
           , 'FALSE'
           , sysdate
           , pcs.PC_I_LIB_SESSION.getuserini
        from dual;
  end if;

  -- Réinitialisation des tabelles des notations associées
  -- Axe de type booléen --> une tabelle avec valeurs discrètes de l'axe
  if    (:new.C_AXIS_TYPE = '1')
     or (:new.C_AXIS_TYPE = '3') then
    insert into SQM_SCALE_TABLE
                (SQM_SCALE_TABLE_ID
               , SQM_SCALE_ID
               , SQM_AXIS_VALUE_ID
               , STA_PENALTY
               , A_IDCRE
               , A_DATECRE
                )
      select init_id_seq.nextval
           , SQM_SCALE_ID
           , SQM_AXIS_VALUE_ID
           , 0
           , pcs.PC_I_LIB_SESSION.getUserIni
           , sysdate
        from SQM_SCALE SCA
           , SQM_AXIS_VALUE AXV
       where AXV.SQM_AXIS_ID = :new.SQM_AXIS_ID
         and SCA.SQM_AXIS_ID = :new.SQM_AXIS_ID;
  else   -- axe de type numérique --> un écart 0,0,0 positif et un écart 0,0,0 négatif
    insert into SQM_SCALE_TABLE
                (SQM_SCALE_TABLE_ID
               , SQM_SCALE_ID
               , C_SQM_VARIATION_TYPE
               , STA_VARIATION_FROM
               , STA_VARIATION_TO
               , STA_PENALTY
               , A_IDCRE
               , A_DATECRE
                )
      select init_id_seq.nextval
           , SQM_SCALE_ID
           , 'POS'
           , 0
           , 0
           , 0
           , pcs.PC_I_LIB_SESSION.getUserIni
           , sysdate
        from SQM_SCALE SCA
       where SCA.SQM_AXIS_ID = :new.SQM_AXIS_ID;

    insert into SQM_SCALE_TABLE
                (SQM_SCALE_TABLE_ID
               , SQM_SCALE_ID
               , C_SQM_VARIATION_TYPE
               , STA_VARIATION_FROM
               , STA_VARIATION_TO
               , STA_PENALTY
               , A_IDCRE
               , A_DATECRE
                )
      select init_id_seq.nextval
           , SQM_SCALE_ID
           , 'NEG'
           , 0
           , 0
           , 0
           , pcs.PC_I_LIB_SESSION.getUserIni
           , sysdate
        from SQM_SCALE SCA
       where SCA.SQM_AXIS_ID = :new.SQM_AXIS_ID;
  end if;
end SQM_AXI_AU_VALUES;

ALTER TRIGGER "C_ITX"."SQM_AXI_AU_VALUES" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SQM_AXV_AI_VALUES"
  after insert
  on SQM_AXIS_VALUE
  referencing old as old new as new
  for each row
/**
* Description
*    Ajoute la valeur dans la tabelle des notations liées à l'axe alphanumérique concerné
* @author DSA
* @version DEVELOP
*/
declare
  cAxisType varchar2(1);
begin
  if inserting then
    begin
      select C_AXIS_TYPE
        into cAxisType
        from SQM_AXIS
       where SQM_AXIS_ID = :new.SQM_AXIS_ID;

      if cAxisType = '3' then
        insert into SQM_SCALE_TABLE
                    (SQM_SCALE_TABLE_ID
                   , SQM_SCALE_ID
                   , SQM_AXIS_VALUE_ID
                   , STA_PENALTY
                   , A_IDCRE
                   , A_DATECRE
                    )
          select init_id_seq.nextval
               , SQM_SCALE_ID
               , :new.SQM_AXIS_VALUE_ID
               , 0
               , pcs.PC_I_LIB_SESSION.getUserIni
               , sysdate
            from SQM_SCALE SCA
           where SCA.SQM_AXIS_ID = :new.SQM_AXIS_ID;
      end if;
    exception
      when ex.TABLE_MUTATING then
        null;
    end;
  end if;
end SQM_AXV_AI_VALUES;

ALTER TRIGGER "C_ITX"."SQM_AXV_AI_VALUES" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SQM_AXV_BD_VALUES"
  before delete
  on SQM_AXIS_VALUE
  referencing old as old new as new
  for each row
/**
* Description
*    Ajoute la valeur dans la tabelle des notations liées à l'axe alphanumérique concerné
* @author DSA
* @version DEVELOP
*/
declare
  cAxisType      varchar2(1);
begin
  if deleting then
    begin
      select C_AXIS_TYPE
        into cAxisType
        from SQM_AXIS
       where SQM_AXIS_ID = :old.SQM_AXIS_ID;

      if cAxisType = '3' then
        delete from SQM_SCALE_TABLE
              where SQM_AXIS_VALUE_ID = :old.SQM_AXIS_VALUE_ID;
      end if;
    exception
      when ex.TABLE_MUTATING then
        null;
    end;
  end if;
end SQM_AXV_BD_VALUES;

ALTER TRIGGER "C_ITX"."SQM_AXV_BD_VALUES" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SQM_EVA_AU_EVENTS"
  after update of C_SQM_EVALUATION_STATUS
  on SQM_EVALUATION
  referencing old as old new as new
  for each row
/**
* Description
*    trigger qui permet l'exécution des événements définis sur la catégorie de l'évaluation
* @author DSA
* @version DEVELOP
*/
begin
  -- Si l'évaluation est au statut "terminée", déclenchement des événements définis sur la catégorie
  if     :new.C_SQM_EVALUATION_STATUS <> :old.C_SQM_EVALUATION_STATUS
     and :new.C_SQM_EVALUATION_STATUS = 'DEF' then
     for res in (select SQM_FUNCTIONS.GetEvent(RES.SQM_RESULT_ID,:new.SQM_EVALUATION_CATEGORY_ID) EVENT
                     , PAC_THIRD_ID
                     , GCO_GOOD_ID
                  from SQM_RESULT RES
                     , SQM_EVALUATION_CATEGORY ECA
                 where ECA.SQM_EVALUATION_CATEGORY_ID = :new.SQM_EVALUATION_CATEGORY_ID
                   and RES.SQM_EVALUATION_METHOD_ID = ECA.SQM_EVALUATION_METHOD_ID) loop
      if RES.EVENT is not null then
        execute immediate 'begin ' || RES.EVENT || '(:ThirdId,:GoodId); end;'
                    using RES.PAC_THIRD_ID, RES.GCO_GOOD_ID;
      end if;
    end loop;
  end if;
end SQM_EVA_AU_EVENTS;

ALTER TRIGGER "C_ITX"."SQM_EVA_AU_EVENTS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SQM_SDA_AIU_DELAY"
  after insert or update of DIC_DELAY_TYPE_ID, SDA_DELAY
  on SQM_ANC_DIRECT_ACTION
  referencing old as old new as new
  for each row
/**
* Description
*    historisation des modifications de délais de mesures immédiates
* @author ECA
* @version DEVELOP
*/
declare
  aSQM_ANC_HIST_DELAY_ID SQM_ANC_HIST_DELAY.SQM_ANC_HIST_DELAY_ID%type;
  blnDoUpdate            boolean;
begin
  blnDoUpdate  := false;

  if     inserting
     and (   not(:new.SDA_DELAY is null)
          or not(:new.DIC_DELAY_TYPE_ID is null) ) then
    blnDoUpdate  := true;
  end if;

  if     updating
     and (    (:new.SDA_DELAY <> :old.SDA_DELAY)
          or (:new.DIC_DELAY_TYPE_ID <> :old.DIC_DELAY_TYPE_ID)
          or (    :new.DIC_DELAY_TYPE_ID is null
              and :old.DIC_DELAY_TYPE_ID is not null)
          or (    :new.DIC_DELAY_TYPE_ID is not null
              and :old.DIC_DELAY_TYPE_ID is null)
          or (    :new.SDA_DELAY is null
              and :old.SDA_DELAY is not null)
          or (    :new.SDA_DELAY is not null
              and :old.SDA_DELAY is null)
         ) then
    blnDoUpdate  := true;
  end if;

  if blnDoUpdate then
    aSQM_ANC_HIST_DELAY_ID  := GetNewId;

    insert into SQM_ANC_HIST_DELAY
                (SQM_ANC_HIST_DELAY_ID
               , DIC_DELAY_TYPE_ID
               , SQM_ANC_DIRECT_ACTION_ID
               , SAH_DELAY
               , A_DATECRE
               , A_IDCRE
                )
         values (aSQM_ANC_HIST_DELAY_ID
               , :new.DIC_DELAY_TYPE_ID
               , :new.SQM_ANC_DIRECT_ACTION_ID
               , :new.SDA_DELAY
               , sysdate
               , PCS.PC_PUBLIC.GetUserIni
                );
  end if;
end SQM_SDA_AIU_DELAY;

ALTER TRIGGER "C_ITX"."SQM_SDA_AIU_DELAY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SQM_SPA_AIU_DELAY"
  after insert or update of DIC_DELAY_TYPE_ID, SPA_DELAY
  on SQM_ANC_PREVENTIVE_ACTION
  referencing old as old new as new
  for each row
/**
* Description
*    historisation des modifications de délais de mesures immédiates
* @author ECA
* @version DEVELOP
*/
declare
  aSQM_ANC_HIST_DELAY_ID SQM_ANC_HIST_DELAY.SQM_ANC_HIST_DELAY_ID%type;
  blnDoUpdate            boolean;
begin
  blnDoUpdate  := false;

  if     inserting
     and (   not(:new.SPA_DELAY is null)
          or not(:new.DIC_DELAY_TYPE_ID is null) ) then
    blnDoUpdate  := true;
  end if;

  if     updating
     and (    (:new.SPA_DELAY <> :old.SPA_DELAY)
          or (:new.DIC_DELAY_TYPE_ID <> :old.DIC_DELAY_TYPE_ID)
          or (    :new.DIC_DELAY_TYPE_ID is null
              and :old.DIC_DELAY_TYPE_ID is not null)
          or (    :new.DIC_DELAY_TYPE_ID is not null
              and :old.DIC_DELAY_TYPE_ID is null)
          or (    :new.SPA_DELAY is null
              and :old.SPA_DELAY is not null)
          or (    :new.SPA_DELAY is not null
              and :old.SPA_DELAY is null)
         ) then
    blnDoUpdate  := true;
  end if;

  if blnDoUpdate then
    aSQM_ANC_HIST_DELAY_ID  := GetNewId;

    insert into SQM_ANC_HIST_DELAY
                (SQM_ANC_HIST_DELAY_ID
               , DIC_DELAY_TYPE_ID
               , SQM_ANC_PREVENTIVE_ACTION_ID
               , SAH_DELAY
               , A_DATECRE
               , A_IDCRE
                )
         values (aSQM_ANC_HIST_DELAY_ID
               , :new.DIC_DELAY_TYPE_ID
               , :new.SQM_ANC_PREVENTIVE_ACTION_ID
               , :new.SPA_DELAY
               , sysdate
               , PCS.PC_PUBLIC.GetUserIni
                );
  end if;
end SQM_SPA_AIU_DELAY;

ALTER TRIGGER "C_ITX"."SQM_SPA_AIU_DELAY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SQM_SPE_AU_DENORM"
AFTER UPDATE
OF DOC_POSITION_DETAIL_ID
ON SQM_PENALTY
Referencing OLD as OLD NEW as NEW
For each row
/**
* Description
*    Controle la non nullité de DOC_POSITION_DETAIL_ID dans SQM_PENALTY
* @author DSA
* @version DEVELOP
*/
Begin
  if :NEW.DOC_POSITION_DETAIL_ID <> :OLD.DOC_POSITION_DETAIL_ID then
    Raise_Application_Error(-20020,'PCS - SQM_PENALTY->DOC_POSITION_DETAIL_ID cannot be NULL or modified');
  end if;
end SQM_SPE_AU_DENORM;


ALTER TRIGGER "C_ITX"."SQM_SPE_AU_DENORM" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."SQM_SPE_BIU_AXIS_VALUE"
  before insert or update of SPE_UPDATED_VALUE
  on SQM_PENALTY
  referencing old as old new as new
  for each row
/**
* Description
*    trigger qui recalcule la valeur de la note modifiée après mise à jour de la valeur modifiée de l'axe
* @author DSA
* @version DEVELOP
*/
begin
  if nvl(to_char(:new.SPE_UPDATED_VALUE), 'NULL') <> nvl(to_char(:old.SPE_UPDATED_VALUE), 'NULL') then
    :new.SPE_MODIFIED_PENALTY  := SQM_FUNCTIONS.CalcPenalty(:new.SQM_SCALE_ID, :new.SPE_UPDATED_VALUE);
  end if;
end SQM_SPE_BIU_AXIS_VALUE;


ALTER TRIGGER "C_ITX"."SQM_SPE_BIU_AXIS_VALUE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_DIU_AIU_REPLICATE"
  after insert or update
  on STM_DISTRIBUTION_UNIT
  referencing OLD as OLD NEW as NEW
  for each row
/**
 * Réplication d'une unité de distribution.
 * @author pzuchetto
 * @author spfister
 * @date 07.2004
 * Modifications:
 * spfister 10.08.2012:
 *   - SolvaQueuing
 */
declare
  ln_result INTEGER;
begin
  if (rep_lib_replicate.can_trigger_replicate('REP_LOG_TRIGGERS') = 1) then
    if (nvl(:OLD.C_DRP_UNIT_TYPE,' ') <> nvl(:NEW.C_DRP_UNIT_TYPE,' ')) or
       (nvl(:OLD.DIC_DISTRIB_COMPL_DATA_ID,' ') <> nvl(:NEW.DIC_DISTRIB_COMPL_DATA_ID,' ')) or
       (nvl(:OLD.DIU_BLOCKED_FROM,to_date('01011900','DDMMYYYY')) <> nvl(:NEW.DIU_BLOCKED_FROM,to_date('01011900','DDMMYYYY'))) or
       (nvl(:OLD.DIU_BLOCKED_TO,to_date('01011900','DDMMYYYY')) <> nvl(:NEW.DIU_BLOCKED_TO,to_date('01011900','DDMMYYYY'))) or
       (nvl(:OLD.DIU_DESCRIPTION,' ') <> nvl(:NEW.DIU_DESCRIPTION,' ')) or
       (nvl(:OLD.DIU_LEVEL,0) <> nvl(:NEW.DIU_LEVEL,0)) or
       (nvl(:OLD.DIU_NAME,' ') <> nvl(:NEW.DIU_NAME,' ')) or
       (nvl(:OLD.DIU_PREPARE_TIME,0) <> nvl(:NEW.DIU_PREPARE_TIME,0)) or
       (nvl(:OLD.PAC_ADDRESS_ID,0) <> nvl(:NEW.PAC_ADDRESS_ID,0)) or
       (nvl(:OLD.STM_STM_DISTRIBUTION_UNIT_ID,0) <> nvl(:NEW.STM_STM_DISTRIBUTION_UNIT_ID,0)) or
       (nvl(:OLD.STM_STOCK_ID,0) <> nvl(:NEW.STM_STOCK_ID,0)) then
      rep_functions.PublishDIU(:new.STM_DISTRIBUTION_UNIT_ID, ln_result);
    end if;
  end if;
end;

ALTER TRIGGER "C_ITX"."STM_DIU_AIU_REPLICATE" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_ILP_AI_STATUS"
  after insert
  on STM_INVENTORY_LIST_POS
  referencing old as old new as new
  for each row
/**
* Description
*   maj du flag en inventaire du bien et du status des positions de stock
* @created SK 2003
* @updated : SMA 08.2012
*            FPE 04.02.2014 : normalisation du nom du trigger
*/
begin
  update GCO_GOOD_CALC_DATA
     set GOO_IN_INVENTORY = 1
       , GOO_INV_POS_COUNTER = GOO_INV_POS_COUNTER + 1   /*Incrémente le compteur de position d'inventaire */
       , a_datemod = sysdate
       , a_idmod = PCS.PC_I_LIB_SESSION.GetUserIni
   where GCO_GOOD_ID = :new.GCO_GOOD_ID;

  if not :new.STM_STOCK_POSITION_ID is null then   /* La position de liste fait référence à une position de stock*/
    update STM_STOCK_POSITION   /* Mise à jour du statut de la position de stock */
       set C_POSITION_STATUS = decode(GCO_LIB_COMPL_DATA.GetFixedStockPosition(:new.GCO_GOOD_ID, :new.STM_STOCK_ID, :new.STM_LOCATION_ID), 1, '03', '02')
         , a_datemod = sysdate
         , a_idmod = PCS.PC_I_LIB_SESSION.GetUserIni
     where STM_STOCK_POSITION_ID = :new.STM_STOCK_POSITION_ID;
  end if;
end STM_ILP_AI_STATUS;

ALTER TRIGGER "C_ITX"."STM_ILP_AI_STATUS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_ILP_BIUD_ELEMENT_NUMBER"
  before insert or delete or update of ILP_CHARACTERIZATION_VALUE_1
                                     , ILP_CHARACTERIZATION_VALUE_2
                                     , ILP_CHARACTERIZATION_VALUE_3
                                     , ILP_CHARACTERIZATION_VALUE_4
                                     , ILP_CHARACTERIZATION_VALUE_5
  on STM_INVENTORY_LIST_POS
  referencing old as old new as new
  for each row
/**
* Description
*    Maj de STM_ELEMENT_NUMBER
* @created fp 25.09.2003
* @version 2003
* @lastUpdate
*/
declare
  vMovementSort     STM_MOVEMENT_KIND.C_MOVEMENT_SORT%type;
  vElementNumberID1 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vElementNumberID2 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  vElementNumberID3 STM_ELEMENT_NUMBER.STM_ELEMENT_NUMBER_ID%type;
  lQualityStatusId  STM_ELEMENT_NUMBER.GCO_QUALITY_STATUS_ID%type;
  updateMode        varchar2(2);
begin
  -- si on a au moins une caractérization
  if nvl(:new.GCO_CHARACTERIZATION_ID, :old.GCO_CHARACTERIZATION_ID) is not null then
    -- Reception PT => Entrée en stock
    vMovementSort  := 'ENT';

    -- En effacement et en modification, traitement des anciennes valeurs
    if     (   deleting
            or updating)
       and (:old.ILP_IS_ORIGINAL_POS = 0) then
      -- Maj STM_ELEMENT_NUMBER en mode suppression
      STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => :old.GCO_GOOD_ID   /* Bien */
                                              , iUpdateMode               => 'D'   /* Mode de mise à jour (A-> Archivage des numéro) */
                                              , iMovementSort             => vMovementSort   /* Type de mouvement 'ENT' = Entrée 'SOR' = Sortie */
                                              , iCharacterizationId       => :old.GCO_CHARACTERIZATION_ID   /* Caractérisation 1-5 */
                                              , iCharacterization2Id      => :old.GCO_GCO_CHARACTERIZATION_ID
                                              , iCharacterization3Id      => :old.GCO2_GCO_CHARACTERIZATION_ID
                                              , iCharacterization4Id      => :old.GCO3_GCO_CHARACTERIZATION_ID
                                              , iCharacterization5Id      => :old.GCO4_GCO_CHARACTERIZATION_ID
                                              , iCharacterizationValue1   => :old.ILP_CHARACTERIZATION_VALUE_1   /* Valeur de caractérisation 1-5 */
                                              , iCharacterizationValue2   => :old.ILP_CHARACTERIZATION_VALUE_2
                                              , iCharacterizationValue3   => :old.ILP_CHARACTERIZATION_VALUE_3
                                              , iCharacterizationValue4   => :old.ILP_CHARACTERIZATION_VALUE_4
                                              , iCharacterizationValue5   => :old.ILP_CHARACTERIZATION_VALUE_5
                                              , iVerifyChar               => 1
                                              , iElementStatus            => null   /* Statut de l'élement après mise à jour */
                                              , ioElementNumberId1        => vElementNumberID1   /* Elément 1 en sortie */
                                              , ioElementNumberId2        => vElementNumberID2   /* Elément 2 en sortie */
                                              , ioElementNumberId3        => vElementNumberID3   /* Elément 3 en sortie */
                                              , ioQualityStatusId         => lQualityStatusId
                                               );
    end if;

    -- En création et en modification, traitement des nouvelles valeurs
    if     (   inserting
            or updating)
       and (:new.ILP_IS_ORIGINAL_POS = 0) then
      -- Maj STM_ELEMENT_NUMBER en mode insertion
      STM_I_PRC_STOCK_POSITION.GetElementNumber(iGoodId                   => :new.GCO_GOOD_ID   /* Bien */
                                              , iUpdateMode               => 'I'   /* Mode de mise à jour (A-> Archivage des numéro) */
                                              , iMovementSort             => vMovementSort   /* Type de mouvement 'ENT' = Entrée 'SOR' = Sortie */
                                              , iCharacterizationId       => :new.GCO_CHARACTERIZATION_ID   /* Caractérisation 1-5 */
                                              , iCharacterization2Id      => :new.GCO_GCO_CHARACTERIZATION_ID
                                              , iCharacterization3Id      => :new.GCO2_GCO_CHARACTERIZATION_ID
                                              , iCharacterization4Id      => :new.GCO3_GCO_CHARACTERIZATION_ID
                                              , iCharacterization5Id      => :new.GCO4_GCO_CHARACTERIZATION_ID
                                              , iCharacterizationValue1   => :new.ILP_CHARACTERIZATION_VALUE_1   /* Valeur de caractérisation 1-5 */
                                              , iCharacterizationValue2   => :new.ILP_CHARACTERIZATION_VALUE_2
                                              , iCharacterizationValue3   => :new.ILP_CHARACTERIZATION_VALUE_3
                                              , iCharacterizationValue4   => :new.ILP_CHARACTERIZATION_VALUE_4
                                              , iCharacterizationValue5   => :new.ILP_CHARACTERIZATION_VALUE_5
                                              , iVerifyChar               => 1   /* Vérification de l'unicité des valeurs de caract. */
                                              , iElementStatus            => null   /* Statut de l'élement après mise à jour */
                                              , ioElementNumberId1        => :new.STM_ELEMENT_NUMBER_ID   /* Elément 1 en sortie */
                                              , ioElementNumberId2        => :new.STM_STM_ELEMENT_NUMBER_ID   /* Elément 2 en sortie */
                                              , ioElementNumberId3        => :new.STM2_STM_ELEMENT_NUMBER_ID   /* Elément 3 en sortie */
                                              , ioQualityStatusId         => lQualityStatusId
                                               );
    end if;
  end if;
end STM_ILP_BIUD_ELEMENT_NUMBER;

ALTER TRIGGER "C_ITX"."STM_ILP_BIUD_ELEMENT_NUMBER" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_INV_AU_LOG"
  after update
  on STM_INVENTORY_EXTERNAL_LINE
  referencing old as old new as new
  for each row
/**
* Description
*    Trigger sur l'événement AfterUpdate de la table des lignes d'inventaires externes.
*    Il va ravitailler la table STM_INVENTORY_EXTERNAL_LOG contenant le log de toutes les modifications.
* @author JPZ
* @created
* @version 2002_05
* @lastUpdate 12.04.2002
* Modification
*   DSA 30.09.2005
*/
declare
  aNew STM_INVENTORY_EXTERNAL_LINE%rowtype;
  aOld STM_INVENTORY_EXTERNAL_LINE%rowtype;
begin
  -- transfert de :NEW dans aNew pour passage en paramètre
  aNew.STM_INVENTORY_EXTERNAL_LINE_ID  := :new.STM_INVENTORY_EXTERNAL_LINE_ID;
  aNew.C_INVENTORY_EXT_LINE_STATUS     := :new.C_INVENTORY_EXT_LINE_STATUS;
  aNew.A_DATEMOD                       := :new.A_DATEMOD;
  aNew.A_IDCRE                         := :new.A_IDCRE;
  aNew.A_IDMOD                         := :new.A_IDMOD;
  aNew.A_RECLEVEL                      := :new.A_RECLEVEL;
  aNew.A_RECSTATUS                     := :new.A_RECSTATUS;
  aNew.GCO_GOOD_ID                     := nvl(:new.GCO_GOOD_ID, 0);
  aNew.STM_STOCK_ID                    := nvl(:new.STM_STOCK_ID, 0);
  aNew.STM_LOCATION_ID                 := nvl(:new.STM_LOCATION_ID, 0);
  aNew.IEX_QUANTITY                    := nvl(:new.IEX_QUANTITY, 0);
  aNew.IEX_CHARACTERIZATION_VALUE_1    := nvl(:new.IEX_CHARACTERIZATION_VALUE_1, ' ');
  aNew.IEX_CHARACTERIZATION_VALUE_2    := nvl(:new.IEX_CHARACTERIZATION_VALUE_2, ' ');
  aNew.IEX_CHARACTERIZATION_VALUE_3    := nvl(:new.IEX_CHARACTERIZATION_VALUE_3, ' ');
  aNew.IEX_CHARACTERIZATION_VALUE_4    := nvl(:new.IEX_CHARACTERIZATION_VALUE_4, ' ');
  aNew.IEX_CHARACTERIZATION_VALUE_5    := nvl(:new.IEX_CHARACTERIZATION_VALUE_5, ' ');
  aNew.IEX_FREE_TEXT1                  := nvl(:new.IEX_FREE_TEXT1, ' ');
  aNew.IEX_FREE_TEXT2                  := nvl(:new.IEX_FREE_TEXT2, ' ');
  aNew.IEX_FREE_TEXT3                  := nvl(:new.IEX_FREE_TEXT3, ' ');
  aNew.IEX_FREE_TEXT4                  := nvl(:new.IEX_FREE_TEXT4, ' ');
  aNew.IEX_FREE_TEXT5                  := nvl(:new.IEX_FREE_TEXT5, ' ');
  aNew.IEX_FREE_NUMBER1                := nvl(:new.IEX_FREE_NUMBER1, 0);
  aNew.IEX_FREE_NUMBER2                := nvl(:new.IEX_FREE_NUMBER2, 0);
  aNew.IEX_FREE_NUMBER3                := nvl(:new.IEX_FREE_NUMBER3, 0);
  aNew.IEX_FREE_NUMBER4                := nvl(:new.IEX_FREE_NUMBER4, 0);
  aNew.IEX_FREE_NUMBER5                := nvl(:new.IEX_FREE_NUMBER5, 0);
  aNew.IEX_FREE_DATE1                  := :new.IEX_FREE_DATE1;
  aNew.IEX_FREE_DATE2                  := :new.IEX_FREE_DATE2;
  aNew.IEX_FREE_DATE3                  := :new.IEX_FREE_DATE3;
  aNew.IEX_FREE_DATE4                  := :new.IEX_FREE_DATE4;
  aNew.IEX_FREE_DATE5                  := :new.IEX_FREE_DATE5;
  -- transfert de :OLD dans aOld pour passage en paramètre
  aOld.STM_INVENTORY_EXTERNAL_LINE_ID  := :old.STM_INVENTORY_EXTERNAL_LINE_ID;
  aOld.C_INVENTORY_EXT_LINE_STATUS     := :old.C_INVENTORY_EXT_LINE_STATUS;
  aOld.A_DATECRE                       := :old.A_DATECRE;
  aOld.A_DATEMOD                       := :old.A_DATEMOD;
  aOld.A_IDCRE                         := :old.A_IDCRE;
  aOld.A_IDMOD                         := :old.A_IDMOD;
  aOld.A_RECLEVEL                      := :old.A_RECLEVEL;
  aOld.A_RECSTATUS                     := :old.A_RECSTATUS;
  aOld.GCO_GOOD_ID                     := nvl(:old.GCO_GOOD_ID, 0);
  aOld.STM_STOCK_ID                    := nvl(:old.STM_STOCK_ID, 0);
  aOld.STM_LOCATION_ID                 := nvl(:old.STM_LOCATION_ID, 0);
  aOld.IEX_QUANTITY                    := nvl(:old.IEX_QUANTITY, 0);
  aOld.IEX_CHARACTERIZATION_VALUE_1    := nvl(:old.IEX_CHARACTERIZATION_VALUE_1, ' ');
  aOld.IEX_CHARACTERIZATION_VALUE_2    := nvl(:old.IEX_CHARACTERIZATION_VALUE_2, ' ');
  aOld.IEX_CHARACTERIZATION_VALUE_3    := nvl(:old.IEX_CHARACTERIZATION_VALUE_3, ' ');
  aOld.IEX_CHARACTERIZATION_VALUE_4    := nvl(:old.IEX_CHARACTERIZATION_VALUE_4, ' ');
  aOld.IEX_CHARACTERIZATION_VALUE_5    := nvl(:old.IEX_CHARACTERIZATION_VALUE_5, ' ');
  aOld.IEX_FREE_TEXT1                  := nvl(:old.IEX_FREE_TEXT1, ' ');
  aOld.IEX_FREE_TEXT2                  := nvl(:old.IEX_FREE_TEXT2, ' ');
  aOld.IEX_FREE_TEXT3                  := nvl(:old.IEX_FREE_TEXT3, ' ');
  aOld.IEX_FREE_TEXT4                  := nvl(:old.IEX_FREE_TEXT4, ' ');
  aOld.IEX_FREE_TEXT5                  := nvl(:old.IEX_FREE_TEXT5, ' ');
  aOld.IEX_FREE_NUMBER1                := nvl(:old.IEX_FREE_NUMBER1, 0);
  aOld.IEX_FREE_NUMBER2                := nvl(:old.IEX_FREE_NUMBER2, 0);
  aOld.IEX_FREE_NUMBER3                := nvl(:old.IEX_FREE_NUMBER3, 0);
  aOld.IEX_FREE_NUMBER4                := nvl(:old.IEX_FREE_NUMBER4, 0);
  aOld.IEX_FREE_NUMBER5                := nvl(:old.IEX_FREE_NUMBER5, 0);
  aOld.IEX_FREE_DATE1                  := :old.IEX_FREE_DATE1;
  aOld.IEX_FREE_DATE2                  := :old.IEX_FREE_DATE2;
  aOld.IEX_FREE_DATE3                  := :old.IEX_FREE_DATE3;
  aOld.IEX_FREE_DATE4                  := :old.IEX_FREE_DATE4;
  aOld.IEX_FREE_DATE5                  := :old.IEX_FREE_DATE5;
  -- mise à jour de log
  STM_INVENTORY_EXT_FUNCTIONS.STM_INSERT_LOG(aOld, aNew);
end STM_INV_AU_LOG;

ALTER TRIGGER "C_ITX"."STM_INV_AU_LOG" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_INV_BD_LOG"
  before delete
  on STM_INVENTORY_EXTERNAL_LINE
  referencing old as old new as new
  for each row
/**
* Description
*    Trigger sur l'événement beforeDelete de la table des lignes d'inventaires externes.
*    Suppression des lignes d'historique pour la ligne supprimée
* @author PYV
* @created
* @version 2003
* */
begin
  delete from stm_inventory_external_log ilo
        where ilo.stm_inventory_external_line_id = :old.stm_inventory_external_line_id;
end STM_INV_BD_LOG;

ALTER TRIGGER "C_ITX"."STM_INV_BD_LOG" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_INV_JOB_DET_AD"
  after delete
  on STM_INVENTORY_JOB_DETAIL
  referencing old as old new as new
  for each row
declare
  vCInventoryMode   STM_INVENTORY_TASK.C_INVENTORY_MODE%type;
  vdRetestDate      STM_ELEMENT_NUMBER.SEM_RETEST_DATE%type;
  vnQualityStatusId STM_ELEMENT_NUMBER.GCO_QUALITY_STATUS_ID%type;
begin
  /*Mise à jour de la position d'inventaire relatif au détail*/
  if :old.IJD_LINE_VALIDATED = 0 then   /* Détail  non validé */
    select INV.C_INVENTORY_MODE
      into vCInventoryMode
      from STM_INVENTORY_TASK INV
     where INV.STM_INVENTORY_TASK_ID = :old.STM_INVENTORY_TASK_ID;

    select ENU.SEM_RETEST_DATE
         , ENU.GCO_QUALITY_STATUS_ID
      into vdRetestDate
         , vnQualityStatusId
      from STM_INVENTORY_LIST_POS LPO
         , STM_ELEMENT_NUMBER ENU
     where LPO.STM_INVENTORY_LIST_POS_ID = :old.STM_INVENTORY_LIST_POS_ID
       and LPO.STM_ELEMENT_NUMBER_ID = ENU.STM_ELEMENT_NUMBER_ID(+);

    if vdRetestDate is null then
      vdRetestDate  := GCO_I_LIB_CHARACTERIZATION.GetInitialRetestDelay(:old.gco_good_id, sysdate);
    end if;

    if vnQualityStatusId is null then
      vnQualityStatusId  := GCO_I_LIB_QUALITY_STATUS.GetReceiptStatus(iGoodId => :old.gco_good_id);
    end if;

    if vCInventoryMode = '1' then
      update STM_INVENTORY_LIST_POS
         set ILP_INVENTORY_QUANTITY = decode(sign(ILP_INVENTORY_QUANTITY - :old.IJD_QUANTITY), -1, 0, ILP_INVENTORY_QUANTITY - :old.IJD_QUANTITY)
           , ILP_INVENTORY_VALUE = decode(sign(ILP_INVENTORY_QUANTITY - :old.IJD_QUANTITY), -1, 0, 0, 0, ILP_INVENTORY_VALUE - :old.IJD_VALUE)
           , ILP_INV_ALTERNATIV_QTY_1 =
                                    decode(sign(ILP_INV_ALTERNATIV_QTY_1 - :old.IJD_ALTERNATIV_QTY_1)
                                         , -1, 0
                                         , ILP_INV_ALTERNATIV_QTY_1 - :old.IJD_ALTERNATIV_QTY_1
                                          )
           , ILP_INV_ALTERNATIV_QTY_2 =
                                    decode(sign(ILP_INV_ALTERNATIV_QTY_2 - :old.IJD_ALTERNATIV_QTY_2)
                                         , -1, 0
                                         , ILP_INV_ALTERNATIV_QTY_2 - :old.IJD_ALTERNATIV_QTY_2
                                          )
           , ILP_INV_ALTERNATIV_QTY_3 =
                                    decode(sign(ILP_INV_ALTERNATIV_QTY_3 - :old.IJD_ALTERNATIV_QTY_3)
                                         , -1, 0
                                         , ILP_INV_ALTERNATIV_QTY_3 - :old.IJD_ALTERNATIV_QTY_3
                                          )
           , ILP_INVENTORY_UNIT_PRICE =
               decode(sign(ILP_INVENTORY_QUANTITY - :old.IJD_QUANTITY)
                    , -1, 0
                    , 0, 0
                    , (ILP_INVENTORY_VALUE - :old.IJD_VALUE) /(ILP_INVENTORY_QUANTITY - :old.IJD_QUANTITY)
                     )
           , ILP_RETEST_DATE = vdRetestDate
           , GCO_QUALITY_STATUS_ID = vnQualityStatusId
           , a_datemod = sysdate
           , a_idmod = PCS.PC_I_LIB_SESSION.GetUserIni
       where STM_INVENTORY_LIST_POS_ID = :old.STM_INVENTORY_LIST_POS_ID;
    else
      update STM_INVENTORY_LIST_POS ILP
         set ILP.ILP_INVENTORY_QUANTITY = ILP.ILP_SYSTEM_QUANTITY
           , ILP.ILP_INVENTORY_VALUE = ILP.ILP_SYSTEM_VALUE
           , ILP.ILP_INV_ALTERNATIV_QTY_1 = ILP.ILP_SYS_ALTERNATIV_QTY_1
           , ILP.ILP_INV_ALTERNATIV_QTY_2 = ILP.ILP_SYS_ALTERNATIV_QTY_2
           , ILP.ILP_INV_ALTERNATIV_QTY_3 = ILP.ILP_SYS_ALTERNATIV_QTY_3
           , ILP.ILP_INVENTORY_UNIT_PRICE = ILP.ILP_SYSTEM_UNIT_PRICE
           , ILP_RETEST_DATE = vdRetestDate
           , GCO_QUALITY_STATUS_ID = vnQualityStatusId
           , a_datemod = sysdate
           , a_idmod = PCS.PC_I_LIB_SESSION.GetUserIni
       where ILP.STM_INVENTORY_LIST_POS_ID = :old.STM_INVENTORY_LIST_POS_ID;
    end if;
  end if;
exception
  when ex.TABLE_MUTATING then
    null;
end STM_INV_JOB_DET_AD;

ALTER TRIGGER "C_ITX"."STM_INV_JOB_DET_AD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_INV_JOB_DET_AI"
  after insert
  on STM_INVENTORY_JOB_DETAIL
  referencing old as old new as new
  for each row
declare
  vIlp_is_validated number(1);
  vCInventoryMode   STM_INVENTORY_TASK.C_INVENTORY_MODE%type;
begin   /* trigger */
  select ilp.ilp_is_validated
    into vIlp_is_validated
    from stm_inventory_list_pos ilp
   where ilp.stm_inventory_list_pos_id = :new.stm_inventory_list_pos_id;

  if vIlp_is_validated = 0 then
    select INV.C_INVENTORY_MODE
      into vCInventoryMode
      from STM_INVENTORY_TASK INV
     where INV.STM_INVENTORY_TASK_ID = :new.STM_INVENTORY_TASK_ID;

    if vCInventoryMode = '1' then
      /*mise à jour de la position d'inventaire relatif au détail*/
      update stm_inventory_list_pos
         set ilp_inventory_quantity = ilp_inventory_quantity + :new.ijd_quantity
           , ilp_inventory_value = ilp_inventory_value + :new.ijd_value
           , ilp_retest_date = :new.IJD_RETEST_DATE
           , GCO_QUALITY_STATUS_ID = :new.GCO_QUALITY_STATUS_ID
           , ilp_inv_alternativ_qty_1 = ilp_inv_alternativ_qty_1 + :new.ijd_alternativ_qty_1
           , ilp_inv_alternativ_qty_2 = ilp_inv_alternativ_qty_2 + :new.ijd_alternativ_qty_2
           , ilp_inv_alternativ_qty_3 = ilp_inv_alternativ_qty_3 + :new.ijd_alternativ_qty_3
           , ilp_inventory_unit_price =
               decode(sign(ilp_inventory_quantity + :new.ijd_quantity)
                    , -1, 0
                    , 0, 0
                    , (ilp_inventory_value + :new.ijd_value) /(ilp_inventory_quantity + :new.ijd_quantity)
                     )
           , ILP_COMMENT = :new.IJD_WORDING
           , a_datemod = sysdate
           , a_idmod = PCS.PC_I_LIB_SESSION.GetUserIni
       where stm_inventory_list_pos_id = :new.stm_inventory_list_pos_id;
    else
      update STM_INVENTORY_LIST_POS
         set ILP_INVENTORY_QUANTITY = :new.IJD_QUANTITY
           , ILP_INVENTORY_VALUE = :new.IJD_VALUE
           , ILP_RETEST_DATE = :new.IJD_RETEST_DATE
           , GCO_QUALITY_STATUS_ID = :new.GCO_QUALITY_STATUS_ID
           , ILP_INV_ALTERNATIV_QTY_1 = :new.IJD_ALTERNATIV_QTY_1
           , ILP_INV_ALTERNATIV_QTY_2 = :new.IJD_ALTERNATIV_QTY_2
           , ILP_INV_ALTERNATIV_QTY_3 = :new.IJD_ALTERNATIV_QTY_3
           , ILP_INVENTORY_UNIT_PRICE = decode(sign(:new.IJD_QUANTITY), -1, 0, 0, 0,(:new.IJD_VALUE) /(:new.IJD_QUANTITY) )
           , ILP_COMMENT = :new.IJD_WORDING
           , a_datemod = sysdate
           , a_idmod = PCS.PC_I_LIB_SESSION.GetUserIni
       where STM_INVENTORY_LIST_POS_ID = :new.STM_INVENTORY_LIST_POS_ID;
    end if;
  end if;
end STM_INV_JOB_DET_AI;

ALTER TRIGGER "C_ITX"."STM_INV_JOB_DET_AI" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_INV_JOB_DET_BI"
  before insert
  on stm_inventory_job_detail
  referencing old as old new as new
  for each row
declare
  vIlp_is_validated number(1);
begin   /* trigger */
  select ilp.ilp_is_validated
    into vIlp_is_validated
    from stm_inventory_list_pos ilp
   where ilp.stm_inventory_list_pos_id = :new.stm_inventory_list_pos_id;

  if vIlp_is_validated = 1 then
    raise_application_error(-20010
                          , chr(10) ||
                            chr(13) ||
                            pcs.pc_functions.translateword('STM_INV_LIST_POS_WRONG_STATE', pcs.PC_I_LIB_SESSION.getuserlangid) ||
                            chr(10) ||
                            chr(13)
                           );
  end if;
end STM_INV_JOB_DET_BI;

ALTER TRIGGER "C_ITX"."STM_INV_JOB_DET_BI" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_INV_LIST_POS_BD"
  before delete
  on STM_INVENTORY_LIST_POS
  referencing old as old new as new
  for each row
/*
 Createur : SK
 Date     : 2003
 Update   : SMA 08.2012
*/
declare
  vInventoryStatus varchar2(10);
begin
  delete from stm_inventory_list_work
        where stm_inventory_list_pos_id = :old.stm_inventory_list_pos_id;

  delete from stm_inventory_job_detail
        where stm_inventory_list_pos_id = :old.stm_inventory_list_pos_id;

  if :old.ilp_is_validated = 0 then
    STM_INVENTORY.update_status_after_delete(:old.GCO_GOOD_ID
                                           , :old.STM_STOCK_ID
                                           , :old.STM_LOCATION_ID
                                           , :old.GCO_CHARACTERIZATION_ID
                                           , :old.GCO_GCO_CHARACTERIZATION_ID
                                           , :old.GCO2_GCO_CHARACTERIZATION_ID
                                           , :old.GCO3_GCO_CHARACTERIZATION_ID
                                           , :old.GCO4_GCO_CHARACTERIZATION_ID
                                           , :old.ILP_CHARACTERIZATION_VALUE_1
                                           , :old.ILP_CHARACTERIZATION_VALUE_2
                                           , :old.ILP_CHARACTERIZATION_VALUE_3
                                           , :old.ILP_CHARACTERIZATION_VALUE_4
                                           , :old.ILP_CHARACTERIZATION_VALUE_5
                                            );
  end if;
end STM_INV_LIST_POS_BD;

ALTER TRIGGER "C_ITX"."STM_INV_LIST_POS_BD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_INV_LIST_POS_BI"
  before insert
  on STM_INVENTORY_LIST_POS
  referencing old as old new as new
  for each row
/**
* @author
* @version 2003
*/
declare
  vPer_ending   date;
  vPer_starting date;
begin
  select PER.PER_STARTING_PERIOD
       , PER.PER_ENDING_PERIOD
    into VPER_STARTING
       , VPER_ENDING
    from STM_PERIOD PER
   where PER.STM_PERIOD_ID = :new.STM_PERIOD_ID;

  if trunc(:new.ILP_INVENTORY_DATE) > trunc(VPER_ENDING) then
    :new.ILP_INVENTORY_DATE  := VPER_ENDING;
  elsif trunc(:new.ILP_INVENTORY_DATE) < trunc(VPER_STARTING) then
    :new.ILP_INVENTORY_DATE  := VPER_STARTING;
  end if;
end STM_INV_LIST_POS_BI;

ALTER TRIGGER "C_ITX"."STM_INV_LIST_POS_BI" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_INV_LIST_USER_AI"
AFTER INSERT ON STM_INVENTORY_LIST_USER
REFERENCING OLD AS OLD NEW AS NEW
FOR EACH ROW
/**
* Description
*     Ajout du lien entre la connection et le journal
* @author DSA
* @version 2003
*/
BEGIN
  UPDATE STM_INVENTORY_JOB
     SET STM_INVENTORY_LIST_USER_ID = :NEW.STM_INVENTORY_LIST_USER_ID
   WHERE STM_INVENTORY_JOB_ID = :NEW.STM_INVENTORY_JOB_ID;
end STM_INV_LIST_USER_AI;

ALTER TRIGGER "C_ITX"."STM_INV_LIST_USER_AI" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_INV_LIST_USER_BD"
BEFORE DELETE ON STM_INVENTORY_LIST_USER
REFERENCING OLD AS OLD NEW AS NEW
FOR EACH ROW
/**
* Description
*     Suppression du lien entre l'utilisateur et le journal suite à la suppression
*     de la connexion du user à une liste
* @author SK
* @version 2003
*/
BEGIN
  UPDATE STM_INVENTORY_JOB
  SET PC__PC_USER_ID          = NULL,
      IJO_CONNECTED_USER_NAME = NULL,
      IJO_JOB_AVAILABLE       = 1,
      STM_INVENTORY_LIST_USER_ID = null
  WHERE STM_INVENTORY_JOB_ID = :OLD.STM_INVENTORY_JOB_ID;

end STM_INV_LIST_USER_BD;

ALTER TRIGGER "C_ITX"."STM_INV_LIST_USER_BD" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_IPR_BI_INIT"
  before insert
  on STM_INVENTORY_PREPARE
  referencing old as old new as new
  for each row
/**
* Description
*     Initialisation de champs avant insertion
* @version 2003
*/
declare
  pNewTableId   STM_INVENTORY_PREPARE.STM_INVENTORY_PREPARE_ID%type;
  pNewSessionId STM_INVENTORY_PREPARE.IPR_SESSION_ID%type;
begin
  /*Génération d'un nouvel id de record et récupération de la session*/
  select init_id_seq.nextval
       , userenv('SESSIONID')
    into pNewTableId
       , pNewSessionId
    from dual;

  :new.STM_INVENTORY_PREPARE_ID  := pNewTableId;
  :new.IPR_SESSION_ID            := pNewSessionId;
  :new.A_DATECRE                 := sysdate;
  :new.A_IDCRE                   := PCS.PC_I_LIB_SESSION.GetUserIni;
end STM_IPR_BI_INIT;

ALTER TRIGGER "C_ITX"."STM_IPR_BI_INIT" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_SIS_AIUD_UPDATE_TEMP"
  after insert or update of "GCO_GOOD_ID"
                          , "SIS_QUANTITY_TRANSFER"
                          , "C_TRANSFER_STATUS"
                          , "PC_COMP_SRC_ID"
                          , "STM_STOCK_SRC_ID"
                          , "STM_LOCATION_SRC_ID"
                          , "PC_COMP_DST_ID"
                          , "STM_STOCK_DST_ID"
                          , "STM_LOCATION_DST_ID" or delete
  on STM_INTERC_STOCK_TRSF
  referencing old as old new as new
  for each row
/**
* Description
*    maj de la table temporaire de transfert
* @created fp 09.11.2006
* @lastUpdate
*/
begin
  -- retrait des anciennes valeurs
  if    updating
     or deleting then
    -- mise à jour de la table STM_STOCK_INTERC_TEMP
    STM_INTER_STOCK.majQtyInTemp('TRIGGER'
                               , :old.GCO_GOOD_ID
                               , -:old.SIS_QUANTITY_TRANSFER
                               , :old.C_TRANSFER_STATUS
                               , :old.PC_COMP_SRC_ID
                               , :old.STM_STOCK_SRC_ID
                               , :old.STM_LOCATION_SRC_ID
                               , :old.PC_COMP_DST_ID
                               , :old.STM_STOCK_DST_ID
                               , :old.STM_LOCATION_DST_ID
                                );
  end if;

  -- ajout des nouvelles valeurs
  if    updating
     or inserting then
    -- mise à jour de la table STM_STOCK_INTERC_TEMP
    STM_INTER_STOCK.majQtyInTemp('TRIGGER'
                               , :new.GCO_GOOD_ID
                               , :new.SIS_QUANTITY_TRANSFER
                               , :new.C_TRANSFER_STATUS
                               , :new.PC_COMP_SRC_ID
                               , :new.STM_STOCK_SRC_ID
                               , :new.STM_LOCATION_SRC_ID
                               , :new.PC_COMP_DST_ID
                               , :new.STM_STOCK_DST_ID
                               , :new.STM_LOCATION_DST_ID
                                );
  end if;
end STM_SIS_AIUD_UPDATE_TEMP;


ALTER TRIGGER "C_ITX"."STM_SIS_AIUD_UPDATE_TEMP" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_SIS_BIUD_PROV_QTY"
  before insert or delete or update of sis_quantity_transfer
                                     , doc_gauge_src_id
                                     , doc_gauge_dst_id
                                     , stm_stock_src_id
                                     , stm_stock_dst_id
                                     , stm_location_src_id
                                     , stm_location_dst_id
                                     , c_transfer_status
  on STM_INTERC_STOCK_TRSF
  referencing old as old new as new
  for each row
/**
* Description
*    Mise à jour des compteurs de stock touchées par la saisie de transfert inter-société
* @created JSC 14.07.2003
* @lastUpdate : JSC 28.10.2004 (gestion des caractérisations)
* @version 2003
*/
declare
  vstock_position_src_id   		stm_stock_position.stm_stock_position_id%type;
  vstock_position_dst_id   		stm_stock_position.stm_stock_position_id%type;
  vmvt_princ_src_id   			stm_movement_kind.stm_movement_kind_id%type;
  vmvt_sec_src_id     			stm_movement_kind.stm_movement_kind_id%type;
  vmvt_princ_src_sort 			stm_movement_kind.c_movement_sort%type;
  vmvt_princ_src_type 			stm_movement_kind.c_movement_type%type;
  vmvt_sec_src_sort   			stm_movement_kind.c_movement_sort%type;
  vmvt_sec_src_type   			stm_movement_kind.c_movement_type%type;
  vmvt_princ_dst_id   			stm_movement_kind.stm_movement_kind_id%type;
  vmvt_princ_dst_sort 			stm_movement_kind.c_movement_sort%type;
  vmvt_princ_dst_type 			stm_movement_kind.c_movement_type%type;
  vmvt_sec_dst_id     		    stm_movement_kind.stm_movement_kind_id%type;
  vmvt_princ_dst_verify_charac  stm_movement_kind.mok_verify_characterization%type;
  vmvt_princ_src_verify_charac  stm_movement_kind.mok_verify_characterization%type;

begin

  if    deleting
     or updating then

    if :old.c_transfer_status in ('01', '02') then
      --Recherche du mouvement principal du gabarit source
      select nvl(max(gau.stm_movement_kind_id), 0)
           , nvl(max(kind.stm_stm_movement_kind_id), 0)
           , nvl(max(kind.c_movement_sort), 0)
           , nvl(max(kind.c_movement_type), 0)
		   , nvl(max(kind.mok_verify_characterization), 0)
        into vmvt_princ_src_id
           , vmvt_sec_src_id
           , vmvt_princ_src_sort
           , vmvt_princ_src_type
		   , vmvt_princ_src_verify_charac
        from doc_gauge_position gau
           , stm_movement_kind kind
       where doc_gauge_id = :old.doc_gauge_src_id
         and gau.stm_movement_kind_id = kind.stm_movement_kind_id
         and c_gauge_type_pos = 1
         and gap_default = 1;

      --Recherche du mouvement secondaire du gabarit source
      select nvl(max(kind.c_movement_sort), 0)
           , nvl(max(kind.c_movement_type), 0)
        into vmvt_sec_src_sort
           , vmvt_sec_src_type
        from stm_movement_kind kind
       where kind.stm_movement_kind_id = vmvt_sec_src_id;


	  if (:old.pc_comp_src_id = :old.pc_comp_dst_id)
	  then
	  --Recherche du mouvement principal du gabarit cible
      select nvl(max(gau.stm_movement_kind_id), 0)
           , nvl(max(kind.stm_stm_movement_kind_id), 0)
           , nvl(max(kind.c_movement_sort), 0)
           , nvl(max(kind.c_movement_type), 0)
		   , nvl(max(kind.mok_verify_characterization), 0)
        into vmvt_princ_dst_id
           , vmvt_sec_dst_id
           , vmvt_princ_dst_sort
           , vmvt_princ_dst_type
		   , vmvt_princ_dst_verify_charac
        from doc_gauge_position gau
           , stm_movement_kind kind
       where doc_gauge_id = :old.doc_gauge_dst_id
         and gau.stm_movement_kind_id = kind.stm_movement_kind_id
         and c_gauge_type_pos = 1
         and gap_default = 1;

	  else
	  	   vmvt_princ_dst_id := 0;
           vmvt_sec_dst_id := 0;
           vmvt_princ_dst_sort := 0;
           vmvt_princ_dst_type := 0;
		   vmvt_princ_dst_verify_charac:= 0;

	  end if;

      ---Contrôle si les sociétés et gabarits sources et cibles sont identiques
	      if   (:old.doc_gauge_src_id = :old.doc_gauge_dst_id)
		  then
		  	   if vmvt_sec_src_id <> 0
		  	   then

					--Cas d'un document de transfert

					DOC_INIT_MOVEMENT.doc_prov_qty(
						  :old.gco_good_id
						, 'D'
						, vmvt_princ_src_sort
						, vmvt_princ_src_verify_charac
						, vmvt_sec_src_id
						, :old.gco_characterization_1_id
						, :old.gco_characterization_2_id
						, :old.gco_characterization_3_id
						, :old.gco_characterization_4_id
						, :old.gco_characterization_5_id
						, :old.sis_characterization_value_1
						, :old.sis_characterization_value_2
						, :old.sis_characterization_value_3
						, :old.sis_characterization_value_4
						, :old.sis_characterization_value_5
						, :old.stm_stock_src_id
						, :old.stm_location_src_id
						, :old.stm_stock_dst_id
						, :old.stm_location_dst_id
						, :old.sis_quantity_transfer * (-1));


	      		else
					 	  --Si les gabarits source et cible sont identiques, il faut que ce soit un gabarit de transfert !
				          raise_application_error(-20111,'PCS - #Error in document gauge definition of inter-company transfer !');
			    end if;

		  else
		  	   if vmvt_sec_src_id <> 0 or vmvt_sec_dst_id <> 0
			   then
			   	   -- Si les gabarits sont différents, il ne faut pas qu'un ou l'autre soit de type transfert !
			   	   raise_application_error(-20111,'PCS - ##Error in document gauge definition of inter-company transfer !');

			   else

					--Traitement position source
					DOC_INIT_MOVEMENT.doc_prov_qty(
						  :old.gco_good_id
						, 'D'
						, vmvt_princ_src_sort
						, vmvt_princ_src_verify_charac
						, 0
						, :old.gco_characterization_1_id
						, :old.gco_characterization_2_id
						, :old.gco_characterization_3_id
						, :old.gco_characterization_4_id
						, :old.gco_characterization_5_id
						, :old.sis_characterization_value_1
						, :old.sis_characterization_value_2
						, :old.sis_characterization_value_3
						, :old.sis_characterization_value_4
						, :old.sis_characterization_value_5
						, :old.stm_stock_src_id
						, :old.stm_location_src_id
						,  null
						,  null
						, :old.sis_quantity_transfer*(-1));


				  if (:old.pc_comp_src_id = :old.pc_comp_dst_id)
	      		  then
				  --Traitement position cible
				  DOC_INIT_MOVEMENT.doc_prov_qty(
						  :old.gco_good_id
						, 'D'
						, vmvt_princ_dst_sort
						, vmvt_princ_dst_verify_charac
						, 0
						, :old.gco_characterization_1_id
						, :old.gco_characterization_2_id
						, :old.gco_characterization_3_id
						, :old.gco_characterization_4_id
						, :old.gco_characterization_5_id
						, :old.sis_characterization_value_1
						, :old.sis_characterization_value_2
						, :old.sis_characterization_value_3
						, :old.sis_characterization_value_4
						, :old.sis_characterization_value_5
						, :old.stm_stock_dst_id
						, :old.stm_location_dst_id
						,  null
						,  null
						, :old.sis_quantity_transfer*(-1));
				   end if;
				end if;
	      end if;

    end if;

  end if;

  --Création ou modification
  if inserting or updating
  then

	    if :new.c_transfer_status in ('01','02')
		then
	      --Recherche du mouvement principal du gabarit source
	      select nvl(max(gau.stm_movement_kind_id), 0)
	           , nvl(max(kind.stm_stm_movement_kind_id), 0)
	           , nvl(max(kind.c_movement_sort), 0)
	           , nvl(max(kind.c_movement_type), 0)
			   , nvl(max(kind.mok_verify_characterization), 0)
	        into vmvt_princ_src_id
	           , vmvt_sec_src_id
	           , vmvt_princ_src_sort
	           , vmvt_princ_src_type
			   , vmvt_princ_src_verify_charac
	        from doc_gauge_position gau
	           , stm_movement_kind kind
	       where doc_gauge_id = :new.doc_gauge_src_id
	         and gau.stm_movement_kind_id = kind.stm_movement_kind_id
	         and c_gauge_type_pos = 1
	         and gap_default = 1;

	      --Recherche du mouvement secondaire du gabarit source
	      select nvl(max(kind.c_movement_sort), 0)
	           , nvl(max(kind.c_movement_type), 0)
	        into vmvt_sec_src_sort
	           , vmvt_sec_src_type
	        from stm_movement_kind kind
	       where kind.stm_movement_kind_id = vmvt_sec_src_id;


		  if (:new.pc_comp_src_id = :new.pc_comp_dst_id)
	      then

	      --Recherche du mouvement principal du gabarit cible
	      select nvl(max(gau.stm_movement_kind_id), 0)
	           , nvl(max(kind.stm_stm_movement_kind_id), 0)
	           , nvl(max(kind.c_movement_sort), 0)
	           , nvl(max(kind.c_movement_type), 0)
			   , nvl(max(kind.mok_verify_characterization), 0)
	        into vmvt_princ_dst_id
	           , vmvt_sec_dst_id
	           , vmvt_princ_dst_sort
	           , vmvt_princ_dst_type
			   , vmvt_princ_dst_verify_charac
	        from doc_gauge_position gau
	           , stm_movement_kind kind
	       where doc_gauge_id = :new.doc_gauge_dst_id
	         and gau.stm_movement_kind_id = kind.stm_movement_kind_id
	         and c_gauge_type_pos = 1
	         and gap_default = 1;

		  else

		  	   vmvt_princ_dst_id := 0;
	           vmvt_sec_dst_id := 0;
	           vmvt_princ_dst_sort := 0;
	           vmvt_princ_dst_type := 0;
			   vmvt_princ_dst_verify_charac := 0;

		  end if;

	      --Contrôle si les gabarits sont identiques
	      if   (:new.doc_gauge_src_id = :new.doc_gauge_dst_id)
		  then
		  	   if vmvt_sec_src_id <> 0
		  	   then

					--Cas d'un document de transfert

					DOC_INIT_MOVEMENT.doc_prov_qty(
						  :new.gco_good_id
						, 'I'
						, vmvt_princ_src_sort
						, vmvt_princ_src_verify_charac
						, vmvt_sec_src_id
						, :new.gco_characterization_1_id
						, :new.gco_characterization_2_id
						, :new.gco_characterization_3_id
						, :new.gco_characterization_4_id
						, :new.gco_characterization_5_id
						, :new.sis_characterization_value_1
						, :new.sis_characterization_value_2
						, :new.sis_characterization_value_3
						, :new.sis_characterization_value_4
						, :new.sis_characterization_value_5
						, :new.stm_stock_src_id
						, :new.stm_location_src_id
						, :new.stm_stock_dst_id
						, :new.stm_location_dst_id
						, :new.sis_quantity_transfer);

	      		else
					 	  --Si les gabarits source et cible sont identiques, il faut que ce soit un gabarit de transfert !
				          raise_application_error(-20111,'PCS - *Error in document gauge definition of inter-company transfer !');
			    end if;

		  else
		  	   if vmvt_sec_src_id <> 0 or vmvt_sec_dst_id <> 0
			   then
			   	   -- Si les gabarits sont différents, il ne faut pas qu'un ou l'autre soit de type transfert !
			   	   raise_application_error(-20111,'PCS - **Error in document gauge definition of inter-company transfer !');

			   else

					--Traitement position source
					DOC_INIT_MOVEMENT.doc_prov_qty(
						  :new.gco_good_id
						, 'I'
						, vmvt_princ_src_sort
						, vmvt_princ_src_verify_charac
						, 0
						, :new.gco_characterization_1_id
						, :new.gco_characterization_2_id
						, :new.gco_characterization_3_id
						, :new.gco_characterization_4_id
						, :new.gco_characterization_5_id
						, :new.sis_characterization_value_1
						, :new.sis_characterization_value_2
						, :new.sis_characterization_value_3
						, :new.sis_characterization_value_4
						, :new.sis_characterization_value_5
						, :new.stm_stock_src_id
						, :new.stm_location_src_id
						,  null
						,  null
						, :new.sis_quantity_transfer);


				  if (:new.pc_comp_src_id = :new.pc_comp_dst_id)
	      		  then
				  --Traitement position cible
				  DOC_INIT_MOVEMENT.doc_prov_qty(
						  :new.gco_good_id
						, 'I'
						, vmvt_princ_dst_sort
						, vmvt_princ_dst_verify_charac
						, 0
						, :new.gco_characterization_1_id
						, :new.gco_characterization_2_id
						, :new.gco_characterization_3_id
						, :new.gco_characterization_4_id
						, :new.gco_characterization_5_id
						, :new.sis_characterization_value_1
						, :new.sis_characterization_value_2
						, :new.sis_characterization_value_3
						, :new.sis_characterization_value_4
						, :new.sis_characterization_value_5
						, :new.stm_stock_dst_id
						, :new.stm_location_dst_id
						,  null
						,  null
						, :new.sis_quantity_transfer);
				  end if;
				end if;
	      end if;

	    end if;
  end if;
end STM_SIS_BIUD_PROV_QTY;

ALTER TRIGGER "C_ITX"."STM_SIS_BIUD_PROV_QTY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_SMO_BIUD_FWK"
  before insert or delete or update
  on STM_STOCK_MOVEMENT
  for each row
declare
  ltCRUD_DEF     fwk_i_typ_definition.t_crud_def;
  lFrameworkCall boolean                         := false;
begin
  if (is_framework_call = 0) then
    lFrameworkCall  := true;

    if inserting then
      FWK_I_MGT_ENTITY.new(FWK_TYP_STM_ENTITY.gcStmStockMovement, ltCRUD_DEF, true);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'STM_STOCK_MOVEMENT_ID', :new.STM_STOCK_MOVEMENT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'STM_STM_STOCK_MOVEMENT_ID', :new.STM_STM_STOCK_MOVEMENT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'STM2_STM_STOCK_MOVEMENT_ID', :new.STM2_STM_STOCK_MOVEMENT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'STM_EXERCISE_ID', :new.STM_EXERCISE_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'STM_PERIOD_ID', :new.STM_PERIOD_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'STM_MOVEMENT_KIND_ID', :new.STM_MOVEMENT_KIND_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'STM_STOCK_ID', :new.STM_STOCK_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'STM_LOCATION_ID', :new.STM_LOCATION_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'PAC_THIRD_ID', :new.PAC_THIRD_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'GCO_GOOD_ID', :new.GCO_GOOD_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_ACCOUNT_ID', :new.ACS_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'GCO_CHARACTERIZATION_ID', :new.GCO_CHARACTERIZATION_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'GCO_GCO_CHARACTERIZATION_ID', :new.GCO_GCO_CHARACTERIZATION_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'GCO2_GCO_CHARACTERIZATION_ID', :new.GCO2_GCO_CHARACTERIZATION_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'GCO3_GCO_CHARACTERIZATION_ID', :new.GCO3_GCO_CHARACTERIZATION_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'GCO4_GCO_CHARACTERIZATION_ID', :new.GCO4_GCO_CHARACTERIZATION_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'DOC_RECORD_ID', :new.DOC_RECORD_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_MOVEMENT_DATE', :new.SMO_MOVEMENT_DATE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_WORDING', :new.SMO_WORDING);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_EXTERNAL_DOCUMENT', :new.SMO_EXTERNAL_DOCUMENT);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_EXTERNAL_PARTNER', :new.SMO_EXTERNAL_PARTNER);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_CHARACTERIZATION_VALUE_1', :new.SMO_CHARACTERIZATION_VALUE_1);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_CHARACTERIZATION_VALUE_2', :new.SMO_CHARACTERIZATION_VALUE_2);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_CHARACTERIZATION_VALUE_3', :new.SMO_CHARACTERIZATION_VALUE_3);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_CHARACTERIZATION_VALUE_4', :new.SMO_CHARACTERIZATION_VALUE_4);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_CHARACTERIZATION_VALUE_5', :new.SMO_CHARACTERIZATION_VALUE_5);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_MOVEMENT_QUANTITY', :new.SMO_MOVEMENT_QUANTITY);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_MOVEMENT_PRICE', :new.SMO_MOVEMENT_PRICE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_DOCUMENT_QUANTITY', :new.SMO_DOCUMENT_QUANTITY);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_DOCUMENT_PRICE', :new.SMO_DOCUMENT_PRICE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_UNIT_PRICE', :new.SMO_UNIT_PRICE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_FINANCIAL_CHARGING', :new.SMO_FINANCIAL_CHARGING);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'A_DATECRE', :new.A_DATECRE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'A_DATEMOD', :new.A_DATEMOD);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'A_IDCRE', :new.A_IDCRE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'A_IDMOD', :new.A_IDMOD);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'A_RECLEVEL', :new.A_RECLEVEL);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'A_RECSTATUS', :new.A_RECSTATUS);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'A_CONFIRM', :new.A_CONFIRM);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_FINANCIAL_ACCOUNT_ID', :new.ACS_FINANCIAL_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_DIVISION_ACCOUNT_ID', :new.ACS_DIVISION_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_ACS_DIVISION_ACCOUNT_ID', :new.ACS_ACS_DIVISION_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_ACS_FINANCIAL_ACCOUNT_ID', :new.ACS_ACS_FINANCIAL_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'DOC_POSITION_DETAIL_ID', :new.DOC_POSITION_DETAIL_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_MVT_ALTERNATIV_QTY_1', :new.SMO_MVT_ALTERNATIV_QTY_1);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_MVT_ALTERNATIV_QTY_2', :new.SMO_MVT_ALTERNATIV_QTY_2);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_MVT_ALTERNATIV_QTY_3', :new.SMO_MVT_ALTERNATIV_QTY_3);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_REFERENCE_UNIT_PRICE', :new.SMO_REFERENCE_UNIT_PRICE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_CPN_ACCOUNT_ID', :new.ACS_CPN_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_ACS_CPN_ACCOUNT_ID', :new.ACS_ACS_CPN_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_CDA_ACCOUNT_ID', :new.ACS_CDA_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_ACS_CDA_ACCOUNT_ID', :new.ACS_ACS_CDA_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_PF_ACCOUNT_ID', :new.ACS_PF_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_ACS_PF_ACCOUNT_ID', :new.ACS_ACS_PF_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_PJ_ACCOUNT_ID', :new.ACS_PJ_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_ACS_PJ_ACCOUNT_ID', :new.ACS_ACS_PJ_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'DOC_POSITION_ID', :new.DOC_POSITION_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_UPDATE_PROV', :new.SMO_UPDATE_PROV);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_EXTOURNE_MVT', :new.SMO_EXTOURNE_MVT);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'FAM_FIXED_ASSETS_ID', :new.FAM_FIXED_ASSETS_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'HRM_PERSON_ID', :new.HRM_PERSON_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'C_FAM_TRANSACTION_TYP', :new.C_FAM_TRANSACTION_TYP);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'DIC_IMP_FREE1_ID', :new.DIC_IMP_FREE1_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'DIC_IMP_FREE2_ID', :new.DIC_IMP_FREE2_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'DIC_IMP_FREE3_ID', :new.DIC_IMP_FREE3_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'DIC_IMP_FREE4_ID', :new.DIC_IMP_FREE4_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'DIC_IMP_FREE5_ID', :new.DIC_IMP_FREE5_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_IMP_TEXT_1', :new.SMO_IMP_TEXT_1);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_IMP_TEXT_2', :new.SMO_IMP_TEXT_2);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_IMP_TEXT_3', :new.SMO_IMP_TEXT_3);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_IMP_TEXT_4', :new.SMO_IMP_TEXT_4);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_IMP_TEXT_5', :new.SMO_IMP_TEXT_5);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_IMP_NUMBER_1', :new.SMO_IMP_NUMBER_1);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_IMP_NUMBER_2', :new.SMO_IMP_NUMBER_2);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_IMP_NUMBER_3', :new.SMO_IMP_NUMBER_3);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_IMP_NUMBER_4', :new.SMO_IMP_NUMBER_4);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_IMP_NUMBER_5', :new.SMO_IMP_NUMBER_5);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_UPDATE_PRCS', :new.SMO_UPDATE_PRCS);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_PRCS_BEFORE', :new.SMO_PRCS_BEFORE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_PRCS_AFTER', :new.SMO_PRCS_AFTER);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_PIECE', :new.SMO_PIECE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_SET', :new.SMO_SET);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_VERSION', :new.SMO_VERSION);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_CHRONOLOGICAL', :new.SMO_CHRONOLOGICAL);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_STD_CHAR_1', :new.SMO_STD_CHAR_1);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_STD_CHAR_2', :new.SMO_STD_CHAR_2);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_STD_CHAR_3', :new.SMO_STD_CHAR_3);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_STD_CHAR_4', :new.SMO_STD_CHAR_4);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_STD_CHAR_5', :new.SMO_STD_CHAR_5);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_FINANCIAL_PRICE', :new.SMO_FINANCIAL_PRICE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_PRCS_ADDED_QUANTITY_BEFORE', :new.SMO_PRCS_ADDED_QUANTITY_BEFORE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_PRCS_ADDED_QUANTITY_AFTER', :new.SMO_PRCS_ADDED_QUANTITY_AFTER);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_PRCS_ADDED_VALUE_BEFORE', :new.SMO_PRCS_ADDED_VALUE_BEFORE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_PRCS_ADDED_VALUE_AFTER', :new.SMO_PRCS_ADDED_VALUE_AFTER);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'STM_DISTRIBUTION_UNIT_ID', :new.STM_DISTRIBUTION_UNIT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'STM_STM_DISTRIBUTION_UNIT_ID', :new.STM_STM_DISTRIBUTION_UNIT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_USE_RESTOCKING', :new.SMO_USE_RESTOCKING);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_VALUE_DATE', :new.SMO_VALUE_DATE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_MOVEMENT_ORDER_KEY', :new.SMO_MOVEMENT_ORDER_KEY);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_PRCS_UPDATED', :new.SMO_PRCS_UPDATED);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'DOC_FOOT_ALLOY_ID', :new.DOC_FOOT_ALLOY_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_STOCK_MANAGEMENT', :new.SMO_STOCK_MANAGEMENT);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'FAL_LOT_ID', :new.FAL_LOT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'FAL_FACTORY_IN_ID', :new.FAL_FACTORY_IN_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'FAL_FACTORY_OUT_ID', :new.FAL_FACTORY_OUT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'PAC_THIRD_ACI_ID', :new.PAC_THIRD_ACI_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'PAC_THIRD_DELIVERY_ID', :new.PAC_THIRD_DELIVERY_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'PAC_THIRD_TARIFF_ID', :new.PAC_THIRD_TARIFF_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ASA_INTERVENTION_DETAIL_ID', :new.ASA_INTERVENTION_DETAIL_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_PRCS_VALUE', :new.SMO_PRCS_VALUE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'DIC_REBUT_ID', :new.DIC_REBUT_ID);
      FWK_I_MGT_ENTITY.InsertEntity(ltCRUD_DEF);
      FWK_I_MGT_ENTITY.Release(ltCRUD_DEF);
    elsif deleting then
      FWK_I_MGT_ENTITY.new(FWK_TYP_STM_ENTITY.gcStmStockMovement, ltCRUD_DEF, true);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'STM_STOCK_MOVEMENT_ID', :old.STM_STOCK_MOVEMENT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'STM_STM_STOCK_MOVEMENT_ID', :old.STM_STM_STOCK_MOVEMENT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'STM2_STM_STOCK_MOVEMENT_ID', :old.STM2_STM_STOCK_MOVEMENT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'STM_EXERCISE_ID', :old.STM_EXERCISE_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'STM_PERIOD_ID', :old.STM_PERIOD_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'STM_MOVEMENT_KIND_ID', :old.STM_MOVEMENT_KIND_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'STM_STOCK_ID', :old.STM_STOCK_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'STM_LOCATION_ID', :old.STM_LOCATION_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'PAC_THIRD_ID', :old.PAC_THIRD_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'GCO_GOOD_ID', :old.GCO_GOOD_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_ACCOUNT_ID', :old.ACS_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'GCO_CHARACTERIZATION_ID', :old.GCO_CHARACTERIZATION_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'GCO_GCO_CHARACTERIZATION_ID', :old.GCO_GCO_CHARACTERIZATION_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'GCO2_GCO_CHARACTERIZATION_ID', :old.GCO2_GCO_CHARACTERIZATION_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'GCO3_GCO_CHARACTERIZATION_ID', :old.GCO3_GCO_CHARACTERIZATION_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'GCO4_GCO_CHARACTERIZATION_ID', :old.GCO4_GCO_CHARACTERIZATION_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'DOC_RECORD_ID', :old.DOC_RECORD_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_MOVEMENT_DATE', :old.SMO_MOVEMENT_DATE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_WORDING', :old.SMO_WORDING);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_EXTERNAL_DOCUMENT', :old.SMO_EXTERNAL_DOCUMENT);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_EXTERNAL_PARTNER', :old.SMO_EXTERNAL_PARTNER);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_CHARACTERIZATION_VALUE_1', :old.SMO_CHARACTERIZATION_VALUE_1);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_CHARACTERIZATION_VALUE_2', :old.SMO_CHARACTERIZATION_VALUE_2);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_CHARACTERIZATION_VALUE_3', :old.SMO_CHARACTERIZATION_VALUE_3);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_CHARACTERIZATION_VALUE_4', :old.SMO_CHARACTERIZATION_VALUE_4);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_CHARACTERIZATION_VALUE_5', :old.SMO_CHARACTERIZATION_VALUE_5);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_MOVEMENT_QUANTITY', :old.SMO_MOVEMENT_QUANTITY);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_MOVEMENT_PRICE', :old.SMO_MOVEMENT_PRICE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_DOCUMENT_QUANTITY', :old.SMO_DOCUMENT_QUANTITY);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_DOCUMENT_PRICE', :old.SMO_DOCUMENT_PRICE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_UNIT_PRICE', :old.SMO_UNIT_PRICE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_FINANCIAL_CHARGING', :old.SMO_FINANCIAL_CHARGING);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'A_DATECRE', :old.A_DATECRE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'A_DATEMOD', :old.A_DATEMOD);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'A_IDCRE', :old.A_IDCRE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'A_IDMOD', :old.A_IDMOD);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'A_RECLEVEL', :old.A_RECLEVEL);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'A_RECSTATUS', :old.A_RECSTATUS);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'A_CONFIRM', :old.A_CONFIRM);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_FINANCIAL_ACCOUNT_ID', :old.ACS_FINANCIAL_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_DIVISION_ACCOUNT_ID', :old.ACS_DIVISION_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_ACS_DIVISION_ACCOUNT_ID', :old.ACS_ACS_DIVISION_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_ACS_FINANCIAL_ACCOUNT_ID', :old.ACS_ACS_FINANCIAL_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'DOC_POSITION_DETAIL_ID', :old.DOC_POSITION_DETAIL_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_MVT_ALTERNATIV_QTY_1', :old.SMO_MVT_ALTERNATIV_QTY_1);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_MVT_ALTERNATIV_QTY_2', :old.SMO_MVT_ALTERNATIV_QTY_2);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_MVT_ALTERNATIV_QTY_3', :old.SMO_MVT_ALTERNATIV_QTY_3);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_REFERENCE_UNIT_PRICE', :old.SMO_REFERENCE_UNIT_PRICE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_CPN_ACCOUNT_ID', :old.ACS_CPN_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_ACS_CPN_ACCOUNT_ID', :old.ACS_ACS_CPN_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_CDA_ACCOUNT_ID', :old.ACS_CDA_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_ACS_CDA_ACCOUNT_ID', :old.ACS_ACS_CDA_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_PF_ACCOUNT_ID', :old.ACS_PF_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_ACS_PF_ACCOUNT_ID', :old.ACS_ACS_PF_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_PJ_ACCOUNT_ID', :old.ACS_PJ_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ACS_ACS_PJ_ACCOUNT_ID', :old.ACS_ACS_PJ_ACCOUNT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'DOC_POSITION_ID', :old.DOC_POSITION_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_UPDATE_PROV', :old.SMO_UPDATE_PROV);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_EXTOURNE_MVT', :old.SMO_EXTOURNE_MVT);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'FAM_FIXED_ASSETS_ID', :old.FAM_FIXED_ASSETS_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'HRM_PERSON_ID', :old.HRM_PERSON_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'C_FAM_TRANSACTION_TYP', :old.C_FAM_TRANSACTION_TYP);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'DIC_IMP_FREE1_ID', :old.DIC_IMP_FREE1_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'DIC_IMP_FREE2_ID', :old.DIC_IMP_FREE2_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'DIC_IMP_FREE3_ID', :old.DIC_IMP_FREE3_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'DIC_IMP_FREE4_ID', :old.DIC_IMP_FREE4_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'DIC_IMP_FREE5_ID', :old.DIC_IMP_FREE5_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_IMP_TEXT_1', :old.SMO_IMP_TEXT_1);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_IMP_TEXT_2', :old.SMO_IMP_TEXT_2);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_IMP_TEXT_3', :old.SMO_IMP_TEXT_3);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_IMP_TEXT_4', :old.SMO_IMP_TEXT_4);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_IMP_TEXT_5', :old.SMO_IMP_TEXT_5);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_IMP_NUMBER_1', :old.SMO_IMP_NUMBER_1);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_IMP_NUMBER_2', :old.SMO_IMP_NUMBER_2);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_IMP_NUMBER_3', :old.SMO_IMP_NUMBER_3);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_IMP_NUMBER_4', :old.SMO_IMP_NUMBER_4);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_IMP_NUMBER_5', :old.SMO_IMP_NUMBER_5);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_UPDATE_PRCS', :old.SMO_UPDATE_PRCS);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_PRCS_BEFORE', :old.SMO_PRCS_BEFORE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_PRCS_AFTER', :old.SMO_PRCS_AFTER);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_PIECE', :old.SMO_PIECE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_SET', :old.SMO_SET);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_VERSION', :old.SMO_VERSION);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_CHRONOLOGICAL', :old.SMO_CHRONOLOGICAL);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_STD_CHAR_1', :old.SMO_STD_CHAR_1);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_STD_CHAR_2', :old.SMO_STD_CHAR_2);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_STD_CHAR_3', :old.SMO_STD_CHAR_3);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_STD_CHAR_4', :old.SMO_STD_CHAR_4);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_STD_CHAR_5', :old.SMO_STD_CHAR_5);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_FINANCIAL_PRICE', :old.SMO_FINANCIAL_PRICE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_PRCS_ADDED_QUANTITY_BEFORE', :old.SMO_PRCS_ADDED_QUANTITY_BEFORE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_PRCS_ADDED_QUANTITY_AFTER', :old.SMO_PRCS_ADDED_QUANTITY_AFTER);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_PRCS_ADDED_VALUE_BEFORE', :old.SMO_PRCS_ADDED_VALUE_BEFORE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_PRCS_ADDED_VALUE_AFTER', :old.SMO_PRCS_ADDED_VALUE_AFTER);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'STM_DISTRIBUTION_UNIT_ID', :old.STM_DISTRIBUTION_UNIT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'STM_STM_DISTRIBUTION_UNIT_ID', :old.STM_STM_DISTRIBUTION_UNIT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_USE_RESTOCKING', :old.SMO_USE_RESTOCKING);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_VALUE_DATE', :old.SMO_VALUE_DATE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_MOVEMENT_ORDER_KEY', :old.SMO_MOVEMENT_ORDER_KEY);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_PRCS_UPDATED', :old.SMO_PRCS_UPDATED);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'DOC_FOOT_ALLOY_ID', :old.DOC_FOOT_ALLOY_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_STOCK_MANAGEMENT', :old.SMO_STOCK_MANAGEMENT);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'FAL_LOT_ID', :old.FAL_LOT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'FAL_FACTORY_IN_ID', :old.FAL_FACTORY_IN_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'FAL_FACTORY_OUT_ID', :old.FAL_FACTORY_OUT_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'PAC_THIRD_ACI_ID', :old.PAC_THIRD_ACI_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'PAC_THIRD_DELIVERY_ID', :old.PAC_THIRD_DELIVERY_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'PAC_THIRD_TARIFF_ID', :old.PAC_THIRD_TARIFF_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'ASA_INTERVENTION_DETAIL_ID', :old.ASA_INTERVENTION_DETAIL_ID);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'SMO_PRCS_VALUE', :old.SMO_PRCS_VALUE);
      FWK_I_MGT_ENTITY_DATA.SetColumn(ltCRUD_DEF, 'DIC_REBUT_ID', :old.DIC_REBUT_ID);
      FWK_I_MGT_ENTITY.DeleteEntity(ltCRUD_DEF);
      FWK_I_MGT_ENTITY.Release(ltCRUD_DEF);
    elsif updating then
      null;   -- on ne fait rien en mode update
    end if;
  end if;
exception
  when others then
    if lFrameworkCall then
      ra(PCS.PC_FUNCTIONS.TranslateWord('PCS - Cette erreur apparaît car vous n''avez pas utilisé le framework PLSQL pour votre instruction DML.') );
    end if;
end STM_SMO_BIUD_FWK;

ALTER TRIGGER "C_ITX"."STM_SMO_BIUD_FWK" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_SPO_AIU_CHECK_ASSIGNED"
  before insert or update of SPO_STOCK_QUANTITY, SPO_AVAILABLE_QUANTITY, SPO_ASSIGN_QUANTITY
  on STM_STOCK_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*   Contrôle de la quantité disponible (remplace la contrainte CKT_STM_AVAILABLE_QUANTITY)
* @author Fabrice Perotto
* @version 2003
* @lastUpdate fp 26.11.2008
*/
declare
  vAccessMethod STM_STOCK.C_ACCESS_METHOD%type;
begin
  -- on ne doit pas être en mode transfert d'attribution,
  -- et il doit y avoir une quantité attribuée pour faire le test
  if     not STM_PRC_MOVEMENT.gAttribTransfertMode
     and not FAL_NETWORK.gAttribTransfertMode
     and :new.SPO_ASSIGN_QUANTITY > 0 then
    begin
      -- Effectue le contrôle des quantités disponibles uniquement si le stock n'est pas privé. Suite à des problèmes
      -- de transfert d'attribution.
      select STO.C_ACCESS_METHOD
        into vAccessMethod
        from STM_STOCK STO
       where STO.STM_STOCK_ID = :new.STM_STOCK_ID
         and STO.C_ACCESS_METHOD <> 'PRIVATE';
    exception
      when no_data_found then
        vAccessMethod  := 'PRIVATE';
    end;

    if (vAccessMethod <> 'PRIVATE') then
      STM_PRC_STOCK_POSITION.checkAssignedQuantity(:new.GCO_GOOD_ID
                                                 , :new.STM_STOCK_ID
                                                 , :new.SPO_STOCK_QUANTITY
                                                 , :new.SPO_ASSIGN_QUANTITY
                                                 , :new.SPO_PROVISORY_INPUT
                                                  );
    end if;
  end if;
end STM_SPO_AIU_CHECK_ASSIGNED;

ALTER TRIGGER "C_ITX"."STM_SPO_AIU_CHECK_ASSIGNED" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_SPO_BD_CHECK_ATTRIB"
  before delete
  on STM_STOCK_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Garantit la suppression des attributions lié à la position de stock en cours d'effacement
* @author VJE
* @created 16.01.2006
* @version 2003
* */
begin
  FAL_PRC_REPORT_ATTRIB.CheckAttributionLink(:old.STM_STOCK_POSITION_ID
                                               , null
                                                );
exception
  when ex.TABLE_MUTATING then
    null;
end STM_SPO_BD_CHECK_ATTRIB;

ALTER TRIGGER "C_ITX"."STM_SPO_BD_CHECK_ATTRIB" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_SPO_BIU_CONSTRAINTS"
  before insert or update of spo_stock_quantity, spo_provisory_input, spo_provisory_output
  on STM_STOCK_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*   Vérifie que les biens avec gestion de pièce
*   ne puisse pas avoir de quantités supérieures à 1 sur une position de stock
* @created  fp 01.09.2003
* @version 2003
* @lastUpdate 30.05.2006 (test sur valeur absolue)
*/
declare
  vthirdid number;
  lControl pls_integer;

  function verifyQty4Char(
    aCharId GCO_CHARACTERIZATION.GCO_CHARACTERIZATION_ID%type
  , aValue  STM_STOCK_POSITION.SPO_CHARACTERIZATION_VALUE_1%type
  )
    return boolean
  is
  begin
    if    upper(aValue) = 'N/A'
       or aValue is null then
      return true;
    else
      if gco_functions.getcharactype(aCharId) = '3' then
        return false;
      else
        return true;
      end if;
    end if;
  end verifyQty4Char;

  function getCharacterizationValues(
    aGCO_CHARACTERIZATION_ID      STM_STOCK_POSITION.GCO_CHARACTERIZATION_ID%type
  , aGCO_GCO_CHARACTERIZATION_ID  STM_STOCK_POSITION.GCO_GCO_CHARACTERIZATION_ID%type
  , aGCO2_GCO_CHARACTERIZATION_ID STM_STOCK_POSITION.GCO2_GCO_CHARACTERIZATION_ID%type
  , aGCO3_GCO_CHARACTERIZATION_ID STM_STOCK_POSITION.GCO3_GCO_CHARACTERIZATION_ID%type
  , aGCO4_GCO_CHARACTERIZATION_ID STM_STOCK_POSITION.GCO4_GCO_CHARACTERIZATION_ID%type
  , aSPO_CHARACTERIZATION_VALUE_1 STM_STOCK_POSITION.SPO_CHARACTERIZATION_VALUE_1%type
  , aSPO_CHARACTERIZATION_VALUE_2 STM_STOCK_POSITION.SPO_CHARACTERIZATION_VALUE_2%type
  , aSPO_CHARACTERIZATION_VALUE_3 STM_STOCK_POSITION.SPO_CHARACTERIZATION_VALUE_3%type
  , aSPO_CHARACTERIZATION_VALUE_4 STM_STOCK_POSITION.SPO_CHARACTERIZATION_VALUE_4%type
  , aSPO_CHARACTERIZATION_VALUE_5 STM_STOCK_POSITION.SPO_CHARACTERIZATION_VALUE_5%type
  )
    return varchar2
  is
  begin
    if aGCO_CHARACTERIZATION_ID is null then
      return '';
    else
      return PCS.PC_FUNCTIONS.TranslateWord('Caractérisation(s)') ||
             ': ' ||
             aSPO_CHARACTERIZATION_VALUE_1 ||
             case
               when aGCO_GCO_CHARACTERIZATION_ID is not null then ', ' || aSPO_CHARACTERIZATION_VALUE_2
               else ''
             end ||
             case
               when aGCO2_GCO_CHARACTERIZATION_ID is not null then ', ' || aSPO_CHARACTERIZATION_VALUE_3
               else ''
             end ||
             case
               when aGCO3_GCO_CHARACTERIZATION_ID is not null then ', ' || aSPO_CHARACTERIZATION_VALUE_4
               else ''
             end ||
             case
               when aGCO4_GCO_CHARACTERIZATION_ID is not null then ', ' || aSPO_CHARACTERIZATION_VALUE_5
               else ''
             end ||
             '.' ||
             CO.cLineBreak;
    end if;
  end getCharacterizationValues;
begin
  -- control that the quantity of goods with piecenumbers cannot exceed 1
  if abs(:new.SPO_STOCK_QUANTITY + :new.SPO_PROVISORY_INPUT - :new.SPO_PROVISORY_OUTPUT) > 1 then
    if    (    :new.GCO_CHARACTERIZATION_ID is not null
           and not verifyQty4Char(:new.GCO_CHARACTERIZATION_ID, :new.SPO_CHARACTERIZATION_VALUE_1)
          )
       or (    :new.GCO_GCO_CHARACTERIZATION_ID is not null
           and not verifyQty4Char(:new.GCO_GCO_CHARACTERIZATION_ID, :new.SPO_CHARACTERIZATION_VALUE_2)
          )
       or (    :new.GCO2_GCO_CHARACTERIZATION_ID is not null
           and not verifyQty4Char(:new.GCO2_GCO_CHARACTERIZATION_ID, :new.SPO_CHARACTERIZATION_VALUE_3)
          )
       or (    :new.gco3_gco_characterization_id is not null
           and not verifyQty4Char(:new.GCO3_GCO_CHARACTERIZATION_ID, :new.SPO_CHARACTERIZATION_VALUE_4)
          )
       or (    :new.gco4_gco_characterization_id is not null
           and not verifyQty4Char(:new.GCO4_GCO_CHARACTERIZATION_ID, :new.SPO_CHARACTERIZATION_VALUE_5)
          ) then
      raise_application_error
                          (-20111
                         , 'PCS - Impossible to have a good with piecenumber management with a quantity greater than 1'
                          );
    end if;
  end if;

  -- control that non metal-account stocks quantity cannot be under zero
  if :new.SPO_STOCK_QUANTITY < 0 then
    lControl  := DOC_I_LIB_ALLOY.StockDeficitControl(:new.STM_STOCK_ID, :new.GCO_GOOD_ID);

    case
      when lControl = 1 then
        ra
          (replace
             (replace
                (replace
                   (PCS.PC_FUNCTIONS.TranslateWord
                      ('PCS - Une position du stock [STOCK] (emplacement [LOCATION]) pour le bien [GOOD] est en rupture de stock.'
                      )
                  , '[GOOD]'
                  , GCO_FUNCTIONS.getMajorReference(:new.GCO_GOOD_ID)
                   )
               , '[STOCK]'
               , STM_STOCK_FUNCTIONS.getStockDescription(:new.STM_STOCK_ID)
                )
            , '[LOCATION]'
            , STM_INVENTORY_EXT_FUNCTIONS.pGetLocationDescr(:new.STM_LOCATION_ID)
             ) ||
           CO.cLineBreak ||
           getCharacterizationValues(:new.GCO_CHARACTERIZATION_ID
                                   , :new.GCO_GCO_CHARACTERIZATION_ID
                                   , :new.GCO2_GCO_CHARACTERIZATION_ID
                                   , :new.GCO3_GCO_CHARACTERIZATION_ID
                                   , :new.GCO4_GCO_CHARACTERIZATION_ID
                                   , :new.SPO_CHARACTERIZATION_VALUE_1
                                   , :new.SPO_CHARACTERIZATION_VALUE_2
                                   , :new.SPO_CHARACTERIZATION_VALUE_3
                                   , :new.SPO_CHARACTERIZATION_VALUE_4
                                   , :new.SPO_CHARACTERIZATION_VALUE_5
                                    ) ||
           '(' ||
           PCS.PC_FUNCTIONS.TranslateWord
                 ('La quantité en stock ne peut être négative. Remplace la contrainte CKC_SPO_STOCK_QUANTIT_STM_STOC') ||
           ')'
          );
      when lControl in(2, 3, 4, 5, 6) then
        ra
          (PCS.PC_FUNCTIONS.TranslateWord
                      ('Paramétrage du tiers, de l''alliage ou du compte-poids à vérifier. Compte-poids négatif refusé!')
          );
      when lControl = 7 then
        ra
          (replace
             (replace
                (PCS.PC_FUNCTIONS.TranslateWord
                   ('PCS - La quantité en stock ne peut être négative. Le bien [GOOD] n''est pas lié au compte poids [CPT]'
                   )
               , '[GOOD]'
               , GCO_FUNCTIONS.getMajorReference(:new.GCO_GOOD_ID)
                )
            , '[CPT]'
            , STM_STOCK_FUNCTIONS.getStockDescription(:new.STM_STOCK_ID)
             )
          );
      else
        null;
    end case;
  end if;
end STM_SPO_BIU_CONSTRAINTS;

ALTER TRIGGER "C_ITX"."STM_SPO_BIU_CONSTRAINTS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_SPO_BIU_DENORM_CHAR"
  before insert or update of "SPO_CHARACTERIZATION_VALUE_1"
                           , "SPO_CHARACTERIZATION_VALUE_2"
                           , "SPO_CHARACTERIZATION_VALUE_3"
                           , "SPO_CHARACTERIZATION_VALUE_4"
                           , "SPO_CHARACTERIZATION_VALUE_5"
                           , "A_RECSTATUS"   -- permet de forcer la mise à niveau
  on STM_STOCK_POSITION
  referencing old as old new as new
  for each row
/**
* Description
*    Dénormalisation des caractérisations dans l'événement before insert
* @created fp 11.12.2001
* @version 2003
* @updated fp 14.01.2014 - mise à jour du champ dénormalisé STM_ELEMENT_NUMBER_DETAIL_ID
*/
begin
  -- vérifie que les informations ne soient pas déjà données
  if :new.GCO_CHARACTERIZATION_ID is not null then
    -- Mise à jour des champs dénormalisé d'affichage des caractérisations
    GCO_FUNCTIONS.ClassifyCharacterizations(:new.GCO_CHARACTERIZATION_ID
                                          , :new.GCO_GCO_CHARACTERIZATION_ID
                                          , :new.GCO2_GCO_CHARACTERIZATION_ID
                                          , :new.GCO3_GCO_CHARACTERIZATION_ID
                                          , :new.GCO4_GCO_CHARACTERIZATION_ID
                                          , :new.SPO_CHARACTERIZATION_VALUE_1
                                          , :new.SPO_CHARACTERIZATION_VALUE_2
                                          , :new.SPO_CHARACTERIZATION_VALUE_3
                                          , :new.SPO_CHARACTERIZATION_VALUE_4
                                          , :new.SPO_CHARACTERIZATION_VALUE_5
                                          , :new.SPO_PIECE
                                          , :new.SPO_SET
                                          , :new.SPO_VERSION
                                          , :new.SPO_CHRONOLOGICAL
                                          , :new.SPO_STD_CHAR_1
                                          , :new.SPO_STD_CHAR_2
                                          , :new.SPO_STD_CHAR_3
                                          , :new.SPO_STD_CHAR_4
                                          , :new.SPO_STD_CHAR_5
                                           );
  end if;
  -- dénormalise l'élément portant le détail de caractérisation
  if (:new.STM_ELEMENT_NUMBER_DETAIL_ID is null) and (:new.STM_ELEMENT_NUMBER_ID is not null) then
    :new.STM_ELEMENT_NUMBER_DETAIL_ID  :=
      STM_I_LIB_ELEMENT_NUMBER.GetDetailElement(iGoodID    => :new.GCO_GOOD_ID
                                              , iDetail1   => :new.STM_ELEMENT_NUMBER_ID
                                              , iDetail2   => :new.STM_STM_ELEMENT_NUMBER_ID
                                              , iDetail3   => :new.STM2_STM_ELEMENT_NUMBER_ID
                                               );
  end if;
end STM_SPO_BIU_DENORM_CHAR;

ALTER TRIGGER "C_ITX"."STM_SPO_BIU_DENORM_CHAR" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_SPO_BIU_QUANTITY"
before insert or update
of SPO_STOCK_QUANTITY
 , SPO_ASSIGN_QUANTITY
 , SPO_PROVISORY_INPUT
 , SPO_PROVISORY_OUTPUT
on STM_STOCK_POSITION
referencing old as old new as new
for each row
/**
* Description
*    Mise à jour des compteurs de stock qui sont uniquement calculé sur
*    la base d'autre quantité de la table des positions de stock
* @author VJ
* @created 25.02.2003
* @version DEVELOP
*/


begin

  /**
  * Quantité disponible gestion
  *
  *   Quantité disponible = Quantité effective - Quantité sortie provisoire - Quantité besoin attribué sur stock
  */
  :new.SPO_AVAILABLE_QUANTITY := nvl(:new.SPO_STOCK_QUANTITY, 0) - nvl(:new.SPO_PROVISORY_OUTPUT, 0) - nvl(:new.SPO_ASSIGN_QUANTITY, 0);

  /**
  * Quantité théorique
  *
  *   Quantité théorique = Quantité effective + Quantité entrée provisoire - Quantité sortie provisoire
  */
  :new.SPO_THEORETICAL_QUANTITY := nvl(:new.SPO_STOCK_QUANTITY, 0) + nvl(:new.SPO_PROVISORY_INPUT, 0) - nvl(:new.SPO_PROVISORY_OUTPUT, 0);

end STM_SPO_BIU_QUANTITY;


ALTER TRIGGER "C_ITX"."STM_SPO_BIU_QUANTITY" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_STO_AIU_FAL_POSITION"
  after insert or update of STO_DESCRIPTION
  on STM_STOCK
  referencing new as new
  for each row
/*----------------------------------------------
 Createur : Cassis Emmanuel .
 Date     : 26/03/2003 ;
 Objet    : Création d'un poste de pesée pour chaque
            Atelier non opérateur
----------------------------------------------*/
declare
  AUTO_UPDATE       varchar2(255);
  vValidDescription FAL_POSITION.FPO_DESCRIPTION%type;
  lnPositionID      FAL_POSITION.FAL_POSITION_ID%type;
begin
  vValidDescription  := '';

  select nvl(PCS.PC_CONFIG.GETCONFIG('FAL_AUTO_UPDATE_POSITION'), '0')
    into AUTO_UPDATE
    from dual;

  if AUTO_UPDATE = '1' then
    -- Récupération d'une description unique pour le poste
    vValidDescription  := FAL_I_LIB_POSITION.GetValidPositionDescr(:new.STO_DESCRIPTION);

    -- Création du poste
    if inserting then
--       FAL_POSITION_FUNCTIONS.FAL_POSITION_CREATE(vValidDescription, null, :new.STM_STOCK_ID);
      FAL_PRC_POSITION.createPosition(ivFpoDescription => vValidDescription, inStmStockID => :new.STM_STOCK_ID, onFalPositionID => lnPositionID);
    -- Modifcation de la référence du poste
    elsif updating then
      if :old.STO_DESCRIPTION <> :new.STO_DESCRIPTION then
        update FAL_POSITION
           set FPO_DESCRIPTION = vValidDescription
             , A_DATEMOD = sysdate
             , A_IDMOD = PCS.PC_I_LIB_SESSION.GetUserIni
         where STM_STOCK_ID = :new.STM_STOCK_ID;
      end if;
    end if;
  end if;
end STM_STO_AIU_FAL_POSITION;

ALTER TRIGGER "C_ITX"."STM_STO_AIU_FAL_POSITION" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."STM_STO_BD_FAL_POSITION"
BEFORE DELETE
ON STM_STOCK
REFERENCING OLD as OLD
FOR EACH ROW
/*----------------------------------------------
 Createur : Cassis Emmanuel .
 Date     : 26/03/2003 ;
 Objet    : Création d'un poste de pesée pour chaque
            Atelier non opérateur
----------------------------------------------*/
DECLARE
  AUTO_UPDATE VARCHAR2(255);
BEGIN

  SELECT NVL(PCS.PC_CONFIG.GETCONFIG('FAL_AUTO_UPDATE_POSITION'),'0')
	  INTO AUTO_UPDATE
		FROM DUAL;

	IF AUTO_UPDATE = '1' THEN

    -- Suppression du poste
    DELETE FROM FAL_POSITION
    WHERE STM_STOCK_ID = :OLD.STM_STOCK_ID;

  END IF;

end STM_STO_BD_FAL_POSITION;

ALTER TRIGGER "C_ITX"."STM_STO_BD_FAL_POSITION" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."WEB_CATEG_ARRAY_BIU"
  before insert or update of "WEB_CATEG_ID_LEVEL1","WEB_CATEG_ID_LEVEL2",
  "WEB_CATEG_ID_LEVEL3","WEB_CATEG_ID_LEVEL4","WEB_CATEG_ID_LEVEL5" on WEB_CATEG_ARRAY
  referencing old as old new as new
  for each row
/**
* Description
*  mise à jour de la signature et du niveau de profondeur de la structure (WCA_LEVEL)
* idéalement on devrait gérer la règle suivante :
* pour un web_categ_array_id, si le champ web_categ_id_leveln est nul, tous les autres champs
* sont nuls (pas de trous !)
* @author RR
* @version 2003
* @lastUpdate
*/
declare
  lev number(2);
  signature varchar2(200);
begin
  if :new.WEB_CATEG_ID_LEVEL1 is null then
    raise_application_error (-20230,'WEB_CATEG_ID_LEVEL1 can not be null.');
  elsif :new.WEB_CATEG_ID_LEVEL2 is null then
    signature:=:new.WEB_CATEG_ID_LEVEL1;
    lev:=1;
  elsif :new.WEB_CATEG_ID_LEVEL3 is null then
    signature:=:new.WEB_CATEG_ID_LEVEL1||'-'||:new.WEB_CATEG_ID_LEVEL2;
    lev:=2;
  elsif :new.WEB_CATEG_ID_LEVEL4 is null then
    signature:=:new.WEB_CATEG_ID_LEVEL1||'-'||:new.WEB_CATEG_ID_LEVEL2||'-'||:new.WEB_CATEG_ID_LEVEL3;
    lev:=3;
  elsif :new.WEB_CATEG_ID_LEVEL5 is null then
    signature:=:new.WEB_CATEG_ID_LEVEL1||'-'||:new.WEB_CATEG_ID_LEVEL2||'-'||:new.WEB_CATEG_ID_LEVEL3||'-'||:new.WEB_CATEG_ID_LEVEL4;
    lev:=4;
  else
    lev:=5;
    signature:=:new.WEB_CATEG_ID_LEVEL1||'-'||:new.WEB_CATEG_ID_LEVEL2||'-'||:new.WEB_CATEG_ID_LEVEL3||'-'||:new.WEB_CATEG_ID_LEVEL4||'-'||:new.WEB_CATEG_ID_LEVEL5;
  end if;

 :new.WCA_LEVEL     := lev;
 :new.WCA_SIGNATURE := signature;
end WEB_CATEG_ARRAY_BIU;

ALTER TRIGGER "C_ITX"."WEB_CATEG_ARRAY_BIU" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."WEB_V_WEU_IOIUD_PCS"
  instead of insert or update or delete
  on V_WEB_USER_IO
  for each row
declare
  lUseIni     PCS.PC_USER.USE_INI%type                := PCS.PC_I_LIB_SESSION.GetUserIni;
  lCompLangId PCS.PC_LANG.PC_LANG_ID%type             := PCS.PC_I_LIB_SESSION.GetCompLangId;
  lnLinkID    PCS.PC_USER_LINK.PC_USER_LINK_ID%type;
  lCompId     PCS.PC_COMP.PC_COMP_ID%type;
begin

  select min(PC_COMP_ID)
    into lCompId
    from PCS.PC_COMP COM
       , PCS.PC_SCRIP SCR
   where SCR.SCRDBOWNER = COM_CURRENTSCHEMA
     and COM.PC_SCRIP_ID = SCR.PC_SCRIP_ID;

  if inserting then
    -- create new user in PC_USER
    -- system must have checked that the user does not exist before inserting
    insert into PCS.PC_USER
                (PC_USER_ID
               , PC_LANG_ID
               , USE_WEB
               , USE_NAME
               , USE_ACCOUNT_NAME
               , USE_PASSWORD
               , USE_CONFIRM_VALUE
               , USE_FIRST_NAME
               , USE_LAST_NAME
               , USE_DESCR
               , USE_EMAIL
               , USE_INI
               , USE_LAST_LOGIN
               , USE_LAST_PWD_CHANGE
               , A_DATECRE
               , A_IDCRE
               , A_DATEMOD
               , A_IDMOD
               , A_RECSTATUS
               , A_RECLEVEL
               , USE_CREATE_REP
               , USE_MODIF_REP
                )
         values (:new.WEB_USER_ID
               , nvl(:new.PC_LANG_ID, lCompLangId)
               , 1
               , :new.WEU_LOGIN_NAME
               , :new.WEU_LOGIN_NAME
               , :new.WEU_PASSWORD_VALUE
               , :new.WEU_CONFIRM_VALUE
               , :new.WEU_FIRST_NAME
               , :new.WEU_LAST_NAME
               , :new.WEU_FIRST_NAME || ' ' || :new.WEU_LAST_NAME
               , :new.WEU_EMAIL
               , nvl(:new.WEU_INI, nvl(substr(:new.WEU_FIRST_NAME, 1, 1) || substr(:new.WEU_FIRST_NAME, 1, 2), substr(:new.WEU_LOGIN_NAME, 1, 5) ) )
               , :new.WEU_LAST_LOGIN
               , :new.WEU_PASSWORD_CHANGED
               , nvl(:new.A_DATECRE, sysdate)
               , nvl(:new.A_IDCRE, lUseIni)
               , :new.A_DATEMOD
               , :new.A_IDMOD
               , :new.A_RECSTATUS
               , :new.A_RECLEVEL
               , 0   -- USE_CREATE_REP
               , 0   -- USE_MODIF_REP
                );

    -- Field PC_COMP_ID is materialized in table PC_USER_LINK
    -- and determine that this user is active in the company
    insert into PCS.PC_USER_LINK
                (PC_USER_LINK_ID
               , PC_USER_ID
               , PC_COMP_ID
               , ULI_LINK_CODE
               , ULI_LINK_RECORD_ID
               , ULI_DESC
               , A_DATECRE
               , A_IDCRE
                )
         values (pcs.init_id_seq.nextval
               , :new.WEB_USER_ID
               , lCompId
               , 'WEB_USER'
               , :new.WEB_USER_ID
               , 'Created by WEB_V_WEU_IOIUD_PCS'
               , sysdate
               , lUseIni
                );

    -- Field WEU_DISABLED is materialized in table PC_USER_LINK
    insert into PCS.PC_USER_LINK
                (PC_USER_LINK_ID
               , PC_USER_ID
               , PC_COMP_ID
               , ULI_LINK_CODE
               , ULI_LINK_RECORD_ID
               , ULI_DESC
               , A_DATECRE
               , A_IDCRE
                )
         values (pcs.init_id_seq.nextval
               , :new.WEB_USER_ID
               , lCompId
               , 'WEB_USER.WEU_DISABLED'
               , :new.WEU_DISABLED
               , 'Created by WEB_V_WEU_IOIUD_PCS'
               , sysdate
               , lUseIni
                );

    -- Field HRM_PERSON_ID is materialized in table PC_USER_LINK
    if :new.HRM_PERSON_ID is not null then
      insert into PCS.PC_USER_LINK
                  (PC_USER_LINK_ID
                 , PC_USER_ID
                 , PC_COMP_ID
                 , ULI_LINK_CODE
                 , ULI_LINK_RECORD_ID
                 , ULI_DESC
                 , A_DATECRE
                 , A_IDCRE
                  )
           values (pcs.init_id_seq.nextval
                 , :new.WEB_USER_ID
                 , lCompId
                 , 'HRM_PERSON'
                 , :new.HRM_PERSON_ID
                 , 'Created by WEB_V_WEU_IOIUD_PCS'
                 , sysdate
                 , lUseIni
                  );
    end if;

    -- Field PAC_REPRESENTATIVE_ID is materialized in table PC_USER_LINK
    if :new.PAC_REPRESENTATIVE_ID is not null then
      insert into PCS.PC_USER_LINK
                  (PC_USER_LINK_ID
                 , PC_USER_ID
                 , PC_COMP_ID
                 , ULI_LINK_CODE
                 , ULI_LINK_RECORD_ID
                 , ULI_DESC
                 , A_DATECRE
                 , A_IDCRE
                  )
           values (pcs.init_id_seq.nextval
                 , :new.WEB_USER_ID
                 , lCompId
                 , 'PAC_REPRESENTATIVE'
                 , :new.PAC_REPRESENTATIVE_ID
                 , 'Created by WEB_V_WEU_IOIUD_PCS'
                 , sysdate
                 , lUseIni
                  );
    end if;

    -- Field PAC_CUSTOM_PARTNER_ID is materialized in table PC_USER_LINK
    if :new.PAC_CUSTOM_PARTNER_ID is not null then
      insert into PCS.PC_USER_LINK
                  (PC_USER_LINK_ID
                 , PC_USER_ID
                 , PC_COMP_ID
                 , ULI_LINK_CODE
                 , ULI_LINK_RECORD_ID
                 , ULI_DESC
                 , A_DATECRE
                 , A_IDCRE
                  )
           values (pcs.init_id_seq.nextval
                 , :new.WEB_USER_ID
                 , lCompId
                 , 'PAC_CUSTOM_PARTNER'
                 , :new.PAC_CUSTOM_PARTNER_ID
                 , 'Created by WEB_V_WEU_IOIUD_PCS'
                 , sysdate
                 , lUseIni
                  );
    end if;

    -- Field PAC_SUPPLIER_PARTNER_ID is materialized in table PC_USER_LINK
    if :new.PAC_SUPPLIER_PARTNER_ID is not null then
      insert into PCS.PC_USER_LINK
                  (PC_USER_LINK_ID
                 , PC_USER_ID
                 , PC_COMP_ID
                 , ULI_LINK_CODE
                 , ULI_LINK_RECORD_ID
                 , ULI_DESC
                 , A_DATECRE
                 , A_IDCRE
                  )
           values (pcs.init_id_seq.nextval
                 , :new.WEB_USER_ID
                 , lCompId
                 , 'PAC_SUPPLIER_PARTNER'
                 , :new.PAC_SUPPLIER_PARTNER_ID
                 , 'Created by WEB_V_WEU_IOIUD_PCS'
                 , sysdate
                 , lUseIni
                  );
    end if;

    -- Field PAC_PERSON_ID is materialized in table PC_USER_LINK
    if :new.PAC_PERSON_ID is not null then
      insert into PCS.PC_USER_LINK
                  (PC_USER_LINK_ID
                 , PC_USER_ID
                 , PC_COMP_ID
                 , ULI_LINK_CODE
                 , ULI_LINK_RECORD_ID
                 , ULI_DESC
                 , A_DATECRE
                 , A_IDCRE
                  )
           values (pcs.init_id_seq.nextval
                 , :new.WEB_USER_ID
                 , lCompId
                 , 'PAC_PERSON'
                 , :new.PAC_PERSON_ID
                 , 'Created by WEB_V_WEU_IOIUD_PCS'
                 , sysdate
                 , lUseIni
                  );
    end if;
  elsif updating then
    -- update follow in PC_USER
    -- beware that modification for a user used in more than one company are done for all these companies
    update PCS.PC_USER
       set PC_LANG_ID = nvl(:new.PC_LANG_ID, lCompLangId)
         , USE_NAME = case
                       when USE_NAME = :old.WEU_LOGIN_NAME then :new.WEU_LOGIN_NAME
                       else USE_NAME
                     end
         , USE_ACCOUNT_NAME = :new.WEU_LOGIN_NAME
         , USE_PASSWORD = :new.WEU_PASSWORD_VALUE
         , USE_CONFIRM_VALUE = :new.WEU_CONFIRM_VALUE
         , USE_FIRST_NAME = :new.WEU_FIRST_NAME
         , USE_LAST_NAME = :new.WEU_LAST_NAME
         , USE_DESCR = case
                        when USE_DESCR = :old.WEU_FIRST_NAME || ' ' || :old.WEU_LAST_NAME then :new.WEU_FIRST_NAME || ' ' || :new.WEU_LAST_NAME
                        else USE_DESCR
                      end
         , USE_EMAIL = :new.WEU_EMAIL
         , USE_INI = :new.WEU_INI
         , USE_LAST_LOGIN = :new.WEU_LAST_LOGIN
         , USE_LAST_PWD_CHANGE = :new.WEU_PASSWORD_CHANGED
         , A_DATEMOD = nvl(:new.A_DATEMOD, sysdate)
         , A_IDMOD = nvl(:new.A_IDMOD, lUseIni)
         , A_RECSTATUS = :new.A_RECSTATUS
         , A_RECLEVEL = :new.A_RECLEVEL
     where PC_USER_ID = :new.PC_USER_ID;

    -- Managing WEU_DISABLED
    select max(PC_USER_LINK_ID)
      into lnLinkID
      from PCS.PC_USER_LINK
     where PC_USER_ID = :new.PC_USER_ID
       and PC_COMP_ID = lCompId
       and ULI_LINK_CODE = 'WEB_USER.WEU_DISABLED';

    -- Person link exists -> Update
    if lnLinkID is not null then
      update PCS.PC_USER_LINK ULI
         set ULI.ULI_LINK_RECORD_ID = :new.WEU_DISABLED
           , ULI.A_DATEMOD = nvl(:new.A_DATEMOD, sysdate)
           , ULI.A_IDMOD = nvl(:new.A_IDMOD, lUseIni)
       where PC_USER_LINK_ID = lnLinkID;
    else
      -- Insert Person link to manage the field WEU_DISABLED
      insert into PCS.PC_USER_LINK
                  (PC_USER_LINK_ID
                 , PC_USER_ID
                 , PC_COMP_ID
                 , ULI_LINK_CODE
                 , ULI_LINK_RECORD_ID
                 , ULI_DESC
                 , A_DATECRE
                 , A_IDCRE
                  )
           values (PCS.INIT_ID_SEQ.nextval
                 , :new.PC_USER_ID
                 , lCompId
                 , 'WEB_USER.WEU_DISABLED'
                 , :new.WEU_DISABLED
                 , 'Created by WEB_V_WEU_IOIUD_PCS'
                 , sysdate
                 , lUseIni
                  );
    end if;

    -- Managing HRM_PERSON_ID
    -- if a value appears for HRM_PERSON_ID during this update
    if     :old.HRM_PERSON_ID is null
       and :new.HRM_PERSON_ID is not null then
      insert into PCS.PC_USER_LINK
                  (PC_USER_LINK_ID
                 , PC_USER_ID
                 , PC_COMP_ID
                 , ULI_LINK_CODE
                 , ULI_LINK_RECORD_ID
                 , ULI_DESC
                 , A_DATECRE
                 , A_IDCRE
                  )
           values (pcs.init_id_seq.nextval
                 , :new.PC_USER_ID
                 , lCompId
                 , 'HRM_PERSON'
                 , :new.HRM_PERSON_ID
                 , 'Created by WEB_V_WEU_IOIUD_PCS'
                 , sysdate
                 , lUseIni
                  );
    -- if the value disappears for HRM_PERSON_ID during this update
    elsif     :old.HRM_PERSON_ID is not null
          and :new.HRM_PERSON_ID is null then
      delete from PCS.PC_USER_LINK
            where PC_USER_ID = :new.PC_USER_ID
              and ULI_LINK_CODE = 'HRM_PERSON'
              and PC_COMP_ID = lCompId;
    -- if the value changes for HRM_PERSON_ID during this update
    elsif :old.HRM_PERSON_ID <> :new.HRM_PERSON_ID then
      update PCS.PC_USER_LINK
         set ULI_LINK_RECORD_ID = :new.HRM_PERSON_ID
           , ULI_DESC = 'Updated by WEB_V_WEU_IOIUD_PCS'
           , A_DATEMOD = sysdate
           , A_IDMOD = lUseIni
       where PC_USER_ID = :new.PC_USER_ID
         and PC_COMP_ID = lCompId
         and ULI_LINK_CODE = 'HRM_PERSON';
    end if;

    -- Managing PAC_REPRESENTATIVE_ID
    -- if a value appears for PAC_REPRESENTATIVE_ID during this update
    if     :old.PAC_REPRESENTATIVE_ID is null
       and :new.PAC_REPRESENTATIVE_ID is not null then
      insert into PCS.PC_USER_LINK
                  (PC_USER_LINK_ID
                 , PC_USER_ID
                 , PC_COMP_ID
                 , ULI_LINK_CODE
                 , ULI_LINK_RECORD_ID
                 , ULI_DESC
                 , A_DATECRE
                 , A_IDCRE
                  )
           values (pcs.init_id_seq.nextval
                 , :new.PC_USER_ID
                 , lCompId
                 , 'PAC_REPRESENTATIVE'
                 , :new.PAC_REPRESENTATIVE_ID
                 , 'Created by WEB_V_WEU_IOIUD_PCS'
                 , sysdate
                 , lUseIni
                  );
    -- if the value disappears for PAC_REPRESENTATIVE_ID during this update
    elsif     :old.PAC_REPRESENTATIVE_ID is not null
          and :new.PAC_REPRESENTATIVE_ID is null then
      delete from PCS.PC_USER_LINK
            where PC_USER_ID = :new.PC_USER_ID
              and ULI_LINK_CODE = 'PAC_REPRESENTATIVE'
              and PC_COMP_ID = lCompId;
    -- if the value changes for PAC_REPRESENTATIVE_ID during this update
    elsif :old.PAC_REPRESENTATIVE_ID <> :new.PAC_REPRESENTATIVE_ID then
      update PCS.PC_USER_LINK
         set ULI_LINK_RECORD_ID = :new.PAC_REPRESENTATIVE_ID
           , ULI_DESC = 'Updated by WEB_V_WEU_IOIUD_PCS'
           , A_DATEMOD = sysdate
           , A_IDMOD = lUseIni
       where PC_USER_ID = :new.PC_USER_ID
         and PC_COMP_ID = lCompId
         and ULI_LINK_CODE = 'PAC_REPRESENTATIVE';
    end if;

    -- Managing PAC_CUSTOM_PARTNER_ID
    -- if a value appears for PAC_CUSTOM_PARTNER_ID during this update
    if     :old.PAC_CUSTOM_PARTNER_ID is null
       and :new.PAC_CUSTOM_PARTNER_ID is not null then
      insert into PCS.PC_USER_LINK
                  (PC_USER_LINK_ID
                 , PC_USER_ID
                 , PC_COMP_ID
                 , ULI_LINK_CODE
                 , ULI_LINK_RECORD_ID
                 , ULI_DESC
                 , A_DATECRE
                 , A_IDCRE
                  )
           values (pcs.init_id_seq.nextval
                 , :new.PC_USER_ID
                 , lCompId
                 , 'PAC_CUSTOM_PARTNER'
                 , :new.PAC_CUSTOM_PARTNER_ID
                 , 'Created by WEB_V_WEU_IOIUD_PCS'
                 , sysdate
                 , lUseIni
                  );
    -- if the value disappears for PAC_CUSTOM_PARTNER_ID during this update
    elsif     :old.PAC_CUSTOM_PARTNER_ID is not null
          and :new.PAC_CUSTOM_PARTNER_ID is null then
      delete from PCS.PC_USER_LINK
            where PC_USER_ID = :new.PC_USER_ID
              and ULI_LINK_CODE = 'PAC_CUSTOM_PARTNER'
              and PC_COMP_ID = lCompId;
    -- if the value changes for PAC_CUSTOM_PARTNER_ID during this update
    elsif :old.PAC_CUSTOM_PARTNER_ID <> :new.PAC_CUSTOM_PARTNER_ID then
      update PCS.PC_USER_LINK
         set ULI_LINK_RECORD_ID = :new.PAC_CUSTOM_PARTNER_ID
           , ULI_DESC = 'Updated by WEB_V_WEU_IOIUD_PCS'
           , A_DATEMOD = sysdate
           , A_IDMOD = lUseIni
       where PC_USER_ID = :new.PC_USER_ID
         and PC_COMP_ID = lCompId
         and ULI_LINK_CODE = 'PAC_CUSTOM_PARTNER';
    end if;

    -- Managing PAC_SUPPLIER_PARTNER_ID
    -- if a value appears for PAC_SUPPLIER_PARTNER_ID during this update
    if     :old.PAC_SUPPLIER_PARTNER_ID is null
       and :new.PAC_SUPPLIER_PARTNER_ID is not null then
      insert into PCS.PC_USER_LINK
                  (PC_USER_LINK_ID
                 , PC_USER_ID
                 , PC_COMP_ID
                 , ULI_LINK_CODE
                 , ULI_LINK_RECORD_ID
                 , ULI_DESC
                 , A_DATECRE
                 , A_IDCRE
                  )
           values (pcs.init_id_seq.nextval
                 , :new.PC_USER_ID
                 , lCompId
                 , 'PAC_SUPPLIER_PARTNER'
                 , :new.PAC_SUPPLIER_PARTNER_ID
                 , 'Created by WEB_V_WEU_IOIUD_PCS'
                 , sysdate
                 , lUseIni
                  );
    -- if the value disappears for PAC_SUPPLIER_PARTNER_ID during this update
    elsif     :old.PAC_SUPPLIER_PARTNER_ID is not null
          and :new.PAC_SUPPLIER_PARTNER_ID is null then
      delete from PCS.PC_USER_LINK
            where PC_USER_ID = :new.PC_USER_ID
              and ULI_LINK_CODE = 'PAC_SUPPLIER_PARTNER'
              and PC_COMP_ID = lCompId;
    -- if the value changes for PAC_SUPPLIER_PARTNER_ID during this update
    elsif :old.PAC_SUPPLIER_PARTNER_ID <> :new.PAC_SUPPLIER_PARTNER_ID then
      update PCS.PC_USER_LINK
         set ULI_LINK_RECORD_ID = :new.PAC_SUPPLIER_PARTNER_ID
           , ULI_DESC = 'Updated by WEB_V_WEU_IOIUD_PCS'
           , A_DATEMOD = sysdate
           , A_IDMOD = lUseIni
       where PC_USER_ID = :new.PC_USER_ID
         and PC_COMP_ID = lCompId
         and ULI_LINK_CODE = 'PAC_SUPPLIER_PARTNER';
    end if;

    -- Managing PAC_PERSON_ID
    -- if a value appears for PAC_PERSON_ID during this update
    if     :old.PAC_PERSON_ID is null
       and :new.PAC_PERSON_ID is not null then
      insert into PCS.PC_USER_LINK
                  (PC_USER_LINK_ID
                 , PC_USER_ID
                 , PC_COMP_ID
                 , ULI_LINK_CODE
                 , ULI_LINK_RECORD_ID
                 , ULI_DESC
                 , A_DATECRE
                 , A_IDCRE
                  )
           values (pcs.init_id_seq.nextval
                 , :new.PC_USER_ID
                 , lCompId
                 , 'PAC_PERSON'
                 , :new.PAC_PERSON_ID
                 , 'Created by WEB_V_WEU_IOIUD_PCS'
                 , sysdate
                 , lUseIni
                  );
    -- if the value disappears for PAC_PERSON_ID during this update
    elsif     :old.PAC_PERSON_ID is not null
          and :new.PAC_PERSON_ID is null then
      delete from PCS.PC_USER_LINK
            where PC_USER_ID = :new.PC_USER_ID
              and ULI_LINK_CODE = 'PAC_PERSON'
              and PC_COMP_ID = lCompId;
    -- if the value changes for PAC_PERSON_ID during this update
    elsif :old.PAC_PERSON_ID <> :new.PAC_PERSON_ID then
      update PCS.PC_USER_LINK
         set ULI_LINK_RECORD_ID = :new.PAC_PERSON_ID
           , ULI_DESC = 'Updated by WEB_V_WEU_IOIUD_PCS'
           , A_DATEMOD = sysdate
           , A_IDMOD = lUseIni
       where PC_USER_ID = :new.PC_USER_ID
         and PC_COMP_ID = lCompId
         and ULI_LINK_CODE = 'PAC_PERSON';
    end if;
  elsif deleting then

    -- delete all linked data in WEB_USER_GROUP_ROLE
    delete from WEB_USER_GROUP_ROLE
      where WEB_USER_ID = :old.WEB_USER_ID;

    -- delete all link for the user in the company
    delete from PCS.PC_USER_LINK
          where PC_USER_ID = :old.PC_USER_ID
            and PC_COMP_ID = lCompId;

    -- no deletion, only unflagging field USE_WEB
    -- when no more WEB_USER in no other companies
    update PCS.PC_USER
       set USE_WEB = 0
     where PC_USER_ID = :old.WEB_USER_ID
       and not exists(select PC_USER_LINK_ID
                        from PCS.PC_USER_LINK
                       where PC_USER_ID = :old.PC_USER_ID
                         and ULI_LINK_CODE = 'WEB_USER');
  end if;
end WEB_V_WEU_IOIUD_PCS;

ALTER TRIGGER "C_ITX"."WEB_V_WEU_IOIUD_PCS" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."WFL_APA_BUI_PROCDEF"
Before update or insert on WFL_ACTUAL_PARAMETERS
for EACH ROW
begin
  --XOR sur l'identifiant de l'attribut et l'expression
  if  :new.WFL_ATTRIBUTES_ID is null and :new.APA_EXPRESSION is null then
    Raise_Application_Error(-20000,'WFL_ACTUAL_PARAMETERS(' || :new.WFL_ACTUAL_PARAMETERS_ID || ') : Specifie si un id d''attribut ou une expression est utilisée comme paramètre actuel.');
  end if;

  if :new.WFL_ATTRIBUTES_ID is not null and :new.APA_EXPRESSION is not null then
    Raise_Application_Error(-20000,'WFL_ACTUAL_PARAMETERS(' || :new.WFL_ACTUAL_PARAMETERS_ID || ') : Choisit entre un id d''attribut ou une expression pour utiliser comme paramètre actuel, mais pas les 2.' );
  end if;
end WFL_APA_BUI_PROCDEF;

ALTER TRIGGER "C_ITX"."WFL_APA_BUI_PROCDEF" ENABLE


  CREATE OR REPLACE TRIGGER "C_ITX"."WFL_FPA_BUI_PROCDEF"
Before update or insert on WFL_FORMAL_PARAMETERS
for EACH ROW
begin
  -- XOR sur l'id du processus et l'id de l'application, car le paramètre peut être soit un process soit une
  -- application, mais pas les 2.
  if :new.WFL_PROCESSES_ID is null and :new.WFL_APPLICATIONS_ID is null then
    Raise_Application_Error(-20000,'WFL_FORMAL_PARAMETERS(' || :new.WFL_FORMAL_PARAMETERS_ID || ') : un paramètre formel est paramètre d''un (sous-)processus, ou paramètre d''une application.' ||
                                   ' Specifie si un id de processus ou un id d''application.' );
  end if;

  if :new.WFL_PROCESSES_ID is not null and :new.WFL_APPLICATIONS_ID is not null then
    Raise_Application_Error(-20000,'WFL_FORMAL_PARAMETERS(' || :new.WFL_FORMAL_PARAMETERS_ID || ') : un paramètre formel est paramétre d''un (sous-)processus, ou paramètre d''une application, mais pas les 2. ' ||
                                   ' Choisit entre un id de process ou un id d''application.' );
  end if;
end WFL_FPA_BUI_PROCDEF;

ALTER TRIGGER "C_ITX"."WFL_FPA_BUI_PROCDEF" ENABLE

